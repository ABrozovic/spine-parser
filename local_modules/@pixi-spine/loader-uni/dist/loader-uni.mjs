/*!
 * @pixi-spine/loader-uni - v4.0.3
 * Compiled Fri, 16 Jun 2023 00:33:40 UTC
 *
 * @pixi-spine/loader-uni is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 * 
 * Copyright 2023, Mat Groves, All Rights Reserved
 */import{SpineLoaderAbstract as qe}from"@pixi-spine/loader-base";import{Utils as T,AttachmentType as xt,Color as B,MathUtils as y,PowOut as Ue,MixBlend as R,MixDirection as St,IntSet as $e,Pool as He,settings as ie,TransformMode as Z,RotateMode as Ct,PositionMode as Vt,Vector2 as je,BinaryInput as oe,SkeletonBoundsBase as Ge,SpineBase as Ne}from"@pixi-spine/base";import{Matrix as Ze,BLEND_MODES as Pt}from"@pixi/core";import*as Ut from"@pixi-spine/runtime-3.8";import*as le from"@pixi-spine/runtime-3.7";import*as $t from"@pixi-spine/runtime-4.1";class ce{constructor(t){if(t==null)throw new Error("name cannot be null.");this.name=t}}const De=class extends ce{constructor(e){super(e),this.id=(De.nextID++&65535)<<11,this.worldVerticesLength=0,this.deformAttachment=this}computeWorldVerticesOld(e,t){this.computeWorldVertices(e,0,this.worldVerticesLength,t,0,2)}computeWorldVertices(e,t,n,s,a,c){n=a+(n>>1)*c;const d=e.bone.skeleton,o=e.deform;let r=this.vertices;const i=this.bones;if(i==null){o.length>0&&(r=o);const h=e.bone.matrix,m=h.tx,p=h.ty,g=h.a,x=h.c,E=h.b,w=h.d;for(let M=t,b=a;b<n;M+=2,b+=c){const S=r[M],A=r[M+1];s[b]=S*g+A*x+m,s[b+1]=S*E+A*w+p}return}let l=0,f=0;for(let h=0;h<t;h+=2){const m=i[l];l+=m+1,f+=m}const u=d.bones;if(o.length==0)for(let h=a,m=f*3;h<n;h+=c){let p=0,g=0,x=i[l++];for(x+=l;l<x;l++,m+=3){const E=u[i[l]].matrix,w=r[m],M=r[m+1],b=r[m+2];p+=(w*E.a+M*E.c+E.tx)*b,g+=(w*E.b+M*E.d+E.ty)*b}s[h]=p,s[h+1]=g}else{const h=o;for(let m=a,p=f*3,g=f<<1;m<n;m+=c){let x=0,E=0,w=i[l++];for(w+=l;l<w;l++,p+=3,g+=2){const M=u[i[l]].matrix,b=r[p]+h[g],S=r[p+1]+h[g+1],A=r[p+2];x+=(b*M.a+S*M.c+M.tx)*A,E+=(b*M.b+S*M.d+M.ty)*A}s[m]=x,s[m+1]=E}}}copyTo(e){this.bones!=null?(e.bones=new Array(this.bones.length),T.arrayCopy(this.bones,0,e.bones,0,this.bones.length)):e.bones=null,this.vertices!=null?(e.vertices=T.newFloatArray(this.vertices.length),T.arrayCopy(this.vertices,0,e.vertices,0,this.vertices.length)):e.vertices=null,e.worldVerticesLength=this.worldVerticesLength,e.deformAttachment=this.deformAttachment}};let Ft=De;Ft.nextID=0;class ee extends Ft{constructor(t){super(t),this.type=xt.BoundingBox,this.color=new B(1,1,1,1)}copy(){const t=new ee(this.name);return this.copyTo(t),t.color.setFromColor(this.color),t}}class ne extends Ft{constructor(t){super(t),this.type=xt.Clipping,this.color=new B(.2275,.2275,.8078,1)}copy(){const t=new ne(this.name);return this.copyTo(t),t.endSlot=this.endSlot,t.color.setFromColor(this.color),t}}class Xt extends Ft{constructor(t){super(t),this.type=xt.Mesh,this.color=new B(1,1,1,1),this.tempColor=new B(0,0,0,0)}getParentMesh(){return this.parentMesh}setParentMesh(t){this.parentMesh=t,t!=null&&(this.bones=t.bones,this.vertices=t.vertices,this.worldVerticesLength=t.worldVerticesLength,this.regionUVs=t.regionUVs,this.triangles=t.triangles,this.hullLength=t.hullLength,this.worldVerticesLength=t.worldVerticesLength)}copy(){if(this.parentMesh!=null)return this.newLinkedMesh();const t=new Xt(this.name);return t.region=this.region,t.path=this.path,t.color.setFromColor(this.color),this.copyTo(t),t.regionUVs=new Float32Array(this.regionUVs.length),T.arrayCopy(this.regionUVs,0,t.regionUVs,0,this.regionUVs.length),t.triangles=new Array(this.triangles.length),T.arrayCopy(this.triangles,0,t.triangles,0,this.triangles.length),t.hullLength=this.hullLength,this.edges!=null&&(t.edges=new Array(this.edges.length),T.arrayCopy(this.edges,0,t.edges,0,this.edges.length)),t.width=this.width,t.height=this.height,t}newLinkedMesh(){const t=new Xt(this.name);return t.region=this.region,t.path=this.path,t.color.setFromColor(this.color),t.deformAttachment=this.deformAttachment,t.setParentMesh(this.parentMesh!=null?this.parentMesh:this),t}}class Lt extends Ft{constructor(t){super(t),this.type=xt.Path,this.closed=!1,this.constantSpeed=!1,this.color=new B(1,1,1,1)}copy(){const t=new Lt(this.name);return this.copyTo(t),t.lengths=new Array(this.lengths.length),T.arrayCopy(this.lengths,0,t.lengths,0,this.lengths.length),t.closed=closed,t.constantSpeed=this.constantSpeed,t.color.setFromColor(this.color),t}}class se extends Ft{constructor(t){super(t),this.type=xt.Point,this.color=new B(.38,.94,0,1)}computeWorldPosition(t,n){const s=t.matrix;return n.x=this.x*s.a+this.y*s.c+t.worldX,n.y=this.x*s.b+this.y*s.d+t.worldY,n}computeWorldRotation(t){const n=t.matrix,s=y.cosDeg(this.rotation),a=y.sinDeg(this.rotation),c=s*n.a+a*n.c,d=s*n.b+a*n.d;return Math.atan2(d,c)*y.radDeg}copy(){const t=new se(this.name);return t.x=this.x,t.y=this.y,t.rotation=this.rotation,t.color.setFromColor(this.color),t}}class he{constructor(t,n){if(this.deform=new Array,t==null)throw new Error("data cannot be null.");if(n==null)throw new Error("bone cannot be null.");this.data=t,this.bone=n,this.color=new B,this.darkColor=t.darkColor==null?null:new B,this.setToSetupPose(),this.blendMode=this.data.blendMode}getAttachment(){return this.attachment}setAttachment(t){this.attachment!=t&&(this.attachment=t,this.attachmentTime=this.bone.skeleton.time,this.deform.length=0)}setAttachmentTime(t){this.attachmentTime=this.bone.skeleton.time-t}getAttachmentTime(){return this.bone.skeleton.time-this.attachmentTime}setToSetupPose(){this.color.setFromColor(this.data.color),this.darkColor!=null&&this.darkColor.setFromColor(this.data.darkColor),this.data.attachmentName==null?this.attachment=null:(this.attachment=null,this.setAttachment(this.bone.skeleton.getAttachment(this.data.index,this.data.attachmentName)))}}const et=class extends ce{constructor(e){super(e),this.type=xt.Region,this.x=0,this.y=0,this.scaleX=1,this.scaleY=1,this.rotation=0,this.width=0,this.height=0,this.color=new B(1,1,1,1),this.offset=T.newFloatArray(8),this.uvs=T.newFloatArray(8),this.tempColor=new B(1,1,1,1)}updateOffset(){const e=this.width/this.region.originalWidth*this.scaleX,t=this.height/this.region.originalHeight*this.scaleY,n=-this.width/2*this.scaleX+this.region.offsetX*e,s=-this.height/2*this.scaleY+this.region.offsetY*t,a=n+this.region.width*e,c=s+this.region.height*t,d=this.rotation*Math.PI/180,o=Math.cos(d),r=Math.sin(d),i=n*o+this.x,l=n*r,f=s*o+this.y,u=s*r,h=a*o+this.x,m=a*r,p=c*o+this.y,g=c*r,x=this.offset;x[et.OX1]=i-u,x[et.OY1]=f+l,x[et.OX2]=i-g,x[et.OY2]=p+l,x[et.OX3]=h-g,x[et.OY3]=p+m,x[et.OX4]=h-u,x[et.OY4]=f+m}setRegion(e){this.region=e;const t=this.uvs;e.rotate?(t[2]=e.u,t[3]=e.v2,t[4]=e.u,t[5]=e.v,t[6]=e.u2,t[7]=e.v,t[0]=e.u2,t[1]=e.v2):(t[0]=e.u,t[1]=e.v2,t[2]=e.u,t[3]=e.v,t[4]=e.u2,t[5]=e.v,t[6]=e.u2,t[7]=e.v2)}computeWorldVertices(e,t,n,s){const a=this.offset,c=e instanceof he?e.bone.matrix:e.matrix,d=c.tx,o=c.ty,r=c.a,i=c.c,l=c.b,f=c.d;let u=0,h=0;u=a[et.OX1],h=a[et.OY1],t[n]=u*r+h*i+d,t[n+1]=u*l+h*f+o,n+=s,u=a[et.OX2],h=a[et.OY2],t[n]=u*r+h*i+d,t[n+1]=u*l+h*f+o,n+=s,u=a[et.OX3],h=a[et.OY3],t[n]=u*r+h*i+d,t[n+1]=u*l+h*f+o,n+=s,u=a[et.OX4],h=a[et.OY4],t[n]=u*r+h*i+d,t[n+1]=u*l+h*f+o}copy(){const e=new et(this.name);return e.region=this.region,e.rendererObject=this.rendererObject,e.path=this.path,e.x=this.x,e.y=this.y,e.scaleX=this.scaleX,e.scaleY=this.scaleY,e.rotation=this.rotation,e.width=this.width,e.height=this.height,T.arrayCopy(this.uvs,0,e.uvs,0,8),T.arrayCopy(this.offset,0,e.offset,0,8),e.color.setFromColor(this.color),e}};let F=et;F.OX1=0,F.OY1=1,F.OX2=2,F.OY2=3,F.OX3=4,F.OY3=5,F.OX4=6,F.OY4=7,F.X1=0,F.Y1=1,F.C1R=2,F.C1G=3,F.C1B=4,F.C1A=5,F.U1=6,F.V1=7,F.X2=8,F.Y2=9,F.C2R=10,F.C2G=11,F.C2B=12,F.C2A=13,F.U2=14,F.V2=15,F.X3=16,F.Y3=17,F.C3R=18,F.C3G=19,F.C3B=20,F.C3A=21,F.U3=22,F.V3=23,F.X4=24,F.Y4=25,F.C4R=26,F.C4G=27,F.C4B=28,F.C4A=29,F.U4=30,F.V4=31;class ze{constructor(t,n){this.jitterX=0,this.jitterY=0,this.jitterX=t,this.jitterY=n}begin(t){}transform(t,n,s,a){t.x+=y.randomTriangular(-this.jitterX,this.jitterY),t.y+=y.randomTriangular(-this.jitterX,this.jitterY)}end(){}}const Ye=class{constructor(e){this.centerX=0,this.centerY=0,this.radius=0,this.angle=0,this.worldX=0,this.worldY=0,this.radius=e}begin(e){this.worldX=e.x+this.centerX,this.worldY=e.y+this.centerY}transform(e,t,n,s){const a=this.angle*y.degreesToRadians,c=e.x-this.worldX,d=e.y-this.worldY,o=Math.sqrt(c*c+d*d);if(o<this.radius){const r=Ye.interpolation.apply(0,a,(this.radius-o)/this.radius),i=Math.cos(r),l=Math.sin(r);e.x=i*c-l*d+this.worldX,e.y=l*c+i*d+this.worldY}}end(){}};let Le=Ye;Le.interpolation=new Ue(2);class z{constructor(t,n,s){if(t==null)throw new Error("name cannot be null.");if(n==null)throw new Error("timelines cannot be null.");this.name=t,this.timelines=n,this.timelineIds=[];for(let a=0;a<n.length;a++)this.timelineIds[n[a].getPropertyId()]=!0;this.duration=s}hasTimeline(t){return this.timelineIds[t]==!0}apply(t,n,s,a,c,d,o,r){if(t==null)throw new Error("skeleton cannot be null.");a&&this.duration!=0&&(s%=this.duration,n>0&&(n%=this.duration));const i=this.timelines;for(let l=0,f=i.length;l<f;l++)i[l].apply(t,n,s,c,d,o,r)}static binarySearch(t,n,s=1){let a=0,c=t.length/s-2;if(c==0)return s;let d=c>>>1;for(;;){if(t[(d+1)*s]<=n?a=d+1:c=d,a==c)return(a+1)*s;d=a+c>>>1}}static linearSearch(t,n,s){for(let a=0,c=t.length-s;a<=c;a+=s)if(t[a]>n)return a;return-1}}var Oe=(e=>(e[e.rotate=0]="rotate",e[e.translate=1]="translate",e[e.scale=2]="scale",e[e.shear=3]="shear",e[e.attachment=4]="attachment",e[e.color=5]="color",e[e.deform=6]="deform",e[e.event=7]="event",e[e.drawOrder=8]="drawOrder",e[e.ikConstraint=9]="ikConstraint",e[e.transformConstraint=10]="transformConstraint",e[e.pathConstraintPosition=11]="pathConstraintPosition",e[e.pathConstraintSpacing=12]="pathConstraintSpacing",e[e.pathConstraintMix=13]="pathConstraintMix",e[e.twoColor=14]="twoColor",e))(Oe||{});const Q=class{constructor(e){if(this.curveData=[],e<=0)throw new Error(`frameCount must be > 0: ${e}`);this.curves=T.newFloatArray((e-1)*Q.BEZIER_SIZE)}getFrameCount(){return this.curves.length/Q.BEZIER_SIZE+1}setLinear(e){this.curves[e*Q.BEZIER_SIZE]=Q.LINEAR}setStepped(e){this.curves[e*Q.BEZIER_SIZE]=Q.STEPPED}getCurveType(e){const t=e*Q.BEZIER_SIZE;if(t==this.curves.length)return Q.LINEAR;const n=this.curves[t];return n==Q.LINEAR?Q.LINEAR:n==Q.STEPPED?Q.STEPPED:Q.BEZIER}setCurve(e,t,n,s,a){this.curveData.push({frameIndex:e,cx1:t,cy1:n,cx2:s,cy2:a});const c=(-t*2+s)*.03,d=(-n*2+a)*.03,o=((t-s)*3+1)*.006,r=((n-a)*3+1)*.006;let i=c*2+o,l=d*2+r,f=t*.3+c+o*.16666667,u=n*.3+d+r*.16666667,h=e*Q.BEZIER_SIZE;const m=this.curves;m[h++]=Q.BEZIER;let p=f,g=u;for(let x=h+Q.BEZIER_SIZE-1;h<x;h+=2)m[h]=p,m[h+1]=g,f+=i,u+=l,i+=o,l+=r,p+=f,g+=u}getCurvePercent(e,t){t=y.clamp(t,0,1);const n=this.curves;let s=e*Q.BEZIER_SIZE;const a=n[s];if(a==Q.LINEAR)return t;if(a==Q.STEPPED)return 0;s++;let c=0;for(let o=s,r=s+Q.BEZIER_SIZE-1;s<r;s+=2)if(c=n[s],c>=t){let i,l;return s==o?(i=0,l=0):(i=n[s-2],l=n[s-1]),l+(n[s+1]-l)*(t-i)/(c-i)}const d=n[s-1];return d+(1-d)*(t-c)/(1-c)}};let ut=Q;ut.LINEAR=0,ut.STEPPED=1,ut.BEZIER=2,ut.BEZIER_SIZE=10*2-1;const Nt=class extends ut{constructor(e){super(e),this.type="RotateTimeline",this.data=[],this.frames=T.newFloatArray(e<<1)}getPropertyId(){return(0<<24)+this.boneIndex}setFrame(e,t,n){this.data.push({frameIndex:e,time:t,degrees:n}),e<<=1,this.frames[e]=t,this.frames[e+Nt.ROTATION]=n}apply(e,t,n,s,a,c,d){const o=this.frames,r=e.bones[this.boneIndex];if(!r.active)return;if(n<o[0]){switch(c){case R.setup:r.rotation=r.data.rotation;return;case R.first:const m=r.data.rotation-r.rotation;r.rotation+=(m-(16384-(16384.499999999996-m/360|0))*360)*a}return}if(n>=o[o.length-Nt.ENTRIES]){let m=o[o.length+Nt.PREV_ROTATION];switch(c){case R.setup:r.rotation=r.data.rotation+m*a;break;case R.first:case R.replace:m+=r.data.rotation-r.rotation,m-=(16384-(16384.499999999996-m/360|0))*360;case R.add:r.rotation+=m*a}return}const i=z.binarySearch(o,n,Nt.ENTRIES),l=o[i+Nt.PREV_ROTATION],f=o[i],u=this.getCurvePercent((i>>1)-1,1-(n-f)/(o[i+Nt.PREV_TIME]-f));let h=o[i+Nt.ROTATION]-l;switch(h=l+(h-(16384-(16384.499999999996-h/360|0))*360)*u,c){case R.setup:r.rotation=r.data.rotation+(h-(16384-(16384.499999999996-h/360|0))*360)*a;break;case R.first:case R.replace:h+=r.data.rotation-r.rotation;case R.add:r.rotation+=(h-(16384-(16384.499999999996-h/360|0))*360)*a}}};let st=Nt;st.ENTRIES=2,st.PREV_TIME=-2,st.PREV_ROTATION=-1,st.ROTATION=1;const ot=class extends ut{constructor(e){super(e),this.type="TranslateTimeline",this.data=[],this.frames=T.newFloatArray(e*ot.ENTRIES)}getPropertyId(){return(1<<24)+this.boneIndex}setFrame(e,t,n,s){this.data.push({frameIndex:e,time:t,x:n,y:s}),e*=ot.ENTRIES,this.frames[e]=t,this.frames[e+ot.X]=n,this.frames[e+ot.Y]=s}apply(e,t,n,s,a,c,d){const o=this.frames,r=e.bones[this.boneIndex];if(!r.active)return;if(n<o[0]){switch(c){case R.setup:r.x=r.data.x,r.y=r.data.y;return;case R.first:r.x+=(r.data.x-r.x)*a,r.y+=(r.data.y-r.y)*a}return}let i=0,l=0;if(n>=o[o.length-ot.ENTRIES])i=o[o.length+ot.PREV_X],l=o[o.length+ot.PREV_Y];else{const f=z.binarySearch(o,n,ot.ENTRIES);i=o[f+ot.PREV_X],l=o[f+ot.PREV_Y];const u=o[f],h=this.getCurvePercent(f/ot.ENTRIES-1,1-(n-u)/(o[f+ot.PREV_TIME]-u));i+=(o[f+ot.X]-i)*h,l+=(o[f+ot.Y]-l)*h}switch(c){case R.setup:r.x=r.data.x+i*a,r.y=r.data.y+l*a;break;case R.first:case R.replace:r.x+=(r.data.x+i-r.x)*a,r.y+=(r.data.y+l-r.y)*a;break;case R.add:r.x+=i*a,r.y+=l*a}}};let Et=ot;Et.ENTRIES=3,Et.PREV_TIME=-3,Et.PREV_X=-2,Et.PREV_Y=-1,Et.X=1,Et.Y=2;class gt extends Et{constructor(t){super(t),this.type="ScaleTimeline"}getPropertyId(){return(2<<24)+this.boneIndex}apply(t,n,s,a,c,d,o){const r=this.frames,i=t.bones[this.boneIndex];if(!i.active)return;if(s<r[0]){switch(d){case R.setup:i.scaleX=i.data.scaleX,i.scaleY=i.data.scaleY;return;case R.first:i.scaleX+=(i.data.scaleX-i.scaleX)*c,i.scaleY+=(i.data.scaleY-i.scaleY)*c}return}let l=0,f=0;if(s>=r[r.length-gt.ENTRIES])l=r[r.length+gt.PREV_X]*i.data.scaleX,f=r[r.length+gt.PREV_Y]*i.data.scaleY;else{const u=z.binarySearch(r,s,gt.ENTRIES);l=r[u+gt.PREV_X],f=r[u+gt.PREV_Y];const h=r[u],m=this.getCurvePercent(u/gt.ENTRIES-1,1-(s-h)/(r[u+gt.PREV_TIME]-h));l=(l+(r[u+gt.X]-l)*m)*i.data.scaleX,f=(f+(r[u+gt.Y]-f)*m)*i.data.scaleY}if(c==1)d==R.add?(i.scaleX+=l-i.data.scaleX,i.scaleY+=f-i.data.scaleY):(i.scaleX=l,i.scaleY=f);else{let u=0,h=0;if(o==St.mixOut)switch(d){case R.setup:u=i.data.scaleX,h=i.data.scaleY,i.scaleX=u+(Math.abs(l)*y.signum(u)-u)*c,i.scaleY=h+(Math.abs(f)*y.signum(h)-h)*c;break;case R.first:case R.replace:u=i.scaleX,h=i.scaleY,i.scaleX=u+(Math.abs(l)*y.signum(u)-u)*c,i.scaleY=h+(Math.abs(f)*y.signum(h)-h)*c;break;case R.add:u=i.scaleX,h=i.scaleY,i.scaleX=u+(Math.abs(l)*y.signum(u)-i.data.scaleX)*c,i.scaleY=h+(Math.abs(f)*y.signum(h)-i.data.scaleY)*c}else switch(d){case R.setup:u=Math.abs(i.data.scaleX)*y.signum(l),h=Math.abs(i.data.scaleY)*y.signum(f),i.scaleX=u+(l-u)*c,i.scaleY=h+(f-h)*c;break;case R.first:case R.replace:u=Math.abs(i.scaleX)*y.signum(l),h=Math.abs(i.scaleY)*y.signum(f),i.scaleX=u+(l-u)*c,i.scaleY=h+(f-h)*c;break;case R.add:u=y.signum(l),h=y.signum(f),i.scaleX=Math.abs(i.scaleX)*u+(l-Math.abs(i.data.scaleX)*u)*c,i.scaleY=Math.abs(i.scaleY)*h+(f-Math.abs(i.data.scaleY)*h)*c}}}}class pt extends Et{constructor(t){super(t),this.type="ShearTimeline"}getPropertyId(){return(3<<24)+this.boneIndex}apply(t,n,s,a,c,d,o){const r=this.frames,i=t.bones[this.boneIndex];if(!i.active)return;if(s<r[0]){switch(d){case R.setup:i.shearX=i.data.shearX,i.shearY=i.data.shearY;return;case R.first:i.shearX+=(i.data.shearX-i.shearX)*c,i.shearY+=(i.data.shearY-i.shearY)*c}return}let l=0,f=0;if(s>=r[r.length-pt.ENTRIES])l=r[r.length+pt.PREV_X],f=r[r.length+pt.PREV_Y];else{const u=z.binarySearch(r,s,pt.ENTRIES);l=r[u+pt.PREV_X],f=r[u+pt.PREV_Y];const h=r[u],m=this.getCurvePercent(u/pt.ENTRIES-1,1-(s-h)/(r[u+pt.PREV_TIME]-h));l=l+(r[u+pt.X]-l)*m,f=f+(r[u+pt.Y]-f)*m}switch(d){case R.setup:i.shearX=i.data.shearX+l*c,i.shearY=i.data.shearY+f*c;break;case R.first:case R.replace:i.shearX+=(i.data.shearX+l-i.shearX)*c,i.shearY+=(i.data.shearY+f-i.shearY)*c;break;case R.add:i.shearX+=l*c,i.shearY+=f*c}}}const q=class extends ut{constructor(e){super(e),this.type="ColorTimeline",this.data=[],this.frames=T.newFloatArray(e*q.ENTRIES)}getPropertyId(){return(5<<24)+this.slotIndex}setFrame(e,t,n,s,a,c){this.data.push({frameIndex:e,time:t,r:n,g:s,b:a,a:c}),e*=q.ENTRIES,this.frames[e]=t,this.frames[e+q.R]=n,this.frames[e+q.G]=s,this.frames[e+q.B]=a,this.frames[e+q.A]=c}apply(e,t,n,s,a,c,d){const o=e.slots[this.slotIndex];if(!o.bone.active)return;const r=this.frames;if(n<r[0]){switch(c){case R.setup:o.color.setFromColor(o.data.color);return;case R.first:const h=o.color,m=o.data.color;h.add((m.r-h.r)*a,(m.g-h.g)*a,(m.b-h.b)*a,(m.a-h.a)*a)}return}let i=0,l=0,f=0,u=0;if(n>=r[r.length-q.ENTRIES]){const h=r.length;i=r[h+q.PREV_R],l=r[h+q.PREV_G],f=r[h+q.PREV_B],u=r[h+q.PREV_A]}else{const h=z.binarySearch(r,n,q.ENTRIES);i=r[h+q.PREV_R],l=r[h+q.PREV_G],f=r[h+q.PREV_B],u=r[h+q.PREV_A];const m=r[h],p=this.getCurvePercent(h/q.ENTRIES-1,1-(n-m)/(r[h+q.PREV_TIME]-m));i+=(r[h+q.R]-i)*p,l+=(r[h+q.G]-l)*p,f+=(r[h+q.B]-f)*p,u+=(r[h+q.A]-u)*p}if(a==1)o.color.set(i,l,f,u);else{const h=o.color;c==R.setup&&h.setFromColor(o.data.color),h.add((i-h.r)*a,(l-h.g)*a,(f-h.b)*a,(u-h.a)*a)}}};let lt=q;lt.ENTRIES=5,lt.PREV_TIME=-5,lt.PREV_R=-4,lt.PREV_G=-3,lt.PREV_B=-2,lt.PREV_A=-1,lt.R=1,lt.G=2,lt.B=3,lt.A=4;const X=class extends ut{constructor(e){super(e),this.type="TwoColorTimeline",this.data=[],this.frames=T.newFloatArray(e*X.ENTRIES)}getPropertyId(){return(14<<24)+this.slotIndex}setFrame(e,t,n,s,a,c,d,o,r){this.data.push({frameIndex:e,time:t,r:n,g:s,b:a,a:c,r2:d,g2:o,b2:r}),e*=X.ENTRIES,this.frames[e]=t,this.frames[e+X.R]=n,this.frames[e+X.G]=s,this.frames[e+X.B]=a,this.frames[e+X.A]=c,this.frames[e+X.R2]=d,this.frames[e+X.G2]=o,this.frames[e+X.B2]=r}apply(e,t,n,s,a,c,d){const o=e.slots[this.slotIndex];if(!o.bone.active)return;const r=this.frames;if(n<r[0]){switch(c){case R.setup:o.color.setFromColor(o.data.color),o.darkColor.setFromColor(o.data.darkColor);return;case R.first:const g=o.color,x=o.darkColor,E=o.data.color,w=o.data.darkColor;g.add((E.r-g.r)*a,(E.g-g.g)*a,(E.b-g.b)*a,(E.a-g.a)*a),x.add((w.r-x.r)*a,(w.g-x.g)*a,(w.b-x.b)*a,0)}return}let i=0,l=0,f=0,u=0,h=0,m=0,p=0;if(n>=r[r.length-X.ENTRIES]){const g=r.length;i=r[g+X.PREV_R],l=r[g+X.PREV_G],f=r[g+X.PREV_B],u=r[g+X.PREV_A],h=r[g+X.PREV_R2],m=r[g+X.PREV_G2],p=r[g+X.PREV_B2]}else{const g=z.binarySearch(r,n,X.ENTRIES);i=r[g+X.PREV_R],l=r[g+X.PREV_G],f=r[g+X.PREV_B],u=r[g+X.PREV_A],h=r[g+X.PREV_R2],m=r[g+X.PREV_G2],p=r[g+X.PREV_B2];const x=r[g],E=this.getCurvePercent(g/X.ENTRIES-1,1-(n-x)/(r[g+X.PREV_TIME]-x));i+=(r[g+X.R]-i)*E,l+=(r[g+X.G]-l)*E,f+=(r[g+X.B]-f)*E,u+=(r[g+X.A]-u)*E,h+=(r[g+X.R2]-h)*E,m+=(r[g+X.G2]-m)*E,p+=(r[g+X.B2]-p)*E}if(a==1)o.color.set(i,l,f,u),o.darkColor.set(h,m,p,1);else{const g=o.color,x=o.darkColor;c==R.setup&&(g.setFromColor(o.data.color),x.setFromColor(o.data.darkColor)),g.add((i-g.r)*a,(l-g.g)*a,(f-g.b)*a,(u-g.a)*a),x.add((h-x.r)*a,(m-x.g)*a,(p-x.b)*a,0)}}};let tt=X;tt.ENTRIES=8,tt.PREV_TIME=-8,tt.PREV_R=-7,tt.PREV_G=-6,tt.PREV_B=-5,tt.PREV_A=-4,tt.PREV_R2=-3,tt.PREV_G2=-2,tt.PREV_B2=-1,tt.R=1,tt.G=2,tt.B=3,tt.A=4,tt.R2=5,tt.G2=6,tt.B2=7;class Dt{constructor(t){this.type="AttachmentTimeline",this.data=[],this.frames=T.newFloatArray(t),this.attachmentNames=new Array(t)}getPropertyId(){return(4<<24)+this.slotIndex}getFrameCount(){return this.frames.length}setFrame(t,n,s){this.data.push({frameIndex:t,time:n,attachmentName:s}),this.frames[t]=n,this.attachmentNames[t]=s}apply(t,n,s,a,c,d,o){const r=t.slots[this.slotIndex];if(!r.bone.active)return;if(o==St.mixOut){d==R.setup&&this.setAttachment(t,r,r.data.attachmentName);return}const i=this.frames;if(s<i[0]){(d==R.setup||d==R.first)&&this.setAttachment(t,r,r.data.attachmentName);return}let l=0;s>=i[i.length-1]?l=i.length-1:l=z.binarySearch(i,s,1)-1;const f=this.attachmentNames[l];t.slots[this.slotIndex].setAttachment(f==null?null:t.getAttachment(this.slotIndex,f))}setAttachment(t,n,s){n.setAttachment(s==null?null:t.getAttachment(this.slotIndex,s))}}let Xe=null;class de extends ut{constructor(t){super(t),this.type="DeformTimeline",this.data=[],this.frames=T.newFloatArray(t),this.frameVertices=new Array(t),Xe==null&&(Xe=T.newFloatArray(64))}getPropertyId(){return(6<<27)+Number(this.attachment.id)+this.slotIndex}setFrame(t,n,s,a){this.data.push({frameIndex:t,time:n,vertices:s,skin:a}),this.frames[t]=n,this.frameVertices[t]=s}apply(t,n,s,a,c,d,o){const r=t.slots[this.slotIndex];if(!r.bone.active)return;const i=r.getAttachment();if(!(i instanceof Ft)||i.deformAttachment!=this.attachment)return;const l=r.deform||[];l.length==0&&(d=R.setup);const f=this.frameVertices,u=f[0].length,h=this.frames;if(s<h[0]){const M=i;switch(d){case R.setup:l.length=0;return;case R.first:if(c==1){l.length=0;break}const b=T.setArraySize(l,u);if(M.bones==null){const S=M.vertices;for(let A=0;A<u;A++)b[A]+=(S[A]-b[A])*c}else{c=1-c;for(let S=0;S<u;S++)b[S]*=c}}return}const m=T.setArraySize(l,u);if(s>=h[h.length-1]){const M=f[h.length-1];if(c==1)if(d==R.add){const b=i;if(b.bones==null){const S=b.vertices;for(let A=0;A<u;A++)m[A]+=M[A]-S[A]}else for(let S=0;S<u;S++)m[S]+=M[S]}else T.arrayCopy(M,0,m,0,u);else switch(d){case R.setup:{const S=i;if(S.bones==null){const A=S.vertices;for(let C=0;C<u;C++){const I=A[C];m[C]=I+(M[C]-I)*c}}else for(let A=0;A<u;A++)m[A]=M[A]*c;break}case R.first:case R.replace:for(let S=0;S<u;S++)m[S]+=(M[S]-m[S])*c;break;case R.add:const b=i;if(b.bones==null){const S=b.vertices;for(let A=0;A<u;A++)m[A]+=(M[A]-S[A])*c}else for(let S=0;S<u;S++)m[S]+=M[S]*c}return}const p=z.binarySearch(h,s),g=f[p-1],x=f[p],E=h[p],w=this.getCurvePercent(p-1,1-(s-E)/(h[p-1]-E));if(c==1)if(d==R.add){const M=i;if(M.bones==null){const b=M.vertices;for(let S=0;S<u;S++){const A=g[S];m[S]+=A+(x[S]-A)*w-b[S]}}else for(let b=0;b<u;b++){const S=g[b];m[b]+=S+(x[b]-S)*w}}else for(let M=0;M<u;M++){const b=g[M];m[M]=b+(x[M]-b)*w}else switch(d){case R.setup:{const b=i;if(b.bones==null){const S=b.vertices;for(let A=0;A<u;A++){const C=g[A],I=S[A];m[A]=I+(C+(x[A]-C)*w-I)*c}}else for(let S=0;S<u;S++){const A=g[S];m[S]=(A+(x[S]-A)*w)*c}break}case R.first:case R.replace:for(let b=0;b<u;b++){const S=g[b];m[b]+=(S+(x[b]-S)*w-m[b])*c}break;case R.add:const M=i;if(M.bones==null){const b=M.vertices;for(let S=0;S<u;S++){const A=g[S];m[S]+=(A+(x[S]-A)*w-b[S])*c}}else for(let b=0;b<u;b++){const S=g[b];m[b]+=(S+(x[b]-S)*w)*c}}}}class Qt{constructor(t){this.type="EventTimeline",this.data=[],this.frames=T.newFloatArray(t),this.events=new Array(t)}getPropertyId(){return 7<<24}getFrameCount(){return this.frames.length}setFrame(t,n){this.data.push({frameIndex:t,event:n}),this.frames[t]=n.time,this.events[t]=n}apply(t,n,s,a,c,d,o){if(a==null)return;const r=this.frames,i=this.frames.length;if(n>s)this.apply(t,n,Number.MAX_VALUE,a,c,d,o),n=-1;else if(n>=r[i-1])return;if(s<r[0])return;let l=0;if(n<r[0])l=0;else{l=z.binarySearch(r,n);const f=r[l];for(;l>0&&r[l-1]==f;)l--}for(;l<i&&s>=r[l];l++)a.push(this.events[l])}}class Wt{constructor(t){this.type="DrawOrderTimeline",this.data=[],this.frames=T.newFloatArray(t),this.drawOrders=new Array(t)}getPropertyId(){return 8<<24}getFrameCount(){return this.frames.length}setFrame(t,n,s){this.data.push({frameIndex:t,time:n,drawOrder:s}),this.frames[t]=n,this.drawOrders[t]=s}apply(t,n,s,a,c,d,o){const r=t.drawOrder,i=t.slots;if(o==St.mixOut&&d==R.setup){T.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}const l=this.frames;if(s<l[0]){(d==R.setup||d==R.first)&&T.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}let f=0;s>=l[l.length-1]?f=l.length-1:f=z.binarySearch(l,s)-1;const u=this.drawOrders[f];if(u==null)T.arrayCopy(i,0,r,0,i.length);else for(let h=0,m=u.length;h<m;h++)r[h]=i[u[h]]}}const G=class extends ut{constructor(e){super(e),this.type="IkConstraintTimeline",this.data=[],this.frames=T.newFloatArray(e*G.ENTRIES)}getPropertyId(){return(9<<24)+this.ikConstraintIndex}setFrame(e,t,n,s){this.data.push({frameIndex:e,time:t,mix:n,bendDirection:s}),e*=G.ENTRIES,this.frames[e]=t,this.frames[e+G.MIX]=n,this.frames[e+G.BEND_DIRECTION]=s}apply(e,t,n,s,a,c,d){const o=this.frames,r=e.ikConstraints[this.ikConstraintIndex];if(!r.active)return;if(n<o[0]){switch(c){case R.setup:r.mix=r.data.mix,r.softness=r.data.softness,r.bendDirection=r.data.bendDirection,r.compress=r.data.compress,r.stretch=r.data.stretch;return;case R.first:r.mix+=(r.data.mix-r.mix)*a,r.softness+=(r.data.softness-r.softness)*a,r.bendDirection=r.data.bendDirection,r.compress=r.data.compress,r.stretch=r.data.stretch}return}if(n>=o[o.length-G.ENTRIES]){c===R.setup?(r.mix=r.data.mix+(o[o.length+G.PREV_MIX]-r.data.mix)*a,r.softness=r.data.softness+(o[o.length+G.PREV_SOFTNESS]-r.data.softness)*a,d===St.mixOut?(r.bendDirection=r.data.bendDirection,r.compress=r.data.compress,r.stretch=r.data.stretch):(r.bendDirection=o[o.length+G.PREV_BEND_DIRECTION],r.compress=o[o.length+G.PREV_COMPRESS]!==0,r.stretch=o[o.length+G.PREV_STRETCH]!==0)):(r.mix+=(o[o.length+G.PREV_MIX]-r.mix)*a,r.softness+=(o[o.length+G.PREV_SOFTNESS]-r.softness)*a,d===St.mixIn&&(r.bendDirection=o[o.length+G.PREV_BEND_DIRECTION],r.compress=o[o.length+G.PREV_COMPRESS]!==0,r.stretch=o[o.length+G.PREV_STRETCH]!==0));return}const i=z.binarySearch(o,n,G.ENTRIES),l=o[i+G.PREV_MIX],f=o[i],u=this.getCurvePercent(i/G.ENTRIES-1,1-(n-f)/(o[i+G.PREV_TIME]-f));r.mix+=(l+(o[i+G.MIX]-l)*u-r.mix)*a,r.bendDirection=Math.floor(o[i+G.PREV_BEND_DIRECTION])}};let at=G;at.ENTRIES=6,at.PREV_TIME=-6,at.PREV_MIX=-5,at.PREV_SOFTNESS=-4,at.PREV_BEND_DIRECTION=-3,at.PREV_COMPRESS=-2,at.PREV_STRETCH=-1,at.MIX=1,at.SOFTNESS=2,at.BEND_DIRECTION=3,at.COMPRESS=4,at.STRETCH=5;const U=class extends ut{constructor(e){super(e),this.type="TransformConstraintTimeline",this.data=[],this.frames=T.newFloatArray(e*U.ENTRIES)}getPropertyId(){return(10<<24)+this.transformConstraintIndex}setFrame(e,t,n,s,a,c){this.data.push({frameIndex:e,time:t,rotateMix:n,translateMix:s,scaleMix:a,shearMix:c}),e*=U.ENTRIES,this.frames[e]=t,this.frames[e+U.ROTATE]=n,this.frames[e+U.TRANSLATE]=s,this.frames[e+U.SCALE]=a,this.frames[e+U.SHEAR]=c}apply(e,t,n,s,a,c,d){const o=this.frames,r=e.transformConstraints[this.transformConstraintIndex];if(!r.active)return;if(n<o[0]){const h=r.data;switch(c){case R.setup:r.rotateMix=h.rotateMix,r.translateMix=h.translateMix,r.scaleMix=h.scaleMix,r.shearMix=h.shearMix;return;case R.first:r.rotateMix+=(h.rotateMix-r.rotateMix)*a,r.translateMix+=(h.translateMix-r.translateMix)*a,r.scaleMix+=(h.scaleMix-r.scaleMix)*a,r.shearMix+=(h.shearMix-r.shearMix)*a}return}let i=0,l=0,f=0,u=0;if(n>=o[o.length-U.ENTRIES]){const h=o.length;i=o[h+U.PREV_ROTATE],l=o[h+U.PREV_TRANSLATE],f=o[h+U.PREV_SCALE],u=o[h+U.PREV_SHEAR]}else{const h=z.binarySearch(o,n,U.ENTRIES);i=o[h+U.PREV_ROTATE],l=o[h+U.PREV_TRANSLATE],f=o[h+U.PREV_SCALE],u=o[h+U.PREV_SHEAR];const m=o[h],p=this.getCurvePercent(h/U.ENTRIES-1,1-(n-m)/(o[h+U.PREV_TIME]-m));i+=(o[h+U.ROTATE]-i)*p,l+=(o[h+U.TRANSLATE]-l)*p,f+=(o[h+U.SCALE]-f)*p,u+=(o[h+U.SHEAR]-u)*p}if(c==R.setup){const h=r.data;r.rotateMix=h.rotateMix+(i-h.rotateMix)*a,r.translateMix=h.translateMix+(l-h.translateMix)*a,r.scaleMix=h.scaleMix+(f-h.scaleMix)*a,r.shearMix=h.shearMix+(u-h.shearMix)*a}else r.rotateMix+=(i-r.rotateMix)*a,r.translateMix+=(l-r.translateMix)*a,r.scaleMix+=(f-r.scaleMix)*a,r.shearMix+=(u-r.shearMix)*a}};let ct=U;ct.ENTRIES=5,ct.PREV_TIME=-5,ct.PREV_ROTATE=-4,ct.PREV_TRANSLATE=-3,ct.PREV_SCALE=-2,ct.PREV_SHEAR=-1,ct.ROTATE=1,ct.TRANSLATE=2,ct.SCALE=3,ct.SHEAR=4;const bt=class extends ut{constructor(e){super(e),this.type="PathConstraintPositionTimeline",this.data=[],this.frames=T.newFloatArray(e*bt.ENTRIES)}getPropertyId(){return(11<<24)+this.pathConstraintIndex}setFrame(e,t,n){this.data.push({frameIndex:e,time:t,value:n}),e*=bt.ENTRIES,this.frames[e]=t,this.frames[e+bt.VALUE]=n}apply(e,t,n,s,a,c,d){const o=this.frames,r=e.pathConstraints[this.pathConstraintIndex];if(!r.active)return;if(n<o[0]){switch(c){case R.setup:r.position=r.data.position;return;case R.first:r.position+=(r.data.position-r.position)*a}return}let i=0;if(n>=o[o.length-bt.ENTRIES])i=o[o.length+bt.PREV_VALUE];else{const l=z.binarySearch(o,n,bt.ENTRIES);i=o[l+bt.PREV_VALUE];const f=o[l],u=this.getCurvePercent(l/bt.ENTRIES-1,1-(n-f)/(o[l+bt.PREV_TIME]-f));i+=(o[l+bt.VALUE]-i)*u}c==R.setup?r.position=r.data.position+(i-r.data.position)*a:r.position+=(i-r.position)*a}};let Rt=bt;Rt.ENTRIES=2,Rt.PREV_TIME=-2,Rt.PREV_VALUE=-1,Rt.VALUE=1;class yt extends Rt{constructor(t){super(t),this.type="PathConstraintSpacingTimeline"}getPropertyId(){return(12<<24)+this.pathConstraintIndex}apply(t,n,s,a,c,d,o){const r=this.frames,i=t.pathConstraints[this.pathConstraintIndex];if(!i.active)return;if(s<r[0]){switch(d){case R.setup:i.spacing=i.data.spacing;return;case R.first:i.spacing+=(i.data.spacing-i.spacing)*c}return}let l=0;if(s>=r[r.length-yt.ENTRIES])l=r[r.length+yt.PREV_VALUE];else{const f=z.binarySearch(r,s,yt.ENTRIES);l=r[f+yt.PREV_VALUE];const u=r[f],h=this.getCurvePercent(f/yt.ENTRIES-1,1-(s-u)/(r[f+yt.PREV_TIME]-u));l+=(r[f+yt.VALUE]-l)*h}d==R.setup?i.spacing=i.data.spacing+(l-i.data.spacing)*c:i.spacing+=(l-i.spacing)*c}}const ht=class extends ut{constructor(e){super(e),this.type="PathConstraintMixTimeline",this.data=[],this.frames=T.newFloatArray(e*ht.ENTRIES)}getPropertyId(){return(13<<24)+this.pathConstraintIndex}setFrame(e,t,n,s){this.data.push({frameIndex:e,time:t,rotateMix:n,translateMix:s}),e*=ht.ENTRIES,this.frames[e]=t,this.frames[e+ht.ROTATE]=n,this.frames[e+ht.TRANSLATE]=s}apply(e,t,n,s,a,c,d){const o=this.frames,r=e.pathConstraints[this.pathConstraintIndex];if(!r.active)return;if(n<o[0]){switch(c){case R.setup:r.rotateMix=r.data.rotateMix,r.translateMix=r.data.translateMix;return;case R.first:r.rotateMix+=(r.data.rotateMix-r.rotateMix)*a,r.translateMix+=(r.data.translateMix-r.translateMix)*a}return}let i=0,l=0;if(n>=o[o.length-ht.ENTRIES])i=o[o.length+ht.PREV_ROTATE],l=o[o.length+ht.PREV_TRANSLATE];else{const f=z.binarySearch(o,n,ht.ENTRIES);i=o[f+ht.PREV_ROTATE],l=o[f+ht.PREV_TRANSLATE];const u=o[f],h=this.getCurvePercent(f/ht.ENTRIES-1,1-(n-u)/(o[f+ht.PREV_TIME]-u));i+=(o[f+ht.ROTATE]-i)*h,l+=(o[f+ht.TRANSLATE]-l)*h}c==R.setup?(r.rotateMix=r.data.rotateMix+(i-r.data.rotateMix)*a,r.translateMix=r.data.translateMix+(l-r.data.translateMix)*a):(r.rotateMix+=(i-r.rotateMix)*a,r.translateMix+=(l-r.translateMix)*a)}};let At=ht;At.ENTRIES=3,At.PREV_TIME=-3,At.PREV_ROTATE=-2,At.PREV_TRANSLATE=-1,At.ROTATE=1,At.TRANSLATE=2;const $=class{constructor(e){this.tracks=new Array,this.timeScale=1,this.unkeyedState=0,this.events=new Array,this.listeners=new Array,this.queue=new ue(this),this.propertyIDs=new $e,this.animationsChanged=!1,this.trackEntryPool=new He(()=>new Kt),this.data=e}update(e){e*=this.timeScale;const t=this.tracks;for(let n=0,s=t.length;n<s;n++){const a=t[n];if(a==null)continue;a.animationLast=a.nextAnimationLast,a.trackLast=a.nextTrackLast;let c=e*a.timeScale;if(a.delay>0){if(a.delay-=c,a.delay>0)continue;c=-a.delay,a.delay=0}let d=a.next;if(d!=null){const o=a.trackLast-d.delay;if(o>=0){for(d.delay=0,d.trackTime+=a.timeScale==0?0:(o/a.timeScale+e)*d.timeScale,a.trackTime+=c,this.setCurrent(n,d,!0);d.mixingFrom!=null;)d.mixTime+=e,d=d.mixingFrom;continue}}else if(a.trackLast>=a.trackEnd&&a.mixingFrom==null){t[n]=null,this.queue.end(a),this.disposeNext(a);continue}if(a.mixingFrom!=null&&this.updateMixingFrom(a,e)){let o=a.mixingFrom;for(a.mixingFrom=null,o!=null&&(o.mixingTo=null);o!=null;)this.queue.end(o),o=o.mixingFrom}a.trackTime+=c}this.queue.drain()}updateMixingFrom(e,t){const n=e.mixingFrom;if(n==null)return!0;const s=this.updateMixingFrom(n,t);return n.animationLast=n.nextAnimationLast,n.trackLast=n.nextTrackLast,e.mixTime>0&&e.mixTime>=e.mixDuration?((n.totalAlpha==0||e.mixDuration==0)&&(e.mixingFrom=n.mixingFrom,n.mixingFrom!=null&&(n.mixingFrom.mixingTo=e),e.interruptAlpha=n.interruptAlpha,this.queue.end(n)),s):(n.trackTime+=t*n.timeScale,e.mixTime+=t,!1)}apply(e){if(e==null)throw new Error("skeleton cannot be null.");this.animationsChanged&&this._animationsChanged();const t=this.events,n=this.tracks;let s=!1;for(let d=0,o=n.length;d<o;d++){const r=n[d];if(r==null||r.delay>0)continue;s=!0;const i=d==0?R.first:r.mixBlend;let l=r.alpha;r.mixingFrom!=null?l*=this.applyMixingFrom(r,e,i):r.trackTime>=r.trackEnd&&r.next==null&&(l=0);const f=r.animationLast,u=r.getAnimationTime(),h=r.animation.timelines.length,m=r.animation.timelines;if(d==0&&l==1||i==R.add)for(let p=0;p<h;p++){T.webkit602BugfixHelper(l,i);const g=m[p];g instanceof Dt?this.applyAttachmentTimeline(g,e,u,i,!0):g.apply(e,f,u,t,l,i,St.mixIn)}else{const p=r.timelineMode,g=r.timelinesRotation.length==0;g&&T.setArraySize(r.timelinesRotation,h<<1,null);const x=r.timelinesRotation;for(let E=0;E<h;E++){const w=m[E],M=p[E]==$.SUBSEQUENT?i:R.setup;w instanceof st?this.applyRotateTimeline(w,e,u,l,M,x,E<<1,g):w instanceof Dt?this.applyAttachmentTimeline(w,e,u,i,!0):(T.webkit602BugfixHelper(l,i),w.apply(e,f,u,t,l,M,St.mixIn))}}this.queueEvents(r,u),t.length=0,r.nextAnimationLast=u,r.nextTrackLast=r.trackTime}const a=this.unkeyedState+$.SETUP,c=e.slots;for(let d=0,o=e.slots.length;d<o;d++){const r=c[d];if(r.attachmentState==a){const i=r.data.attachmentName;r.setAttachment(i==null?null:e.getAttachment(r.data.index,i))}}return this.unkeyedState+=2,this.queue.drain(),s}applyMixingFrom(e,t,n){const s=e.mixingFrom;s.mixingFrom!=null&&this.applyMixingFrom(s,t,n);let a=0;e.mixDuration==0?(a=1,n==R.first&&(n=R.setup)):(a=e.mixTime/e.mixDuration,a>1&&(a=1),n!=R.first&&(n=s.mixBlend));const c=a<s.eventThreshold?this.events:null,d=a<s.attachmentThreshold,o=a<s.drawOrderThreshold,r=s.animationLast,i=s.getAnimationTime(),l=s.animation.timelines.length,f=s.animation.timelines,u=s.alpha*e.interruptAlpha,h=u*(1-a);if(n==R.add)for(let m=0;m<l;m++)f[m].apply(t,r,i,c,h,n,St.mixOut);else{const m=s.timelineMode,p=s.timelineHoldMix,g=s.timelinesRotation.length==0;g&&T.setArraySize(s.timelinesRotation,l<<1,null);const x=s.timelinesRotation;s.totalAlpha=0;for(let E=0;E<l;E++){const w=f[E];let M=St.mixOut,b,S=0;switch(m[E]){case $.SUBSEQUENT:if(!o&&w instanceof Wt)continue;b=n,S=h;break;case $.FIRST:b=R.setup,S=h;break;case $.HOLD_SUBSEQUENT:b=n,S=u;break;case $.HOLD_FIRST:b=R.setup,S=u;break;default:b=R.setup;const A=p[E];S=u*Math.max(0,1-A.mixTime/A.mixDuration);break}s.totalAlpha+=S,w instanceof st?this.applyRotateTimeline(w,t,i,S,b,x,E<<1,g):w instanceof Dt?this.applyAttachmentTimeline(w,t,i,b,d):(T.webkit602BugfixHelper(S,n),o&&w instanceof Wt&&b==R.setup&&(M=St.mixIn),w.apply(t,r,i,c,S,b,M))}}return e.mixDuration>0&&this.queueEvents(s,i),this.events.length=0,s.nextAnimationLast=i,s.nextTrackLast=s.trackTime,a}applyAttachmentTimeline(e,t,n,s,a){const c=t.slots[e.slotIndex];if(!c.bone.active)return;const d=e.frames;if(n<d[0])(s==R.setup||s==R.first)&&this.setAttachment(t,c,c.data.attachmentName,a);else{let o;n>=d[d.length-1]?o=d.length-1:o=z.binarySearch(d,n)-1,this.setAttachment(t,c,e.attachmentNames[o],a)}c.attachmentState<=this.unkeyedState&&(c.attachmentState=this.unkeyedState+$.SETUP)}setAttachment(e,t,n,s){t.setAttachment(n==null?null:e.getAttachment(t.data.index,n)),s&&(t.attachmentState=this.unkeyedState+$.CURRENT)}applyRotateTimeline(e,t,n,s,a,c,d,o){if(o&&(c[d]=0),s==1){e.apply(t,0,n,null,1,a,St.mixIn);return}const r=e,i=r.frames,l=t.bones[r.boneIndex];if(!l.active)return;let f=0,u=0;if(n<i[0])switch(a){case R.setup:l.rotation=l.data.rotation;default:return;case R.first:f=l.rotation,u=l.data.rotation}else if(f=a==R.setup?l.data.rotation:l.rotation,n>=i[i.length-st.ENTRIES])u=l.data.rotation+i[i.length+st.PREV_ROTATION];else{const p=z.binarySearch(i,n,st.ENTRIES),g=i[p+st.PREV_ROTATION],x=i[p],E=r.getCurvePercent((p>>1)-1,1-(n-x)/(i[p+st.PREV_TIME]-x));u=i[p+st.ROTATION]-g,u-=(16384-(16384.499999999996-u/360|0))*360,u=g+u*E+l.data.rotation,u-=(16384-(16384.499999999996-u/360|0))*360}let h=0,m=u-f;if(m-=(16384-(16384.499999999996-m/360|0))*360,m==0)h=c[d];else{let p=0,g=0;o?(p=0,g=m):(p=c[d],g=c[d+1]);const x=m>0;let E=p>=0;y.signum(g)!=y.signum(m)&&Math.abs(g)<=90&&(Math.abs(p)>180&&(p+=360*y.signum(p)),E=x),h=m+p-p%360,E!=x&&(h+=360*y.signum(p)),c[d]=h}c[d+1]=m,f+=h*s,l.rotation=f-(16384-(16384.499999999996-f/360|0))*360}queueEvents(e,t){const n=e.animationStart,s=e.animationEnd,a=s-n,c=e.trackLast%a,d=this.events;let o=0;const r=d.length;for(;o<r;o++){const l=d[o];if(l.time<c)break;l.time>s||this.queue.event(e,l)}let i=!1;for(e.loop?i=a==0||c>e.trackTime%a:i=t>=s&&e.animationLast<s,i&&this.queue.complete(e);o<r;o++)d[o].time<n||this.queue.event(e,d[o])}clearTracks(){const e=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let t=0,n=this.tracks.length;t<n;t++)this.clearTrack(t);this.tracks.length=0,this.queue.drainDisabled=e,this.queue.drain()}clearTrack(e){if(e>=this.tracks.length)return;const t=this.tracks[e];if(t==null)return;this.queue.end(t),this.disposeNext(t);let n=t;for(;;){const s=n.mixingFrom;if(s==null)break;this.queue.end(s),n.mixingFrom=null,n.mixingTo=null,n=s}this.tracks[t.trackIndex]=null,this.queue.drain()}setCurrent(e,t,n){const s=this.expandToIndex(e);this.tracks[e]=t,s!=null&&(n&&this.queue.interrupt(s),t.mixingFrom=s,s.mixingTo=t,t.mixTime=0,s.mixingFrom!=null&&s.mixDuration>0&&(t.interruptAlpha*=Math.min(1,s.mixTime/s.mixDuration)),s.timelinesRotation.length=0),this.queue.start(t)}setAnimation(e,t,n){const s=this.data.skeletonData.findAnimation(t);if(s==null)throw new Error(`Animation not found: ${t}`);return this.setAnimationWith(e,s,n)}setAnimationWith(e,t,n){if(t==null)throw new Error("animation cannot be null.");let s=!0,a=this.expandToIndex(e);a!=null&&(a.nextTrackLast==-1?(this.tracks[e]=a.mixingFrom,this.queue.interrupt(a),this.queue.end(a),this.disposeNext(a),a=a.mixingFrom,s=!1):this.disposeNext(a));const c=this.trackEntry(e,t,n,a);return this.setCurrent(e,c,s),this.queue.drain(),c}addAnimation(e,t,n,s){const a=this.data.skeletonData.findAnimation(t);if(a==null)throw new Error(`Animation not found: ${t}`);return this.addAnimationWith(e,a,n,s)}addAnimationWith(e,t,n,s){if(t==null)throw new Error("animation cannot be null.");let a=this.expandToIndex(e);if(a!=null)for(;a.next!=null;)a=a.next;const c=this.trackEntry(e,t,n,a);if(a==null)this.setCurrent(e,c,!0),this.queue.drain();else if(a.next=c,s<=0){const d=a.animationEnd-a.animationStart;d!=0?(a.loop?s+=d*(1+(a.trackTime/d|0)):s+=Math.max(d,a.trackTime),s-=this.data.getMix(a.animation,t)):s=a.trackTime}return c.delay=s,c}setEmptyAnimation(e,t){const n=this.setAnimationWith(e,$.emptyAnimation,!1);return n.mixDuration=t,n.trackEnd=t,n}addEmptyAnimation(e,t,n){n<=0&&(n-=t);const s=this.addAnimationWith(e,$.emptyAnimation,!1,n);return s.mixDuration=t,s.trackEnd=t,s}setEmptyAnimations(e){const t=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let n=0,s=this.tracks.length;n<s;n++){const a=this.tracks[n];a!=null&&this.setEmptyAnimation(a.trackIndex,e)}this.queue.drainDisabled=t,this.queue.drain()}expandToIndex(e){return e<this.tracks.length?this.tracks[e]:(T.ensureArrayCapacity(this.tracks,e+1,null),this.tracks.length=e+1,null)}trackEntry(e,t,n,s){const a=this.trackEntryPool.obtain();return a.trackIndex=e,a.animation=t,a.loop=n,a.holdPrevious=!1,a.eventThreshold=0,a.attachmentThreshold=0,a.drawOrderThreshold=0,a.animationStart=0,a.animationEnd=t.duration,a.animationLast=-1,a.nextAnimationLast=-1,a.delay=0,a.trackTime=0,a.trackLast=-1,a.nextTrackLast=-1,a.trackEnd=Number.MAX_VALUE,a.timeScale=1,a.alpha=1,a.interruptAlpha=1,a.mixTime=0,a.mixDuration=s==null?0:this.data.getMix(s.animation,t),a.mixBlend=R.replace,a}disposeNext(e){let t=e.next;for(;t!=null;)this.queue.dispose(t),t=t.next;e.next=null}_animationsChanged(){this.animationsChanged=!1,this.propertyIDs.clear();for(let e=0,t=this.tracks.length;e<t;e++){let n=this.tracks[e];if(n!=null){for(;n.mixingFrom!=null;)n=n.mixingFrom;do(n.mixingFrom==null||n.mixBlend!=R.add)&&this.computeHold(n),n=n.mixingTo;while(n!=null)}}}computeHold(e){const t=e.mixingTo,n=e.animation.timelines,s=e.animation.timelines.length,a=T.setArraySize(e.timelineMode,s);e.timelineHoldMix.length=0;const c=T.setArraySize(e.timelineHoldMix,s),d=this.propertyIDs;if(t!=null&&t.holdPrevious){for(let o=0;o<s;o++)a[o]=d.add(n[o].getPropertyId())?$.HOLD_FIRST:$.HOLD_SUBSEQUENT;return}t:for(let o=0;o<s;o++){const r=n[o],i=r.getPropertyId();if(!d.add(i))a[o]=$.SUBSEQUENT;else if(t==null||r instanceof Dt||r instanceof Wt||r instanceof Qt||!t.animation.hasTimeline(i))a[o]=$.FIRST;else{for(let l=t.mixingTo;l!=null;l=l.mixingTo)if(!l.animation.hasTimeline(i)){if(e.mixDuration>0){a[o]=$.HOLD_MIX,c[o]=l;continue t}break}a[o]=$.HOLD_FIRST}}}getCurrent(e){return e>=this.tracks.length?null:this.tracks[e]}addListener(e){if(e==null)throw new Error("listener cannot be null.");this.listeners.push(e)}removeListener(e){const t=this.listeners.indexOf(e);t>=0&&this.listeners.splice(t,1)}clearListeners(){this.listeners.length=0}clearListenerNotifications(){this.queue.clear()}setAnimationByName(e,t,n){$.deprecatedWarning1||($.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.")),this.setAnimation(e,t,n)}addAnimationByName(e,t,n,s){$.deprecatedWarning2||($.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.")),this.addAnimation(e,t,n,s)}hasAnimation(e){return this.data.skeletonData.findAnimation(e)!==null}hasAnimationByName(e){return $.deprecatedWarning3||($.deprecatedWarning3=!0,console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.")),this.hasAnimation(e)}};let wt=$;wt.emptyAnimation=new z("<empty>",[],0),wt.SUBSEQUENT=0,wt.FIRST=1,wt.HOLD_SUBSEQUENT=2,wt.HOLD_FIRST=3,wt.HOLD_MIX=4,wt.SETUP=1,wt.CURRENT=2,wt.deprecatedWarning1=!1,wt.deprecatedWarning2=!1,wt.deprecatedWarning3=!1;const vt=class{constructor(){this.mixBlend=R.replace,this.timelineMode=new Array,this.timelineHoldMix=new Array,this.timelinesRotation=new Array}reset(){this.next=null,this.mixingFrom=null,this.mixingTo=null,this.animation=null,this.listener=null,this.timelineMode.length=0,this.timelineHoldMix.length=0,this.timelinesRotation.length=0}getAnimationTime(){if(this.loop){const e=this.animationEnd-this.animationStart;return e==0?this.animationStart:this.trackTime%e+this.animationStart}return Math.min(this.trackTime+this.animationStart,this.animationEnd)}setAnimationLast(e){this.animationLast=e,this.nextAnimationLast=e}isComplete(){return this.trackTime>=this.animationEnd-this.animationStart}resetRotationDirections(){this.timelinesRotation.length=0}get time(){return vt.deprecatedWarning1||(vt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime}set time(e){vt.deprecatedWarning1||(vt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime=e}get endTime(){return vt.deprecatedWarning2||(vt.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime}set endTime(e){vt.deprecatedWarning2||(vt.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime=e}loopsCount(){return Math.floor(this.trackTime/this.trackEnd)}};let Kt=vt;Kt.deprecatedWarning1=!1,Kt.deprecatedWarning2=!1;const fe=class{constructor(e){this.objects=[],this.drainDisabled=!1,this.animState=e}start(e){this.objects.push(mt.start),this.objects.push(e),this.animState.animationsChanged=!0}interrupt(e){this.objects.push(mt.interrupt),this.objects.push(e)}end(e){this.objects.push(mt.end),this.objects.push(e),this.animState.animationsChanged=!0}dispose(e){this.objects.push(mt.dispose),this.objects.push(e)}complete(e){this.objects.push(mt.complete),this.objects.push(e)}event(e,t){this.objects.push(mt.event),this.objects.push(e),this.objects.push(t)}deprecateStuff(){return fe.deprecatedWarning1||(fe.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'")),!0}drain(){if(this.drainDisabled)return;this.drainDisabled=!0;const e=this.objects,t=this.animState.listeners;for(let n=0;n<e.length;n+=2){const s=e[n],a=e[n+1];switch(s){case mt.start:a.listener!=null&&a.listener.start&&a.listener.start(a);for(let o=0;o<t.length;o++)t[o].start&&t[o].start(a);a.onStart&&this.deprecateStuff()&&a.onStart(a.trackIndex),this.animState.onStart&&this.deprecateStuff()&&this.deprecateStuff&&this.animState.onStart(a.trackIndex);break;case mt.interrupt:a.listener!=null&&a.listener.interrupt&&a.listener.interrupt(a);for(let o=0;o<t.length;o++)t[o].interrupt&&t[o].interrupt(a);break;case mt.end:a.listener!=null&&a.listener.end&&a.listener.end(a);for(let o=0;o<t.length;o++)t[o].end&&t[o].end(a);a.onEnd&&this.deprecateStuff()&&a.onEnd(a.trackIndex),this.animState.onEnd&&this.deprecateStuff()&&this.animState.onEnd(a.trackIndex);case mt.dispose:a.listener!=null&&a.listener.dispose&&a.listener.dispose(a);for(let o=0;o<t.length;o++)t[o].dispose&&t[o].dispose(a);this.animState.trackEntryPool.free(a);break;case mt.complete:a.listener!=null&&a.listener.complete&&a.listener.complete(a);for(let o=0;o<t.length;o++)t[o].complete&&t[o].complete(a);const c=y.toInt(a.loopsCount());a.onComplete&&this.deprecateStuff()&&a.onComplete(a.trackIndex,c),this.animState.onComplete&&this.deprecateStuff()&&this.animState.onComplete(a.trackIndex,c);break;case mt.event:const d=e[n+++2];a.listener!=null&&a.listener.event&&a.listener.event(a,d);for(let o=0;o<t.length;o++)t[o].event&&t[o].event(a,d);a.onEvent&&this.deprecateStuff()&&a.onEvent(a.trackIndex,d),this.animState.onEvent&&this.deprecateStuff()&&this.animState.onEvent(a.trackIndex,d);break}}this.clear(),this.drainDisabled=!1}clear(){this.objects.length=0}};let ue=fe;ue.deprecatedWarning1=!1;var mt=(e=>(e[e.start=0]="start",e[e.interrupt=1]="interrupt",e[e.end=2]="end",e[e.dispose=3]="dispose",e[e.complete=4]="complete",e[e.event=5]="event",e))(mt||{});class Qe{start(t){}interrupt(t){}end(t){}dispose(t){}complete(t){}event(t,n){}}const me=class{constructor(e){if(this.animationToMixTime={},this.defaultMix=0,e==null)throw new Error("skeletonData cannot be null.");this.skeletonData=e}setMix(e,t,n){const s=this.skeletonData.findAnimation(e);if(s==null)throw new Error(`Animation not found: ${e}`);const a=this.skeletonData.findAnimation(t);if(a==null)throw new Error(`Animation not found: ${t}`);this.setMixWith(s,a,n)}setMixByName(e,t,n){me.deprecatedWarning1||(me.deprecatedWarning1=!0,console.warn("Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.")),this.setMix(e,t,n)}setMixWith(e,t,n){if(e==null)throw new Error("from cannot be null.");if(t==null)throw new Error("to cannot be null.");const s=`${e.name}.${t.name}`;this.animationToMixTime[s]=n}getMix(e,t){const n=`${e.name}.${t.name}`,s=this.animationToMixTime[n];return s===void 0?this.defaultMix:s}};let ge=me;ge.deprecatedWarning1=!1;class _e{constructor(t){this.atlas=t}newRegionAttachment(t,n,s){const a=this.atlas.findRegion(s);if(a==null)throw new Error(`Region not found in atlas: ${s} (region attachment: ${n})`);const c=new F(n);return c.region=a,c}newMeshAttachment(t,n,s){const a=this.atlas.findRegion(s);if(a==null)throw new Error(`Region not found in atlas: ${s} (mesh attachment: ${n})`);const c=new Xt(n);return c.region=a,c}newBoundingBoxAttachment(t,n){return new ee(n)}newPathAttachment(t,n){return new Lt(n)}newPointAttachment(t,n){return new se(n)}newClippingAttachment(t,n){return new ne(n)}}class pe{constructor(t,n,s){if(this.matrix=new Ze,this.children=new Array,this.x=0,this.y=0,this.rotation=0,this.scaleX=0,this.scaleY=0,this.shearX=0,this.shearY=0,this.ax=0,this.ay=0,this.arotation=0,this.ascaleX=0,this.ascaleY=0,this.ashearX=0,this.ashearY=0,this.appliedValid=!1,this.sorted=!1,this.active=!1,t==null)throw new Error("data cannot be null.");if(n==null)throw new Error("skeleton cannot be null.");this.data=t,this.skeleton=n,this.parent=s,this.setToSetupPose()}get worldX(){return this.matrix.tx}get worldY(){return this.matrix.ty}isActive(){return this.active}update(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransform(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransformWith(t,n,s,a,c,d,o){this.ax=t,this.ay=n,this.arotation=s,this.ascaleX=a,this.ascaleY=c,this.ashearX=d,this.ashearY=o,this.appliedValid=!0;const r=this.parent,i=this.matrix,l=this.skeleton.scaleX,f=ie.yDown?-this.skeleton.scaleY:this.skeleton.scaleY;if(r==null){const g=this.skeleton,x=s+90+o;i.a=y.cosDeg(s+d)*a*l,i.c=y.cosDeg(x)*c*l,i.b=y.sinDeg(s+d)*a*f,i.d=y.sinDeg(x)*c*f,i.tx=t*l+g.x,i.ty=n*f+g.y;return}let u=r.matrix.a,h=r.matrix.c,m=r.matrix.b,p=r.matrix.d;switch(i.tx=u*t+h*n+r.matrix.tx,i.ty=m*t+p*n+r.matrix.ty,this.data.transformMode){case Z.Normal:{const g=s+90+o,x=y.cosDeg(s+d)*a,E=y.cosDeg(g)*c,w=y.sinDeg(s+d)*a,M=y.sinDeg(g)*c;i.a=u*x+h*w,i.c=u*E+h*M,i.b=m*x+p*w,i.d=m*E+p*M;return}case Z.OnlyTranslation:{const g=s+90+o;i.a=y.cosDeg(s+d)*a,i.c=y.cosDeg(g)*c,i.b=y.sinDeg(s+d)*a,i.d=y.sinDeg(g)*c;break}case Z.NoRotationOrReflection:{let g=u*u+m*m,x=0;g>1e-4?(g=Math.abs(u*p-h*m)/g,u/=this.skeleton.scaleX,m/=this.skeleton.scaleY,h=m*g,p=u*g,x=Math.atan2(m,u)*y.radDeg):(u=0,m=0,x=90-Math.atan2(p,h)*y.radDeg);const E=s+d-x,w=s+o-x+90,M=y.cosDeg(E)*a,b=y.cosDeg(w)*c,S=y.sinDeg(E)*a,A=y.sinDeg(w)*c;i.a=u*M-h*S,i.c=u*b-h*A,i.b=m*M+p*S,i.d=m*b+p*A;break}case Z.NoScale:case Z.NoScaleOrReflection:{const g=y.cosDeg(s),x=y.sinDeg(s);let E=(u*g+h*x)/l,w=(m*g+p*x)/f,M=Math.sqrt(E*E+w*w);M>1e-5&&(M=1/M),E*=M,w*=M,M=Math.sqrt(E*E+w*w),this.data.transformMode==Z.NoScale&&u*p-h*m<0!=(ie.yDown?this.skeleton.scaleX<0!=this.skeleton.scaleY>0:this.skeleton.scaleX<0!=this.skeleton.scaleY<0)&&(M=-M);const b=Math.PI/2+Math.atan2(w,E),S=Math.cos(b)*M,A=Math.sin(b)*M,C=y.cosDeg(d)*a,I=y.cosDeg(90+o)*c,V=y.sinDeg(d)*a,O=y.sinDeg(90+o)*c;i.a=E*C+S*V,i.c=E*I+S*O,i.b=w*C+A*V,i.d=w*I+A*O;break}}i.a*=l,i.c*=l,i.b*=f,i.d*=f}setToSetupPose(){const t=this.data;this.x=t.x,this.y=t.y,this.rotation=t.rotation,this.scaleX=t.scaleX,this.scaleY=t.scaleY,this.shearX=t.shearX,this.shearY=t.shearY}getWorldRotationX(){return Math.atan2(this.matrix.b,this.matrix.a)*y.radDeg}getWorldRotationY(){return Math.atan2(this.matrix.d,this.matrix.c)*y.radDeg}getWorldScaleX(){const t=this.matrix;return Math.sqrt(t.a*t.a+t.c*t.c)}getWorldScaleY(){const t=this.matrix;return Math.sqrt(t.b*t.b+t.d*t.d)}updateAppliedTransform(){this.appliedValid=!0;const t=this.parent,n=this.matrix;if(t==null){this.ax=n.tx,this.ay=n.ty,this.arotation=Math.atan2(n.b,n.a)*y.radDeg,this.ascaleX=Math.sqrt(n.a*n.a+n.b*n.b),this.ascaleY=Math.sqrt(n.c*n.c+n.d*n.d),this.ashearX=0,this.ashearY=Math.atan2(n.a*n.c+n.b*n.d,n.a*n.d-n.b*n.c)*y.radDeg;return}const s=t.matrix,a=1/(s.a*s.d-s.b*s.c),c=n.tx-s.tx,d=n.ty-s.ty;this.ax=c*s.d*a-d*s.c*a,this.ay=d*s.a*a-c*s.b*a;const o=a*s.d,r=a*s.a,i=a*s.c,l=a*s.b,f=o*n.a-i*n.b,u=o*n.c-i*n.d,h=r*n.b-l*n.a,m=r*n.d-l*n.c;if(this.ashearX=0,this.ascaleX=Math.sqrt(f*f+h*h),this.ascaleX>1e-4){const p=f*m-u*h;this.ascaleY=p/this.ascaleX,this.ashearY=Math.atan2(f*u+h*m,p)*y.radDeg,this.arotation=Math.atan2(h,f)*y.radDeg}else this.ascaleX=0,this.ascaleY=Math.sqrt(u*u+m*m),this.ashearY=0,this.arotation=90-Math.atan2(m,u)*y.radDeg}worldToLocal(t){const n=this.matrix,s=n.a,a=n.c,c=n.b,d=n.d,o=1/(s*d-a*c),r=t.x-n.tx,i=t.y-n.ty;return t.x=r*d*o-i*a*o,t.y=i*s*o-r*c*o,t}localToWorld(t){const n=this.matrix,s=t.x,a=t.y;return t.x=s*n.a+a*n.c+n.tx,t.y=s*n.b+a*n.d+n.ty,t}worldToLocalRotation(t){const n=y.sinDeg(t),s=y.cosDeg(t),a=this.matrix;return Math.atan2(a.a*n-a.b*s,a.d*s-a.c*n)*y.radDeg}localToWorldRotation(t){const n=y.sinDeg(t),s=y.cosDeg(t),a=this.matrix;return Math.atan2(s*a.b+n*a.d,s*a.a+n*a.c)*y.radDeg}rotateWorld(t){const n=this.matrix,s=n.a,a=n.c,c=n.b,d=n.d,o=y.cosDeg(t),r=y.sinDeg(t);n.a=o*s-r*c,n.c=o*a-r*d,n.b=r*s+o*c,n.d=r*a+o*d,this.appliedValid=!1}}class xe{constructor(t,n,s){if(this.x=0,this.y=0,this.rotation=0,this.scaleX=1,this.scaleY=1,this.shearX=0,this.shearY=0,this.transformMode=Z.Normal,this.skinRequired=!1,this.inheritRotation=!0,this.inheritScale=!0,this.color=new B,t<0)throw new Error("index must be >= 0.");if(n==null)throw new Error("name cannot be null.");this.index=t,this.name=n,this.parent=s}}class Jt{constructor(t,n,s){this.name=t,this.order=n,this.skinRequired=s}}class Ee{constructor(t,n){if(n==null)throw new Error("data cannot be null.");this.time=t,this.data=n}}class we{constructor(t){this.name=t}}class Be{constructor(t,n){if(this.bendDirection=0,this.compress=!1,this.stretch=!1,this.mix=1,this.softness=0,this.active=!1,t==null)throw new Error("data cannot be null.");if(n==null)throw new Error("skeleton cannot be null.");this.data=t,this.mix=t.mix,this.softness=t.softness,this.bendDirection=t.bendDirection,this.compress=t.compress,this.stretch=t.stretch,this.bones=new Array;for(let s=0;s<t.bones.length;s++)this.bones.push(n.findBone(t.bones[s].name));this.target=n.findBone(t.target.name)}isActive(){return this.active}apply(){this.update()}update(){const t=this.target,n=this.bones;switch(n.length){case 1:this.apply1(n[0],t.worldX,t.worldY,this.compress,this.stretch,this.data.uniform,this.mix);break;case 2:this.apply2(n[0],n[1],t.worldX,t.worldY,this.bendDirection,this.stretch,this.softness,this.mix);break}}apply1(t,n,s,a,c,d,o){t.appliedValid||t.updateAppliedTransform();const r=t.parent.matrix,i=r.a;let l=r.c;const f=r.b;let u=r.d,h=-t.ashearX-t.arotation,m=0,p=0;switch(t.data.transformMode){case Z.OnlyTranslation:m=n-t.worldX,p=s-t.worldY;break;case Z.NoRotationOrReflection:const E=Math.abs(i*u-l*f)/(i*i+f*f),w=i/t.skeleton.scaleX,M=f/t.skeleton.scaleY;l=-M*E*t.skeleton.scaleX,u=w*E*t.skeleton.scaleY,h+=Math.atan2(M,w)*y.radDeg;default:const b=n-r.tx,S=s-r.ty,A=i*u-l*f;m=(b*u-S*l)/A-t.ax,p=(S*i-b*f)/A-t.ay}h+=Math.atan2(p,m)*y.radDeg,t.ascaleX<0&&(h+=180),h>180?h-=360:h<-180&&(h+=360);let g=t.ascaleX,x=t.ascaleY;if(a||c){switch(t.data.transformMode){case Z.NoScale:case Z.NoScaleOrReflection:m=n-t.worldX,p=s-t.worldY}const E=t.data.length*g,w=Math.sqrt(m*m+p*p);if(a&&w<E||c&&w>E&&E>1e-4){const M=(w/E-1)*o+1;g*=M,d&&(x*=M)}}t.updateWorldTransformWith(t.ax,t.ay,t.arotation+h*o,g,x,t.ashearX,t.ashearY)}apply2(t,n,s,a,c,d,o,r){if(r==0){n.updateWorldTransform();return}t.appliedValid||t.updateAppliedTransform(),n.appliedValid||n.updateAppliedTransform();const i=t.ax,l=t.ay;let f=t.ascaleX,u=f,h=t.ascaleY,m=n.ascaleX;const p=t.matrix;let g=0,x=0,E=0;f<0?(f=-f,g=180,E=-1):(g=0,E=1),h<0&&(h=-h,E=-E),m<0?(m=-m,x=180):x=0;const w=n.ax;let M=0,b=0,S=0,A=p.a,C=p.c,I=p.b,V=p.d;const O=Math.abs(f-h)<=1e-4;O?(M=n.ay,b=A*w+C*M+p.tx,S=I*w+V*M+p.ty):(M=0,b=A*w+p.tx,S=I*w+p.ty);const N=t.parent.matrix;A=N.a,C=N.c,I=N.b,V=N.d;const H=1/(A*V-C*I);let k=b-N.tx,P=S-N.ty;const rt=(k*V-P*C)*H-i,it=(P*A-k*I)*H-l,v=Math.sqrt(rt*rt+it*it);let Y=n.data.length*m,L,W;if(v<1e-4){this.apply1(t,s,a,!1,d,!1,r),n.updateWorldTransformWith(w,M,0,n.ascaleX,n.ascaleY,n.ashearX,n.ashearY);return}k=s-N.tx,P=a-N.ty;let j=(k*V-P*C)*H-i,_=(P*A-k*I)*H-l,D=j*j+_*_;if(o!=0){o*=f*(m+1)/2;const ft=Math.sqrt(D),It=ft-v-Y*f+o;if(It>0){let Tt=Math.min(1,It/(o*2))-1;Tt=(It-o*(1-Tt*Tt))/ft,j-=Tt*j,_-=Tt*_,D=j*j+_*_}}t:if(O){Y*=f;let ft=(D-v*v-Y*Y)/(2*v*Y);ft<-1?ft=-1:ft>1&&(ft=1,d&&(u*=(Math.sqrt(D)/(v+Y)-1)*r+1)),W=Math.acos(ft)*c,A=v+Y*ft,C=Y*Math.sin(W),L=Math.atan2(_*A-j*C,j*A+_*C)}else{A=f*Y,C=h*Y;const ft=A*A,It=C*C,Tt=Math.atan2(_,j);I=It*v*v+ft*D-ft*It;const Gt=-2*It*v,Te=It-ft;if(V=Gt*Gt-4*Te*I,V>=0){let _t=Math.sqrt(V);Gt<0&&(_t=-_t),_t=-(Gt+_t)/2;const Pe=_t/Te,Fe=I/_t,Bt=Math.abs(Pe)<Math.abs(Fe)?Pe:Fe;if(Bt*Bt<=D){P=Math.sqrt(D-Bt*Bt)*c,L=Tt-Math.atan2(P,Bt),W=Math.atan2(P/h,(Bt-v)/f);break t}}let Ce=y.PI,Zt=v-A,ae=Zt*Zt,Ve=0,ve=0,zt=v+A,re=zt*zt,ke=0;I=-A*v/(ft-It),I>=-1&&I<=1&&(I=Math.acos(I),k=A*Math.cos(I)+v,P=C*Math.sin(I),V=k*k+P*P,V<ae&&(Ce=I,ae=V,Zt=k,Ve=P),V>re&&(ve=I,re=V,zt=k,ke=P)),D<=(ae+re)/2?(L=Tt-Math.atan2(Ve*c,Zt),W=Ce*c):(L=Tt-Math.atan2(ke*c,zt),W=ve*c)}const Mt=Math.atan2(M,w)*E;let kt=t.arotation;L=(L-Mt)*y.radDeg+g-kt,L>180?L-=360:L<-180&&(L+=360),t.updateWorldTransformWith(i,l,kt+L*r,u,t.ascaleY,0,0),kt=n.arotation,W=((W+Mt)*y.radDeg-n.ashearX)*E+x-kt,W>180?W-=360:W<-180&&(W+=360),n.updateWorldTransformWith(w,M,kt+W*r,n.ascaleX,n.ascaleY,n.ashearX,n.ashearY)}}class Me extends Jt{constructor(t){super(t,0,!1),this.bones=new Array,this.bendDirection=1,this.compress=!1,this.stretch=!1,this.uniform=!1,this.mix=1,this.softness=0}}class Se extends Jt{constructor(t){super(t,0,!1),this.bones=new Array}}var nt=(e=>(e[e.Length=0]="Length",e[e.Fixed=1]="Fixed",e[e.Percent=2]="Percent",e))(nt||{});const Yt=class{constructor(e,t){if(this.position=0,this.spacing=0,this.rotateMix=0,this.translateMix=0,this.spaces=new Array,this.positions=new Array,this.world=new Array,this.curves=new Array,this.lengths=new Array,this.segments=new Array,this.active=!1,e==null)throw new Error("data cannot be null.");if(t==null)throw new Error("skeleton cannot be null.");this.data=e,this.bones=new Array;for(let n=0,s=e.bones.length;n<s;n++)this.bones.push(t.findBone(e.bones[n].name));this.target=t.findSlot(e.target.name),this.position=e.position,this.spacing=e.spacing,this.rotateMix=e.rotateMix,this.translateMix=e.translateMix}isActive(){return this.active}apply(){this.update()}update(){const e=this.target.getAttachment();if(!(e instanceof Lt))return;const t=this.rotateMix,n=this.translateMix,s=n>0,a=t>0;if(!s&&!a)return;const c=this.data,d=c.spacingMode,o=d==nt.Length,r=c.rotateMode,i=r==Ct.Tangent,l=r==Ct.ChainScale,f=this.bones.length,u=i?f:f+1,h=this.bones,m=T.setArraySize(this.spaces,u);let p=null;const g=this.spacing;if(l||o){l&&(p=T.setArraySize(this.lengths,f));for(let S=0,A=u-1;S<A;){const C=h[S],I=C.data.length;if(I<Yt.epsilon)l&&(p[S]=0),m[++S]=0;else{const V=I*C.matrix.a,O=I*C.matrix.b,N=Math.sqrt(V*V+O*O);l&&(p[S]=N),m[++S]=(o?I+g:g)*N/I}}}else for(let S=1;S<u;S++)m[S]=g;const x=this.computeWorldPositions(e,u,i,c.positionMode==Vt.Percent,d==nt.Percent);let E=x[0],w=x[1],M=c.offsetRotation,b=!1;if(M==0)b=r==Ct.Chain;else{b=!1;const S=this.target.bone.matrix;M*=S.a*S.d-S.b*S.c>0?y.degRad:-y.degRad}for(let S=0,A=3;S<f;S++,A+=3){const C=h[S],I=C.matrix;I.tx+=(E-I.tx)*n,I.ty+=(w-I.ty)*n;const V=x[A],O=x[A+1],N=V-E,H=O-w;if(l){const k=p[S];if(k!=0){const P=(Math.sqrt(N*N+H*H)/k-1)*t+1;I.a*=P,I.b*=P}}if(E=V,w=O,a){const k=I.a,P=I.c,rt=I.b,it=I.d;let v=0,Y=0,L=0;if(i&&(i?v=x[A-1]:m[S+1]==0?v=x[A+2]:v=Math.atan2(H,N)),v-=Math.atan2(rt,k),b){Y=Math.cos(v),L=Math.sin(v);const W=C.data.length;E+=(W*(Y*k-L*rt)-N)*t,w+=(W*(L*k+Y*rt)-H)*t}else v+=M;v>y.PI?v-=y.PI2:v<-y.PI&&(v+=y.PI2),v*=t,Y=Math.cos(v),L=Math.sin(v),I.a=Y*k-L*rt,I.c=Y*P-L*it,I.b=L*k+Y*rt,I.d=L*P+Y*it}C.appliedValid=!1}}computeWorldPositions(e,t,n,s,a){const c=this.target;let d=this.position;const o=this.spaces,r=T.setArraySize(this.positions,t*3+2);let i=null;const l=e.closed;let f=e.worldVerticesLength,u=f/6,h=Yt.NONE;if(!e.constantSpeed){const v=e.lengths;u-=l?1:2;const Y=v[u];if(s&&(d*=Y),a)for(let L=0;L<t;L++)o[L]*=Y;i=T.setArraySize(this.world,8);for(let L=0,W=0,j=0;L<t;L++,W+=3){const _=o[L];d+=_;let D=d;if(l)D%=Y,D<0&&(D+=Y),j=0;else if(D<0){h!=Yt.BEFORE&&(h=Yt.BEFORE,e.computeWorldVertices(c,2,4,i,0,2)),this.addBeforePosition(D,i,0,r,W);continue}else if(D>Y){h!=Yt.AFTER&&(h=Yt.AFTER,e.computeWorldVertices(c,f-6,4,i,0,2)),this.addAfterPosition(D-Y,i,0,r,W);continue}for(;;j++){const Mt=v[j];if(!(D>Mt)){if(j==0)D/=Mt;else{const kt=v[j-1];D=(D-kt)/(Mt-kt)}break}}j!=h&&(h=j,l&&j==u?(e.computeWorldVertices(c,f-4,4,i,0,2),e.computeWorldVertices(c,0,4,i,4,2)):e.computeWorldVertices(c,j*6+2,8,i,0,2)),this.addCurvePosition(D,i[0],i[1],i[2],i[3],i[4],i[5],i[6],i[7],r,W,n||L>0&&_==0)}return r}l?(f+=2,i=T.setArraySize(this.world,f),e.computeWorldVertices(c,2,f-4,i,0,2),e.computeWorldVertices(c,0,2,i,f-4,2),i[f-2]=i[0],i[f-1]=i[1]):(u--,f-=4,i=T.setArraySize(this.world,f),e.computeWorldVertices(c,2,f,i,0,2));const m=T.setArraySize(this.curves,u);let p=0,g=i[0],x=i[1],E=0,w=0,M=0,b=0,S=0,A=0,C=0,I=0,V=0,O=0,N=0,H=0,k=0,P=0;for(let v=0,Y=2;v<u;v++,Y+=6)E=i[Y],w=i[Y+1],M=i[Y+2],b=i[Y+3],S=i[Y+4],A=i[Y+5],C=(g-E*2+M)*.1875,I=(x-w*2+b)*.1875,V=((E-M)*3-g+S)*.09375,O=((w-b)*3-x+A)*.09375,N=C*2+V,H=I*2+O,k=(E-g)*.75+C+V*.16666667,P=(w-x)*.75+I+O*.16666667,p+=Math.sqrt(k*k+P*P),k+=N,P+=H,N+=V,H+=O,p+=Math.sqrt(k*k+P*P),k+=N,P+=H,p+=Math.sqrt(k*k+P*P),k+=N+V,P+=H+O,p+=Math.sqrt(k*k+P*P),m[v]=p,g=S,x=A;if(s&&(d*=p),a)for(let v=0;v<t;v++)o[v]*=p;const rt=this.segments;let it=0;for(let v=0,Y=0,L=0,W=0;v<t;v++,Y+=3){const j=o[v];d+=j;let _=d;if(l)_%=p,_<0&&(_+=p),L=0;else if(_<0){this.addBeforePosition(_,i,0,r,Y);continue}else if(_>p){this.addAfterPosition(_-p,i,f-4,r,Y);continue}for(;;L++){const D=m[L];if(!(_>D)){if(L==0)_/=D;else{const Mt=m[L-1];_=(_-Mt)/(D-Mt)}break}}if(L!=h){h=L;let D=L*6;for(g=i[D],x=i[D+1],E=i[D+2],w=i[D+3],M=i[D+4],b=i[D+5],S=i[D+6],A=i[D+7],C=(g-E*2+M)*.03,I=(x-w*2+b)*.03,V=((E-M)*3-g+S)*.006,O=((w-b)*3-x+A)*.006,N=C*2+V,H=I*2+O,k=(E-g)*.3+C+V*.16666667,P=(w-x)*.3+I+O*.16666667,it=Math.sqrt(k*k+P*P),rt[0]=it,D=1;D<8;D++)k+=N,P+=H,N+=V,H+=O,it+=Math.sqrt(k*k+P*P),rt[D]=it;k+=N,P+=H,it+=Math.sqrt(k*k+P*P),rt[8]=it,k+=N+V,P+=H+O,it+=Math.sqrt(k*k+P*P),rt[9]=it,W=0}for(_*=it;;W++){const D=rt[W];if(!(_>D)){if(W==0)_/=D;else{const Mt=rt[W-1];_=W+(_-Mt)/(D-Mt)}break}}this.addCurvePosition(_*.1,g,x,E,w,M,b,S,A,r,Y,n||v>0&&j==0)}return r}addBeforePosition(e,t,n,s,a){const c=t[n],d=t[n+1],o=t[n+2]-c,r=t[n+3]-d,i=Math.atan2(r,o);s[a]=c+e*Math.cos(i),s[a+1]=d+e*Math.sin(i),s[a+2]=i}addAfterPosition(e,t,n,s,a){const c=t[n+2],d=t[n+3],o=c-t[n],r=d-t[n+1],i=Math.atan2(r,o);s[a]=c+e*Math.cos(i),s[a+1]=d+e*Math.sin(i),s[a+2]=i}addCurvePosition(e,t,n,s,a,c,d,o,r,i,l,f){(e==0||isNaN(e))&&(e=1e-4);const u=e*e,h=u*e,m=1-e,p=m*m,g=p*m,x=m*e,E=x*3,w=m*E,M=E*e,b=t*g+s*w+c*M+o*h,S=n*g+a*w+d*M+r*h;i[l]=b,i[l+1]=S,f&&(i[l+2]=Math.atan2(S-(n*p+a*x*2+d*u),b-(t*p+s*x*2+c*u)))}};let qt=Yt;qt.NONE=-1,qt.BEFORE=-2,qt.AFTER=-3,qt.epsilon=1e-5;class We{constructor(t,n){if(this.rotateMix=0,this.translateMix=0,this.scaleMix=0,this.shearMix=0,this.temp=new je,this.active=!1,t==null)throw new Error("data cannot be null.");if(n==null)throw new Error("skeleton cannot be null.");this.data=t,this.rotateMix=t.rotateMix,this.translateMix=t.translateMix,this.scaleMix=t.scaleMix,this.shearMix=t.shearMix,this.bones=new Array;for(let s=0;s<t.bones.length;s++)this.bones.push(n.findBone(t.bones[s].name));this.target=n.findBone(t.target.name)}isActive(){return this.active}apply(){this.update()}update(){this.data.local?this.data.relative?this.applyRelativeLocal():this.applyAbsoluteLocal():this.data.relative?this.applyRelativeWorld():this.applyAbsoluteWorld()}applyAbsoluteWorld(){const t=this.rotateMix,n=this.translateMix,s=this.scaleMix,a=this.shearMix,c=this.target,d=c.matrix,o=d.a,r=d.c,i=d.b,l=d.d,f=o*l-r*i>0?y.degRad:-y.degRad,u=this.data.offsetRotation*f,h=this.data.offsetShearY*f,m=this.bones;for(let p=0,g=m.length;p<g;p++){const x=m[p];let E=!1;const w=x.matrix;if(t!=0){const M=w.a,b=w.c,S=w.b,A=w.d;let C=Math.atan2(i,o)-Math.atan2(S,M)+u;C>y.PI?C-=y.PI2:C<-y.PI&&(C+=y.PI2),C*=t;const I=Math.cos(C),V=Math.sin(C);w.a=I*M-V*S,w.c=I*b-V*A,w.b=V*M+I*S,w.d=V*b+I*A,E=!0}if(n!=0){const M=this.temp;c.localToWorld(M.set(this.data.offsetX,this.data.offsetY)),w.tx+=(M.x-w.tx)*n,w.ty+=(M.y-w.ty)*n,E=!0}if(s>0){let M=Math.sqrt(w.a*w.a+w.b*w.b),b=Math.sqrt(o*o+i*i);M>1e-5&&(M=(M+(b-M+this.data.offsetScaleX)*s)/M),w.a*=M,w.b*=M,M=Math.sqrt(w.c*w.c+w.d*w.d),b=Math.sqrt(r*r+l*l),M>1e-5&&(M=(M+(b-M+this.data.offsetScaleY)*s)/M),w.c*=M,w.d*=M,E=!0}if(a>0){const M=w.c,b=w.d,S=Math.atan2(b,M);let A=Math.atan2(l,r)-Math.atan2(i,o)-(S-Math.atan2(w.b,w.a));A>y.PI?A-=y.PI2:A<-y.PI&&(A+=y.PI2),A=S+(A+h)*a;const C=Math.sqrt(M*M+b*b);w.c=Math.cos(A)*C,w.d=Math.sin(A)*C,E=!0}E&&(x.appliedValid=!1)}}applyRelativeWorld(){const t=this.rotateMix,n=this.translateMix,s=this.scaleMix,a=this.shearMix,c=this.target,d=c.matrix,o=d.a,r=d.c,i=d.b,l=d.d,f=o*l-r*i>0?y.degRad:-y.degRad,u=this.data.offsetRotation*f,h=this.data.offsetShearY*f,m=this.bones;for(let p=0,g=m.length;p<g;p++){const x=m[p];let E=!1;const w=x.matrix;if(t!=0){const M=w.a,b=w.c,S=w.b,A=w.d;let C=Math.atan2(i,o)+u;C>y.PI?C-=y.PI2:C<-y.PI&&(C+=y.PI2),C*=t;const I=Math.cos(C),V=Math.sin(C);w.a=I*M-V*S,w.c=I*b-V*A,w.b=V*M+I*S,w.d=V*b+I*A,E=!0}if(n!=0){const M=this.temp;c.localToWorld(M.set(this.data.offsetX,this.data.offsetY)),w.tx+=M.x*n,w.ty+=M.y*n,E=!0}if(s>0){let M=(Math.sqrt(o*o+i*i)-1+this.data.offsetScaleX)*s+1;w.a*=M,w.b*=M,M=(Math.sqrt(r*r+l*l)-1+this.data.offsetScaleY)*s+1,w.c*=M,w.d*=M,E=!0}if(a>0){let M=Math.atan2(l,r)-Math.atan2(i,o);M>y.PI?M-=y.PI2:M<-y.PI&&(M+=y.PI2);const b=w.c,S=w.d;M=Math.atan2(S,b)+(M-y.PI/2+h)*a;const A=Math.sqrt(b*b+S*S);w.c=Math.cos(M)*A,w.d=Math.sin(M)*A,E=!0}E&&(x.appliedValid=!1)}}applyAbsoluteLocal(){const t=this.rotateMix,n=this.translateMix,s=this.scaleMix,a=this.shearMix,c=this.target;c.appliedValid||c.updateAppliedTransform();const d=this.bones;for(let o=0,r=d.length;o<r;o++){const i=d[o];i.appliedValid||i.updateAppliedTransform();let l=i.arotation;if(t!=0){let g=c.arotation-l+this.data.offsetRotation;g-=(16384-(16384.499999999996-g/360|0))*360,l+=g*t}let f=i.ax,u=i.ay;n!=0&&(f+=(c.ax-f+this.data.offsetX)*n,u+=(c.ay-u+this.data.offsetY)*n);let h=i.ascaleX,m=i.ascaleY;s>0&&(h>1e-5&&(h=(h+(c.ascaleX-h+this.data.offsetScaleX)*s)/h),m>1e-5&&(m=(m+(c.ascaleY-m+this.data.offsetScaleY)*s)/m));const p=i.ashearY;if(a>0){let g=c.ashearY-p+this.data.offsetShearY;g-=(16384-(16384.499999999996-g/360|0))*360,i.shearY+=g*a}i.updateWorldTransformWith(f,u,l,h,m,i.ashearX,p)}}applyRelativeLocal(){const t=this.rotateMix,n=this.translateMix,s=this.scaleMix,a=this.shearMix,c=this.target;c.appliedValid||c.updateAppliedTransform();const d=this.bones;for(let o=0,r=d.length;o<r;o++){const i=d[o];i.appliedValid||i.updateAppliedTransform();let l=i.arotation;t!=0&&(l+=(c.arotation+this.data.offsetRotation)*t);let f=i.ax,u=i.ay;n!=0&&(f+=(c.ax+this.data.offsetX)*n,u+=(c.ay+this.data.offsetY)*n);let h=i.ascaleX,m=i.ascaleY;s>0&&(h>1e-5&&(h*=(c.ascaleX-1+this.data.offsetScaleX)*s+1),m>1e-5&&(m*=(c.ascaleY-1+this.data.offsetScaleY)*s+1));let p=i.ashearY;a>0&&(p+=(c.ashearY+this.data.offsetShearY)*a),i.updateWorldTransformWith(f,u,l,h,m,i.ashearX,p)}}}const Ht=class{constructor(e){if(this._updateCache=new Array,this.updateCacheReset=new Array,this.time=0,this.scaleX=1,this.scaleY=1,this.x=0,this.y=0,e==null)throw new Error("data cannot be null.");this.data=e,this.bones=new Array;for(let t=0;t<e.bones.length;t++){const n=e.bones[t];let s;if(n.parent==null)s=new pe(n,this,null);else{const a=this.bones[n.parent.index];s=new pe(n,this,a),a.children.push(s)}this.bones.push(s)}this.slots=new Array,this.drawOrder=new Array;for(let t=0;t<e.slots.length;t++){const n=e.slots[t],s=this.bones[n.boneData.index],a=new he(n,s);this.slots.push(a),this.drawOrder.push(a)}this.ikConstraints=new Array;for(let t=0;t<e.ikConstraints.length;t++){const n=e.ikConstraints[t];this.ikConstraints.push(new Be(n,this))}this.transformConstraints=new Array;for(let t=0;t<e.transformConstraints.length;t++){const n=e.transformConstraints[t];this.transformConstraints.push(new We(n,this))}this.pathConstraints=new Array;for(let t=0;t<e.pathConstraints.length;t++){const n=e.pathConstraints[t];this.pathConstraints.push(new qt(n,this))}this.color=new B(1,1,1,1),this.updateCache()}updateCache(){const e=this._updateCache;e.length=0,this.updateCacheReset.length=0;const t=this.bones;for(let i=0,l=t.length;i<l;i++){const f=t[i];f.sorted=f.data.skinRequired,f.active=!f.sorted}if(this.skin!=null){const i=this.skin.bones;for(let l=0,f=this.skin.bones.length;l<f;l++){let u=this.bones[i[l].index];do u.sorted=!1,u.active=!0,u=u.parent;while(u!=null)}}const n=this.ikConstraints,s=this.transformConstraints,a=this.pathConstraints,c=n.length,d=s.length,o=a.length,r=c+d+o;t:for(let i=0;i<r;i++){for(let l=0;l<c;l++){const f=n[l];if(f.data.order==i){this.sortIkConstraint(f);continue t}}for(let l=0;l<d;l++){const f=s[l];if(f.data.order==i){this.sortTransformConstraint(f);continue t}}for(let l=0;l<o;l++){const f=a[l];if(f.data.order==i){this.sortPathConstraint(f);continue t}}}for(let i=0,l=t.length;i<l;i++)this.sortBone(t[i])}sortIkConstraint(e){if(e.active=e.target.isActive()&&(!e.data.skinRequired||this.skin!=null&&T.contains(this.skin.constraints,e.data,!0)),!e.active)return;const t=e.target;this.sortBone(t);const n=e.bones,s=n[0];if(this.sortBone(s),n.length>1){const a=n[n.length-1];this._updateCache.indexOf(a)>-1||this.updateCacheReset.push(a)}this._updateCache.push(e),this.sortReset(s.children),n[n.length-1].sorted=!0}sortPathConstraint(e){if(e.active=e.target.bone.isActive()&&(!e.data.skinRequired||this.skin!=null&&T.contains(this.skin.constraints,e.data,!0)),!e.active)return;const t=e.target,n=t.data.index,s=t.bone;this.skin!=null&&this.sortPathConstraintAttachment(this.skin,n,s),this.data.defaultSkin!=null&&this.data.defaultSkin!=this.skin&&this.sortPathConstraintAttachment(this.data.defaultSkin,n,s);for(let o=0,r=this.data.skins.length;o<r;o++)this.sortPathConstraintAttachment(this.data.skins[o],n,s);const a=t.getAttachment();a instanceof Lt&&this.sortPathConstraintAttachmentWith(a,s);const c=e.bones,d=c.length;for(let o=0;o<d;o++)this.sortBone(c[o]);this._updateCache.push(e);for(let o=0;o<d;o++)this.sortReset(c[o].children);for(let o=0;o<d;o++)c[o].sorted=!0}sortTransformConstraint(e){if(e.active=e.target.isActive()&&(!e.data.skinRequired||this.skin!=null&&T.contains(this.skin.constraints,e.data,!0)),!e.active)return;this.sortBone(e.target);const t=e.bones,n=t.length;if(e.data.local)for(let s=0;s<n;s++){const a=t[s];this.sortBone(a.parent),this._updateCache.indexOf(a)>-1||this.updateCacheReset.push(a)}else for(let s=0;s<n;s++)this.sortBone(t[s]);this._updateCache.push(e);for(let s=0;s<n;s++)this.sortReset(t[s].children);for(let s=0;s<n;s++)t[s].sorted=!0}sortPathConstraintAttachment(e,t,n){const s=e.attachments[t];if(s)for(const a in s)this.sortPathConstraintAttachmentWith(s[a],n)}sortPathConstraintAttachmentWith(e,t){if(!(e instanceof Lt))return;const n=e.bones;if(n==null)this.sortBone(t);else{const s=this.bones;let a=0;for(;a<n.length;){const c=n[a++];for(let d=a+c;a<d;a++){const o=n[a];this.sortBone(s[o])}}}}sortBone(e){if(e.sorted)return;const t=e.parent;t!=null&&this.sortBone(t),e.sorted=!0,this._updateCache.push(e)}sortReset(e){for(let t=0,n=e.length;t<n;t++){const s=e[t];s.active&&(s.sorted&&this.sortReset(s.children),s.sorted=!1)}}updateWorldTransform(){const e=this.updateCacheReset;for(let n=0,s=e.length;n<s;n++){const a=e[n];a.ax=a.x,a.ay=a.y,a.arotation=a.rotation,a.ascaleX=a.scaleX,a.ascaleY=a.scaleY,a.ashearX=a.shearX,a.ashearY=a.shearY,a.appliedValid=!0}const t=this._updateCache;for(let n=0,s=t.length;n<s;n++)t[n].update()}setToSetupPose(){this.setBonesToSetupPose(),this.setSlotsToSetupPose()}setBonesToSetupPose(){const e=this.bones;for(let a=0,c=e.length;a<c;a++)e[a].setToSetupPose();const t=this.ikConstraints;for(let a=0,c=t.length;a<c;a++){const d=t[a];d.mix=d.data.mix,d.softness=d.data.softness,d.bendDirection=d.data.bendDirection,d.compress=d.data.compress,d.stretch=d.data.stretch}const n=this.transformConstraints;for(let a=0,c=n.length;a<c;a++){const d=n[a],o=d.data;d.rotateMix=o.rotateMix,d.translateMix=o.translateMix,d.scaleMix=o.scaleMix,d.shearMix=o.shearMix}const s=this.pathConstraints;for(let a=0,c=s.length;a<c;a++){const d=s[a],o=d.data;d.position=o.position,d.spacing=o.spacing,d.rotateMix=o.rotateMix,d.translateMix=o.translateMix}}setSlotsToSetupPose(){const e=this.slots;T.arrayCopy(e,0,this.drawOrder,0,e.length);for(let t=0,n=e.length;t<n;t++)e[t].setToSetupPose()}getRootBone(){return this.bones.length==0?null:this.bones[0]}findBone(e){if(e==null)throw new Error("boneName cannot be null.");const t=this.bones;for(let n=0,s=t.length;n<s;n++){const a=t[n];if(a.data.name==e)return a}return null}findBoneIndex(e){if(e==null)throw new Error("boneName cannot be null.");const t=this.bones;for(let n=0,s=t.length;n<s;n++)if(t[n].data.name==e)return n;return-1}findSlot(e){if(e==null)throw new Error("slotName cannot be null.");const t=this.slots;for(let n=0,s=t.length;n<s;n++){const a=t[n];if(a.data.name==e)return a}return null}findSlotIndex(e){if(e==null)throw new Error("slotName cannot be null.");const t=this.slots;for(let n=0,s=t.length;n<s;n++)if(t[n].data.name==e)return n;return-1}setSkinByName(e){const t=this.data.findSkin(e);if(t==null)throw new Error(`Skin not found: ${e}`);this.setSkin(t)}setSkin(e){if(e!=this.skin){if(e!=null)if(this.skin!=null)e.attachAll(this,this.skin);else{const t=this.slots;for(let n=0,s=t.length;n<s;n++){const a=t[n],c=a.data.attachmentName;if(c!=null){const d=e.getAttachment(n,c);d!=null&&a.setAttachment(d)}}}this.skin=e,this.updateCache()}}getAttachmentByName(e,t){return this.getAttachment(this.data.findSlotIndex(e),t)}getAttachment(e,t){if(t==null)throw new Error("attachmentName cannot be null.");if(this.skin!=null){const n=this.skin.getAttachment(e,t);if(n!=null)return n}return this.data.defaultSkin!=null?this.data.defaultSkin.getAttachment(e,t):null}setAttachment(e,t){if(e==null)throw new Error("slotName cannot be null.");const n=this.slots;for(let s=0,a=n.length;s<a;s++){const c=n[s];if(c.data.name==e){let d=null;if(t!=null&&(d=this.getAttachment(s,t),d==null))throw new Error(`Attachment not found: ${t}, for slot: ${e}`);c.setAttachment(d);return}}throw new Error(`Slot not found: ${e}`)}findIkConstraint(e){if(e==null)throw new Error("constraintName cannot be null.");const t=this.ikConstraints;for(let n=0,s=t.length;n<s;n++){const a=t[n];if(a.data.name==e)return a}return null}findTransformConstraint(e){if(e==null)throw new Error("constraintName cannot be null.");const t=this.transformConstraints;for(let n=0,s=t.length;n<s;n++){const a=t[n];if(a.data.name==e)return a}return null}findPathConstraint(e){if(e==null)throw new Error("constraintName cannot be null.");const t=this.pathConstraints;for(let n=0,s=t.length;n<s;n++){const a=t[n];if(a.data.name==e)return a}return null}getBounds(e,t,n=new Array(2)){if(e==null)throw new Error("offset cannot be null.");if(t==null)throw new Error("size cannot be null.");const s=this.drawOrder;let a=Number.POSITIVE_INFINITY,c=Number.POSITIVE_INFINITY,d=Number.NEGATIVE_INFINITY,o=Number.NEGATIVE_INFINITY;for(let r=0,i=s.length;r<i;r++){const l=s[r];if(!l.bone.active)continue;let f=0,u=null;const h=l.getAttachment();if(h instanceof F)f=8,u=T.setArraySize(n,f,0),h.computeWorldVertices(l.bone,u,0,2);else if(h instanceof Xt){const m=h;f=m.worldVerticesLength,u=T.setArraySize(n,f,0),m.computeWorldVertices(l,0,f,u,0,2)}if(u!=null)for(let m=0,p=u.length;m<p;m+=2){const g=u[m],x=u[m+1];a=Math.min(a,g),c=Math.min(c,x),d=Math.max(d,g),o=Math.max(o,x)}}e.set(a,c),t.set(d-a,o-c)}update(e){this.time+=e}get flipX(){return this.scaleX==-1}set flipX(e){Ht.deprecatedWarning1||(Ht.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleX=e?1:-1}get flipY(){return this.scaleY==-1}set flipY(e){Ht.deprecatedWarning1||(Ht.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleY=e?1:-1}};let be=Ht;be.deprecatedWarning1=!1;class Ae{constructor(){this.bones=new Array,this.slots=new Array,this.skins=new Array,this.events=new Array,this.animations=new Array,this.ikConstraints=new Array,this.transformConstraints=new Array,this.pathConstraints=new Array,this.fps=0}findBone(t){if(t==null)throw new Error("boneName cannot be null.");const n=this.bones;for(let s=0,a=n.length;s<a;s++){const c=n[s];if(c.name==t)return c}return null}findBoneIndex(t){if(t==null)throw new Error("boneName cannot be null.");const n=this.bones;for(let s=0,a=n.length;s<a;s++)if(n[s].name==t)return s;return-1}findSlot(t){if(t==null)throw new Error("slotName cannot be null.");const n=this.slots;for(let s=0,a=n.length;s<a;s++){const c=n[s];if(c.name==t)return c}return null}findSlotIndex(t){if(t==null)throw new Error("slotName cannot be null.");const n=this.slots;for(let s=0,a=n.length;s<a;s++)if(n[s].name==t)return s;return-1}findSkin(t){if(t==null)throw new Error("skinName cannot be null.");const n=this.skins;for(let s=0,a=n.length;s<a;s++){const c=n[s];if(c.name==t)return c}return null}findEvent(t){if(t==null)throw new Error("eventDataName cannot be null.");const n=this.events;for(let s=0,a=n.length;s<a;s++){const c=n[s];if(c.name==t)return c}return null}findAnimation(t){if(t==null)throw new Error("animationName cannot be null.");const n=this.animations;for(let s=0,a=n.length;s<a;s++){const c=n[s];if(c.name==t)return c}return null}findIkConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const n=this.ikConstraints;for(let s=0,a=n.length;s<a;s++){const c=n[s];if(c.name==t)return c}return null}findTransformConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const n=this.transformConstraints;for(let s=0,a=n.length;s<a;s++){const c=n[s];if(c.name==t)return c}return null}findPathConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const n=this.pathConstraints;for(let s=0,a=n.length;s<a;s++){const c=n[s];if(c.name==t)return c}return null}findPathConstraintIndex(t){if(t==null)throw new Error("pathConstraintName cannot be null.");const n=this.pathConstraints;for(let s=0,a=n.length;s<a;s++)if(n[s].name==t)return s;return-1}}class ye{constructor(t,n,s){if(this.color=new B(1,1,1,1),t<0)throw new Error("index must be >= 0.");if(n==null)throw new Error("name cannot be null.");if(s==null)throw new Error("boneData cannot be null.");this.index=t,this.name=n,this.boneData=s}}class Re extends Jt{constructor(t){super(t,0,!1),this.bones=new Array,this.rotateMix=0,this.translateMix=0,this.scaleMix=0,this.shearMix=0,this.offsetRotation=0,this.offsetX=0,this.offsetY=0,this.offsetScaleX=0,this.offsetScaleY=0,this.offsetShearY=0,this.relative=!1,this.local=!1}}class Ie{constructor(t,n,s){this.slotIndex=t,this.name=n,this.attachment=s}}class te{constructor(t){if(this.attachments=new Array,this.bones=Array(),this.constraints=new Array,t==null)throw new Error("name cannot be null.");this.name=t}setAttachment(t,n,s){if(s==null)throw new Error("attachment cannot be null.");const a=this.attachments;t>=a.length&&(a.length=t+1),a[t]||(a[t]={}),a[t][n]=s}addSkin(t){for(let s=0;s<t.bones.length;s++){const a=t.bones[s];let c=!1;for(let d=0;d<this.bones.length;d++)if(this.bones[d]==a){c=!0;break}c||this.bones.push(a)}for(let s=0;s<t.constraints.length;s++){const a=t.constraints[s];let c=!1;for(let d=0;d<this.constraints.length;d++)if(this.constraints[d]==a){c=!0;break}c||this.constraints.push(a)}const n=t.getAttachments();for(let s=0;s<n.length;s++){const a=n[s];this.setAttachment(a.slotIndex,a.name,a.attachment)}}copySkin(t){for(let s=0;s<t.bones.length;s++){const a=t.bones[s];let c=!1;for(let d=0;d<this.bones.length;d++)if(this.bones[d]==a){c=!0;break}c||this.bones.push(a)}for(let s=0;s<t.constraints.length;s++){const a=t.constraints[s];let c=!1;for(let d=0;d<this.constraints.length;d++)if(this.constraints[d]==a){c=!0;break}c||this.constraints.push(a)}const n=t.getAttachments();for(let s=0;s<n.length;s++){const a=n[s];a.attachment!=null&&(a.attachment instanceof Xt?(a.attachment=a.attachment.newLinkedMesh(),this.setAttachment(a.slotIndex,a.name,a.attachment)):(a.attachment=a.attachment.copy(),this.setAttachment(a.slotIndex,a.name,a.attachment)))}}getAttachment(t,n){const s=this.attachments[t];return s?s[n]:null}removeAttachment(t,n){const s=this.attachments[t];s&&(s[n]=null)}getAttachments(){const t=new Array;for(let n=0;n<this.attachments.length;n++){const s=this.attachments[n];if(s)for(const a in s){const c=s[a];c&&t.push(new Ie(n,a,c))}}return t}getAttachmentsForSlot(t,n){const s=this.attachments[t];if(s)for(const a in s){const c=s[a];c&&n.push(new Ie(t,a,c))}}clear(){this.attachments.length=0,this.bones.length=0,this.constraints.length=0}attachAll(t,n){let s=0;for(let a=0;a<t.slots.length;a++){const c=t.slots[a],d=c.getAttachment();if(d&&s<n.attachments.length){const o=n.attachments[s];for(const r in o){const i=o[r];if(d==i){const l=this.getAttachment(s,r);l!=null&&c.setAttachment(l);break}}}s++}}}const J=class{constructor(e){this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=e}readSkeletonData(e){const t=this.scale,n=new Ae;n.name="";const s=new oe(e);n.hash=s.readString(),n.version=s.readString(),n.version==="3.8.75"&&console.error("Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine."),n.width=s.readFloat(),n.height=s.readFloat();const a=s.readBoolean();a&&(n.imagesPath=s.readString());let c=0;c=s.readInt(!0);for(let o=0;o<c;o++){const r=s.readString(),i=o==0?null:n.bones[s.readInt(!0)],l=new xe(o,r,i);l.rotation=s.readFloat(),l.x=s.readFloat()*t,l.y=s.readFloat()*t,l.scaleX=s.readFloat(),l.scaleY=s.readFloat(),l.shearX=s.readFloat(),l.shearY=s.readFloat(),l.length=s.readFloat()*t,l.inheritRotation=s.readBoolean(),l.inheritScale=s.readBoolean(),a&&B.rgba8888ToColor(l.color,s.readInt32()),n.bones.push(l)}c=s.readInt(!0);for(let o=0;o<c;o++){const r=s.readString(),i=n.bones[s.readInt(!0)],l=new ye(o,r,i);B.rgba8888ToColor(l.color,s.readInt32()),l.attachmentName=s.readString(),l.blendMode=J.BlendModeValues[s.readInt(!0)],n.slots.push(l)}c=s.readInt(!0);for(let o=0,r;o<c;o++){const i=s.readString(),l=new Me(i);r=s.readInt(!0);for(let f=0;f<r;f++)l.bones.push(n.bones[s.readInt(!0)]);l.target=n.bones[s.readInt(!0)],l.mix=s.readFloat(),l.bendDirection=s.readByte(),n.ikConstraints.push(l)}c=s.readInt(!0);for(let o=0,r;o<c;o++){const i=s.readString(),l=new Re(i);r=s.readInt(!0);for(let f=0;f<r;f++)l.bones.push(n.bones[s.readInt(!0)]);l.target=n.bones[s.readInt(!0)],l.offsetRotation=s.readFloat(),l.offsetX=s.readFloat()*t,l.offsetY=s.readFloat()*t,l.offsetScaleX=s.readFloat(),l.offsetScaleY=s.readFloat(),l.offsetShearY=s.readFloat(),l.rotateMix=s.readFloat(),l.translateMix=s.readFloat(),l.scaleMix=s.readFloat(),l.shearMix=s.readFloat(),n.transformConstraints.push(l)}c=s.readInt(!0);for(let o=0,r;o<c;o++){const i=s.readString(),l=new Se(i);r=s.readInt(!0);for(let f=0;f<r;f++)l.bones.push(n.bones[s.readInt(!0)]);l.target=n.slots[s.readInt(!0)],l.positionMode=J.PositionModeValues[s.readInt(!0)],l.spacingMode=J.SpacingModeValues[s.readInt(!0)],l.rotateMode=J.RotateModeValues[s.readInt(!0)],l.offsetRotation=s.readFloat(),l.position=s.readFloat(),l.positionMode==Vt.Fixed&&(l.position*=t),l.spacing=s.readFloat(),(l.spacingMode==nt.Length||l.spacingMode==nt.Fixed)&&(l.spacing*=t),l.rotateMix=s.readFloat(),l.translateMix=s.readFloat(),n.pathConstraints.push(l)}const d=this.readSkin(s,n,!0,a);d!=null&&(n.defaultSkin=d,n.skins.push(d));{let o=n.skins.length;for(T.setArraySize(n.skins,c=o+s.readInt(!0));o<c;o++)n.skins[o]=this.readSkin(s,n,!1,a)}c=this.linkedMeshes.length;for(let o=0;o<c;o++){const r=this.linkedMeshes[o],i=r.skin==null?n.defaultSkin:n.findSkin(r.skin);if(i==null)throw new Error(`Skin not found: ${r.skin}`);const l=i.getAttachment(r.slotIndex,r.parent);if(l==null)throw new Error(`Parent mesh not found: ${r.parent}`);r.mesh.deformAttachment=r.inheritDeform?l:r.mesh,r.mesh.setParentMesh(l)}this.linkedMeshes.length=0,c=s.readInt(!0);for(let o=0;o<c;o++){const r=new we(s.readStringRef());r.intValue=s.readInt(!1),r.floatValue=s.readFloat(),r.stringValue=s.readString(),r.audioPath=s.readString(),r.audioPath!=null&&(r.volume=s.readFloat(),r.balance=s.readFloat()),n.events.push(r)}c=s.readInt(!0);for(let o=0;o<c;o++)n.animations.push(this.readAnimation(s,s.readString(),n));return n}readSkin(e,t,n,s){let a=null,c=0;if(n){if(c=e.readInt(!0),c==0)return null;a=new te("default")}else{a=new te(e.readString()),a.bones.length=e.readInt(!0);for(let d=0,o=a.bones.length;d<o;d++)a.bones[d]=t.bones[e.readInt(!0)];for(let d=0,o=e.readInt(!0);d<o;d++)a.constraints.push(t.ikConstraints[e.readInt(!0)]);for(let d=0,o=e.readInt(!0);d<o;d++)a.constraints.push(t.transformConstraints[e.readInt(!0)]);for(let d=0,o=e.readInt(!0);d<o;d++)a.constraints.push(t.pathConstraints[e.readInt(!0)]);c=e.readInt(!0)}for(let d=0;d<c;d++){const o=e.readInt(!0);for(let r=0,i=e.readInt(!0);r<i;r++){const l=e.readString(),f=this.readAttachment(e,t,a,o,l,s);f!=null&&a.setAttachment(o,l,f)}}return a}readAttachment(e,t,n,s,a,c){const d=this.scale;let o=e.readStringRef();o==null&&(o=a);const r=e.readByte();switch(J.AttachmentTypeValues[r]){case xt.Region:{let l=e.readString();const f=e.readFloat(),u=e.readFloat(),h=e.readFloat(),m=e.readFloat(),p=e.readFloat(),g=e.readFloat(),x=e.readFloat(),E=e.readInt32();l==null&&(l=o);const w=this.attachmentLoader.newRegionAttachment(n,o,l);return w==null?null:(w.path=l,w.x=u*d,w.y=h*d,w.scaleX=m,w.scaleY=p,w.rotation=f,w.width=g*d,w.height=x*d,B.rgba8888ToColor(w.color,E),w)}case xt.BoundingBox:{const l=e.readInt(!0),f=this.readVertices(e,l),u=c?e.readInt32():0,h=this.attachmentLoader.newBoundingBoxAttachment(n,o);return h==null?null:(h.worldVerticesLength=l<<1,h.vertices=f.vertices,h.bones=f.bones,h.cVertices=f.cVertices,c&&B.rgba8888ToColor(h.color,u),h)}case xt.Mesh:{let l=e.readStringRef();const f=e.readInt32(),u=e.readInt(!0),h=this.readFloatArray(e,u<<1,1),m=this.readShortArray(e),p=this.readVertices(e,u),g=e.readInt(!0);let x=null,E=0,w=0;c&&(x=this.readShortArray(e),E=e.readFloat(),w=e.readFloat()),l==null&&(l=o);const M=this.attachmentLoader.newMeshAttachment(n,o,l);return M==null?null:(M.path=l,B.rgba8888ToColor(M.color,f),M.bones=p.bones,M.vertices=p.vertices,M.worldVerticesLength=u<<1,M.triangles=m,M.regionUVs=new Float32Array(h),M.cVertices=p.cVertices,M.hullLength=g<<1,c&&(M.edges=x,M.width=E*d,M.height=w*d),M)}case xt.LinkedMesh:{let l=e.readStringRef();const f=e.readInt32(),u=e.readStringRef(),h=e.readStringRef(),m=e.readBoolean();let p=0,g=0;c&&(p=e.readFloat(),g=e.readFloat()),l==null&&(l=o);const x=this.attachmentLoader.newMeshAttachment(n,o,l);return x==null?null:(x.path=l,B.rgba8888ToColor(x.color,f),c&&(x.width=p*d,x.height=g*d),this.linkedMeshes.push(new Ke(x,u,s,h,m)),x)}case xt.Path:{const l=e.readBoolean(),f=e.readBoolean(),u=e.readInt(!0),h=this.readVertices(e,u),m=T.newArray(u/3,0);for(let x=0,E=m.length;x<E;x++)m[x]=e.readFloat()*d;const p=c?e.readInt32():0,g=this.attachmentLoader.newPathAttachment(n,o);return g==null?null:(g.closed=l,g.constantSpeed=f,g.worldVerticesLength=u<<1,g.vertices=h.vertices,g.bones=h.bones,g.lengths=m,g.cVertices=h.cVertices,c&&B.rgba8888ToColor(g.color,p),g)}case xt.Point:{const l=e.readFloat(),f=e.readFloat(),u=e.readFloat(),h=c?e.readInt32():0,m=this.attachmentLoader.newPointAttachment(n,o);return m==null?null:(m.x=f*d,m.y=u*d,m.rotation=l,c&&B.rgba8888ToColor(m.color,h),m)}case xt.Clipping:{const l=e.readInt(!0),f=e.readInt(!0),u=this.readVertices(e,f),h=c?e.readInt32():0,m=this.attachmentLoader.newClippingAttachment(n,o);return m==null?null:(m.endSlot=t.slots[l],m.worldVerticesLength=f<<1,m.vertices=u.vertices,m.bones=u.bones,m.cVertices=u.cVertices,c&&B.rgba8888ToColor(m.color,h),m)}}return null}readVertices(e,t){const n=t<<1,s=new Je,a=this.scale;if(!e.readBoolean())return s.vertices=this.readFloatArray(e,n,a),s;const c=new Array,d=new Array,o=new Array;for(let r=0;r<t;r++){const i=e.readInt(!0);o.push(i),c.push(i);for(let l=0;l<i;l++){const f=e.readInt(!0);o.push(f),c.push(f);const u=e.readFloat()*a,h=e.readFloat()*a,m=e.readFloat();d.push(u),d.push(h),d.push(m),c.push(u),c.push(h),c.push(m)}}return s.vertices=T.toFloatArray(d),s.bones=o,s.cVertices=c,s}readFloatArray(e,t,n){const s=new Array(t);if(n==1)for(let a=0;a<t;a++)s[a]=e.readFloat();else for(let a=0;a<t;a++)s[a]=e.readFloat()*n;return s}readShortArray(e){const t=e.readInt(!0),n=new Array(t);for(let s=0;s<t;s++)n[s]=e.readShort();return n}readAnimation(e,t,n){const s=new Array,a=this.scale;let c=0;const d=new B;for(let i=0,l=e.readInt(!0);i<l;i++){const f=e.readInt(!0);for(let u=0,h=e.readInt(!0);u<h;u++){const m=e.readByte(),p=e.readInt(!0);switch(m){case J.SLOT_ATTACHMENT:{const g=new Dt(p);g.slotIndex=f;for(let x=0;x<p;x++){const E=e.readFloat(),w=e.readString();g.setFrame(x,E,w)}s.push(g),c=Math.max(c,g.frames[p-1]);break}case J.SLOT_COLOR:{const g=new lt(p);g.slotIndex=f;for(let x=0;x<p;x++){const E=e.readFloat();B.rgba8888ToColor(d,e.readInt32()),g.setFrame(x,E,d.r,d.g,d.b,d.a),x<p-1&&this.readCurve(e,x,g)}s.push(g),c=Math.max(c,g.frames[(p-1)*lt.ENTRIES]);break}}}}for(let i=0,l=e.readInt(!0);i<l;i++){const f=e.readInt(!0);for(let u=0,h=e.readInt(!0);u<h;u++){const m=e.readByte(),p=e.readInt(!0);switch(m){case J.BONE_ROTATE:{const g=new st(p);g.boneIndex=f;for(let x=0;x<p;x++)g.setFrame(x,e.readFloat(),e.readFloat()),x<p-1&&this.readCurve(e,x,g);s.push(g),c=Math.max(c,g.frames[(p-1)*st.ENTRIES]);break}case J.BONE_TRANSLATE:case J.BONE_SCALE:case J.BONE_SHEAR:{let g,x=1;m==J.BONE_SCALE?g=new gt(p):m==J.BONE_SHEAR?g=new pt(p):(g=new Et(p),x=a),g.boneIndex=f;for(let E=0;E<p;E++){const w=e.readFloat(),M=e.readFloat(),b=e.readFloat();g.setFrame(E,w,M*x,b*x),E<p-1&&this.readCurve(e,E,g)}s.push(g),c=Math.max(c,g.frames[(p-1)*Et.ENTRIES]);break}}}}for(let i=0,l=e.readInt(!0);i<l;i++){const f=e.readInt(!0),u=e.readInt(!0),h=new at(u);h.ikConstraintIndex=f;for(let m=0;m<u;m++){const p=e.readFloat(),g=e.readFloat(),x=e.readByte();h.setFrame(m,p,g,x),m<u-1&&this.readCurve(e,m,h)}s.push(h),c=Math.max(c,h.frames[(u-1)*at.ENTRIES])}for(let i=0,l=e.readInt(!0);i<l;i++){const f=e.readInt(!0),u=e.readInt(!0),h=new ct(u);h.transformConstraintIndex=f;for(let m=0;m<u;m++)h.setFrame(m,e.readFloat(),e.readFloat(),e.readFloat(),e.readFloat(),e.readFloat()),m<u-1&&this.readCurve(e,m,h);s.push(h),c=Math.max(c,h.frames[(u-1)*ct.ENTRIES])}for(let i=0,l=e.readInt(!0);i<l;i++){const f=e.readInt(!0),u=n.pathConstraints[f];for(let h=0,m=e.readInt(!0);h<m;h++){const p=e.readByte(),g=e.readInt(!0);switch(p){case J.PATH_POSITION:case J.PATH_SPACING:{let x,E=1;p==J.PATH_SPACING?(x=new yt(g),(u.spacingMode==nt.Length||u.spacingMode==nt.Fixed)&&(E=a)):(x=new Rt(g),u.positionMode==Vt.Fixed&&(E=a)),x.pathConstraintIndex=f;for(let w=0;w<g;w++){const M=e.readFloat(),b=e.readFloat()*E;x.setFrame(w,M,b),w<g-1&&this.readCurve(e,w,x)}s.push(x),c=Math.max(c,x.frames[(g-1)*Rt.ENTRIES]);break}case J.PATH_MIX:{const x=new At(g);x.pathConstraintIndex=f;for(let E=0;E<g;E++){const w=e.readFloat(),M=e.readFloat(),b=e.readFloat();x.setFrame(E,w,M,b),E<g-1&&this.readCurve(e,E,x)}s.push(x),c=Math.max(c,x.frames[(g-1)*At.ENTRIES]);break}}}}for(let i=0,l=e.readInt(!0);i<l;i++){const f=n.skins[e.readInt(!0)];for(let u=0,h=e.readInt(!0);u<h;u++){const m=e.readInt(!0);for(let p=0,g=e.readInt(!0);p<g;p++){const x=f==null?void 0:f.getAttachment(m,e.readString()),E=x.bones!=null,w=x.vertices,M=E?w.length/3*2:w.length,b=e.readInt(!0),S=new de(b);S.slotIndex=m,S.attachment=x;for(let A=0;A<b;A++){const C=e.readFloat();let I,V=e.readInt(!0);if(V==0)I=E?T.newFloatArray(M):w;else{I=T.newFloatArray(M);const O=e.readInt(!0);if(V+=O,a==1)for(let N=O;N<V;N++)I[N]=e.readFloat();else for(let N=O;N<V;N++)I[N]=e.readFloat()*a;if(!E)for(let N=0,H=I.length;N<H;N++)I[N]+=w[N]}S.setFrame(A,C,I,f.name),A<b-1&&this.readCurve(e,A,S)}s.push(S),c=Math.max(c,S.frames[b-1])}}}const o=e.readInt(!0);if(o>0){const i=new Wt(o),l=n.slots.length;for(let f=0;f<o;f++){const u=e.readFloat(),h=e.readInt(!0),m=T.newArray(l,0);for(let E=l-1;E>=0;E--)m[E]=-1;const p=T.newArray(l-h,0);let g=0,x=0;for(let E=0;E<h;E++){const w=e.readInt(!0);for(;g!=w;)p[x++]=g++;m[g+e.readInt(!0)]=g++}for(;g<l;)p[x++]=g++;for(let E=l-1;E>=0;E--)m[E]==-1&&(m[E]=p[--x]);i.setFrame(f,u,m)}s.push(i),c=Math.max(c,i.frames[o-1])}const r=e.readInt(!0);if(r>0){const i=new Qt(r);for(let l=0;l<r;l++){const f=e.readFloat(),u=n.events[e.readInt(!0)],h=new Ee(f,u);h.intValue=e.readInt(!1),h.floatValue=e.readFloat(),h.stringValue=e.readBoolean()?e.readString():u.stringValue,h.data.audioPath!=null&&(h.volume=e.readFloat(),h.balance=e.readFloat()),i.setFrame(l,h)}s.push(i),c=Math.max(c,i.frames[r-1])}return new z(t,s,c)}readCurve(e,t,n){switch(e.readByte()){case J.CURVE_STEPPED:n.setStepped(t);break;case J.CURVE_BEZIER:this.setCurve(n,t,e.readFloat(),e.readFloat(),e.readFloat(),e.readFloat());break}}setCurve(e,t,n,s,a,c){e.setCurve(t,n,s,a,c)}};let K=J;K.AttachmentTypeValues=[0,1,2,3,4,5,6],K.TransformModeValues=[Z.Normal,Z.OnlyTranslation,Z.NoRotationOrReflection,Z.NoScale,Z.NoScaleOrReflection],K.PositionModeValues=[Vt.Fixed,Vt.Percent],K.SpacingModeValues=[nt.Length,nt.Fixed,nt.Percent],K.RotateModeValues=[Ct.Tangent,Ct.Chain,Ct.ChainScale],K.BlendModeValues=[Pt.NORMAL,Pt.ADD,Pt.MULTIPLY,Pt.SCREEN],K.BONE_ROTATE=0,K.BONE_TRANSLATE=1,K.BONE_SCALE=2,K.BONE_SHEAR=3,K.SLOT_ATTACHMENT=0,K.SLOT_COLOR=1,K.SLOT_TWO_COLOR=2,K.PATH_POSITION=0,K.PATH_SPACING=1,K.PATH_MIX=2,K.CURVE_LINEAR=0,K.CURVE_STEPPED=1,K.CURVE_BEZIER=2;let Ke=class{constructor(t,n,s,a,c){this.mesh=t,this.skin=n,this.slotIndex=s,this.parent=a,this.inheritDeform=c}};class Je{constructor(t=null,n=null,s=null){this.bones=t,this.vertices=n,this.cVertices=s}}class tn extends Ge{}class Ot{constructor(t){this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=t}readSkeletonData(t){const n=this.scale,s=new Ae,a=typeof t=="string"?JSON.parse(t):t,c=a.skeleton;if(c!=null){if(s.hash=c.hash,s.version=c.spine,s.version.substr(0,3)!=="3.4"){const d=`Spine 3.4 loader cant load version ${c.spine}. Please configure your pixi-spine bundle`;console.error(d)}s.version==="3.4.75"&&console.error("Unsupported skeleton data, 3.4.75 is deprecated, please export with a newer version of Spine."),s.x=c.x,s.y=c.y,s.width=c.width,s.height=c.height,s.fps=c.fps,s.imagesPath=c.images}if(a.bones)for(let d=0;d<a.bones.length;d++){const o=a.bones[d];let r=null;const i=this.getValue(o,"parent",null);if(i!=null&&(r=s.findBone(i),r==null))throw new Error(`Parent bone not found: ${i}`);const l=new xe(s.bones.length,o.name,r);l.length=this.getValue(o,"length",0)*n,l.x=this.getValue(o,"x",0)*n,l.y=this.getValue(o,"y",0)*n,l.rotation=this.getValue(o,"rotation",0),l.scaleX=this.getValue(o,"scaleX",1),l.scaleY=this.getValue(o,"scaleY",1),l.shearX=this.getValue(o,"shearX",0),l.shearY=this.getValue(o,"shearY",0),l.transformMode=Ot.transformModeFromString(this.getValue(o,"transform","normal")),l.skinRequired=this.getValue(o,"skin",!1),s.bones.push(l)}if(a.slots)for(let d=0;d<a.slots.length;d++){const o=a.slots[d],r=o.name,i=o.bone,l=s.findBone(i);if(l==null)throw new Error(`Slot bone not found: ${i}`);const f=new ye(s.slots.length,r,l),u=this.getValue(o,"color",null);u!=null&&f.color.setFromString(u);const h=this.getValue(o,"dark",null);h!=null&&(f.darkColor=new B(1,1,1,1),f.darkColor.setFromString(h)),f.attachmentName=this.getValue(o,"attachment",null),f.blendMode=Ot.blendModeFromString(this.getValue(o,"blend","normal")),s.slots.push(f)}if(a.ik)for(let d=0;d<a.ik.length;d++){const o=a.ik[d],r=new Me(o.name);r.order=this.getValue(o,"order",0),r.skinRequired=this.getValue(o,"skin",!1);for(let l=0;l<o.bones.length;l++){const f=o.bones[l],u=s.findBone(f);if(u==null)throw new Error(`IK bone not found: ${f}`);r.bones.push(u)}const i=o.target;if(r.target=s.findBone(i),r.target==null)throw new Error(`IK target bone not found: ${i}`);r.mix=this.getValue(o,"mix",1),r.softness=this.getValue(o,"softness",0)*n,r.bendDirection=this.getValue(o,"bendPositive",!0)?1:-1,r.compress=this.getValue(o,"compress",!1),r.stretch=this.getValue(o,"stretch",!1),r.uniform=this.getValue(o,"uniform",!1),s.ikConstraints.push(r)}if(a.transform)for(let d=0;d<a.transform.length;d++){const o=a.transform[d],r=new Re(o.name);r.order=this.getValue(o,"order",0),r.skinRequired=this.getValue(o,"skin",!1);for(let l=0;l<o.bones.length;l++){const f=o.bones[l],u=s.findBone(f);if(u==null)throw new Error(`Transform constraint bone not found: ${f}`);r.bones.push(u)}const i=o.target;if(r.target=s.findBone(i),r.target==null)throw new Error(`Transform constraint target bone not found: ${i}`);r.local=this.getValue(o,"local",!1),r.relative=this.getValue(o,"relative",!1),r.offsetRotation=this.getValue(o,"rotation",0),r.offsetX=this.getValue(o,"x",0)*n,r.offsetY=this.getValue(o,"y",0)*n,r.offsetScaleX=this.getValue(o,"scaleX",0),r.offsetScaleY=this.getValue(o,"scaleY",0),r.offsetShearY=this.getValue(o,"shearY",0),r.rotateMix=this.getValue(o,"rotateMix",1),r.translateMix=this.getValue(o,"translateMix",1),r.scaleMix=this.getValue(o,"scaleMix",1),r.shearMix=this.getValue(o,"shearMix",1),s.transformConstraints.push(r)}if(a.path)for(let d=0;d<a.path.length;d++){const o=a.path[d],r=new Se(o.name);r.order=this.getValue(o,"order",0),r.skinRequired=this.getValue(o,"skin",!1);for(let l=0;l<o.bones.length;l++){const f=o.bones[l],u=s.findBone(f);if(u==null)throw new Error(`Transform constraint bone not found: ${f}`);r.bones.push(u)}const i=o.target;if(r.target=s.findSlot(i),r.target==null)throw new Error(`Path target slot not found: ${i}`);r.positionMode=Ot.positionModeFromString(this.getValue(o,"positionMode","percent")),r.spacingMode=Ot.spacingModeFromString(this.getValue(o,"spacingMode","length")),r.rotateMode=Ot.rotateModeFromString(this.getValue(o,"rotateMode","tangent")),r.offsetRotation=this.getValue(o,"rotation",0),r.position=this.getValue(o,"position",0),r.positionMode==Vt.Fixed&&(r.position*=n),r.spacing=this.getValue(o,"spacing",0),(r.spacingMode==nt.Length||r.spacingMode==nt.Fixed)&&(r.spacing*=n),r.rotateMix=this.getValue(o,"rotateMix",1),r.translateMix=this.getValue(o,"translateMix",1),s.pathConstraints.push(r)}if(a.skins)for(let d=0;d<a.skins.length;d++){const o=a.skins[d],r=new te(o.name);if(o.bones)for(let i=0;i<o.bones.length;i++){const l=s.findBone(o.bones[i]);if(l==null)throw new Error(`Skin bone not found: ${o.bones[d]}`);r.bones.push(l)}if(o.ik)for(let i=0;i<o.ik.length;i++){const l=s.findIkConstraint(o.ik[i]);if(l==null)throw new Error(`Skin IK constraint not found: ${o.ik[d]}`);r.constraints.push(l)}if(o.transform)for(let i=0;i<o.transform.length;i++){const l=s.findTransformConstraint(o.transform[i]);if(l==null)throw new Error(`Skin transform constraint not found: ${o.transform[d]}`);r.constraints.push(l)}if(o.path)for(let i=0;i<o.path.length;i++){const l=s.findPathConstraint(o.path[i]);if(l==null)throw new Error(`Skin path constraint not found: ${o.path[d]}`);r.constraints.push(l)}for(const i in o.attachments){const l=s.findSlot(i);if(l==null)throw new Error(`Slot not found: ${i}`);const f=o.attachments[i];for(const u in f){const h=this.readAttachment(f[u],r,l.index,u,s);h!=null&&r.setAttachment(l.index,u,h)}}s.skins.push(r),r.name=="default"&&(s.defaultSkin=r)}for(let d=0,o=this.linkedMeshes.length;d<o;d++){const r=this.linkedMeshes[d],i=r.skin==null?s.defaultSkin:s.findSkin(r.skin);if(i==null)throw new Error(`Skin not found: ${r.skin}`);const l=i.getAttachment(r.slotIndex,r.parent);if(l==null)throw new Error(`Parent mesh not found: ${r.parent}`);r.mesh.deformAttachment=r.inheritDeform?l:r.mesh,r.mesh.setParentMesh(l)}if(this.linkedMeshes.length=0,a.events)for(const d in a.events){const o=a.events[d],r=new we(d);r.intValue=this.getValue(o,"int",0),r.floatValue=this.getValue(o,"float",0),r.stringValue=this.getValue(o,"string",""),r.audioPath=this.getValue(o,"audio",null),r.audioPath!=null&&(r.volume=this.getValue(o,"volume",1),r.balance=this.getValue(o,"balance",0)),s.events.push(r)}if(a.animations)for(const d in a.animations){const o=a.animations[d];this.readAnimation(o,d,s)}return s}readAttachment(t,n,s,a,c){const d=this.scale;switch(a=this.getValue(t,"name",a),this.getValue(t,"type","region")){case"region":{const r=this.getValue(t,"path",a),i=this.attachmentLoader.newRegionAttachment(n,a,r);if(i==null)return null;i.path=r,i.x=this.getValue(t,"x",0)*d,i.y=this.getValue(t,"y",0)*d,i.scaleX=this.getValue(t,"scaleX",1),i.scaleY=this.getValue(t,"scaleY",1),i.rotation=this.getValue(t,"rotation",0),i.width=t.width*d,i.height=t.height*d;const l=this.getValue(t,"color",null);return l!=null&&i.color.setFromString(l),i}case"boundingbox":{const r=this.attachmentLoader.newBoundingBoxAttachment(n,a);if(r==null)return null;this.readVertices(t,r,t.vertexCount<<1);const i=this.getValue(t,"color",null);return i!=null&&r.color.setFromString(i),r}case"mesh":case"linkedmesh":{const r=this.getValue(t,"path",a),i=this.attachmentLoader.newMeshAttachment(n,a,r);if(i==null)return null;i.path=r;const l=this.getValue(t,"color",null);l!=null&&i.color.setFromString(l),i.width=this.getValue(t,"width",0)*d,i.height=this.getValue(t,"height",0)*d;const f=this.getValue(t,"parent",null);if(f!=null)return this.linkedMeshes.push(new en(i,this.getValue(t,"skin",null),s,f,this.getValue(t,"deform",!0))),i;const u=t.uvs;return this.readVertices(t,i,u.length),i.triangles=t.triangles,i.regionUVs=new Float32Array(u),i.edges=this.getValue(t,"edges",null),i.hullLength=this.getValue(t,"hull",0)*2,i}case"path":{const r=this.attachmentLoader.newPathAttachment(n,a);if(r==null)return null;r.closed=this.getValue(t,"closed",!1),r.constantSpeed=this.getValue(t,"constantSpeed",!0);const i=t.vertexCount;this.readVertices(t,r,i<<1);const l=T.newArray(i/3,0);for(let u=0;u<t.lengths.length;u++)l[u]=t.lengths[u]*d;r.lengths=l;const f=this.getValue(t,"color",null);return f!=null&&r.color.setFromString(f),r}case"point":{const r=this.attachmentLoader.newPointAttachment(n,a);if(r==null)return null;r.x=this.getValue(t,"x",0)*d,r.y=this.getValue(t,"y",0)*d,r.rotation=this.getValue(t,"rotation",0);const i=this.getValue(t,"color",null);return i!=null&&r.color.setFromString(i),r}case"clipping":{const r=this.attachmentLoader.newClippingAttachment(n,a);if(r==null)return null;const i=this.getValue(t,"end",null);if(i!=null){const u=c.findSlot(i);if(u==null)throw new Error(`Clipping end slot not found: ${i}`);r.endSlot=u}const l=t.vertexCount;this.readVertices(t,r,l<<1);const f=this.getValue(t,"color",null);return f!=null&&r.color.setFromString(f),r}}return null}readVertices(t,n,s){const a=this.scale;n.worldVerticesLength=s;const c=t.vertices;if(s==c.length){const r=T.toFloatArray(c);if(a!=1)for(let i=0,l=c.length;i<l;i++)r[i]*=a;n.vertices=r;return}const d=new Array,o=new Array;for(let r=0,i=c.length;r<i;){const l=c[r++];o.push(l);for(let f=r+l*4;r<f;r+=4)o.push(c[r]),d.push(c[r+1]*a),d.push(c[r+2]*a),d.push(c[r+3])}n.bones=o,n.vertices=T.toFloatArray(d)}readAnimation(t,n,s){const a=this.scale,c=new Array;let d=0;if(t.slots)for(const r in t.slots){const i=t.slots[r],l=s.findSlotIndex(r);if(l==-1)throw new Error(`Slot not found: ${r}`);for(const f in i){const u=i[f];if(f=="attachment"){const h=new Dt(u.length);h.slotIndex=l;let m=0;for(let p=0;p<u.length;p++){const g=u[p];h.setFrame(m++,this.getValue(g,"time",0),g.name)}c.push(h),d=Math.max(d,h.frames[h.getFrameCount()-1])}else if(f=="color"){const h=new lt(u.length);h.slotIndex=l;let m=0;for(let p=0;p<u.length;p++){const g=u[p],x=new B;x.setFromString(g.color||"ffffffff"),h.setFrame(m,this.getValue(g,"time",0),x.r,x.g,x.b,x.a),this.readCurve(g,h,m),m++}c.push(h),d=Math.max(d,h.frames[(h.getFrameCount()-1)*lt.ENTRIES])}else if(f=="twoColor"){const h=new tt(u.length);h.slotIndex=l;let m=0;for(let p=0;p<u.length;p++){const g=u[p],x=new B,E=new B;x.setFromString(g.light),E.setFromString(g.dark),h.setFrame(m,this.getValue(g,"time",0),x.r,x.g,x.b,x.a,E.r,E.g,E.b),this.readCurve(g,h,m),m++}c.push(h),d=Math.max(d,h.frames[(h.getFrameCount()-1)*tt.ENTRIES])}else throw new Error(`Invalid timeline type for a slot: ${f} (${r})`)}}if(t.bones)for(const r in t.bones){const i=t.bones[r],l=s.findBoneIndex(r);if(l==-1)throw new Error(`Bone not found: ${r}`);for(const f in i){const u=i[f];if(f==="rotate"){const h=new st(u.length);h.boneIndex=l;let m=0;for(let p=0;p<u.length;p++){const g=u[p];h.setFrame(m,this.getValue(g,"time",0),this.getValue(g,"angle",0)),this.readCurve(g,h,m),m++}c.push(h),d=Math.max(d,h.frames[(h.getFrameCount()-1)*st.ENTRIES])}else if(f==="translate"||f==="scale"||f==="shear"){let h=null,m=1,p=0;f==="scale"?(h=new gt(u.length),p=1):f==="shear"?h=new pt(u.length):(h=new Et(u.length),m=a),h.boneIndex=l;let g=0;for(let x=0;x<u.length;x++){const E=u[x],w=this.getValue(E,"x",p),M=this.getValue(E,"y",p);h.setFrame(g,this.getValue(E,"time",0),w*m,M*m),this.readCurve(E,h,g),g++}c.push(h),d=Math.max(d,h.frames[(h.getFrameCount()-1)*Et.ENTRIES])}else throw new Error(`Invalid timeline type for a bone: ${f} (${r})`)}}if(t.ik)for(const r in t.ik){const i=t.ik[r],l=s.findIkConstraint(r),f=new at(i.length);f.ikConstraintIndex=s.ikConstraints.indexOf(l);let u=0;for(let h=0;h<i.length;h++){const m=i[h];f.setFrame(u,this.getValue(m,"time",0),this.getValue(m,"mix",1),this.getValue(m,"softness",0)*a),this.readCurve(m,f,u),u++}c.push(f),d=Math.max(d,f.frames[(f.getFrameCount()-1)*at.ENTRIES])}if(t.transform)for(const r in t.transform){const i=t.transform[r],l=s.findTransformConstraint(r),f=new ct(i.length);f.transformConstraintIndex=s.transformConstraints.indexOf(l);let u=0;for(let h=0;h<i.length;h++){const m=i[h];f.setFrame(u,this.getValue(m,"time",0),this.getValue(m,"rotateMix",1),this.getValue(m,"translateMix",1),this.getValue(m,"scaleMix",1),this.getValue(m,"shearMix",1)),this.readCurve(m,f,u),u++}c.push(f),d=Math.max(d,f.frames[(f.getFrameCount()-1)*ct.ENTRIES])}if(t.path)for(const r in t.path){const i=t.path[r],l=s.findPathConstraintIndex(r);if(l==-1)throw new Error(`Path constraint not found: ${r}`);const f=s.pathConstraints[l];for(const u in i){const h=i[u];if(u==="position"||u==="spacing"){let m=null,p=1;u==="spacing"?(m=new yt(h.length),(f.spacingMode==nt.Length||f.spacingMode==nt.Fixed)&&(p=a)):(m=new Rt(h.length),f.positionMode==Vt.Fixed&&(p=a)),m.pathConstraintIndex=l;let g=0;for(let x=0;x<h.length;x++){const E=h[x];m.setFrame(g,this.getValue(E,"time",0),this.getValue(E,u,0)*p),this.readCurve(E,m,g),g++}c.push(m),d=Math.max(d,m.frames[(m.getFrameCount()-1)*Rt.ENTRIES])}else if(u==="mix"){const m=new At(h.length);m.pathConstraintIndex=l;let p=0;for(let g=0;g<h.length;g++){const x=h[g];m.setFrame(p,this.getValue(x,"time",0),this.getValue(x,"rotateMix",1),this.getValue(x,"translateMix",1)),this.readCurve(x,m,p),p++}c.push(m),d=Math.max(d,m.frames[(m.getFrameCount()-1)*At.ENTRIES])}}}if(t.deform)for(const r in t.deform){const i=t.deform[r],l=s.findSkin(r);if(l==null){if(ie.FAIL_ON_NON_EXISTING_SKIN)throw new Error(`Skin not found: ${r}`);continue}for(const f in i){const u=i[f],h=s.findSlotIndex(f);if(h==-1)throw new Error(`Slot not found: ${u.name}`);for(const m in u){const p=u[m],g=l.getAttachment(h,m);if(g==null)throw new Error(`Deform attachment not found: ${p.name}`);const x=g.bones!=null,E=g.vertices,w=x?E.length/3*2:E.length,M=new de(p.length);M.slotIndex=h,M.attachment=g;let b=0;for(let S=0;S<p.length;S++){const A=p[S];let C;const I=this.getValue(A,"vertices",null);if(I==null)C=x?T.newFloatArray(w):E;else{C=T.newFloatArray(w);const V=this.getValue(A,"offset",0);if(T.arrayCopy(I,0,C,V,I.length),a!=1)for(let O=V,N=O+I.length;O<N;O++)C[O]*=a;if(!x)for(let O=0;O<w;O++)C[O]+=E[O]}M.setFrame(b,this.getValue(A,"time",0),C,l.name),this.readCurve(A,M,b),b++}c.push(M),d=Math.max(d,M.frames[M.getFrameCount()-1])}}}let o=t.drawOrder;if(o==null&&(o=t.draworder),o!=null){const r=new Wt(o.length),i=s.slots.length;let l=0;for(let f=0;f<o.length;f++){const u=o[f];let h=null;const m=this.getValue(u,"offsets",null);if(m!=null){h=T.newArray(i,-1);const p=T.newArray(i-m.length,0);let g=0,x=0;for(let E=0;E<m.length;E++){const w=m[E],M=s.findSlotIndex(w.slot);if(M==-1)throw new Error(`Slot not found: ${w.slot}`);for(;g!=M;)p[x++]=g++;h[g+w.offset]=g++}for(;g<i;)p[x++]=g++;for(let E=i-1;E>=0;E--)h[E]==-1&&(h[E]=p[--x])}r.setFrame(l++,this.getValue(u,"time",0),h)}c.push(r),d=Math.max(d,r.frames[r.getFrameCount()-1])}if(t.events){const r=new Qt(t.events.length);let i=0;for(let l=0;l<t.events.length;l++){const f=t.events[l],u=s.findEvent(f.name);if(u==null)throw new Error(`Event not found: ${f.name}`);const h=new Ee(T.toSinglePrecision(this.getValue(f,"time",0)),u);h.intValue=this.getValue(f,"int",u.intValue),h.floatValue=this.getValue(f,"float",u.floatValue),h.stringValue=this.getValue(f,"string",u.stringValue),h.data.audioPath!=null&&(h.volume=this.getValue(f,"volume",1),h.balance=this.getValue(f,"balance",0)),r.setFrame(i++,h)}c.push(r),d=Math.max(d,r.frames[r.getFrameCount()-1])}if(isNaN(d))throw new Error("Error while parsing animation, duration is NaN");s.animations.push(new z(n,c,d))}readCurve(t,n,s){if(t.hasOwnProperty("curve"))if(t.curve==="stepped")n.setStepped(s);else{const a=t.curve;n.setCurve(s,a,this.getValue(t,"c2",0),this.getValue(t,"c3",1),this.getValue(t,"c4",1))}}getValue(t,n,s){return t[n]!==void 0?t[n]:s}static blendModeFromString(t){if(t=t.toLowerCase(),t=="normal")return Pt.NORMAL;if(t=="additive")return Pt.ADD;if(t=="multiply")return Pt.MULTIPLY;if(t=="screen")return Pt.SCREEN;throw new Error(`Unknown blend mode: ${t}`)}static positionModeFromString(t){if(t=t.toLowerCase(),t=="fixed")return Vt.Fixed;if(t=="percent")return Vt.Percent;throw new Error(`Unknown position mode: ${t}`)}static spacingModeFromString(t){if(t=t.toLowerCase(),t=="length")return nt.Length;if(t=="fixed")return nt.Fixed;if(t=="percent")return nt.Percent;throw new Error(`Unknown position mode: ${t}`)}static rotateModeFromString(t){if(t=t.toLowerCase(),t=="tangent")return Ct.Tangent;if(t=="chain")return Ct.Chain;if(t=="chainscale")return Ct.ChainScale;throw new Error(`Unknown rotate mode: ${t}`)}static transformModeFromString(t){if(t=t.toLowerCase(),t=="normal")return Z.Normal;if(t=="onlytranslation")return Z.OnlyTranslation;if(t=="norotationorreflection")return Z.NoRotationOrReflection;if(t=="noscale")return Z.NoScale;if(t=="noscaleorreflection")return Z.NoScaleOrReflection;throw new Error(`Unknown transform mode: ${t}`)}}class en{constructor(t,n,s,a,c){this.mesh=t,this.skin=n,this.slotIndex=s,this.parent=a,this.inheritDeform=c}}let nn=class extends Ne{createSkeleton(t){this.skeleton=new be(t),this.skeleton.updateWorldTransform(),this.stateData=new ge(t),this.state=new wt(this.stateData)}};var sn=Object.freeze({__proto__:null,Animation:z,AnimationState:wt,AnimationStateAdapter:Qe,AnimationStateData:ge,AtlasAttachmentLoader:_e,Attachment:ce,AttachmentTimeline:Dt,Bone:pe,BoneData:xe,BoundingBoxAttachment:ee,ClippingAttachment:ne,ColorTimeline:lt,ConstraintData:Jt,CurveTimeline:ut,DeformTimeline:de,DrawOrderTimeline:Wt,Event:Ee,EventData:we,EventQueue:ue,EventTimeline:Qt,EventType:mt,IkConstraint:Be,IkConstraintData:Me,IkConstraintTimeline:at,JitterEffect:ze,MeshAttachment:Xt,PathAttachment:Lt,PathConstraint:qt,PathConstraintData:Se,PathConstraintMixTimeline:At,PathConstraintPositionTimeline:Rt,PathConstraintSpacingTimeline:yt,PointAttachment:se,RegionAttachment:F,RotateTimeline:st,ScaleTimeline:gt,ShearTimeline:pt,Skeleton:be,SkeletonBinary:K,SkeletonBounds:tn,SkeletonData:Ae,SkeletonJson:Ot,Skin:te,SkinEntry:Ie,Slot:he,SlotData:ye,SpacingMode:nt,Spine:nn,SwirlEffect:Le,TimelineType:Oe,TrackEntry:Kt,TransformConstraint:We,TransformConstraintData:Re,TransformConstraintTimeline:ct,TranslateTimeline:Et,TwoColorTimeline:tt,VertexAttachment:Ft}),dt=(e=>(e[e.UNKNOWN=0]="UNKNOWN",e[e.VER34=34]="VER34",e[e.VER37=37]="VER37",e[e.VER38=38]="VER38",e[e.VER40=40]="VER40",e[e.VER41=41]="VER41",e))(dt||{});function jt(e){const t=e.substr(0,3),n=Math.floor(Number(t)*10+.001);return t==="3.3"||t==="3.4"?34:t==="3.7"?37:t==="3.8"?38:t==="4.0"?40:t==="4.1"?41:n<37?37:0}class an{constructor(){this.scale=1}readSkeletonData(t,n){let s=null,a=this.readVersionOldFormat(n),c=jt(a);if(c===dt.VER34&&(s=new K(new _e(t))),c===dt.VER38&&(s=new Ut.SkeletonBinary(new Ut.AtlasAttachmentLoader(t))),a=this.readVersionNewFormat(n),c=jt(a),(c===dt.VER40||c===dt.VER41)&&(s=new $t.SkeletonBinary(new $t.AtlasAttachmentLoader(t))),!s){const d=`Unsupported version of spine model ${a}, please update pixi-spine`;console.error(d)}return s.scale=this.scale,s.readSkeletonData(n)}readVersionOldFormat(t){const n=new oe(t);let s;try{n.readString(),s=n.readString()}catch(a){s=""}return s||""}readVersionNewFormat(t){const n=new oe(t);n.readInt32(),n.readInt32();let s;try{s=n.readString()}catch(a){s=""}return s||""}}class rn{constructor(){this.scale=1}readSkeletonData(t,n){const s=n.skeleton.spine,a=jt(s);let c=null;if(a===dt.VER37&&(c=new le.SkeletonJson(new le.AtlasAttachmentLoader(t))),a===dt.VER38&&(c=new Ut.SkeletonJson(new Ut.AtlasAttachmentLoader(t))),(a===dt.VER40||a===dt.VER41)&&(c=new $t.SkeletonJson(new $t.AtlasAttachmentLoader(t))),!c){const d=`Unsupported version of spine model ${s}, please update pixi-spine`;console.error(d)}return c.scale=this.scale,c.readSkeletonData(n)}}class on extends qe{createBinaryParser(){return new an}createJsonParser(){return new rn}parseData(t,n,s){return{spineData:t.readSkeletonData(n,s),spineAtlas:n}}}class ln extends Ne{createSkeleton(t){const n=jt(t.version);let s=null;if(n===dt.VER34&&(s=sn),n===dt.VER37&&(s=le),n===dt.VER38&&(s=Ut),(n===dt.VER40||n===dt.VER41)&&(s=$t),!s){const a=`Cant detect version of spine model ${t.version}`;console.error(a)}this.skeleton=new s.Skeleton(t),this.skeleton.updateWorldTransform(),this.stateData=new s.AnimationStateData(t),this.state=new s.AnimationState(this.stateData)}}new on().installLoader();export{dt as SPINE_VERSION,ln as Spine,jt as detectSpineVersion};
//# sourceMappingURL=loader-uni.mjs.map
