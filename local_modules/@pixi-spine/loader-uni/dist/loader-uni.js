/*!
 * @pixi-spine/loader-uni - v4.0.3
 * Compiled Tue, 13 Jun 2023 20:46:33 UTC
 *
 * @pixi-spine/loader-uni is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 * 
 * Copyright 2023, Mat Groves, All Rights Reserved
 */this.PIXI=this.PIXI||{},this.PIXI.spine=function(_t,Ne,f,wt,Ue,De,Oe){"use strict";function Qt(e){var t=Object.create(null);return e&&Object.keys(e).forEach(function(n){if(n!=="default"){var s=Object.getOwnPropertyDescriptor(e,n);Object.defineProperty(t,n,s.get?s:{enumerable:!0,get:function(){return e[n]}})}}),t.default=e,Object.freeze(t)}var Dt=Qt(Ue),Kt=Qt(De),Ot=Qt(Oe);class Jt{constructor(t){if(t==null)throw new Error("name cannot be null.");this.name=t}}const Ee=class extends Jt{constructor(e){super(e),this.id=(Ee.nextID++&65535)<<11,this.worldVerticesLength=0,this.deformAttachment=this}computeWorldVerticesOld(e,t){this.computeWorldVertices(e,0,this.worldVerticesLength,t,0,2)}computeWorldVertices(e,t,n,s,i,c){n=i+(n>>1)*c;const d=e.bone.skeleton,a=e.deform;let r=this.vertices;const o=this.bones;if(o==null){a.length>0&&(r=a);const h=e.bone.matrix,g=h.tx,M=h.ty,x=h.a,p=h.c,E=h.b,w=h.d;for(let S=t,y=i;y<n;S+=2,y+=c){const A=r[S],R=r[S+1];s[y]=A*x+R*p+g,s[y+1]=A*E+R*w+M}return}let l=0,u=0;for(let h=0;h<t;h+=2){const g=o[l];l+=g+1,u+=g}const m=d.bones;if(a.length==0)for(let h=i,g=u*3;h<n;h+=c){let M=0,x=0,p=o[l++];for(p+=l;l<p;l++,g+=3){const E=m[o[l]].matrix,w=r[g],S=r[g+1],y=r[g+2];M+=(w*E.a+S*E.c+E.tx)*y,x+=(w*E.b+S*E.d+E.ty)*y}s[h]=M,s[h+1]=x}else{const h=a;for(let g=i,M=u*3,x=u<<1;g<n;g+=c){let p=0,E=0,w=o[l++];for(w+=l;l<w;l++,M+=3,x+=2){const S=m[o[l]].matrix,y=r[M]+h[x],A=r[M+1]+h[x+1],R=r[M+2];p+=(y*S.a+A*S.c+S.tx)*R,E+=(y*S.b+A*S.d+S.ty)*R}s[g]=p,s[g+1]=E}}}copyTo(e){this.bones!=null?(e.bones=new Array(this.bones.length),f.Utils.arrayCopy(this.bones,0,e.bones,0,this.bones.length)):e.bones=null,this.vertices!=null?(e.vertices=f.Utils.newFloatArray(this.vertices.length),f.Utils.arrayCopy(this.vertices,0,e.vertices,0,this.vertices.length)):e.vertices=null,e.worldVerticesLength=this.worldVerticesLength,e.deformAttachment=this.deformAttachment}};let Rt=Ee;Rt.nextID=0;class Xt extends Rt{constructor(t){super(t),this.type=f.AttachmentType.BoundingBox,this.color=new f.Color(1,1,1,1)}copy(){const t=new Xt(this.name);return this.copyTo(t),t.color.setFromColor(this.color),t}}class bt extends Rt{constructor(t){super(t),this.type=f.AttachmentType.Clipping,this.color=new f.Color(.2275,.2275,.8078,1)}copy(){const t=new bt(this.name);return this.copyTo(t),t.endSlot=this.endSlot,t.color.setFromColor(this.color),t}}class Ct extends Rt{constructor(t){super(t),this.type=f.AttachmentType.Mesh,this.color=new f.Color(1,1,1,1),this.tempColor=new f.Color(0,0,0,0)}getParentMesh(){return this.parentMesh}setParentMesh(t){this.parentMesh=t,t!=null&&(this.bones=t.bones,this.vertices=t.vertices,this.worldVerticesLength=t.worldVerticesLength,this.regionUVs=t.regionUVs,this.triangles=t.triangles,this.hullLength=t.hullLength,this.worldVerticesLength=t.worldVerticesLength)}copy(){if(this.parentMesh!=null)return this.newLinkedMesh();const t=new Ct(this.name);return t.region=this.region,t.path=this.path,t.color.setFromColor(this.color),this.copyTo(t),t.regionUVs=new Float32Array(this.regionUVs.length),f.Utils.arrayCopy(this.regionUVs,0,t.regionUVs,0,this.regionUVs.length),t.triangles=new Array(this.triangles.length),f.Utils.arrayCopy(this.triangles,0,t.triangles,0,this.triangles.length),t.hullLength=this.hullLength,this.edges!=null&&(t.edges=new Array(this.edges.length),f.Utils.arrayCopy(this.edges,0,t.edges,0,this.edges.length)),t.width=this.width,t.height=this.height,t}newLinkedMesh(){const t=new Ct(this.name);return t.region=this.region,t.path=this.path,t.color.setFromColor(this.color),t.deformAttachment=this.deformAttachment,t.setParentMesh(this.parentMesh!=null?this.parentMesh:this),t}}class Vt extends Rt{constructor(t){super(t),this.type=f.AttachmentType.Path,this.closed=!1,this.constantSpeed=!1,this.color=new f.Color(1,1,1,1)}copy(){const t=new Vt(this.name);return this.copyTo(t),t.lengths=new Array(this.lengths.length),f.Utils.arrayCopy(this.lengths,0,t.lengths,0,this.lengths.length),t.closed=closed,t.constantSpeed=this.constantSpeed,t.color.setFromColor(this.color),t}}class Wt extends Rt{constructor(t){super(t),this.type=f.AttachmentType.Point,this.color=new f.Color(.38,.94,0,1)}computeWorldPosition(t,n){const s=t.matrix;return n.x=this.x*s.a+this.y*s.c+t.worldX,n.y=this.x*s.b+this.y*s.d+t.worldY,n}computeWorldRotation(t){const n=t.matrix,s=f.MathUtils.cosDeg(this.rotation),i=f.MathUtils.sinDeg(this.rotation),c=s*n.a+i*n.c,d=s*n.b+i*n.d;return Math.atan2(d,c)*f.MathUtils.radDeg}copy(){const t=new Wt(this.name);return t.x=this.x,t.y=this.y,t.rotation=this.rotation,t.color.setFromColor(this.color),t}}class te{constructor(t,n){if(this.deform=new Array,t==null)throw new Error("data cannot be null.");if(n==null)throw new Error("bone cannot be null.");this.data=t,this.bone=n,this.color=new f.Color,this.darkColor=t.darkColor==null?null:new f.Color,this.setToSetupPose(),this.blendMode=this.data.blendMode}getAttachment(){return this.attachment}setAttachment(t){this.attachment!=t&&(this.attachment=t,this.attachmentTime=this.bone.skeleton.time,this.deform.length=0)}setAttachmentTime(t){this.attachmentTime=this.bone.skeleton.time-t}getAttachmentTime(){return this.bone.skeleton.time-this.attachmentTime}setToSetupPose(){this.color.setFromColor(this.data.color),this.darkColor!=null&&this.darkColor.setFromColor(this.data.darkColor),this.data.attachmentName==null?this.attachment=null:(this.attachment=null,this.setAttachment(this.bone.skeleton.getAttachment(this.data.index,this.data.attachmentName)))}}const Q=class extends Jt{constructor(e){super(e),this.type=f.AttachmentType.Region,this.x=0,this.y=0,this.scaleX=1,this.scaleY=1,this.rotation=0,this.width=0,this.height=0,this.color=new f.Color(1,1,1,1),this.offset=f.Utils.newFloatArray(8),this.uvs=f.Utils.newFloatArray(8),this.tempColor=new f.Color(1,1,1,1)}updateOffset(){const e=this.width/this.region.originalWidth*this.scaleX,t=this.height/this.region.originalHeight*this.scaleY,n=-this.width/2*this.scaleX+this.region.offsetX*e,s=-this.height/2*this.scaleY+this.region.offsetY*t,i=n+this.region.width*e,c=s+this.region.height*t,d=this.rotation*Math.PI/180,a=Math.cos(d),r=Math.sin(d),o=n*a+this.x,l=n*r,u=s*a+this.y,m=s*r,h=i*a+this.x,g=i*r,M=c*a+this.y,x=c*r,p=this.offset;p[Q.OX1]=o-m,p[Q.OY1]=u+l,p[Q.OX2]=o-x,p[Q.OY2]=M+l,p[Q.OX3]=h-x,p[Q.OY3]=M+g,p[Q.OX4]=h-m,p[Q.OY4]=u+g}setRegion(e){this.region=e;const t=this.uvs;e.rotate?(t[2]=e.u,t[3]=e.v2,t[4]=e.u,t[5]=e.v,t[6]=e.u2,t[7]=e.v,t[0]=e.u2,t[1]=e.v2):(t[0]=e.u,t[1]=e.v2,t[2]=e.u,t[3]=e.v,t[4]=e.u2,t[5]=e.v,t[6]=e.u2,t[7]=e.v2)}computeWorldVertices(e,t,n,s){const i=this.offset,c=e instanceof te?e.bone.matrix:e.matrix,d=c.tx,a=c.ty,r=c.a,o=c.c,l=c.b,u=c.d;let m=0,h=0;m=i[Q.OX1],h=i[Q.OY1],t[n]=m*r+h*o+d,t[n+1]=m*l+h*u+a,n+=s,m=i[Q.OX2],h=i[Q.OY2],t[n]=m*r+h*o+d,t[n+1]=m*l+h*u+a,n+=s,m=i[Q.OX3],h=i[Q.OY3],t[n]=m*r+h*o+d,t[n+1]=m*l+h*u+a,n+=s,m=i[Q.OX4],h=i[Q.OY4],t[n]=m*r+h*o+d,t[n+1]=m*l+h*u+a}copy(){const e=new Q(this.name);return e.region=this.region,e.rendererObject=this.rendererObject,e.path=this.path,e.x=this.x,e.y=this.y,e.scaleX=this.scaleX,e.scaleY=this.scaleY,e.rotation=this.rotation,e.width=this.width,e.height=this.height,f.Utils.arrayCopy(this.uvs,0,e.uvs,0,8),f.Utils.arrayCopy(this.offset,0,e.offset,0,8),e.color.setFromColor(this.color),e}};let P=Q;P.OX1=0,P.OY1=1,P.OX2=2,P.OY2=3,P.OX3=4,P.OY3=5,P.OX4=6,P.OY4=7,P.X1=0,P.Y1=1,P.C1R=2,P.C1G=3,P.C1B=4,P.C1A=5,P.U1=6,P.V1=7,P.X2=8,P.Y2=9,P.C2R=10,P.C2G=11,P.C2B=12,P.C2A=13,P.U2=14,P.V2=15,P.X3=16,P.Y3=17,P.C3R=18,P.C3G=19,P.C3B=20,P.C3A=21,P.U3=22,P.V3=23,P.X4=24,P.Y4=25,P.C4R=26,P.C4G=27,P.C4B=28,P.C4A=29,P.U4=30,P.V4=31;class Le{constructor(t,n){this.jitterX=0,this.jitterY=0,this.jitterX=t,this.jitterY=n}begin(t){}transform(t,n,s,i){t.x+=f.MathUtils.randomTriangular(-this.jitterX,this.jitterY),t.y+=f.MathUtils.randomTriangular(-this.jitterX,this.jitterY)}end(){}}const we=class{constructor(e){this.centerX=0,this.centerY=0,this.radius=0,this.angle=0,this.worldX=0,this.worldY=0,this.radius=e}begin(e){this.worldX=e.x+this.centerX,this.worldY=e.y+this.centerY}transform(e,t,n,s){const i=this.angle*f.MathUtils.degreesToRadians,c=e.x-this.worldX,d=e.y-this.worldY,a=Math.sqrt(c*c+d*d);if(a<this.radius){const r=we.interpolation.apply(0,i,(this.radius-a)/this.radius),o=Math.cos(r),l=Math.sin(r);e.x=o*c-l*d+this.worldX,e.y=l*c+o*d+this.worldY}}end(){}};let Se=we;Se.interpolation=new f.PowOut(2);class H{constructor(t,n,s){if(t==null)throw new Error("name cannot be null.");if(n==null)throw new Error("timelines cannot be null.");this.name=t,this.timelines=n,this.timelineIds=[];for(let i=0;i<n.length;i++)this.timelineIds[n[i].getPropertyId()]=!0;this.duration=s}hasTimeline(t){return this.timelineIds[t]==!0}apply(t,n,s,i,c,d,a,r){if(t==null)throw new Error("skeleton cannot be null.");i&&this.duration!=0&&(s%=this.duration,n>0&&(n%=this.duration));const o=this.timelines;for(let l=0,u=o.length;l<u;l++)o[l].apply(t,n,s,c,d,a,r)}static binarySearch(t,n,s=1){let i=0,c=t.length/s-2;if(c==0)return s;let d=c>>>1;for(;;){if(t[(d+1)*s]<=n?i=d+1:c=d,i==c)return(i+1)*s;d=i+c>>>1}}static linearSearch(t,n,s){for(let i=0,c=t.length-s;i<=c;i+=s)if(t[i]>n)return i;return-1}}var Ae=(e=>(e[e.rotate=0]="rotate",e[e.translate=1]="translate",e[e.scale=2]="scale",e[e.shear=3]="shear",e[e.attachment=4]="attachment",e[e.color=5]="color",e[e.deform=6]="deform",e[e.event=7]="event",e[e.drawOrder=8]="drawOrder",e[e.ikConstraint=9]="ikConstraint",e[e.transformConstraint=10]="transformConstraint",e[e.pathConstraintPosition=11]="pathConstraintPosition",e[e.pathConstraintSpacing=12]="pathConstraintSpacing",e[e.pathConstraintMix=13]="pathConstraintMix",e[e.twoColor=14]="twoColor",e))(Ae||{});const j=class{constructor(e){if(this.curveData=[],e<=0)throw new Error(`frameCount must be > 0: ${e}`);this.curves=f.Utils.newFloatArray((e-1)*j.BEZIER_SIZE)}getFrameCount(){return this.curves.length/j.BEZIER_SIZE+1}setLinear(e){this.curves[e*j.BEZIER_SIZE]=j.LINEAR}setStepped(e){this.curves[e*j.BEZIER_SIZE]=j.STEPPED}getCurveType(e){const t=e*j.BEZIER_SIZE;if(t==this.curves.length)return j.LINEAR;const n=this.curves[t];return n==j.LINEAR?j.LINEAR:n==j.STEPPED?j.STEPPED:j.BEZIER}setCurve(e,t,n,s,i){this.curveData.push({frameIndex:e,cx1:t,cy1:n,cx2:s,cy2:i});const c=(-t*2+s)*.03,d=(-n*2+i)*.03,a=((t-s)*3+1)*.006,r=((n-i)*3+1)*.006;let o=c*2+a,l=d*2+r,u=t*.3+c+a*.16666667,m=n*.3+d+r*.16666667,h=e*j.BEZIER_SIZE;const g=this.curves;g[h++]=j.BEZIER;let M=u,x=m;for(let p=h+j.BEZIER_SIZE-1;h<p;h+=2)g[h]=M,g[h+1]=x,u+=o,m+=l,o+=a,l+=r,M+=u,x+=m}getCurvePercent(e,t){t=f.MathUtils.clamp(t,0,1);const n=this.curves;let s=e*j.BEZIER_SIZE;const i=n[s];if(i==j.LINEAR)return t;if(i==j.STEPPED)return 0;s++;let c=0;for(let a=s,r=s+j.BEZIER_SIZE-1;s<r;s+=2)if(c=n[s],c>=t){let o,l;return s==a?(o=0,l=0):(o=n[s-2],l=n[s-1]),l+(n[s+1]-l)*(t-o)/(c-o)}const d=n[s-1];return d+(1-d)*(t-c)/(1-c)}};let lt=j;lt.LINEAR=0,lt.STEPPED=1,lt.BEZIER=2,lt.BEZIER_SIZE=10*2-1;const It=class extends lt{constructor(e){super(e),this.data=[],this.frames=f.Utils.newFloatArray(e<<1)}getPropertyId(){return(0<<24)+this.boneIndex}setFrame(e,t,n){this.data.push({frameIndex:e,time:t,degrees:n}),e<<=1,this.frames[e]=t,this.frames[e+It.ROTATION]=n}apply(e,t,n,s,i,c,d){const a=this.frames,r=e.bones[this.boneIndex];if(!r.active)return;if(n<a[0]){switch(c){case f.MixBlend.setup:r.rotation=r.data.rotation;return;case f.MixBlend.first:const g=r.data.rotation-r.rotation;r.rotation+=(g-(16384-(16384.499999999996-g/360|0))*360)*i}return}if(n>=a[a.length-It.ENTRIES]){let g=a[a.length+It.PREV_ROTATION];switch(c){case f.MixBlend.setup:r.rotation=r.data.rotation+g*i;break;case f.MixBlend.first:case f.MixBlend.replace:g+=r.data.rotation-r.rotation,g-=(16384-(16384.499999999996-g/360|0))*360;case f.MixBlend.add:r.rotation+=g*i}return}const o=H.binarySearch(a,n,It.ENTRIES),l=a[o+It.PREV_ROTATION],u=a[o],m=this.getCurvePercent((o>>1)-1,1-(n-u)/(a[o+It.PREV_TIME]-u));let h=a[o+It.ROTATION]-l;switch(h=l+(h-(16384-(16384.499999999996-h/360|0))*360)*m,c){case f.MixBlend.setup:r.rotation=r.data.rotation+(h-(16384-(16384.499999999996-h/360|0))*360)*i;break;case f.MixBlend.first:case f.MixBlend.replace:h+=r.data.rotation-r.rotation;case f.MixBlend.add:r.rotation+=(h-(16384-(16384.499999999996-h/360|0))*360)*i}}};let J=It;J.ENTRIES=2,J.PREV_TIME=-2,J.PREV_ROTATION=-1,J.ROTATION=1;const et=class extends lt{constructor(e){super(e),this.data=[],this.frames=f.Utils.newFloatArray(e*et.ENTRIES)}getPropertyId(){return(1<<24)+this.boneIndex}setFrame(e,t,n,s){this.data.push({frameIndex:e,time:t,x:n,y:s}),e*=et.ENTRIES,this.frames[e]=t,this.frames[e+et.X]=n,this.frames[e+et.Y]=s}apply(e,t,n,s,i,c,d){const a=this.frames,r=e.bones[this.boneIndex];if(!r.active)return;if(n<a[0]){switch(c){case f.MixBlend.setup:r.x=r.data.x,r.y=r.data.y;return;case f.MixBlend.first:r.x+=(r.data.x-r.x)*i,r.y+=(r.data.y-r.y)*i}return}let o=0,l=0;if(n>=a[a.length-et.ENTRIES])o=a[a.length+et.PREV_X],l=a[a.length+et.PREV_Y];else{const u=H.binarySearch(a,n,et.ENTRIES);o=a[u+et.PREV_X],l=a[u+et.PREV_Y];const m=a[u],h=this.getCurvePercent(u/et.ENTRIES-1,1-(n-m)/(a[u+et.PREV_TIME]-m));o+=(a[u+et.X]-o)*h,l+=(a[u+et.Y]-l)*h}switch(c){case f.MixBlend.setup:r.x=r.data.x+o*i,r.y=r.data.y+l*i;break;case f.MixBlend.first:case f.MixBlend.replace:r.x+=(r.data.x+o-r.x)*i,r.y+=(r.data.y+l-r.y)*i;break;case f.MixBlend.add:r.x+=o*i,r.y+=l*i}}};let ut=et;ut.ENTRIES=3,ut.PREV_TIME=-3,ut.PREV_X=-2,ut.PREV_Y=-1,ut.X=1,ut.Y=2;class ct extends ut{constructor(t){super(t)}getPropertyId(){return(2<<24)+this.boneIndex}apply(t,n,s,i,c,d,a){const r=this.frames,o=t.bones[this.boneIndex];if(!o.active)return;if(s<r[0]){switch(d){case f.MixBlend.setup:o.scaleX=o.data.scaleX,o.scaleY=o.data.scaleY;return;case f.MixBlend.first:o.scaleX+=(o.data.scaleX-o.scaleX)*c,o.scaleY+=(o.data.scaleY-o.scaleY)*c}return}let l=0,u=0;if(s>=r[r.length-ct.ENTRIES])l=r[r.length+ct.PREV_X]*o.data.scaleX,u=r[r.length+ct.PREV_Y]*o.data.scaleY;else{const m=H.binarySearch(r,s,ct.ENTRIES);l=r[m+ct.PREV_X],u=r[m+ct.PREV_Y];const h=r[m],g=this.getCurvePercent(m/ct.ENTRIES-1,1-(s-h)/(r[m+ct.PREV_TIME]-h));l=(l+(r[m+ct.X]-l)*g)*o.data.scaleX,u=(u+(r[m+ct.Y]-u)*g)*o.data.scaleY}if(c==1)d==f.MixBlend.add?(o.scaleX+=l-o.data.scaleX,o.scaleY+=u-o.data.scaleY):(o.scaleX=l,o.scaleY=u);else{let m=0,h=0;if(a==f.MixDirection.mixOut)switch(d){case f.MixBlend.setup:m=o.data.scaleX,h=o.data.scaleY,o.scaleX=m+(Math.abs(l)*f.MathUtils.signum(m)-m)*c,o.scaleY=h+(Math.abs(u)*f.MathUtils.signum(h)-h)*c;break;case f.MixBlend.first:case f.MixBlend.replace:m=o.scaleX,h=o.scaleY,o.scaleX=m+(Math.abs(l)*f.MathUtils.signum(m)-m)*c,o.scaleY=h+(Math.abs(u)*f.MathUtils.signum(h)-h)*c;break;case f.MixBlend.add:m=o.scaleX,h=o.scaleY,o.scaleX=m+(Math.abs(l)*f.MathUtils.signum(m)-o.data.scaleX)*c,o.scaleY=h+(Math.abs(u)*f.MathUtils.signum(h)-o.data.scaleY)*c}else switch(d){case f.MixBlend.setup:m=Math.abs(o.data.scaleX)*f.MathUtils.signum(l),h=Math.abs(o.data.scaleY)*f.MathUtils.signum(u),o.scaleX=m+(l-m)*c,o.scaleY=h+(u-h)*c;break;case f.MixBlend.first:case f.MixBlend.replace:m=Math.abs(o.scaleX)*f.MathUtils.signum(l),h=Math.abs(o.scaleY)*f.MathUtils.signum(u),o.scaleX=m+(l-m)*c,o.scaleY=h+(u-h)*c;break;case f.MixBlend.add:m=f.MathUtils.signum(l),h=f.MathUtils.signum(u),o.scaleX=Math.abs(o.scaleX)*m+(l-Math.abs(o.data.scaleX)*m)*c,o.scaleY=Math.abs(o.scaleY)*h+(u-Math.abs(o.data.scaleY)*h)*c}}}}class ht extends ut{constructor(t){super(t)}getPropertyId(){return(3<<24)+this.boneIndex}apply(t,n,s,i,c,d,a){const r=this.frames,o=t.bones[this.boneIndex];if(!o.active)return;if(s<r[0]){switch(d){case f.MixBlend.setup:o.shearX=o.data.shearX,o.shearY=o.data.shearY;return;case f.MixBlend.first:o.shearX+=(o.data.shearX-o.shearX)*c,o.shearY+=(o.data.shearY-o.shearY)*c}return}let l=0,u=0;if(s>=r[r.length-ht.ENTRIES])l=r[r.length+ht.PREV_X],u=r[r.length+ht.PREV_Y];else{const m=H.binarySearch(r,s,ht.ENTRIES);l=r[m+ht.PREV_X],u=r[m+ht.PREV_Y];const h=r[m],g=this.getCurvePercent(m/ht.ENTRIES-1,1-(s-h)/(r[m+ht.PREV_TIME]-h));l=l+(r[m+ht.X]-l)*g,u=u+(r[m+ht.Y]-u)*g}switch(d){case f.MixBlend.setup:o.shearX=o.data.shearX+l*c,o.shearY=o.data.shearY+u*c;break;case f.MixBlend.first:case f.MixBlend.replace:o.shearX+=(o.data.shearX+l-o.shearX)*c,o.shearY+=(o.data.shearY+u-o.shearY)*c;break;case f.MixBlend.add:o.shearX+=l*c,o.shearY+=u*c}}}const _=class extends lt{constructor(e){super(e),this.data=[],this.frames=f.Utils.newFloatArray(e*_.ENTRIES)}getPropertyId(){return(5<<24)+this.slotIndex}setFrame(e,t,n,s,i,c){this.data.push({frameIndex:e,time:t,r:n,g:s,b:i,a:c}),e*=_.ENTRIES,this.frames[e]=t,this.frames[e+_.R]=n,this.frames[e+_.G]=s,this.frames[e+_.B]=i,this.frames[e+_.A]=c}apply(e,t,n,s,i,c,d){const a=e.slots[this.slotIndex];if(!a.bone.active)return;const r=this.frames;if(n<r[0]){switch(c){case f.MixBlend.setup:a.color.setFromColor(a.data.color);return;case f.MixBlend.first:const h=a.color,g=a.data.color;h.add((g.r-h.r)*i,(g.g-h.g)*i,(g.b-h.b)*i,(g.a-h.a)*i)}return}let o=0,l=0,u=0,m=0;if(n>=r[r.length-_.ENTRIES]){const h=r.length;o=r[h+_.PREV_R],l=r[h+_.PREV_G],u=r[h+_.PREV_B],m=r[h+_.PREV_A]}else{const h=H.binarySearch(r,n,_.ENTRIES);o=r[h+_.PREV_R],l=r[h+_.PREV_G],u=r[h+_.PREV_B],m=r[h+_.PREV_A];const g=r[h],M=this.getCurvePercent(h/_.ENTRIES-1,1-(n-g)/(r[h+_.PREV_TIME]-g));o+=(r[h+_.R]-o)*M,l+=(r[h+_.G]-l)*M,u+=(r[h+_.B]-u)*M,m+=(r[h+_.A]-m)*M}if(i==1)a.color.set(o,l,u,m);else{const h=a.color;c==f.MixBlend.setup&&h.setFromColor(a.data.color),h.add((o-h.r)*i,(l-h.g)*i,(u-h.b)*i,(m-h.a)*i)}}};let nt=_;nt.ENTRIES=5,nt.PREV_TIME=-5,nt.PREV_R=-4,nt.PREV_G=-3,nt.PREV_B=-2,nt.PREV_A=-1,nt.R=1,nt.G=2,nt.B=3,nt.A=4;const O=class extends lt{constructor(e){super(e),this.data=[],this.frames=f.Utils.newFloatArray(e*O.ENTRIES)}getPropertyId(){return(14<<24)+this.slotIndex}setFrame(e,t,n,s,i,c,d,a,r){this.data.push({frameIndex:e,time:t,r:n,g:s,b:i,a:c,r2:d,g2:a,b2:r}),e*=O.ENTRIES,this.frames[e]=t,this.frames[e+O.R]=n,this.frames[e+O.G]=s,this.frames[e+O.B]=i,this.frames[e+O.A]=c,this.frames[e+O.R2]=d,this.frames[e+O.G2]=a,this.frames[e+O.B2]=r}apply(e,t,n,s,i,c,d){const a=e.slots[this.slotIndex];if(!a.bone.active)return;const r=this.frames;if(n<r[0]){switch(c){case f.MixBlend.setup:a.color.setFromColor(a.data.color),a.darkColor.setFromColor(a.data.darkColor);return;case f.MixBlend.first:const x=a.color,p=a.darkColor,E=a.data.color,w=a.data.darkColor;x.add((E.r-x.r)*i,(E.g-x.g)*i,(E.b-x.b)*i,(E.a-x.a)*i),p.add((w.r-p.r)*i,(w.g-p.g)*i,(w.b-p.b)*i,0)}return}let o=0,l=0,u=0,m=0,h=0,g=0,M=0;if(n>=r[r.length-O.ENTRIES]){const x=r.length;o=r[x+O.PREV_R],l=r[x+O.PREV_G],u=r[x+O.PREV_B],m=r[x+O.PREV_A],h=r[x+O.PREV_R2],g=r[x+O.PREV_G2],M=r[x+O.PREV_B2]}else{const x=H.binarySearch(r,n,O.ENTRIES);o=r[x+O.PREV_R],l=r[x+O.PREV_G],u=r[x+O.PREV_B],m=r[x+O.PREV_A],h=r[x+O.PREV_R2],g=r[x+O.PREV_G2],M=r[x+O.PREV_B2];const p=r[x],E=this.getCurvePercent(x/O.ENTRIES-1,1-(n-p)/(r[x+O.PREV_TIME]-p));o+=(r[x+O.R]-o)*E,l+=(r[x+O.G]-l)*E,u+=(r[x+O.B]-u)*E,m+=(r[x+O.A]-m)*E,h+=(r[x+O.R2]-h)*E,g+=(r[x+O.G2]-g)*E,M+=(r[x+O.B2]-M)*E}if(i==1)a.color.set(o,l,u,m),a.darkColor.set(h,g,M,1);else{const x=a.color,p=a.darkColor;c==f.MixBlend.setup&&(x.setFromColor(a.data.color),p.setFromColor(a.data.darkColor)),x.add((o-x.r)*i,(l-x.g)*i,(u-x.b)*i,(m-x.a)*i),p.add((h-p.r)*i,(g-p.g)*i,(M-p.b)*i,0)}}};let z=O;z.ENTRIES=8,z.PREV_TIME=-8,z.PREV_R=-7,z.PREV_G=-6,z.PREV_B=-5,z.PREV_A=-4,z.PREV_R2=-3,z.PREV_G2=-2,z.PREV_B2=-1,z.R=1,z.G=2,z.B=3,z.A=4,z.R2=5,z.G2=6,z.B2=7;class vt{constructor(t){this.data=[],this.frames=f.Utils.newFloatArray(t),this.attachmentNames=new Array(t)}getPropertyId(){return(4<<24)+this.slotIndex}getFrameCount(){return this.frames.length}setFrame(t,n,s){this.data.push({frameIndex:t,time:n,attachmentName:s}),this.frames[t]=n,this.attachmentNames[t]=s}apply(t,n,s,i,c,d,a){const r=t.slots[this.slotIndex];if(!r.bone.active)return;if(a==f.MixDirection.mixOut){d==f.MixBlend.setup&&this.setAttachment(t,r,r.data.attachmentName);return}const o=this.frames;if(s<o[0]){(d==f.MixBlend.setup||d==f.MixBlend.first)&&this.setAttachment(t,r,r.data.attachmentName);return}let l=0;s>=o[o.length-1]?l=o.length-1:l=H.binarySearch(o,s,1)-1;const u=this.attachmentNames[l];t.slots[this.slotIndex].setAttachment(u==null?null:t.getAttachment(this.slotIndex,u))}setAttachment(t,n,s){n.setAttachment(s==null?null:t.getAttachment(this.slotIndex,s))}}let ye=null;class ee extends lt{constructor(t){super(t),this.data=[],this.frames=f.Utils.newFloatArray(t),this.frameVertices=new Array(t),ye==null&&(ye=f.Utils.newFloatArray(64))}getPropertyId(){return(6<<27)+Number(this.attachment.id)+this.slotIndex}setFrame(t,n,s,i){this.data.push({frameIndex:t,time:n,vertices:s,skin:i}),this.frames[t]=n,this.frameVertices[t]=s}apply(t,n,s,i,c,d,a){const r=t.slots[this.slotIndex];if(!r.bone.active)return;const o=r.getAttachment();if(!(o instanceof Rt)||o.deformAttachment!=this.attachment)return;const l=r.deform||[];l.length==0&&(d=f.MixBlend.setup);const u=this.frameVertices,m=u[0].length,h=this.frames;if(s<h[0]){const S=o;switch(d){case f.MixBlend.setup:l.length=0;return;case f.MixBlend.first:if(c==1){l.length=0;break}const y=f.Utils.setArraySize(l,m);if(S.bones==null){const A=S.vertices;for(let R=0;R<m;R++)y[R]+=(A[R]-y[R])*c}else{c=1-c;for(let A=0;A<m;A++)y[A]*=c}}return}const g=f.Utils.setArraySize(l,m);if(s>=h[h.length-1]){const S=u[h.length-1];if(c==1)if(d==f.MixBlend.add){const y=o;if(y.bones==null){const A=y.vertices;for(let R=0;R<m;R++)g[R]+=S[R]-A[R]}else for(let A=0;A<m;A++)g[A]+=S[A]}else f.Utils.arrayCopy(S,0,g,0,m);else switch(d){case f.MixBlend.setup:{const A=o;if(A.bones==null){const R=A.vertices;for(let T=0;T<m;T++){const I=R[T];g[T]=I+(S[T]-I)*c}}else for(let R=0;R<m;R++)g[R]=S[R]*c;break}case f.MixBlend.first:case f.MixBlend.replace:for(let A=0;A<m;A++)g[A]+=(S[A]-g[A])*c;break;case f.MixBlend.add:const y=o;if(y.bones==null){const A=y.vertices;for(let R=0;R<m;R++)g[R]+=(S[R]-A[R])*c}else for(let A=0;A<m;A++)g[A]+=S[A]*c}return}const M=H.binarySearch(h,s),x=u[M-1],p=u[M],E=h[M],w=this.getCurvePercent(M-1,1-(s-E)/(h[M-1]-E));if(c==1)if(d==f.MixBlend.add){const S=o;if(S.bones==null){const y=S.vertices;for(let A=0;A<m;A++){const R=x[A];g[A]+=R+(p[A]-R)*w-y[A]}}else for(let y=0;y<m;y++){const A=x[y];g[y]+=A+(p[y]-A)*w}}else for(let S=0;S<m;S++){const y=x[S];g[S]=y+(p[S]-y)*w}else switch(d){case f.MixBlend.setup:{const y=o;if(y.bones==null){const A=y.vertices;for(let R=0;R<m;R++){const T=x[R],I=A[R];g[R]=I+(T+(p[R]-T)*w-I)*c}}else for(let A=0;A<m;A++){const R=x[A];g[A]=(R+(p[A]-R)*w)*c}break}case f.MixBlend.first:case f.MixBlend.replace:for(let y=0;y<m;y++){const A=x[y];g[y]+=(A+(p[y]-A)*w-g[y])*c}break;case f.MixBlend.add:const S=o;if(S.bones==null){const y=S.vertices;for(let A=0;A<m;A++){const R=x[A];g[A]+=(R+(p[A]-R)*w-y[A])*c}}else for(let y=0;y<m;y++){const A=x[y];g[y]+=(A+(p[y]-A)*w)*c}}}}class qt{constructor(t){this.data=[],this.frames=f.Utils.newFloatArray(t),this.events=new Array(t)}getPropertyId(){return 7<<24}getFrameCount(){return this.frames.length}setFrame(t,n){this.data.push({frameIndex:t,event:n}),this.frames[t]=n.time,this.events[t]=n}apply(t,n,s,i,c,d,a){if(i==null)return;const r=this.frames,o=this.frames.length;if(n>s)this.apply(t,n,Number.MAX_VALUE,i,c,d,a),n=-1;else if(n>=r[o-1])return;if(s<r[0])return;let l=0;if(n<r[0])l=0;else{l=H.binarySearch(r,n);const u=r[l];for(;l>0&&r[l-1]==u;)l--}for(;l<o&&s>=r[l];l++)i.push(this.events[l])}}class Bt{constructor(t){this.data=[],this.frames=f.Utils.newFloatArray(t),this.drawOrders=new Array(t)}getPropertyId(){return 8<<24}getFrameCount(){return this.frames.length}setFrame(t,n,s){this.data.push({frameIndex:t,time:n,drawOrder:s}),this.frames[t]=n,this.drawOrders[t]=s}apply(t,n,s,i,c,d,a){const r=t.drawOrder,o=t.slots;if(a==f.MixDirection.mixOut&&d==f.MixBlend.setup){f.Utils.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}const l=this.frames;if(s<l[0]){(d==f.MixBlend.setup||d==f.MixBlend.first)&&f.Utils.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}let u=0;s>=l[l.length-1]?u=l.length-1:u=H.binarySearch(l,s)-1;const m=this.drawOrders[u];if(m==null)f.Utils.arrayCopy(o,0,r,0,o.length);else for(let h=0,g=m.length;h<g;h++)r[h]=o[m[h]]}}const W=class extends lt{constructor(e){super(e),this.data=[],this.frames=f.Utils.newFloatArray(e*W.ENTRIES)}getPropertyId(){return(9<<24)+this.ikConstraintIndex}setFrame(e,t,n,s){this.data.push({frameIndex:e,time:t,mix:n,bendDirection:s}),e*=W.ENTRIES,this.frames[e]=t,this.frames[e+W.MIX]=n,this.frames[e+W.BEND_DIRECTION]=s}apply(e,t,n,s,i,c,d){const a=this.frames,r=e.ikConstraints[this.ikConstraintIndex];if(!r.active)return;if(n<a[0]){switch(c){case f.MixBlend.setup:r.mix=r.data.mix,r.softness=r.data.softness,r.bendDirection=r.data.bendDirection,r.compress=r.data.compress,r.stretch=r.data.stretch;return;case f.MixBlend.first:r.mix+=(r.data.mix-r.mix)*i,r.softness+=(r.data.softness-r.softness)*i,r.bendDirection=r.data.bendDirection,r.compress=r.data.compress,r.stretch=r.data.stretch}return}if(n>=a[a.length-W.ENTRIES]){c===f.MixBlend.setup?(r.mix=r.data.mix+(a[a.length+W.PREV_MIX]-r.data.mix)*i,r.softness=r.data.softness+(a[a.length+W.PREV_SOFTNESS]-r.data.softness)*i,d===f.MixDirection.mixOut?(r.bendDirection=r.data.bendDirection,r.compress=r.data.compress,r.stretch=r.data.stretch):(r.bendDirection=a[a.length+W.PREV_BEND_DIRECTION],r.compress=a[a.length+W.PREV_COMPRESS]!==0,r.stretch=a[a.length+W.PREV_STRETCH]!==0)):(r.mix+=(a[a.length+W.PREV_MIX]-r.mix)*i,r.softness+=(a[a.length+W.PREV_SOFTNESS]-r.softness)*i,d===f.MixDirection.mixIn&&(r.bendDirection=a[a.length+W.PREV_BEND_DIRECTION],r.compress=a[a.length+W.PREV_COMPRESS]!==0,r.stretch=a[a.length+W.PREV_STRETCH]!==0));return}const o=H.binarySearch(a,n,W.ENTRIES),l=a[o+W.PREV_MIX],u=a[o],m=this.getCurvePercent(o/W.ENTRIES-1,1-(n-u)/(a[o+W.PREV_TIME]-u));r.mix+=(l+(a[o+W.MIX]-l)*m-r.mix)*i,r.bendDirection=Math.floor(a[o+W.PREV_BEND_DIRECTION])}};let tt=W;tt.ENTRIES=6,tt.PREV_TIME=-6,tt.PREV_MIX=-5,tt.PREV_SOFTNESS=-4,tt.PREV_BEND_DIRECTION=-3,tt.PREV_COMPRESS=-2,tt.PREV_STRETCH=-1,tt.MIX=1,tt.SOFTNESS=2,tt.BEND_DIRECTION=3,tt.COMPRESS=4,tt.STRETCH=5;const X=class extends lt{constructor(e){super(e),this.data=[],this.frames=f.Utils.newFloatArray(e*X.ENTRIES)}getPropertyId(){return(10<<24)+this.transformConstraintIndex}setFrame(e,t,n,s,i,c){this.data.push({frameIndex:e,time:t,rotateMix:n,translateMix:s,scaleMix:i,shearMix:c}),e*=X.ENTRIES,this.frames[e]=t,this.frames[e+X.ROTATE]=n,this.frames[e+X.TRANSLATE]=s,this.frames[e+X.SCALE]=i,this.frames[e+X.SHEAR]=c}apply(e,t,n,s,i,c,d){const a=this.frames,r=e.transformConstraints[this.transformConstraintIndex];if(!r.active)return;if(n<a[0]){const h=r.data;switch(c){case f.MixBlend.setup:r.rotateMix=h.rotateMix,r.translateMix=h.translateMix,r.scaleMix=h.scaleMix,r.shearMix=h.shearMix;return;case f.MixBlend.first:r.rotateMix+=(h.rotateMix-r.rotateMix)*i,r.translateMix+=(h.translateMix-r.translateMix)*i,r.scaleMix+=(h.scaleMix-r.scaleMix)*i,r.shearMix+=(h.shearMix-r.shearMix)*i}return}let o=0,l=0,u=0,m=0;if(n>=a[a.length-X.ENTRIES]){const h=a.length;o=a[h+X.PREV_ROTATE],l=a[h+X.PREV_TRANSLATE],u=a[h+X.PREV_SCALE],m=a[h+X.PREV_SHEAR]}else{const h=H.binarySearch(a,n,X.ENTRIES);o=a[h+X.PREV_ROTATE],l=a[h+X.PREV_TRANSLATE],u=a[h+X.PREV_SCALE],m=a[h+X.PREV_SHEAR];const g=a[h],M=this.getCurvePercent(h/X.ENTRIES-1,1-(n-g)/(a[h+X.PREV_TIME]-g));o+=(a[h+X.ROTATE]-o)*M,l+=(a[h+X.TRANSLATE]-l)*M,u+=(a[h+X.SCALE]-u)*M,m+=(a[h+X.SHEAR]-m)*M}if(c==f.MixBlend.setup){const h=r.data;r.rotateMix=h.rotateMix+(o-h.rotateMix)*i,r.translateMix=h.translateMix+(l-h.translateMix)*i,r.scaleMix=h.scaleMix+(u-h.scaleMix)*i,r.shearMix=h.shearMix+(m-h.shearMix)*i}else r.rotateMix+=(o-r.rotateMix)*i,r.translateMix+=(l-r.translateMix)*i,r.scaleMix+=(u-r.scaleMix)*i,r.shearMix+=(m-r.shearMix)*i}};let st=X;st.ENTRIES=5,st.PREV_TIME=-5,st.PREV_ROTATE=-4,st.PREV_TRANSLATE=-3,st.PREV_SCALE=-2,st.PREV_SHEAR=-1,st.ROTATE=1,st.TRANSLATE=2,st.SCALE=3,st.SHEAR=4;const xt=class extends lt{constructor(e){super(e),this.data=[],this.frames=f.Utils.newFloatArray(e*xt.ENTRIES)}getPropertyId(){return(11<<24)+this.pathConstraintIndex}setFrame(e,t,n){this.data.push({frameIndex:e,time:t,value:n}),e*=xt.ENTRIES,this.frames[e]=t,this.frames[e+xt.VALUE]=n}apply(e,t,n,s,i,c,d){const a=this.frames,r=e.pathConstraints[this.pathConstraintIndex];if(!r.active)return;if(n<a[0]){switch(c){case f.MixBlend.setup:r.position=r.data.position;return;case f.MixBlend.first:r.position+=(r.data.position-r.position)*i}return}let o=0;if(n>=a[a.length-xt.ENTRIES])o=a[a.length+xt.PREV_VALUE];else{const l=H.binarySearch(a,n,xt.ENTRIES);o=a[l+xt.PREV_VALUE];const u=a[l],m=this.getCurvePercent(l/xt.ENTRIES-1,1-(n-u)/(a[l+xt.PREV_TIME]-u));o+=(a[l+xt.VALUE]-o)*m}c==f.MixBlend.setup?r.position=r.data.position+(o-r.data.position)*i:r.position+=(o-r.position)*i}};let Et=xt;Et.ENTRIES=2,Et.PREV_TIME=-2,Et.PREV_VALUE=-1,Et.VALUE=1;class Mt extends Et{constructor(t){super(t)}getPropertyId(){return(12<<24)+this.pathConstraintIndex}apply(t,n,s,i,c,d,a){const r=this.frames,o=t.pathConstraints[this.pathConstraintIndex];if(!o.active)return;if(s<r[0]){switch(d){case f.MixBlend.setup:o.spacing=o.data.spacing;return;case f.MixBlend.first:o.spacing+=(o.data.spacing-o.spacing)*c}return}let l=0;if(s>=r[r.length-Mt.ENTRIES])l=r[r.length+Mt.PREV_VALUE];else{const u=H.binarySearch(r,s,Mt.ENTRIES);l=r[u+Mt.PREV_VALUE];const m=r[u],h=this.getCurvePercent(u/Mt.ENTRIES-1,1-(s-m)/(r[u+Mt.PREV_TIME]-m));l+=(r[u+Mt.VALUE]-l)*h}d==f.MixBlend.setup?o.spacing=o.data.spacing+(l-o.data.spacing)*c:o.spacing+=(l-o.spacing)*c}}const it=class extends lt{constructor(e){super(e),this.data=[],this.frames=f.Utils.newFloatArray(e*it.ENTRIES)}getPropertyId(){return(13<<24)+this.pathConstraintIndex}setFrame(e,t,n,s){this.data.push({frameIndex:e,time:t,rotateMix:n,translateMix:s}),e*=it.ENTRIES,this.frames[e]=t,this.frames[e+it.ROTATE]=n,this.frames[e+it.TRANSLATE]=s}apply(e,t,n,s,i,c,d){const a=this.frames,r=e.pathConstraints[this.pathConstraintIndex];if(!r.active)return;if(n<a[0]){switch(c){case f.MixBlend.setup:r.rotateMix=r.data.rotateMix,r.translateMix=r.data.translateMix;return;case f.MixBlend.first:r.rotateMix+=(r.data.rotateMix-r.rotateMix)*i,r.translateMix+=(r.data.translateMix-r.translateMix)*i}return}let o=0,l=0;if(n>=a[a.length-it.ENTRIES])o=a[a.length+it.PREV_ROTATE],l=a[a.length+it.PREV_TRANSLATE];else{const u=H.binarySearch(a,n,it.ENTRIES);o=a[u+it.PREV_ROTATE],l=a[u+it.PREV_TRANSLATE];const m=a[u],h=this.getCurvePercent(u/it.ENTRIES-1,1-(n-m)/(a[u+it.PREV_TIME]-m));o+=(a[u+it.ROTATE]-o)*h,l+=(a[u+it.TRANSLATE]-l)*h}c==f.MixBlend.setup?(r.rotateMix=r.data.rotateMix+(o-r.data.rotateMix)*i,r.translateMix=r.data.translateMix+(l-r.data.translateMix)*i):(r.rotateMix+=(o-r.rotateMix)*i,r.translateMix+=(l-r.translateMix)*i)}};let pt=it;pt.ENTRIES=3,pt.PREV_TIME=-3,pt.PREV_ROTATE=-2,pt.PREV_TRANSLATE=-1,pt.ROTATE=1,pt.TRANSLATE=2;const b=class{constructor(e){this.tracks=new Array,this.timeScale=1,this.unkeyedState=0,this.events=new Array,this.listeners=new Array,this.queue=new se(this),this.propertyIDs=new f.IntSet,this.animationsChanged=!1,this.trackEntryPool=new f.Pool(()=>new $t),this.data=e}update(e){e*=this.timeScale;const t=this.tracks;for(let n=0,s=t.length;n<s;n++){const i=t[n];if(i==null)continue;i.animationLast=i.nextAnimationLast,i.trackLast=i.nextTrackLast;let c=e*i.timeScale;if(i.delay>0){if(i.delay-=c,i.delay>0)continue;c=-i.delay,i.delay=0}let d=i.next;if(d!=null){const a=i.trackLast-d.delay;if(a>=0){for(d.delay=0,d.trackTime+=i.timeScale==0?0:(a/i.timeScale+e)*d.timeScale,i.trackTime+=c,this.setCurrent(n,d,!0);d.mixingFrom!=null;)d.mixTime+=e,d=d.mixingFrom;continue}}else if(i.trackLast>=i.trackEnd&&i.mixingFrom==null){t[n]=null,this.queue.end(i),this.disposeNext(i);continue}if(i.mixingFrom!=null&&this.updateMixingFrom(i,e)){let a=i.mixingFrom;for(i.mixingFrom=null,a!=null&&(a.mixingTo=null);a!=null;)this.queue.end(a),a=a.mixingFrom}i.trackTime+=c}this.queue.drain()}updateMixingFrom(e,t){const n=e.mixingFrom;if(n==null)return!0;const s=this.updateMixingFrom(n,t);return n.animationLast=n.nextAnimationLast,n.trackLast=n.nextTrackLast,e.mixTime>0&&e.mixTime>=e.mixDuration?((n.totalAlpha==0||e.mixDuration==0)&&(e.mixingFrom=n.mixingFrom,n.mixingFrom!=null&&(n.mixingFrom.mixingTo=e),e.interruptAlpha=n.interruptAlpha,this.queue.end(n)),s):(n.trackTime+=t*n.timeScale,e.mixTime+=t,!1)}apply(e){if(e==null)throw new Error("skeleton cannot be null.");this.animationsChanged&&this._animationsChanged();const t=this.events,n=this.tracks;let s=!1;for(let d=0,a=n.length;d<a;d++){const r=n[d];if(r==null||r.delay>0)continue;s=!0;const o=d==0?f.MixBlend.first:r.mixBlend;let l=r.alpha;r.mixingFrom!=null?l*=this.applyMixingFrom(r,e,o):r.trackTime>=r.trackEnd&&r.next==null&&(l=0);const u=r.animationLast,m=r.getAnimationTime(),h=r.animation.timelines.length,g=r.animation.timelines;if(d==0&&l==1||o==f.MixBlend.add)for(let M=0;M<h;M++){f.Utils.webkit602BugfixHelper(l,o);const x=g[M];x instanceof vt?this.applyAttachmentTimeline(x,e,m,o,!0):x.apply(e,u,m,t,l,o,f.MixDirection.mixIn)}else{const M=r.timelineMode,x=r.timelinesRotation.length==0;x&&f.Utils.setArraySize(r.timelinesRotation,h<<1,null);const p=r.timelinesRotation;for(let E=0;E<h;E++){const w=g[E],S=M[E]==b.SUBSEQUENT?o:f.MixBlend.setup;w instanceof J?this.applyRotateTimeline(w,e,m,l,S,p,E<<1,x):w instanceof vt?this.applyAttachmentTimeline(w,e,m,o,!0):(f.Utils.webkit602BugfixHelper(l,o),w.apply(e,u,m,t,l,S,f.MixDirection.mixIn))}}this.queueEvents(r,m),t.length=0,r.nextAnimationLast=m,r.nextTrackLast=r.trackTime}const i=this.unkeyedState+b.SETUP,c=e.slots;for(let d=0,a=e.slots.length;d<a;d++){const r=c[d];if(r.attachmentState==i){const o=r.data.attachmentName;r.setAttachment(o==null?null:e.getAttachment(r.data.index,o))}}return this.unkeyedState+=2,this.queue.drain(),s}applyMixingFrom(e,t,n){const s=e.mixingFrom;s.mixingFrom!=null&&this.applyMixingFrom(s,t,n);let i=0;e.mixDuration==0?(i=1,n==f.MixBlend.first&&(n=f.MixBlend.setup)):(i=e.mixTime/e.mixDuration,i>1&&(i=1),n!=f.MixBlend.first&&(n=s.mixBlend));const c=i<s.eventThreshold?this.events:null,d=i<s.attachmentThreshold,a=i<s.drawOrderThreshold,r=s.animationLast,o=s.getAnimationTime(),l=s.animation.timelines.length,u=s.animation.timelines,m=s.alpha*e.interruptAlpha,h=m*(1-i);if(n==f.MixBlend.add)for(let g=0;g<l;g++)u[g].apply(t,r,o,c,h,n,f.MixDirection.mixOut);else{const g=s.timelineMode,M=s.timelineHoldMix,x=s.timelinesRotation.length==0;x&&f.Utils.setArraySize(s.timelinesRotation,l<<1,null);const p=s.timelinesRotation;s.totalAlpha=0;for(let E=0;E<l;E++){const w=u[E];let S=f.MixDirection.mixOut,y,A=0;switch(g[E]){case b.SUBSEQUENT:if(!a&&w instanceof Bt)continue;y=n,A=h;break;case b.FIRST:y=f.MixBlend.setup,A=h;break;case b.HOLD_SUBSEQUENT:y=n,A=m;break;case b.HOLD_FIRST:y=f.MixBlend.setup,A=m;break;default:y=f.MixBlend.setup;const R=M[E];A=m*Math.max(0,1-R.mixTime/R.mixDuration);break}s.totalAlpha+=A,w instanceof J?this.applyRotateTimeline(w,t,o,A,y,p,E<<1,x):w instanceof vt?this.applyAttachmentTimeline(w,t,o,y,d):(f.Utils.webkit602BugfixHelper(A,n),a&&w instanceof Bt&&y==f.MixBlend.setup&&(S=f.MixDirection.mixIn),w.apply(t,r,o,c,A,y,S))}}return e.mixDuration>0&&this.queueEvents(s,o),this.events.length=0,s.nextAnimationLast=o,s.nextTrackLast=s.trackTime,i}applyAttachmentTimeline(e,t,n,s,i){const c=t.slots[e.slotIndex];if(!c.bone.active)return;const d=e.frames;if(n<d[0])(s==f.MixBlend.setup||s==f.MixBlend.first)&&this.setAttachment(t,c,c.data.attachmentName,i);else{let a;n>=d[d.length-1]?a=d.length-1:a=H.binarySearch(d,n)-1,this.setAttachment(t,c,e.attachmentNames[a],i)}c.attachmentState<=this.unkeyedState&&(c.attachmentState=this.unkeyedState+b.SETUP)}setAttachment(e,t,n,s){t.setAttachment(n==null?null:e.getAttachment(t.data.index,n)),s&&(t.attachmentState=this.unkeyedState+b.CURRENT)}applyRotateTimeline(e,t,n,s,i,c,d,a){if(a&&(c[d]=0),s==1){e.apply(t,0,n,null,1,i,f.MixDirection.mixIn);return}const r=e,o=r.frames,l=t.bones[r.boneIndex];if(!l.active)return;let u=0,m=0;if(n<o[0])switch(i){case f.MixBlend.setup:l.rotation=l.data.rotation;default:return;case f.MixBlend.first:u=l.rotation,m=l.data.rotation}else if(u=i==f.MixBlend.setup?l.data.rotation:l.rotation,n>=o[o.length-J.ENTRIES])m=l.data.rotation+o[o.length+J.PREV_ROTATION];else{const M=H.binarySearch(o,n,J.ENTRIES),x=o[M+J.PREV_ROTATION],p=o[M],E=r.getCurvePercent((M>>1)-1,1-(n-p)/(o[M+J.PREV_TIME]-p));m=o[M+J.ROTATION]-x,m-=(16384-(16384.499999999996-m/360|0))*360,m=x+m*E+l.data.rotation,m-=(16384-(16384.499999999996-m/360|0))*360}let h=0,g=m-u;if(g-=(16384-(16384.499999999996-g/360|0))*360,g==0)h=c[d];else{let M=0,x=0;a?(M=0,x=g):(M=c[d],x=c[d+1]);const p=g>0;let E=M>=0;f.MathUtils.signum(x)!=f.MathUtils.signum(g)&&Math.abs(x)<=90&&(Math.abs(M)>180&&(M+=360*f.MathUtils.signum(M)),E=p),h=g+M-M%360,E!=p&&(h+=360*f.MathUtils.signum(M)),c[d]=h}c[d+1]=g,u+=h*s,l.rotation=u-(16384-(16384.499999999996-u/360|0))*360}queueEvents(e,t){const n=e.animationStart,s=e.animationEnd,i=s-n,c=e.trackLast%i,d=this.events;let a=0;const r=d.length;for(;a<r;a++){const l=d[a];if(l.time<c)break;l.time>s||this.queue.event(e,l)}let o=!1;for(e.loop?o=i==0||c>e.trackTime%i:o=t>=s&&e.animationLast<s,o&&this.queue.complete(e);a<r;a++)d[a].time<n||this.queue.event(e,d[a])}clearTracks(){const e=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let t=0,n=this.tracks.length;t<n;t++)this.clearTrack(t);this.tracks.length=0,this.queue.drainDisabled=e,this.queue.drain()}clearTrack(e){if(e>=this.tracks.length)return;const t=this.tracks[e];if(t==null)return;this.queue.end(t),this.disposeNext(t);let n=t;for(;;){const s=n.mixingFrom;if(s==null)break;this.queue.end(s),n.mixingFrom=null,n.mixingTo=null,n=s}this.tracks[t.trackIndex]=null,this.queue.drain()}setCurrent(e,t,n){const s=this.expandToIndex(e);this.tracks[e]=t,s!=null&&(n&&this.queue.interrupt(s),t.mixingFrom=s,s.mixingTo=t,t.mixTime=0,s.mixingFrom!=null&&s.mixDuration>0&&(t.interruptAlpha*=Math.min(1,s.mixTime/s.mixDuration)),s.timelinesRotation.length=0),this.queue.start(t)}setAnimation(e,t,n){const s=this.data.skeletonData.findAnimation(t);if(s==null)throw new Error(`Animation not found: ${t}`);return this.setAnimationWith(e,s,n)}setAnimationWith(e,t,n){if(t==null)throw new Error("animation cannot be null.");let s=!0,i=this.expandToIndex(e);i!=null&&(i.nextTrackLast==-1?(this.tracks[e]=i.mixingFrom,this.queue.interrupt(i),this.queue.end(i),this.disposeNext(i),i=i.mixingFrom,s=!1):this.disposeNext(i));const c=this.trackEntry(e,t,n,i);return this.setCurrent(e,c,s),this.queue.drain(),c}addAnimation(e,t,n,s){const i=this.data.skeletonData.findAnimation(t);if(i==null)throw new Error(`Animation not found: ${t}`);return this.addAnimationWith(e,i,n,s)}addAnimationWith(e,t,n,s){if(t==null)throw new Error("animation cannot be null.");let i=this.expandToIndex(e);if(i!=null)for(;i.next!=null;)i=i.next;const c=this.trackEntry(e,t,n,i);if(i==null)this.setCurrent(e,c,!0),this.queue.drain();else if(i.next=c,s<=0){const d=i.animationEnd-i.animationStart;d!=0?(i.loop?s+=d*(1+(i.trackTime/d|0)):s+=Math.max(d,i.trackTime),s-=this.data.getMix(i.animation,t)):s=i.trackTime}return c.delay=s,c}setEmptyAnimation(e,t){const n=this.setAnimationWith(e,b.emptyAnimation,!1);return n.mixDuration=t,n.trackEnd=t,n}addEmptyAnimation(e,t,n){n<=0&&(n-=t);const s=this.addAnimationWith(e,b.emptyAnimation,!1,n);return s.mixDuration=t,s.trackEnd=t,s}setEmptyAnimations(e){const t=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let n=0,s=this.tracks.length;n<s;n++){const i=this.tracks[n];i!=null&&this.setEmptyAnimation(i.trackIndex,e)}this.queue.drainDisabled=t,this.queue.drain()}expandToIndex(e){return e<this.tracks.length?this.tracks[e]:(f.Utils.ensureArrayCapacity(this.tracks,e+1,null),this.tracks.length=e+1,null)}trackEntry(e,t,n,s){const i=this.trackEntryPool.obtain();return i.trackIndex=e,i.animation=t,i.loop=n,i.holdPrevious=!1,i.eventThreshold=0,i.attachmentThreshold=0,i.drawOrderThreshold=0,i.animationStart=0,i.animationEnd=t.duration,i.animationLast=-1,i.nextAnimationLast=-1,i.delay=0,i.trackTime=0,i.trackLast=-1,i.nextTrackLast=-1,i.trackEnd=Number.MAX_VALUE,i.timeScale=1,i.alpha=1,i.interruptAlpha=1,i.mixTime=0,i.mixDuration=s==null?0:this.data.getMix(s.animation,t),i.mixBlend=f.MixBlend.replace,i}disposeNext(e){let t=e.next;for(;t!=null;)this.queue.dispose(t),t=t.next;e.next=null}_animationsChanged(){this.animationsChanged=!1,this.propertyIDs.clear();for(let e=0,t=this.tracks.length;e<t;e++){let n=this.tracks[e];if(n!=null){for(;n.mixingFrom!=null;)n=n.mixingFrom;do(n.mixingFrom==null||n.mixBlend!=f.MixBlend.add)&&this.computeHold(n),n=n.mixingTo;while(n!=null)}}}computeHold(e){const t=e.mixingTo,n=e.animation.timelines,s=e.animation.timelines.length,i=f.Utils.setArraySize(e.timelineMode,s);e.timelineHoldMix.length=0;const c=f.Utils.setArraySize(e.timelineHoldMix,s),d=this.propertyIDs;if(t!=null&&t.holdPrevious){for(let a=0;a<s;a++)i[a]=d.add(n[a].getPropertyId())?b.HOLD_FIRST:b.HOLD_SUBSEQUENT;return}t:for(let a=0;a<s;a++){const r=n[a],o=r.getPropertyId();if(!d.add(o))i[a]=b.SUBSEQUENT;else if(t==null||r instanceof vt||r instanceof Bt||r instanceof qt||!t.animation.hasTimeline(o))i[a]=b.FIRST;else{for(let l=t.mixingTo;l!=null;l=l.mixingTo)if(!l.animation.hasTimeline(o)){if(e.mixDuration>0){i[a]=b.HOLD_MIX,c[a]=l;continue t}break}i[a]=b.HOLD_FIRST}}}getCurrent(e){return e>=this.tracks.length?null:this.tracks[e]}addListener(e){if(e==null)throw new Error("listener cannot be null.");this.listeners.push(e)}removeListener(e){const t=this.listeners.indexOf(e);t>=0&&this.listeners.splice(t,1)}clearListeners(){this.listeners.length=0}clearListenerNotifications(){this.queue.clear()}setAnimationByName(e,t,n){b.deprecatedWarning1||(b.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.")),this.setAnimation(e,t,n)}addAnimationByName(e,t,n,s){b.deprecatedWarning2||(b.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.")),this.addAnimation(e,t,n,s)}hasAnimation(e){return this.data.skeletonData.findAnimation(e)!==null}hasAnimationByName(e){return b.deprecatedWarning3||(b.deprecatedWarning3=!0,console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.")),this.hasAnimation(e)}};let mt=b;mt.emptyAnimation=new H("<empty>",[],0),mt.SUBSEQUENT=0,mt.FIRST=1,mt.HOLD_SUBSEQUENT=2,mt.HOLD_FIRST=3,mt.HOLD_MIX=4,mt.SETUP=1,mt.CURRENT=2,mt.deprecatedWarning1=!1,mt.deprecatedWarning2=!1,mt.deprecatedWarning3=!1;const St=class{constructor(){this.mixBlend=f.MixBlend.replace,this.timelineMode=new Array,this.timelineHoldMix=new Array,this.timelinesRotation=new Array}reset(){this.next=null,this.mixingFrom=null,this.mixingTo=null,this.animation=null,this.listener=null,this.timelineMode.length=0,this.timelineHoldMix.length=0,this.timelinesRotation.length=0}getAnimationTime(){if(this.loop){const e=this.animationEnd-this.animationStart;return e==0?this.animationStart:this.trackTime%e+this.animationStart}return Math.min(this.trackTime+this.animationStart,this.animationEnd)}setAnimationLast(e){this.animationLast=e,this.nextAnimationLast=e}isComplete(){return this.trackTime>=this.animationEnd-this.animationStart}resetRotationDirections(){this.timelinesRotation.length=0}get time(){return St.deprecatedWarning1||(St.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime}set time(e){St.deprecatedWarning1||(St.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime=e}get endTime(){return St.deprecatedWarning2||(St.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime}set endTime(e){St.deprecatedWarning2||(St.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime=e}loopsCount(){return Math.floor(this.trackTime/this.trackEnd)}};let $t=St;$t.deprecatedWarning1=!1,$t.deprecatedWarning2=!1;const ne=class{constructor(e){this.objects=[],this.drainDisabled=!1,this.animState=e}start(e){this.objects.push(dt.start),this.objects.push(e),this.animState.animationsChanged=!0}interrupt(e){this.objects.push(dt.interrupt),this.objects.push(e)}end(e){this.objects.push(dt.end),this.objects.push(e),this.animState.animationsChanged=!0}dispose(e){this.objects.push(dt.dispose),this.objects.push(e)}complete(e){this.objects.push(dt.complete),this.objects.push(e)}event(e,t){this.objects.push(dt.event),this.objects.push(e),this.objects.push(t)}deprecateStuff(){return ne.deprecatedWarning1||(ne.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'")),!0}drain(){if(this.drainDisabled)return;this.drainDisabled=!0;const e=this.objects,t=this.animState.listeners;for(let n=0;n<e.length;n+=2){const s=e[n],i=e[n+1];switch(s){case dt.start:i.listener!=null&&i.listener.start&&i.listener.start(i);for(let a=0;a<t.length;a++)t[a].start&&t[a].start(i);i.onStart&&this.deprecateStuff()&&i.onStart(i.trackIndex),this.animState.onStart&&this.deprecateStuff()&&this.deprecateStuff&&this.animState.onStart(i.trackIndex);break;case dt.interrupt:i.listener!=null&&i.listener.interrupt&&i.listener.interrupt(i);for(let a=0;a<t.length;a++)t[a].interrupt&&t[a].interrupt(i);break;case dt.end:i.listener!=null&&i.listener.end&&i.listener.end(i);for(let a=0;a<t.length;a++)t[a].end&&t[a].end(i);i.onEnd&&this.deprecateStuff()&&i.onEnd(i.trackIndex),this.animState.onEnd&&this.deprecateStuff()&&this.animState.onEnd(i.trackIndex);case dt.dispose:i.listener!=null&&i.listener.dispose&&i.listener.dispose(i);for(let a=0;a<t.length;a++)t[a].dispose&&t[a].dispose(i);this.animState.trackEntryPool.free(i);break;case dt.complete:i.listener!=null&&i.listener.complete&&i.listener.complete(i);for(let a=0;a<t.length;a++)t[a].complete&&t[a].complete(i);const c=f.MathUtils.toInt(i.loopsCount());i.onComplete&&this.deprecateStuff()&&i.onComplete(i.trackIndex,c),this.animState.onComplete&&this.deprecateStuff()&&this.animState.onComplete(i.trackIndex,c);break;case dt.event:const d=e[n+++2];i.listener!=null&&i.listener.event&&i.listener.event(i,d);for(let a=0;a<t.length;a++)t[a].event&&t[a].event(i,d);i.onEvent&&this.deprecateStuff()&&i.onEvent(i.trackIndex,d),this.animState.onEvent&&this.deprecateStuff()&&this.animState.onEvent(i.trackIndex,d);break}}this.clear(),this.drainDisabled=!1}clear(){this.objects.length=0}};let se=ne;se.deprecatedWarning1=!1;var dt=(e=>(e[e.start=0]="start",e[e.interrupt=1]="interrupt",e[e.end=2]="end",e[e.dispose=3]="dispose",e[e.complete=4]="complete",e[e.event=5]="event",e))(dt||{});class Ye{start(t){}interrupt(t){}end(t){}dispose(t){}complete(t){}event(t,n){}}const ie=class{constructor(e){if(this.animationToMixTime={},this.defaultMix=0,e==null)throw new Error("skeletonData cannot be null.");this.skeletonData=e}setMix(e,t,n){const s=this.skeletonData.findAnimation(e);if(s==null)throw new Error(`Animation not found: ${e}`);const i=this.skeletonData.findAnimation(t);if(i==null)throw new Error(`Animation not found: ${t}`);this.setMixWith(s,i,n)}setMixByName(e,t,n){ie.deprecatedWarning1||(ie.deprecatedWarning1=!0,console.warn("Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.")),this.setMix(e,t,n)}setMixWith(e,t,n){if(e==null)throw new Error("from cannot be null.");if(t==null)throw new Error("to cannot be null.");const s=`${e.name}.${t.name}`;this.animationToMixTime[s]=n}getMix(e,t){const n=`${e.name}.${t.name}`,s=this.animationToMixTime[n];return s===void 0?this.defaultMix:s}};let re=ie;re.deprecatedWarning1=!1;class Re{constructor(t){this.atlas=t}newRegionAttachment(t,n,s){const i=this.atlas.findRegion(s);if(i==null)throw new Error(`Region not found in atlas: ${s} (region attachment: ${n})`);const c=new P(n);return c.region=i,c}newMeshAttachment(t,n,s){const i=this.atlas.findRegion(s);if(i==null)throw new Error(`Region not found in atlas: ${s} (mesh attachment: ${n})`);const c=new Ct(n);return c.region=i,c}newBoundingBoxAttachment(t,n){return new Xt(n)}newPathAttachment(t,n){return new Vt(n)}newPointAttachment(t,n){return new Wt(n)}newClippingAttachment(t,n){return new bt(n)}}class oe{constructor(t,n,s){if(this.matrix=new wt.Matrix,this.children=new Array,this.x=0,this.y=0,this.rotation=0,this.scaleX=0,this.scaleY=0,this.shearX=0,this.shearY=0,this.ax=0,this.ay=0,this.arotation=0,this.ascaleX=0,this.ascaleY=0,this.ashearX=0,this.ashearY=0,this.appliedValid=!1,this.sorted=!1,this.active=!1,t==null)throw new Error("data cannot be null.");if(n==null)throw new Error("skeleton cannot be null.");this.data=t,this.skeleton=n,this.parent=s,this.setToSetupPose()}get worldX(){return this.matrix.tx}get worldY(){return this.matrix.ty}isActive(){return this.active}update(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransform(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransformWith(t,n,s,i,c,d,a){this.ax=t,this.ay=n,this.arotation=s,this.ascaleX=i,this.ascaleY=c,this.ashearX=d,this.ashearY=a,this.appliedValid=!0;const r=this.parent,o=this.matrix,l=this.skeleton.scaleX,u=f.settings.yDown?-this.skeleton.scaleY:this.skeleton.scaleY;if(r==null){const x=this.skeleton,p=s+90+a;o.a=f.MathUtils.cosDeg(s+d)*i*l,o.c=f.MathUtils.cosDeg(p)*c*l,o.b=f.MathUtils.sinDeg(s+d)*i*u,o.d=f.MathUtils.sinDeg(p)*c*u,o.tx=t*l+x.x,o.ty=n*u+x.y;return}let m=r.matrix.a,h=r.matrix.c,g=r.matrix.b,M=r.matrix.d;switch(o.tx=m*t+h*n+r.matrix.tx,o.ty=g*t+M*n+r.matrix.ty,this.data.transformMode){case f.TransformMode.Normal:{const x=s+90+a,p=f.MathUtils.cosDeg(s+d)*i,E=f.MathUtils.cosDeg(x)*c,w=f.MathUtils.sinDeg(s+d)*i,S=f.MathUtils.sinDeg(x)*c;o.a=m*p+h*w,o.c=m*E+h*S,o.b=g*p+M*w,o.d=g*E+M*S;return}case f.TransformMode.OnlyTranslation:{const x=s+90+a;o.a=f.MathUtils.cosDeg(s+d)*i,o.c=f.MathUtils.cosDeg(x)*c,o.b=f.MathUtils.sinDeg(s+d)*i,o.d=f.MathUtils.sinDeg(x)*c;break}case f.TransformMode.NoRotationOrReflection:{let x=m*m+g*g,p=0;x>1e-4?(x=Math.abs(m*M-h*g)/x,m/=this.skeleton.scaleX,g/=this.skeleton.scaleY,h=g*x,M=m*x,p=Math.atan2(g,m)*f.MathUtils.radDeg):(m=0,g=0,p=90-Math.atan2(M,h)*f.MathUtils.radDeg);const E=s+d-p,w=s+a-p+90,S=f.MathUtils.cosDeg(E)*i,y=f.MathUtils.cosDeg(w)*c,A=f.MathUtils.sinDeg(E)*i,R=f.MathUtils.sinDeg(w)*c;o.a=m*S-h*A,o.c=m*y-h*R,o.b=g*S+M*A,o.d=g*y+M*R;break}case f.TransformMode.NoScale:case f.TransformMode.NoScaleOrReflection:{const x=f.MathUtils.cosDeg(s),p=f.MathUtils.sinDeg(s);let E=(m*x+h*p)/l,w=(g*x+M*p)/u,S=Math.sqrt(E*E+w*w);S>1e-5&&(S=1/S),E*=S,w*=S,S=Math.sqrt(E*E+w*w),this.data.transformMode==f.TransformMode.NoScale&&m*M-h*g<0!=(f.settings.yDown?this.skeleton.scaleX<0!=this.skeleton.scaleY>0:this.skeleton.scaleX<0!=this.skeleton.scaleY<0)&&(S=-S);const y=Math.PI/2+Math.atan2(w,E),A=Math.cos(y)*S,R=Math.sin(y)*S,T=f.MathUtils.cosDeg(d)*i,I=f.MathUtils.cosDeg(90+a)*c,C=f.MathUtils.sinDeg(d)*i,D=f.MathUtils.sinDeg(90+a)*c;o.a=E*T+A*C,o.c=E*I+A*D,o.b=w*T+R*C,o.d=w*I+R*D;break}}o.a*=l,o.c*=l,o.b*=u,o.d*=u}setToSetupPose(){const t=this.data;this.x=t.x,this.y=t.y,this.rotation=t.rotation,this.scaleX=t.scaleX,this.scaleY=t.scaleY,this.shearX=t.shearX,this.shearY=t.shearY}getWorldRotationX(){return Math.atan2(this.matrix.b,this.matrix.a)*f.MathUtils.radDeg}getWorldRotationY(){return Math.atan2(this.matrix.d,this.matrix.c)*f.MathUtils.radDeg}getWorldScaleX(){const t=this.matrix;return Math.sqrt(t.a*t.a+t.c*t.c)}getWorldScaleY(){const t=this.matrix;return Math.sqrt(t.b*t.b+t.d*t.d)}updateAppliedTransform(){this.appliedValid=!0;const t=this.parent,n=this.matrix;if(t==null){this.ax=n.tx,this.ay=n.ty,this.arotation=Math.atan2(n.b,n.a)*f.MathUtils.radDeg,this.ascaleX=Math.sqrt(n.a*n.a+n.b*n.b),this.ascaleY=Math.sqrt(n.c*n.c+n.d*n.d),this.ashearX=0,this.ashearY=Math.atan2(n.a*n.c+n.b*n.d,n.a*n.d-n.b*n.c)*f.MathUtils.radDeg;return}const s=t.matrix,i=1/(s.a*s.d-s.b*s.c),c=n.tx-s.tx,d=n.ty-s.ty;this.ax=c*s.d*i-d*s.c*i,this.ay=d*s.a*i-c*s.b*i;const a=i*s.d,r=i*s.a,o=i*s.c,l=i*s.b,u=a*n.a-o*n.b,m=a*n.c-o*n.d,h=r*n.b-l*n.a,g=r*n.d-l*n.c;if(this.ashearX=0,this.ascaleX=Math.sqrt(u*u+h*h),this.ascaleX>1e-4){const M=u*g-m*h;this.ascaleY=M/this.ascaleX,this.ashearY=Math.atan2(u*m+h*g,M)*f.MathUtils.radDeg,this.arotation=Math.atan2(h,u)*f.MathUtils.radDeg}else this.ascaleX=0,this.ascaleY=Math.sqrt(m*m+g*g),this.ashearY=0,this.arotation=90-Math.atan2(g,m)*f.MathUtils.radDeg}worldToLocal(t){const n=this.matrix,s=n.a,i=n.c,c=n.b,d=n.d,a=1/(s*d-i*c),r=t.x-n.tx,o=t.y-n.ty;return t.x=r*d*a-o*i*a,t.y=o*s*a-r*c*a,t}localToWorld(t){const n=this.matrix,s=t.x,i=t.y;return t.x=s*n.a+i*n.c+n.tx,t.y=s*n.b+i*n.d+n.ty,t}worldToLocalRotation(t){const n=f.MathUtils.sinDeg(t),s=f.MathUtils.cosDeg(t),i=this.matrix;return Math.atan2(i.a*n-i.b*s,i.d*s-i.c*n)*f.MathUtils.radDeg}localToWorldRotation(t){const n=f.MathUtils.sinDeg(t),s=f.MathUtils.cosDeg(t),i=this.matrix;return Math.atan2(s*i.b+n*i.d,s*i.a+n*i.c)*f.MathUtils.radDeg}rotateWorld(t){const n=this.matrix,s=n.a,i=n.c,c=n.b,d=n.d,a=f.MathUtils.cosDeg(t),r=f.MathUtils.sinDeg(t);n.a=a*s-r*c,n.c=a*i-r*d,n.b=r*s+a*c,n.d=r*i+a*d,this.appliedValid=!1}}class ae{constructor(t,n,s){if(this.x=0,this.y=0,this.rotation=0,this.scaleX=1,this.scaleY=1,this.shearX=0,this.shearY=0,this.transformMode=f.TransformMode.Normal,this.skinRequired=!1,this.inheritRotation=!0,this.inheritScale=!0,this.color=new f.Color,t<0)throw new Error("index must be >= 0.");if(n==null)throw new Error("name cannot be null.");this.index=t,this.name=n,this.parent=s}}class Ht{constructor(t,n,s){this.name=t,this.order=n,this.skinRequired=s}}class le{constructor(t,n){if(n==null)throw new Error("data cannot be null.");this.time=t,this.data=n}}class ce{constructor(t){this.name=t}}class Ie{constructor(t,n){if(this.bendDirection=0,this.compress=!1,this.stretch=!1,this.mix=1,this.softness=0,this.active=!1,t==null)throw new Error("data cannot be null.");if(n==null)throw new Error("skeleton cannot be null.");this.data=t,this.mix=t.mix,this.softness=t.softness,this.bendDirection=t.bendDirection,this.compress=t.compress,this.stretch=t.stretch,this.bones=new Array;for(let s=0;s<t.bones.length;s++)this.bones.push(n.findBone(t.bones[s].name));this.target=n.findBone(t.target.name)}isActive(){return this.active}apply(){this.update()}update(){const t=this.target,n=this.bones;switch(n.length){case 1:this.apply1(n[0],t.worldX,t.worldY,this.compress,this.stretch,this.data.uniform,this.mix);break;case 2:this.apply2(n[0],n[1],t.worldX,t.worldY,this.bendDirection,this.stretch,this.softness,this.mix);break}}apply1(t,n,s,i,c,d,a){t.appliedValid||t.updateAppliedTransform();const r=t.parent.matrix,o=r.a;let l=r.c;const u=r.b;let m=r.d,h=-t.ashearX-t.arotation,g=0,M=0;switch(t.data.transformMode){case f.TransformMode.OnlyTranslation:g=n-t.worldX,M=s-t.worldY;break;case f.TransformMode.NoRotationOrReflection:const E=Math.abs(o*m-l*u)/(o*o+u*u),w=o/t.skeleton.scaleX,S=u/t.skeleton.scaleY;l=-S*E*t.skeleton.scaleX,m=w*E*t.skeleton.scaleY,h+=Math.atan2(S,w)*f.MathUtils.radDeg;default:const y=n-r.tx,A=s-r.ty,R=o*m-l*u;g=(y*m-A*l)/R-t.ax,M=(A*o-y*u)/R-t.ay}h+=Math.atan2(M,g)*f.MathUtils.radDeg,t.ascaleX<0&&(h+=180),h>180?h-=360:h<-180&&(h+=360);let x=t.ascaleX,p=t.ascaleY;if(i||c){switch(t.data.transformMode){case f.TransformMode.NoScale:case f.TransformMode.NoScaleOrReflection:g=n-t.worldX,M=s-t.worldY}const E=t.data.length*x,w=Math.sqrt(g*g+M*M);if(i&&w<E||c&&w>E&&E>1e-4){const S=(w/E-1)*a+1;x*=S,d&&(p*=S)}}t.updateWorldTransformWith(t.ax,t.ay,t.arotation+h*a,x,p,t.ashearX,t.ashearY)}apply2(t,n,s,i,c,d,a,r){if(r==0){n.updateWorldTransform();return}t.appliedValid||t.updateAppliedTransform(),n.appliedValid||n.updateAppliedTransform();const o=t.ax,l=t.ay;let u=t.ascaleX,m=u,h=t.ascaleY,g=n.ascaleX;const M=t.matrix;let x=0,p=0,E=0;u<0?(u=-u,x=180,E=-1):(x=0,E=1),h<0&&(h=-h,E=-E),g<0?(g=-g,p=180):p=0;const w=n.ax;let S=0,y=0,A=0,R=M.a,T=M.c,I=M.b,C=M.d;const D=Math.abs(u-h)<=1e-4;D?(S=n.ay,y=R*w+T*S+M.tx,A=I*w+C*S+M.ty):(S=0,y=R*w+M.tx,A=I*w+M.ty);const B=t.parent.matrix;R=B.a,T=B.c,I=B.b,C=B.d;const q=1/(R*C-T*I);let v=y-B.tx,k=A-B.ty;const ot=(v*C-k*T)*q-o,at=(k*R-v*I)*q-l,V=Math.sqrt(ot*ot+at*at);let N=n.data.length*g,U,Y;if(V<1e-4){this.apply1(t,s,i,!1,d,!1,r),n.updateWorldTransformWith(w,S,0,n.ascaleX,n.ascaleY,n.ashearX,n.ashearY);return}v=s-B.tx,k=i-B.ty;let $=(v*C-k*T)*q-o,L=(k*R-v*I)*q-l,F=$*$+L*L;if(a!=0){a*=u*(g+1)/2;const ft=Math.sqrt(F),At=ft-V-N*u+a;if(At>0){let yt=Math.min(1,At/(a*2))-1;yt=(At-a*(1-yt*yt))/ft,$-=yt*$,L-=yt*L,F=$*$+L*L}}t:if(D){N*=u;let ft=(F-V*V-N*N)/(2*V*N);ft<-1?ft=-1:ft>1&&(ft=1,d&&(m*=(Math.sqrt(F)/(V+N)-1)*r+1)),Y=Math.acos(ft)*c,R=V+N*ft,T=N*Math.sin(Y),U=Math.atan2(L*R-$*T,$*R+L*T)}else{R=u*N,T=h*N;const ft=R*R,At=T*T,yt=Math.atan2(L,$);I=At*V*V+ft*F-ft*At;const Gt=-2*At*V,Ce=At-ft;if(C=Gt*Gt-4*Ce*I,C>=0){let Nt=Math.sqrt(C);Gt<0&&(Nt=-Nt),Nt=-(Gt+Nt)/2;const Be=Nt/Ce,Fe=I/Nt,Ut=Math.abs(Be)<Math.abs(Fe)?Be:Fe;if(Ut*Ut<=F){k=Math.sqrt(F-Ut*Ut)*c,U=yt-Math.atan2(k,Ut),Y=Math.atan2(k/h,(Ut-V)/u);break t}}let Ve=f.MathUtils.PI,Zt=V-R,Me=Zt*Zt,ve=0,ke=0,zt=V+R,pe=zt*zt,Pe=0;I=-R*V/(ft-At),I>=-1&&I<=1&&(I=Math.acos(I),v=R*Math.cos(I)+V,k=T*Math.sin(I),C=v*v+k*k,C<Me&&(Ve=I,Me=C,Zt=v,ve=k),C>pe&&(ke=I,pe=C,zt=v,Pe=k)),F<=(Me+pe)/2?(U=yt-Math.atan2(ve*c,Zt),Y=Ve*c):(U=yt-Math.atan2(Pe*c,zt),Y=ke*c)}const gt=Math.atan2(S,w)*E;let Tt=t.arotation;U=(U-gt)*f.MathUtils.radDeg+x-Tt,U>180?U-=360:U<-180&&(U+=360),t.updateWorldTransformWith(o,l,Tt+U*r,m,t.ascaleY,0,0),Tt=n.arotation,Y=((Y+gt)*f.MathUtils.radDeg-n.ashearX)*E+p-Tt,Y>180?Y-=360:Y<-180&&(Y+=360),n.updateWorldTransformWith(w,S,Tt+Y*r,n.ascaleX,n.ascaleY,n.ashearX,n.ashearY)}}class he extends Ht{constructor(t){super(t,0,!1),this.bones=new Array,this.bendDirection=1,this.compress=!1,this.stretch=!1,this.uniform=!1,this.mix=1,this.softness=0}}class de extends Ht{constructor(t){super(t,0,!1),this.bones=new Array}}var K=(e=>(e[e.Length=0]="Length",e[e.Fixed=1]="Fixed",e[e.Percent=2]="Percent",e))(K||{});const kt=class{constructor(e,t){if(this.position=0,this.spacing=0,this.rotateMix=0,this.translateMix=0,this.spaces=new Array,this.positions=new Array,this.world=new Array,this.curves=new Array,this.lengths=new Array,this.segments=new Array,this.active=!1,e==null)throw new Error("data cannot be null.");if(t==null)throw new Error("skeleton cannot be null.");this.data=e,this.bones=new Array;for(let n=0,s=e.bones.length;n<s;n++)this.bones.push(t.findBone(e.bones[n].name));this.target=t.findSlot(e.target.name),this.position=e.position,this.spacing=e.spacing,this.rotateMix=e.rotateMix,this.translateMix=e.translateMix}isActive(){return this.active}apply(){this.update()}update(){const e=this.target.getAttachment();if(!(e instanceof Vt))return;const t=this.rotateMix,n=this.translateMix,s=n>0,i=t>0;if(!s&&!i)return;const c=this.data,d=c.spacingMode,a=d==K.Length,r=c.rotateMode,o=r==f.RotateMode.Tangent,l=r==f.RotateMode.ChainScale,u=this.bones.length,m=o?u:u+1,h=this.bones,g=f.Utils.setArraySize(this.spaces,m);let M=null;const x=this.spacing;if(l||a){l&&(M=f.Utils.setArraySize(this.lengths,u));for(let A=0,R=m-1;A<R;){const T=h[A],I=T.data.length;if(I<kt.epsilon)l&&(M[A]=0),g[++A]=0;else{const C=I*T.matrix.a,D=I*T.matrix.b,B=Math.sqrt(C*C+D*D);l&&(M[A]=B),g[++A]=(a?I+x:x)*B/I}}}else for(let A=1;A<m;A++)g[A]=x;const p=this.computeWorldPositions(e,m,o,c.positionMode==f.PositionMode.Percent,d==K.Percent);let E=p[0],w=p[1],S=c.offsetRotation,y=!1;if(S==0)y=r==f.RotateMode.Chain;else{y=!1;const A=this.target.bone.matrix;S*=A.a*A.d-A.b*A.c>0?f.MathUtils.degRad:-f.MathUtils.degRad}for(let A=0,R=3;A<u;A++,R+=3){const T=h[A],I=T.matrix;I.tx+=(E-I.tx)*n,I.ty+=(w-I.ty)*n;const C=p[R],D=p[R+1],B=C-E,q=D-w;if(l){const v=M[A];if(v!=0){const k=(Math.sqrt(B*B+q*q)/v-1)*t+1;I.a*=k,I.b*=k}}if(E=C,w=D,i){const v=I.a,k=I.c,ot=I.b,at=I.d;let V=0,N=0,U=0;if(o&&(o?V=p[R-1]:g[A+1]==0?V=p[R+2]:V=Math.atan2(q,B)),V-=Math.atan2(ot,v),y){N=Math.cos(V),U=Math.sin(V);const Y=T.data.length;E+=(Y*(N*v-U*ot)-B)*t,w+=(Y*(U*v+N*ot)-q)*t}else V+=S;V>f.MathUtils.PI?V-=f.MathUtils.PI2:V<-f.MathUtils.PI&&(V+=f.MathUtils.PI2),V*=t,N=Math.cos(V),U=Math.sin(V),I.a=N*v-U*ot,I.c=N*k-U*at,I.b=U*v+N*ot,I.d=U*k+N*at}T.appliedValid=!1}}computeWorldPositions(e,t,n,s,i){const c=this.target;let d=this.position;const a=this.spaces,r=f.Utils.setArraySize(this.positions,t*3+2);let o=null;const l=e.closed;let u=e.worldVerticesLength,m=u/6,h=kt.NONE;if(!e.constantSpeed){const V=e.lengths;m-=l?1:2;const N=V[m];if(s&&(d*=N),i)for(let U=0;U<t;U++)a[U]*=N;o=f.Utils.setArraySize(this.world,8);for(let U=0,Y=0,$=0;U<t;U++,Y+=3){const L=a[U];d+=L;let F=d;if(l)F%=N,F<0&&(F+=N),$=0;else if(F<0){h!=kt.BEFORE&&(h=kt.BEFORE,e.computeWorldVertices(c,2,4,o,0,2)),this.addBeforePosition(F,o,0,r,Y);continue}else if(F>N){h!=kt.AFTER&&(h=kt.AFTER,e.computeWorldVertices(c,u-6,4,o,0,2)),this.addAfterPosition(F-N,o,0,r,Y);continue}for(;;$++){const gt=V[$];if(!(F>gt)){if($==0)F/=gt;else{const Tt=V[$-1];F=(F-Tt)/(gt-Tt)}break}}$!=h&&(h=$,l&&$==m?(e.computeWorldVertices(c,u-4,4,o,0,2),e.computeWorldVertices(c,0,4,o,4,2)):e.computeWorldVertices(c,$*6+2,8,o,0,2)),this.addCurvePosition(F,o[0],o[1],o[2],o[3],o[4],o[5],o[6],o[7],r,Y,n||U>0&&L==0)}return r}l?(u+=2,o=f.Utils.setArraySize(this.world,u),e.computeWorldVertices(c,2,u-4,o,0,2),e.computeWorldVertices(c,0,2,o,u-4,2),o[u-2]=o[0],o[u-1]=o[1]):(m--,u-=4,o=f.Utils.setArraySize(this.world,u),e.computeWorldVertices(c,2,u,o,0,2));const g=f.Utils.setArraySize(this.curves,m);let M=0,x=o[0],p=o[1],E=0,w=0,S=0,y=0,A=0,R=0,T=0,I=0,C=0,D=0,B=0,q=0,v=0,k=0;for(let V=0,N=2;V<m;V++,N+=6)E=o[N],w=o[N+1],S=o[N+2],y=o[N+3],A=o[N+4],R=o[N+5],T=(x-E*2+S)*.1875,I=(p-w*2+y)*.1875,C=((E-S)*3-x+A)*.09375,D=((w-y)*3-p+R)*.09375,B=T*2+C,q=I*2+D,v=(E-x)*.75+T+C*.16666667,k=(w-p)*.75+I+D*.16666667,M+=Math.sqrt(v*v+k*k),v+=B,k+=q,B+=C,q+=D,M+=Math.sqrt(v*v+k*k),v+=B,k+=q,M+=Math.sqrt(v*v+k*k),v+=B+C,k+=q+D,M+=Math.sqrt(v*v+k*k),g[V]=M,x=A,p=R;if(s&&(d*=M),i)for(let V=0;V<t;V++)a[V]*=M;const ot=this.segments;let at=0;for(let V=0,N=0,U=0,Y=0;V<t;V++,N+=3){const $=a[V];d+=$;let L=d;if(l)L%=M,L<0&&(L+=M),U=0;else if(L<0){this.addBeforePosition(L,o,0,r,N);continue}else if(L>M){this.addAfterPosition(L-M,o,u-4,r,N);continue}for(;;U++){const F=g[U];if(!(L>F)){if(U==0)L/=F;else{const gt=g[U-1];L=(L-gt)/(F-gt)}break}}if(U!=h){h=U;let F=U*6;for(x=o[F],p=o[F+1],E=o[F+2],w=o[F+3],S=o[F+4],y=o[F+5],A=o[F+6],R=o[F+7],T=(x-E*2+S)*.03,I=(p-w*2+y)*.03,C=((E-S)*3-x+A)*.006,D=((w-y)*3-p+R)*.006,B=T*2+C,q=I*2+D,v=(E-x)*.3+T+C*.16666667,k=(w-p)*.3+I+D*.16666667,at=Math.sqrt(v*v+k*k),ot[0]=at,F=1;F<8;F++)v+=B,k+=q,B+=C,q+=D,at+=Math.sqrt(v*v+k*k),ot[F]=at;v+=B,k+=q,at+=Math.sqrt(v*v+k*k),ot[8]=at,v+=B+C,k+=q+D,at+=Math.sqrt(v*v+k*k),ot[9]=at,Y=0}for(L*=at;;Y++){const F=ot[Y];if(!(L>F)){if(Y==0)L/=F;else{const gt=ot[Y-1];L=Y+(L-gt)/(F-gt)}break}}this.addCurvePosition(L*.1,x,p,E,w,S,y,A,R,r,N,n||V>0&&$==0)}return r}addBeforePosition(e,t,n,s,i){const c=t[n],d=t[n+1],a=t[n+2]-c,r=t[n+3]-d,o=Math.atan2(r,a);s[i]=c+e*Math.cos(o),s[i+1]=d+e*Math.sin(o),s[i+2]=o}addAfterPosition(e,t,n,s,i){const c=t[n+2],d=t[n+3],a=c-t[n],r=d-t[n+1],o=Math.atan2(r,a);s[i]=c+e*Math.cos(o),s[i+1]=d+e*Math.sin(o),s[i+2]=o}addCurvePosition(e,t,n,s,i,c,d,a,r,o,l,u){(e==0||isNaN(e))&&(e=1e-4);const m=e*e,h=m*e,g=1-e,M=g*g,x=M*g,p=g*e,E=p*3,w=g*E,S=E*e,y=t*x+s*w+c*S+a*h,A=n*x+i*w+d*S+r*h;o[l]=y,o[l+1]=A,u&&(o[l+2]=Math.atan2(A-(n*M+i*p*2+d*m),y-(t*M+s*p*2+c*m)))}};let Ft=kt;Ft.NONE=-1,Ft.BEFORE=-2,Ft.AFTER=-3,Ft.epsilon=1e-5;class Te{constructor(t,n){if(this.rotateMix=0,this.translateMix=0,this.scaleMix=0,this.shearMix=0,this.temp=new f.Vector2,this.active=!1,t==null)throw new Error("data cannot be null.");if(n==null)throw new Error("skeleton cannot be null.");this.data=t,this.rotateMix=t.rotateMix,this.translateMix=t.translateMix,this.scaleMix=t.scaleMix,this.shearMix=t.shearMix,this.bones=new Array;for(let s=0;s<t.bones.length;s++)this.bones.push(n.findBone(t.bones[s].name));this.target=n.findBone(t.target.name)}isActive(){return this.active}apply(){this.update()}update(){this.data.local?this.data.relative?this.applyRelativeLocal():this.applyAbsoluteLocal():this.data.relative?this.applyRelativeWorld():this.applyAbsoluteWorld()}applyAbsoluteWorld(){const t=this.rotateMix,n=this.translateMix,s=this.scaleMix,i=this.shearMix,c=this.target,d=c.matrix,a=d.a,r=d.c,o=d.b,l=d.d,u=a*l-r*o>0?f.MathUtils.degRad:-f.MathUtils.degRad,m=this.data.offsetRotation*u,h=this.data.offsetShearY*u,g=this.bones;for(let M=0,x=g.length;M<x;M++){const p=g[M];let E=!1;const w=p.matrix;if(t!=0){const S=w.a,y=w.c,A=w.b,R=w.d;let T=Math.atan2(o,a)-Math.atan2(A,S)+m;T>f.MathUtils.PI?T-=f.MathUtils.PI2:T<-f.MathUtils.PI&&(T+=f.MathUtils.PI2),T*=t;const I=Math.cos(T),C=Math.sin(T);w.a=I*S-C*A,w.c=I*y-C*R,w.b=C*S+I*A,w.d=C*y+I*R,E=!0}if(n!=0){const S=this.temp;c.localToWorld(S.set(this.data.offsetX,this.data.offsetY)),w.tx+=(S.x-w.tx)*n,w.ty+=(S.y-w.ty)*n,E=!0}if(s>0){let S=Math.sqrt(w.a*w.a+w.b*w.b),y=Math.sqrt(a*a+o*o);S>1e-5&&(S=(S+(y-S+this.data.offsetScaleX)*s)/S),w.a*=S,w.b*=S,S=Math.sqrt(w.c*w.c+w.d*w.d),y=Math.sqrt(r*r+l*l),S>1e-5&&(S=(S+(y-S+this.data.offsetScaleY)*s)/S),w.c*=S,w.d*=S,E=!0}if(i>0){const S=w.c,y=w.d,A=Math.atan2(y,S);let R=Math.atan2(l,r)-Math.atan2(o,a)-(A-Math.atan2(w.b,w.a));R>f.MathUtils.PI?R-=f.MathUtils.PI2:R<-f.MathUtils.PI&&(R+=f.MathUtils.PI2),R=A+(R+h)*i;const T=Math.sqrt(S*S+y*y);w.c=Math.cos(R)*T,w.d=Math.sin(R)*T,E=!0}E&&(p.appliedValid=!1)}}applyRelativeWorld(){const t=this.rotateMix,n=this.translateMix,s=this.scaleMix,i=this.shearMix,c=this.target,d=c.matrix,a=d.a,r=d.c,o=d.b,l=d.d,u=a*l-r*o>0?f.MathUtils.degRad:-f.MathUtils.degRad,m=this.data.offsetRotation*u,h=this.data.offsetShearY*u,g=this.bones;for(let M=0,x=g.length;M<x;M++){const p=g[M];let E=!1;const w=p.matrix;if(t!=0){const S=w.a,y=w.c,A=w.b,R=w.d;let T=Math.atan2(o,a)+m;T>f.MathUtils.PI?T-=f.MathUtils.PI2:T<-f.MathUtils.PI&&(T+=f.MathUtils.PI2),T*=t;const I=Math.cos(T),C=Math.sin(T);w.a=I*S-C*A,w.c=I*y-C*R,w.b=C*S+I*A,w.d=C*y+I*R,E=!0}if(n!=0){const S=this.temp;c.localToWorld(S.set(this.data.offsetX,this.data.offsetY)),w.tx+=S.x*n,w.ty+=S.y*n,E=!0}if(s>0){let S=(Math.sqrt(a*a+o*o)-1+this.data.offsetScaleX)*s+1;w.a*=S,w.b*=S,S=(Math.sqrt(r*r+l*l)-1+this.data.offsetScaleY)*s+1,w.c*=S,w.d*=S,E=!0}if(i>0){let S=Math.atan2(l,r)-Math.atan2(o,a);S>f.MathUtils.PI?S-=f.MathUtils.PI2:S<-f.MathUtils.PI&&(S+=f.MathUtils.PI2);const y=w.c,A=w.d;S=Math.atan2(A,y)+(S-f.MathUtils.PI/2+h)*i;const R=Math.sqrt(y*y+A*A);w.c=Math.cos(S)*R,w.d=Math.sin(S)*R,E=!0}E&&(p.appliedValid=!1)}}applyAbsoluteLocal(){const t=this.rotateMix,n=this.translateMix,s=this.scaleMix,i=this.shearMix,c=this.target;c.appliedValid||c.updateAppliedTransform();const d=this.bones;for(let a=0,r=d.length;a<r;a++){const o=d[a];o.appliedValid||o.updateAppliedTransform();let l=o.arotation;if(t!=0){let x=c.arotation-l+this.data.offsetRotation;x-=(16384-(16384.499999999996-x/360|0))*360,l+=x*t}let u=o.ax,m=o.ay;n!=0&&(u+=(c.ax-u+this.data.offsetX)*n,m+=(c.ay-m+this.data.offsetY)*n);let h=o.ascaleX,g=o.ascaleY;s>0&&(h>1e-5&&(h=(h+(c.ascaleX-h+this.data.offsetScaleX)*s)/h),g>1e-5&&(g=(g+(c.ascaleY-g+this.data.offsetScaleY)*s)/g));const M=o.ashearY;if(i>0){let x=c.ashearY-M+this.data.offsetShearY;x-=(16384-(16384.499999999996-x/360|0))*360,o.shearY+=x*i}o.updateWorldTransformWith(u,m,l,h,g,o.ashearX,M)}}applyRelativeLocal(){const t=this.rotateMix,n=this.translateMix,s=this.scaleMix,i=this.shearMix,c=this.target;c.appliedValid||c.updateAppliedTransform();const d=this.bones;for(let a=0,r=d.length;a<r;a++){const o=d[a];o.appliedValid||o.updateAppliedTransform();let l=o.arotation;t!=0&&(l+=(c.arotation+this.data.offsetRotation)*t);let u=o.ax,m=o.ay;n!=0&&(u+=(c.ax+this.data.offsetX)*n,m+=(c.ay+this.data.offsetY)*n);let h=o.ascaleX,g=o.ascaleY;s>0&&(h>1e-5&&(h*=(c.ascaleX-1+this.data.offsetScaleX)*s+1),g>1e-5&&(g*=(c.ascaleY-1+this.data.offsetScaleY)*s+1));let M=o.ashearY;i>0&&(M+=(c.ashearY+this.data.offsetShearY)*i),o.updateWorldTransformWith(u,m,l,h,g,o.ashearX,M)}}}const Lt=class{constructor(e){if(this._updateCache=new Array,this.updateCacheReset=new Array,this.time=0,this.scaleX=1,this.scaleY=1,this.x=0,this.y=0,e==null)throw new Error("data cannot be null.");this.data=e,this.bones=new Array;for(let t=0;t<e.bones.length;t++){const n=e.bones[t];let s;if(n.parent==null)s=new oe(n,this,null);else{const i=this.bones[n.parent.index];s=new oe(n,this,i),i.children.push(s)}this.bones.push(s)}this.slots=new Array,this.drawOrder=new Array;for(let t=0;t<e.slots.length;t++){const n=e.slots[t],s=this.bones[n.boneData.index],i=new te(n,s);this.slots.push(i),this.drawOrder.push(i)}this.ikConstraints=new Array;for(let t=0;t<e.ikConstraints.length;t++){const n=e.ikConstraints[t];this.ikConstraints.push(new Ie(n,this))}this.transformConstraints=new Array;for(let t=0;t<e.transformConstraints.length;t++){const n=e.transformConstraints[t];this.transformConstraints.push(new Te(n,this))}this.pathConstraints=new Array;for(let t=0;t<e.pathConstraints.length;t++){const n=e.pathConstraints[t];this.pathConstraints.push(new Ft(n,this))}this.color=new f.Color(1,1,1,1),this.updateCache()}updateCache(){const e=this._updateCache;e.length=0,this.updateCacheReset.length=0;const t=this.bones;for(let o=0,l=t.length;o<l;o++){const u=t[o];u.sorted=u.data.skinRequired,u.active=!u.sorted}if(this.skin!=null){const o=this.skin.bones;for(let l=0,u=this.skin.bones.length;l<u;l++){let m=this.bones[o[l].index];do m.sorted=!1,m.active=!0,m=m.parent;while(m!=null)}}const n=this.ikConstraints,s=this.transformConstraints,i=this.pathConstraints,c=n.length,d=s.length,a=i.length,r=c+d+a;t:for(let o=0;o<r;o++){for(let l=0;l<c;l++){const u=n[l];if(u.data.order==o){this.sortIkConstraint(u);continue t}}for(let l=0;l<d;l++){const u=s[l];if(u.data.order==o){this.sortTransformConstraint(u);continue t}}for(let l=0;l<a;l++){const u=i[l];if(u.data.order==o){this.sortPathConstraint(u);continue t}}}for(let o=0,l=t.length;o<l;o++)this.sortBone(t[o])}sortIkConstraint(e){if(e.active=e.target.isActive()&&(!e.data.skinRequired||this.skin!=null&&f.Utils.contains(this.skin.constraints,e.data,!0)),!e.active)return;const t=e.target;this.sortBone(t);const n=e.bones,s=n[0];if(this.sortBone(s),n.length>1){const i=n[n.length-1];this._updateCache.indexOf(i)>-1||this.updateCacheReset.push(i)}this._updateCache.push(e),this.sortReset(s.children),n[n.length-1].sorted=!0}sortPathConstraint(e){if(e.active=e.target.bone.isActive()&&(!e.data.skinRequired||this.skin!=null&&f.Utils.contains(this.skin.constraints,e.data,!0)),!e.active)return;const t=e.target,n=t.data.index,s=t.bone;this.skin!=null&&this.sortPathConstraintAttachment(this.skin,n,s),this.data.defaultSkin!=null&&this.data.defaultSkin!=this.skin&&this.sortPathConstraintAttachment(this.data.defaultSkin,n,s);for(let a=0,r=this.data.skins.length;a<r;a++)this.sortPathConstraintAttachment(this.data.skins[a],n,s);const i=t.getAttachment();i instanceof Vt&&this.sortPathConstraintAttachmentWith(i,s);const c=e.bones,d=c.length;for(let a=0;a<d;a++)this.sortBone(c[a]);this._updateCache.push(e);for(let a=0;a<d;a++)this.sortReset(c[a].children);for(let a=0;a<d;a++)c[a].sorted=!0}sortTransformConstraint(e){if(e.active=e.target.isActive()&&(!e.data.skinRequired||this.skin!=null&&f.Utils.contains(this.skin.constraints,e.data,!0)),!e.active)return;this.sortBone(e.target);const t=e.bones,n=t.length;if(e.data.local)for(let s=0;s<n;s++){const i=t[s];this.sortBone(i.parent),this._updateCache.indexOf(i)>-1||this.updateCacheReset.push(i)}else for(let s=0;s<n;s++)this.sortBone(t[s]);this._updateCache.push(e);for(let s=0;s<n;s++)this.sortReset(t[s].children);for(let s=0;s<n;s++)t[s].sorted=!0}sortPathConstraintAttachment(e,t,n){const s=e.attachments[t];if(s)for(const i in s)this.sortPathConstraintAttachmentWith(s[i],n)}sortPathConstraintAttachmentWith(e,t){if(!(e instanceof Vt))return;const n=e.bones;if(n==null)this.sortBone(t);else{const s=this.bones;let i=0;for(;i<n.length;){const c=n[i++];for(let d=i+c;i<d;i++){const a=n[i];this.sortBone(s[a])}}}}sortBone(e){if(e.sorted)return;const t=e.parent;t!=null&&this.sortBone(t),e.sorted=!0,this._updateCache.push(e)}sortReset(e){for(let t=0,n=e.length;t<n;t++){const s=e[t];s.active&&(s.sorted&&this.sortReset(s.children),s.sorted=!1)}}updateWorldTransform(){const e=this.updateCacheReset;for(let n=0,s=e.length;n<s;n++){const i=e[n];i.ax=i.x,i.ay=i.y,i.arotation=i.rotation,i.ascaleX=i.scaleX,i.ascaleY=i.scaleY,i.ashearX=i.shearX,i.ashearY=i.shearY,i.appliedValid=!0}const t=this._updateCache;for(let n=0,s=t.length;n<s;n++)t[n].update()}setToSetupPose(){this.setBonesToSetupPose(),this.setSlotsToSetupPose()}setBonesToSetupPose(){const e=this.bones;for(let i=0,c=e.length;i<c;i++)e[i].setToSetupPose();const t=this.ikConstraints;for(let i=0,c=t.length;i<c;i++){const d=t[i];d.mix=d.data.mix,d.softness=d.data.softness,d.bendDirection=d.data.bendDirection,d.compress=d.data.compress,d.stretch=d.data.stretch}const n=this.transformConstraints;for(let i=0,c=n.length;i<c;i++){const d=n[i],a=d.data;d.rotateMix=a.rotateMix,d.translateMix=a.translateMix,d.scaleMix=a.scaleMix,d.shearMix=a.shearMix}const s=this.pathConstraints;for(let i=0,c=s.length;i<c;i++){const d=s[i],a=d.data;d.position=a.position,d.spacing=a.spacing,d.rotateMix=a.rotateMix,d.translateMix=a.translateMix}}setSlotsToSetupPose(){const e=this.slots;f.Utils.arrayCopy(e,0,this.drawOrder,0,e.length);for(let t=0,n=e.length;t<n;t++)e[t].setToSetupPose()}getRootBone(){return this.bones.length==0?null:this.bones[0]}findBone(e){if(e==null)throw new Error("boneName cannot be null.");const t=this.bones;for(let n=0,s=t.length;n<s;n++){const i=t[n];if(i.data.name==e)return i}return null}findBoneIndex(e){if(e==null)throw new Error("boneName cannot be null.");const t=this.bones;for(let n=0,s=t.length;n<s;n++)if(t[n].data.name==e)return n;return-1}findSlot(e){if(e==null)throw new Error("slotName cannot be null.");const t=this.slots;for(let n=0,s=t.length;n<s;n++){const i=t[n];if(i.data.name==e)return i}return null}findSlotIndex(e){if(e==null)throw new Error("slotName cannot be null.");const t=this.slots;for(let n=0,s=t.length;n<s;n++)if(t[n].data.name==e)return n;return-1}setSkinByName(e){const t=this.data.findSkin(e);if(t==null)throw new Error(`Skin not found: ${e}`);this.setSkin(t)}setSkin(e){if(e!=this.skin){if(e!=null)if(this.skin!=null)e.attachAll(this,this.skin);else{const t=this.slots;for(let n=0,s=t.length;n<s;n++){const i=t[n],c=i.data.attachmentName;if(c!=null){const d=e.getAttachment(n,c);d!=null&&i.setAttachment(d)}}}this.skin=e,this.updateCache()}}getAttachmentByName(e,t){return this.getAttachment(this.data.findSlotIndex(e),t)}getAttachment(e,t){if(t==null)throw new Error("attachmentName cannot be null.");if(this.skin!=null){const n=this.skin.getAttachment(e,t);if(n!=null)return n}return this.data.defaultSkin!=null?this.data.defaultSkin.getAttachment(e,t):null}setAttachment(e,t){if(e==null)throw new Error("slotName cannot be null.");const n=this.slots;for(let s=0,i=n.length;s<i;s++){const c=n[s];if(c.data.name==e){let d=null;if(t!=null&&(d=this.getAttachment(s,t),d==null))throw new Error(`Attachment not found: ${t}, for slot: ${e}`);c.setAttachment(d);return}}throw new Error(`Slot not found: ${e}`)}findIkConstraint(e){if(e==null)throw new Error("constraintName cannot be null.");const t=this.ikConstraints;for(let n=0,s=t.length;n<s;n++){const i=t[n];if(i.data.name==e)return i}return null}findTransformConstraint(e){if(e==null)throw new Error("constraintName cannot be null.");const t=this.transformConstraints;for(let n=0,s=t.length;n<s;n++){const i=t[n];if(i.data.name==e)return i}return null}findPathConstraint(e){if(e==null)throw new Error("constraintName cannot be null.");const t=this.pathConstraints;for(let n=0,s=t.length;n<s;n++){const i=t[n];if(i.data.name==e)return i}return null}getBounds(e,t,n=new Array(2)){if(e==null)throw new Error("offset cannot be null.");if(t==null)throw new Error("size cannot be null.");const s=this.drawOrder;let i=Number.POSITIVE_INFINITY,c=Number.POSITIVE_INFINITY,d=Number.NEGATIVE_INFINITY,a=Number.NEGATIVE_INFINITY;for(let r=0,o=s.length;r<o;r++){const l=s[r];if(!l.bone.active)continue;let u=0,m=null;const h=l.getAttachment();if(h instanceof P)u=8,m=f.Utils.setArraySize(n,u,0),h.computeWorldVertices(l.bone,m,0,2);else if(h instanceof Ct){const g=h;u=g.worldVerticesLength,m=f.Utils.setArraySize(n,u,0),g.computeWorldVertices(l,0,u,m,0,2)}if(m!=null)for(let g=0,M=m.length;g<M;g+=2){const x=m[g],p=m[g+1];i=Math.min(i,x),c=Math.min(c,p),d=Math.max(d,x),a=Math.max(a,p)}}e.set(i,c),t.set(d-i,a-c)}update(e){this.time+=e}get flipX(){return this.scaleX==-1}set flipX(e){Lt.deprecatedWarning1||(Lt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleX=e?1:-1}get flipY(){return this.scaleY==-1}set flipY(e){Lt.deprecatedWarning1||(Lt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleY=e?1:-1}};let fe=Lt;fe.deprecatedWarning1=!1;class ue{constructor(){this.bones=new Array,this.slots=new Array,this.skins=new Array,this.events=new Array,this.animations=new Array,this.ikConstraints=new Array,this.transformConstraints=new Array,this.pathConstraints=new Array,this.fps=0}findBone(t){if(t==null)throw new Error("boneName cannot be null.");const n=this.bones;for(let s=0,i=n.length;s<i;s++){const c=n[s];if(c.name==t)return c}return null}findBoneIndex(t){if(t==null)throw new Error("boneName cannot be null.");const n=this.bones;for(let s=0,i=n.length;s<i;s++)if(n[s].name==t)return s;return-1}findSlot(t){if(t==null)throw new Error("slotName cannot be null.");const n=this.slots;for(let s=0,i=n.length;s<i;s++){const c=n[s];if(c.name==t)return c}return null}findSlotIndex(t){if(t==null)throw new Error("slotName cannot be null.");const n=this.slots;for(let s=0,i=n.length;s<i;s++)if(n[s].name==t)return s;return-1}findSkin(t){if(t==null)throw new Error("skinName cannot be null.");const n=this.skins;for(let s=0,i=n.length;s<i;s++){const c=n[s];if(c.name==t)return c}return null}findEvent(t){if(t==null)throw new Error("eventDataName cannot be null.");const n=this.events;for(let s=0,i=n.length;s<i;s++){const c=n[s];if(c.name==t)return c}return null}findAnimation(t){if(t==null)throw new Error("animationName cannot be null.");const n=this.animations;for(let s=0,i=n.length;s<i;s++){const c=n[s];if(c.name==t)return c}return null}findIkConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const n=this.ikConstraints;for(let s=0,i=n.length;s<i;s++){const c=n[s];if(c.name==t)return c}return null}findTransformConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const n=this.transformConstraints;for(let s=0,i=n.length;s<i;s++){const c=n[s];if(c.name==t)return c}return null}findPathConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const n=this.pathConstraints;for(let s=0,i=n.length;s<i;s++){const c=n[s];if(c.name==t)return c}return null}findPathConstraintIndex(t){if(t==null)throw new Error("pathConstraintName cannot be null.");const n=this.pathConstraints;for(let s=0,i=n.length;s<i;s++)if(n[s].name==t)return s;return-1}}class me{constructor(t,n,s){if(this.color=new f.Color(1,1,1,1),t<0)throw new Error("index must be >= 0.");if(n==null)throw new Error("name cannot be null.");if(s==null)throw new Error("boneData cannot be null.");this.index=t,this.name=n,this.boneData=s}}class ge extends Ht{constructor(t){super(t,0,!1),this.bones=new Array,this.rotateMix=0,this.translateMix=0,this.scaleMix=0,this.shearMix=0,this.offsetRotation=0,this.offsetX=0,this.offsetY=0,this.offsetScaleX=0,this.offsetScaleY=0,this.offsetShearY=0,this.relative=!1,this.local=!1}}class xe{constructor(t,n,s){this.slotIndex=t,this.name=n,this.attachment=s}}class jt{constructor(t){if(this.attachments=new Array,this.bones=Array(),this.constraints=new Array,t==null)throw new Error("name cannot be null.");this.name=t}setAttachment(t,n,s){if(s==null)throw new Error("attachment cannot be null.");const i=this.attachments;t>=i.length&&(i.length=t+1),i[t]||(i[t]={}),i[t][n]=s}addSkin(t){for(let s=0;s<t.bones.length;s++){const i=t.bones[s];let c=!1;for(let d=0;d<this.bones.length;d++)if(this.bones[d]==i){c=!0;break}c||this.bones.push(i)}for(let s=0;s<t.constraints.length;s++){const i=t.constraints[s];let c=!1;for(let d=0;d<this.constraints.length;d++)if(this.constraints[d]==i){c=!0;break}c||this.constraints.push(i)}const n=t.getAttachments();for(let s=0;s<n.length;s++){const i=n[s];this.setAttachment(i.slotIndex,i.name,i.attachment)}}copySkin(t){for(let s=0;s<t.bones.length;s++){const i=t.bones[s];let c=!1;for(let d=0;d<this.bones.length;d++)if(this.bones[d]==i){c=!0;break}c||this.bones.push(i)}for(let s=0;s<t.constraints.length;s++){const i=t.constraints[s];let c=!1;for(let d=0;d<this.constraints.length;d++)if(this.constraints[d]==i){c=!0;break}c||this.constraints.push(i)}const n=t.getAttachments();for(let s=0;s<n.length;s++){const i=n[s];i.attachment!=null&&(i.attachment instanceof Ct?(i.attachment=i.attachment.newLinkedMesh(),this.setAttachment(i.slotIndex,i.name,i.attachment)):(i.attachment=i.attachment.copy(),this.setAttachment(i.slotIndex,i.name,i.attachment)))}}getAttachment(t,n){const s=this.attachments[t];return s?s[n]:null}removeAttachment(t,n){const s=this.attachments[t];s&&(s[n]=null)}getAttachments(){const t=new Array;for(let n=0;n<this.attachments.length;n++){const s=this.attachments[n];if(s)for(const i in s){const c=s[i];c&&t.push(new xe(n,i,c))}}return t}getAttachmentsForSlot(t,n){const s=this.attachments[t];if(s)for(const i in s){const c=s[i];c&&n.push(new xe(t,i,c))}}clear(){this.attachments.length=0,this.bones.length=0,this.constraints.length=0}attachAll(t,n){let s=0;for(let i=0;i<t.slots.length;i++){const c=t.slots[i],d=c.getAttachment();if(d&&s<n.attachments.length){const a=n.attachments[s];for(const r in a){const o=a[r];if(d==o){const l=this.getAttachment(s,r);l!=null&&c.setAttachment(l);break}}}s++}}}const Z=class{constructor(e){this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=e}readSkeletonData(e){const t=this.scale,n=new ue;n.name="";const s=new f.BinaryInput(e);n.hash=s.readString(),n.version=s.readString(),n.version==="3.8.75"&&console.error("Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine."),n.width=s.readFloat(),n.height=s.readFloat();const i=s.readBoolean();i&&(n.imagesPath=s.readString());let c=0;c=s.readInt(!0);for(let a=0;a<c;a++){const r=s.readString(),o=a==0?null:n.bones[s.readInt(!0)],l=new ae(a,r,o);l.rotation=s.readFloat(),l.x=s.readFloat()*t,l.y=s.readFloat()*t,l.scaleX=s.readFloat(),l.scaleY=s.readFloat(),l.shearX=s.readFloat(),l.shearY=s.readFloat(),l.length=s.readFloat()*t,l.inheritRotation=s.readBoolean(),l.inheritScale=s.readBoolean(),i&&f.Color.rgba8888ToColor(l.color,s.readInt32()),n.bones.push(l)}c=s.readInt(!0);for(let a=0;a<c;a++){const r=s.readString(),o=n.bones[s.readInt(!0)],l=new me(a,r,o);f.Color.rgba8888ToColor(l.color,s.readInt32()),l.attachmentName=s.readString(),l.blendMode=Z.BlendModeValues[s.readInt(!0)],n.slots.push(l)}c=s.readInt(!0);for(let a=0,r;a<c;a++){const o=s.readString(),l=new he(o);r=s.readInt(!0);for(let u=0;u<r;u++)l.bones.push(n.bones[s.readInt(!0)]);l.target=n.bones[s.readInt(!0)],l.mix=s.readFloat(),l.bendDirection=s.readByte(),n.ikConstraints.push(l)}c=s.readInt(!0);for(let a=0,r;a<c;a++){const o=s.readString(),l=new ge(o);r=s.readInt(!0);for(let u=0;u<r;u++)l.bones.push(n.bones[s.readInt(!0)]);l.target=n.bones[s.readInt(!0)],l.offsetRotation=s.readFloat(),l.offsetX=s.readFloat()*t,l.offsetY=s.readFloat()*t,l.offsetScaleX=s.readFloat(),l.offsetScaleY=s.readFloat(),l.offsetShearY=s.readFloat(),l.rotateMix=s.readFloat(),l.translateMix=s.readFloat(),l.scaleMix=s.readFloat(),l.shearMix=s.readFloat(),n.transformConstraints.push(l)}c=s.readInt(!0);for(let a=0,r;a<c;a++){const o=s.readString(),l=new de(o);r=s.readInt(!0);for(let u=0;u<r;u++)l.bones.push(n.bones[s.readInt(!0)]);l.target=n.slots[s.readInt(!0)],l.positionMode=Z.PositionModeValues[s.readInt(!0)],l.spacingMode=Z.SpacingModeValues[s.readInt(!0)],l.rotateMode=Z.RotateModeValues[s.readInt(!0)],l.offsetRotation=s.readFloat(),l.position=s.readFloat(),l.positionMode==f.PositionMode.Fixed&&(l.position*=t),l.spacing=s.readFloat(),(l.spacingMode==K.Length||l.spacingMode==K.Fixed)&&(l.spacing*=t),l.rotateMix=s.readFloat(),l.translateMix=s.readFloat(),n.pathConstraints.push(l)}const d=this.readSkin(s,n,!0,i);d!=null&&(n.defaultSkin=d,n.skins.push(d));{let a=n.skins.length;for(f.Utils.setArraySize(n.skins,c=a+s.readInt(!0));a<c;a++)n.skins[a]=this.readSkin(s,n,!1,i)}c=this.linkedMeshes.length;for(let a=0;a<c;a++){const r=this.linkedMeshes[a],o=r.skin==null?n.defaultSkin:n.findSkin(r.skin);if(o==null)throw new Error(`Skin not found: ${r.skin}`);const l=o.getAttachment(r.slotIndex,r.parent);if(l==null)throw new Error(`Parent mesh not found: ${r.parent}`);r.mesh.deformAttachment=r.inheritDeform?l:r.mesh,r.mesh.setParentMesh(l)}this.linkedMeshes.length=0,c=s.readInt(!0);for(let a=0;a<c;a++){const r=new ce(s.readStringRef());r.intValue=s.readInt(!1),r.floatValue=s.readFloat(),r.stringValue=s.readString(),r.audioPath=s.readString(),r.audioPath!=null&&(r.volume=s.readFloat(),r.balance=s.readFloat()),n.events.push(r)}c=s.readInt(!0);for(let a=0;a<c;a++)n.animations.push(this.readAnimation(s,s.readString(),n));return n}readSkin(e,t,n,s){let i=null,c=0;if(n){if(c=e.readInt(!0),c==0)return null;i=new jt("default")}else{i=new jt(e.readString()),i.bones.length=e.readInt(!0);for(let d=0,a=i.bones.length;d<a;d++)i.bones[d]=t.bones[e.readInt(!0)];for(let d=0,a=e.readInt(!0);d<a;d++)i.constraints.push(t.ikConstraints[e.readInt(!0)]);for(let d=0,a=e.readInt(!0);d<a;d++)i.constraints.push(t.transformConstraints[e.readInt(!0)]);for(let d=0,a=e.readInt(!0);d<a;d++)i.constraints.push(t.pathConstraints[e.readInt(!0)]);c=e.readInt(!0)}for(let d=0;d<c;d++){const a=e.readInt(!0);for(let r=0,o=e.readInt(!0);r<o;r++){const l=e.readString(),u=this.readAttachment(e,t,i,a,l,s);u!=null&&i.setAttachment(a,l,u)}}return i}readAttachment(e,t,n,s,i,c){const d=this.scale;let a=e.readStringRef();a==null&&(a=i);const r=e.readByte();switch(Z.AttachmentTypeValues[r]){case f.AttachmentType.Region:{let l=e.readString();const u=e.readFloat(),m=e.readFloat(),h=e.readFloat(),g=e.readFloat(),M=e.readFloat(),x=e.readFloat(),p=e.readFloat(),E=e.readInt32();l==null&&(l=a);const w=this.attachmentLoader.newRegionAttachment(n,a,l);return w==null?null:(w.path=l,w.x=m*d,w.y=h*d,w.scaleX=g,w.scaleY=M,w.rotation=u,w.width=x*d,w.height=p*d,f.Color.rgba8888ToColor(w.color,E),w)}case f.AttachmentType.BoundingBox:{const l=e.readInt(!0),u=this.readVertices(e,l),m=c?e.readInt32():0,h=this.attachmentLoader.newBoundingBoxAttachment(n,a);return h==null?null:(h.worldVerticesLength=l<<1,h.vertices=u.vertices,h.bones=u.bones,h.cVertices=u.cVertices,c&&f.Color.rgba8888ToColor(h.color,m),h)}case f.AttachmentType.Mesh:{let l=e.readStringRef();const u=e.readInt32(),m=e.readInt(!0),h=this.readFloatArray(e,m<<1,1),g=this.readShortArray(e),M=this.readVertices(e,m),x=e.readInt(!0);let p=null,E=0,w=0;c&&(p=this.readShortArray(e),E=e.readFloat(),w=e.readFloat()),l==null&&(l=a);const S=this.attachmentLoader.newMeshAttachment(n,a,l);return S==null?null:(S.path=l,f.Color.rgba8888ToColor(S.color,u),S.bones=M.bones,S.vertices=M.vertices,S.worldVerticesLength=m<<1,S.triangles=g,S.regionUVs=new Float32Array(h),S.cVertices=M.cVertices,S.hullLength=x<<1,c&&(S.edges=p,S.width=E*d,S.height=w*d),S)}case f.AttachmentType.LinkedMesh:{let l=e.readStringRef();const u=e.readInt32(),m=e.readStringRef(),h=e.readStringRef(),g=e.readBoolean();let M=0,x=0;c&&(M=e.readFloat(),x=e.readFloat()),l==null&&(l=a);const p=this.attachmentLoader.newMeshAttachment(n,a,l);return p==null?null:(p.path=l,f.Color.rgba8888ToColor(p.color,u),c&&(p.width=M*d,p.height=x*d),this.linkedMeshes.push(new _e(p,m,s,h,g)),p)}case f.AttachmentType.Path:{const l=e.readBoolean(),u=e.readBoolean(),m=e.readInt(!0),h=this.readVertices(e,m),g=f.Utils.newArray(m/3,0);for(let p=0,E=g.length;p<E;p++)g[p]=e.readFloat()*d;const M=c?e.readInt32():0,x=this.attachmentLoader.newPathAttachment(n,a);return x==null?null:(x.closed=l,x.constantSpeed=u,x.worldVerticesLength=m<<1,x.vertices=h.vertices,x.bones=h.bones,x.lengths=g,x.cVertices=h.cVertices,c&&f.Color.rgba8888ToColor(x.color,M),x)}case f.AttachmentType.Point:{const l=e.readFloat(),u=e.readFloat(),m=e.readFloat(),h=c?e.readInt32():0,g=this.attachmentLoader.newPointAttachment(n,a);return g==null?null:(g.x=u*d,g.y=m*d,g.rotation=l,c&&f.Color.rgba8888ToColor(g.color,h),g)}case f.AttachmentType.Clipping:{const l=e.readInt(!0),u=e.readInt(!0),m=this.readVertices(e,u),h=c?e.readInt32():0,g=this.attachmentLoader.newClippingAttachment(n,a);return g==null?null:(g.endSlot=t.slots[l],g.worldVerticesLength=u<<1,g.vertices=m.vertices,g.bones=m.bones,g.cVertices=m.cVertices,c&&f.Color.rgba8888ToColor(g.color,h),g)}}return null}readVertices(e,t){const n=t<<1,s=new Xe,i=this.scale;if(!e.readBoolean())return s.vertices=this.readFloatArray(e,n,i),s;const c=new Array,d=new Array,a=new Array;for(let r=0;r<t;r++){const o=e.readInt(!0);a.push(o),c.push(o);for(let l=0;l<o;l++){const u=e.readInt(!0);a.push(u),c.push(u);const m=e.readFloat()*i,h=e.readFloat()*i,g=e.readFloat();d.push(m),d.push(h),d.push(g),c.push(m),c.push(h),c.push(g)}}return s.vertices=f.Utils.toFloatArray(d),s.bones=a,s.cVertices=c,s}readFloatArray(e,t,n){const s=new Array(t);if(n==1)for(let i=0;i<t;i++)s[i]=e.readFloat();else for(let i=0;i<t;i++)s[i]=e.readFloat()*n;return s}readShortArray(e){const t=e.readInt(!0),n=new Array(t);for(let s=0;s<t;s++)n[s]=e.readShort();return n}readAnimation(e,t,n){const s=new Array,i=this.scale;let c=0;const d=new f.Color;for(let o=0,l=e.readInt(!0);o<l;o++){const u=e.readInt(!0);for(let m=0,h=e.readInt(!0);m<h;m++){const g=e.readByte(),M=e.readInt(!0);switch(g){case Z.SLOT_ATTACHMENT:{const x=new vt(M);x.slotIndex=u;for(let p=0;p<M;p++){const E=e.readFloat(),w=e.readString();x.setFrame(p,E,w)}s.push(x),c=Math.max(c,x.frames[M-1]);break}case Z.SLOT_COLOR:{const x=new nt(M);x.slotIndex=u;for(let p=0;p<M;p++){const E=e.readFloat();f.Color.rgba8888ToColor(d,e.readInt32()),x.setFrame(p,E,d.r,d.g,d.b,d.a),p<M-1&&this.readCurve(e,p,x)}s.push(x),c=Math.max(c,x.frames[(M-1)*nt.ENTRIES]);break}}}}for(let o=0,l=e.readInt(!0);o<l;o++){const u=e.readInt(!0);for(let m=0,h=e.readInt(!0);m<h;m++){const g=e.readByte(),M=e.readInt(!0);switch(g){case Z.BONE_ROTATE:{const x=new J(M);x.boneIndex=u;for(let p=0;p<M;p++)x.setFrame(p,e.readFloat(),e.readFloat()),p<M-1&&this.readCurve(e,p,x);s.push(x),c=Math.max(c,x.frames[(M-1)*J.ENTRIES]);break}case Z.BONE_TRANSLATE:case Z.BONE_SCALE:case Z.BONE_SHEAR:{let x,p=1;g==Z.BONE_SCALE?x=new ct(M):g==Z.BONE_SHEAR?x=new ht(M):(x=new ut(M),p=i),x.boneIndex=u;for(let E=0;E<M;E++){const w=e.readFloat(),S=e.readFloat(),y=e.readFloat();x.setFrame(E,w,S*p,y*p),E<M-1&&this.readCurve(e,E,x)}s.push(x),c=Math.max(c,x.frames[(M-1)*ut.ENTRIES]);break}}}}for(let o=0,l=e.readInt(!0);o<l;o++){const u=e.readInt(!0),m=e.readInt(!0),h=new tt(m);h.ikConstraintIndex=u;for(let g=0;g<m;g++){const M=e.readFloat(),x=e.readFloat(),p=e.readByte();h.setFrame(g,M,x,p),g<m-1&&this.readCurve(e,g,h)}s.push(h),c=Math.max(c,h.frames[(m-1)*tt.ENTRIES])}for(let o=0,l=e.readInt(!0);o<l;o++){const u=e.readInt(!0),m=e.readInt(!0),h=new st(m);h.transformConstraintIndex=u;for(let g=0;g<m;g++)h.setFrame(g,e.readFloat(),e.readFloat(),e.readFloat(),e.readFloat(),e.readFloat()),g<m-1&&this.readCurve(e,g,h);s.push(h),c=Math.max(c,h.frames[(m-1)*st.ENTRIES])}for(let o=0,l=e.readInt(!0);o<l;o++){const u=e.readInt(!0),m=n.pathConstraints[u];for(let h=0,g=e.readInt(!0);h<g;h++){const M=e.readByte(),x=e.readInt(!0);switch(M){case Z.PATH_POSITION:case Z.PATH_SPACING:{let p,E=1;M==Z.PATH_SPACING?(p=new Mt(x),(m.spacingMode==K.Length||m.spacingMode==K.Fixed)&&(E=i)):(p=new Et(x),m.positionMode==f.PositionMode.Fixed&&(E=i)),p.pathConstraintIndex=u;for(let w=0;w<x;w++){const S=e.readFloat(),y=e.readFloat()*E;p.setFrame(w,S,y),w<x-1&&this.readCurve(e,w,p)}s.push(p),c=Math.max(c,p.frames[(x-1)*Et.ENTRIES]);break}case Z.PATH_MIX:{const p=new pt(x);p.pathConstraintIndex=u;for(let E=0;E<x;E++){const w=e.readFloat(),S=e.readFloat(),y=e.readFloat();p.setFrame(E,w,S,y),E<x-1&&this.readCurve(e,E,p)}s.push(p),c=Math.max(c,p.frames[(x-1)*pt.ENTRIES]);break}}}}for(let o=0,l=e.readInt(!0);o<l;o++){const u=n.skins[e.readInt(!0)];for(let m=0,h=e.readInt(!0);m<h;m++){const g=e.readInt(!0);for(let M=0,x=e.readInt(!0);M<x;M++){const p=u==null?void 0:u.getAttachment(g,e.readString()),E=p.bones!=null,w=p.vertices,S=E?w.length/3*2:w.length,y=e.readInt(!0),A=new ee(y);A.slotIndex=g,A.attachment=p;for(let R=0;R<y;R++){const T=e.readFloat();let I,C=e.readInt(!0);if(C==0)I=E?f.Utils.newFloatArray(S):w;else{I=f.Utils.newFloatArray(S);const D=e.readInt(!0);if(C+=D,i==1)for(let B=D;B<C;B++)I[B]=e.readFloat();else for(let B=D;B<C;B++)I[B]=e.readFloat()*i;if(!E)for(let B=0,q=I.length;B<q;B++)I[B]+=w[B]}A.setFrame(R,T,I,u.name),R<y-1&&this.readCurve(e,R,A)}s.push(A),c=Math.max(c,A.frames[y-1])}}}const a=e.readInt(!0);if(a>0){const o=new Bt(a),l=n.slots.length;for(let u=0;u<a;u++){const m=e.readFloat(),h=e.readInt(!0),g=f.Utils.newArray(l,0);for(let E=l-1;E>=0;E--)g[E]=-1;const M=f.Utils.newArray(l-h,0);let x=0,p=0;for(let E=0;E<h;E++){const w=e.readInt(!0);for(;x!=w;)M[p++]=x++;g[x+e.readInt(!0)]=x++}for(;x<l;)M[p++]=x++;for(let E=l-1;E>=0;E--)g[E]==-1&&(g[E]=M[--p]);o.setFrame(u,m,g)}s.push(o),c=Math.max(c,o.frames[a-1])}const r=e.readInt(!0);if(r>0){const o=new qt(r);for(let l=0;l<r;l++){const u=e.readFloat(),m=n.events[e.readInt(!0)],h=new le(u,m);h.intValue=e.readInt(!1),h.floatValue=e.readFloat(),h.stringValue=e.readBoolean()?e.readString():m.stringValue,h.data.audioPath!=null&&(h.volume=e.readFloat(),h.balance=e.readFloat()),o.setFrame(l,h)}s.push(o),c=Math.max(c,o.frames[r-1])}return new H(t,s,c)}readCurve(e,t,n){switch(e.readByte()){case Z.CURVE_STEPPED:n.setStepped(t);break;case Z.CURVE_BEZIER:this.setCurve(n,t,e.readFloat(),e.readFloat(),e.readFloat(),e.readFloat());break}}setCurve(e,t,n,s,i,c){e.setCurve(t,n,s,i,c)}};let G=Z;G.AttachmentTypeValues=[0,1,2,3,4,5,6],G.TransformModeValues=[f.TransformMode.Normal,f.TransformMode.OnlyTranslation,f.TransformMode.NoRotationOrReflection,f.TransformMode.NoScale,f.TransformMode.NoScaleOrReflection],G.PositionModeValues=[f.PositionMode.Fixed,f.PositionMode.Percent],G.SpacingModeValues=[K.Length,K.Fixed,K.Percent],G.RotateModeValues=[f.RotateMode.Tangent,f.RotateMode.Chain,f.RotateMode.ChainScale],G.BlendModeValues=[wt.BLEND_MODES.NORMAL,wt.BLEND_MODES.ADD,wt.BLEND_MODES.MULTIPLY,wt.BLEND_MODES.SCREEN],G.BONE_ROTATE=0,G.BONE_TRANSLATE=1,G.BONE_SCALE=2,G.BONE_SHEAR=3,G.SLOT_ATTACHMENT=0,G.SLOT_COLOR=1,G.SLOT_TWO_COLOR=2,G.PATH_POSITION=0,G.PATH_SPACING=1,G.PATH_MIX=2,G.CURVE_LINEAR=0,G.CURVE_STEPPED=1,G.CURVE_BEZIER=2;let _e=class{constructor(t,n,s,i,c){this.mesh=t,this.skin=n,this.slotIndex=s,this.parent=i,this.inheritDeform=c}};class Xe{constructor(t=null,n=null,s=null){this.bones=t,this.vertices=n,this.cVertices=s}}class be extends f.SkeletonBoundsBase{}class Pt{constructor(t){this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=t}readSkeletonData(t){const n=this.scale,s=new ue,i=typeof t=="string"?JSON.parse(t):t,c=i.skeleton;if(c!=null){if(s.hash=c.hash,s.version=c.spine,s.version.substr(0,3)!=="3.4"){const d=`Spine 3.4 loader cant load version ${c.spine}. Please configure your pixi-spine bundle`;console.error(d)}s.version==="3.4.75"&&console.error("Unsupported skeleton data, 3.4.75 is deprecated, please export with a newer version of Spine."),s.x=c.x,s.y=c.y,s.width=c.width,s.height=c.height,s.fps=c.fps,s.imagesPath=c.images}if(i.bones)for(let d=0;d<i.bones.length;d++){const a=i.bones[d];let r=null;const o=this.getValue(a,"parent",null);if(o!=null&&(r=s.findBone(o),r==null))throw new Error(`Parent bone not found: ${o}`);const l=new ae(s.bones.length,a.name,r);l.length=this.getValue(a,"length",0)*n,l.x=this.getValue(a,"x",0)*n,l.y=this.getValue(a,"y",0)*n,l.rotation=this.getValue(a,"rotation",0),l.scaleX=this.getValue(a,"scaleX",1),l.scaleY=this.getValue(a,"scaleY",1),l.shearX=this.getValue(a,"shearX",0),l.shearY=this.getValue(a,"shearY",0),l.transformMode=Pt.transformModeFromString(this.getValue(a,"transform","normal")),l.skinRequired=this.getValue(a,"skin",!1),s.bones.push(l)}if(i.slots)for(let d=0;d<i.slots.length;d++){const a=i.slots[d],r=a.name,o=a.bone,l=s.findBone(o);if(l==null)throw new Error(`Slot bone not found: ${o}`);const u=new me(s.slots.length,r,l),m=this.getValue(a,"color",null);m!=null&&u.color.setFromString(m);const h=this.getValue(a,"dark",null);h!=null&&(u.darkColor=new f.Color(1,1,1,1),u.darkColor.setFromString(h)),u.attachmentName=this.getValue(a,"attachment",null),u.blendMode=Pt.blendModeFromString(this.getValue(a,"blend","normal")),s.slots.push(u)}if(i.ik)for(let d=0;d<i.ik.length;d++){const a=i.ik[d],r=new he(a.name);r.order=this.getValue(a,"order",0),r.skinRequired=this.getValue(a,"skin",!1);for(let l=0;l<a.bones.length;l++){const u=a.bones[l],m=s.findBone(u);if(m==null)throw new Error(`IK bone not found: ${u}`);r.bones.push(m)}const o=a.target;if(r.target=s.findBone(o),r.target==null)throw new Error(`IK target bone not found: ${o}`);r.mix=this.getValue(a,"mix",1),r.softness=this.getValue(a,"softness",0)*n,r.bendDirection=this.getValue(a,"bendPositive",!0)?1:-1,r.compress=this.getValue(a,"compress",!1),r.stretch=this.getValue(a,"stretch",!1),r.uniform=this.getValue(a,"uniform",!1),s.ikConstraints.push(r)}if(i.transform)for(let d=0;d<i.transform.length;d++){const a=i.transform[d],r=new ge(a.name);r.order=this.getValue(a,"order",0),r.skinRequired=this.getValue(a,"skin",!1);for(let l=0;l<a.bones.length;l++){const u=a.bones[l],m=s.findBone(u);if(m==null)throw new Error(`Transform constraint bone not found: ${u}`);r.bones.push(m)}const o=a.target;if(r.target=s.findBone(o),r.target==null)throw new Error(`Transform constraint target bone not found: ${o}`);r.local=this.getValue(a,"local",!1),r.relative=this.getValue(a,"relative",!1),r.offsetRotation=this.getValue(a,"rotation",0),r.offsetX=this.getValue(a,"x",0)*n,r.offsetY=this.getValue(a,"y",0)*n,r.offsetScaleX=this.getValue(a,"scaleX",0),r.offsetScaleY=this.getValue(a,"scaleY",0),r.offsetShearY=this.getValue(a,"shearY",0),r.rotateMix=this.getValue(a,"rotateMix",1),r.translateMix=this.getValue(a,"translateMix",1),r.scaleMix=this.getValue(a,"scaleMix",1),r.shearMix=this.getValue(a,"shearMix",1),s.transformConstraints.push(r)}if(i.path)for(let d=0;d<i.path.length;d++){const a=i.path[d],r=new de(a.name);r.order=this.getValue(a,"order",0),r.skinRequired=this.getValue(a,"skin",!1);for(let l=0;l<a.bones.length;l++){const u=a.bones[l],m=s.findBone(u);if(m==null)throw new Error(`Transform constraint bone not found: ${u}`);r.bones.push(m)}const o=a.target;if(r.target=s.findSlot(o),r.target==null)throw new Error(`Path target slot not found: ${o}`);r.positionMode=Pt.positionModeFromString(this.getValue(a,"positionMode","percent")),r.spacingMode=Pt.spacingModeFromString(this.getValue(a,"spacingMode","length")),r.rotateMode=Pt.rotateModeFromString(this.getValue(a,"rotateMode","tangent")),r.offsetRotation=this.getValue(a,"rotation",0),r.position=this.getValue(a,"position",0),r.positionMode==f.PositionMode.Fixed&&(r.position*=n),r.spacing=this.getValue(a,"spacing",0),(r.spacingMode==K.Length||r.spacingMode==K.Fixed)&&(r.spacing*=n),r.rotateMix=this.getValue(a,"rotateMix",1),r.translateMix=this.getValue(a,"translateMix",1),s.pathConstraints.push(r)}if(i.skins)for(let d=0;d<i.skins.length;d++){const a=i.skins[d],r=new jt(a.name);if(a.bones)for(let o=0;o<a.bones.length;o++){const l=s.findBone(a.bones[o]);if(l==null)throw new Error(`Skin bone not found: ${a.bones[d]}`);r.bones.push(l)}if(a.ik)for(let o=0;o<a.ik.length;o++){const l=s.findIkConstraint(a.ik[o]);if(l==null)throw new Error(`Skin IK constraint not found: ${a.ik[d]}`);r.constraints.push(l)}if(a.transform)for(let o=0;o<a.transform.length;o++){const l=s.findTransformConstraint(a.transform[o]);if(l==null)throw new Error(`Skin transform constraint not found: ${a.transform[d]}`);r.constraints.push(l)}if(a.path)for(let o=0;o<a.path.length;o++){const l=s.findPathConstraint(a.path[o]);if(l==null)throw new Error(`Skin path constraint not found: ${a.path[d]}`);r.constraints.push(l)}for(const o in a.attachments){const l=s.findSlot(o);if(l==null)throw new Error(`Slot not found: ${o}`);const u=a.attachments[o];for(const m in u){const h=this.readAttachment(u[m],r,l.index,m,s);h!=null&&r.setAttachment(l.index,m,h)}}s.skins.push(r),r.name=="default"&&(s.defaultSkin=r)}for(let d=0,a=this.linkedMeshes.length;d<a;d++){const r=this.linkedMeshes[d],o=r.skin==null?s.defaultSkin:s.findSkin(r.skin);if(o==null)throw new Error(`Skin not found: ${r.skin}`);const l=o.getAttachment(r.slotIndex,r.parent);if(l==null)throw new Error(`Parent mesh not found: ${r.parent}`);r.mesh.deformAttachment=r.inheritDeform?l:r.mesh,r.mesh.setParentMesh(l)}if(this.linkedMeshes.length=0,i.events)for(const d in i.events){const a=i.events[d],r=new ce(d);r.intValue=this.getValue(a,"int",0),r.floatValue=this.getValue(a,"float",0),r.stringValue=this.getValue(a,"string",""),r.audioPath=this.getValue(a,"audio",null),r.audioPath!=null&&(r.volume=this.getValue(a,"volume",1),r.balance=this.getValue(a,"balance",0)),s.events.push(r)}if(i.animations)for(const d in i.animations){const a=i.animations[d];this.readAnimation(a,d,s)}return s}readAttachment(t,n,s,i,c){const d=this.scale;switch(i=this.getValue(t,"name",i),this.getValue(t,"type","region")){case"region":{const r=this.getValue(t,"path",i),o=this.attachmentLoader.newRegionAttachment(n,i,r);if(o==null)return null;o.path=r,o.x=this.getValue(t,"x",0)*d,o.y=this.getValue(t,"y",0)*d,o.scaleX=this.getValue(t,"scaleX",1),o.scaleY=this.getValue(t,"scaleY",1),o.rotation=this.getValue(t,"rotation",0),o.width=t.width*d,o.height=t.height*d;const l=this.getValue(t,"color",null);return l!=null&&o.color.setFromString(l),o}case"boundingbox":{const r=this.attachmentLoader.newBoundingBoxAttachment(n,i);if(r==null)return null;this.readVertices(t,r,t.vertexCount<<1);const o=this.getValue(t,"color",null);return o!=null&&r.color.setFromString(o),r}case"mesh":case"linkedmesh":{const r=this.getValue(t,"path",i),o=this.attachmentLoader.newMeshAttachment(n,i,r);if(o==null)return null;o.path=r;const l=this.getValue(t,"color",null);l!=null&&o.color.setFromString(l),o.width=this.getValue(t,"width",0)*d,o.height=this.getValue(t,"height",0)*d;const u=this.getValue(t,"parent",null);if(u!=null)return this.linkedMeshes.push(new We(o,this.getValue(t,"skin",null),s,u,this.getValue(t,"deform",!0))),o;const m=t.uvs;return this.readVertices(t,o,m.length),o.triangles=t.triangles,o.regionUVs=new Float32Array(m),o.edges=this.getValue(t,"edges",null),o.hullLength=this.getValue(t,"hull",0)*2,o}case"path":{const r=this.attachmentLoader.newPathAttachment(n,i);if(r==null)return null;r.closed=this.getValue(t,"closed",!1),r.constantSpeed=this.getValue(t,"constantSpeed",!0);const o=t.vertexCount;this.readVertices(t,r,o<<1);const l=f.Utils.newArray(o/3,0);for(let m=0;m<t.lengths.length;m++)l[m]=t.lengths[m]*d;r.lengths=l;const u=this.getValue(t,"color",null);return u!=null&&r.color.setFromString(u),r}case"point":{const r=this.attachmentLoader.newPointAttachment(n,i);if(r==null)return null;r.x=this.getValue(t,"x",0)*d,r.y=this.getValue(t,"y",0)*d,r.rotation=this.getValue(t,"rotation",0);const o=this.getValue(t,"color",null);return o!=null&&r.color.setFromString(o),r}case"clipping":{const r=this.attachmentLoader.newClippingAttachment(n,i);if(r==null)return null;const o=this.getValue(t,"end",null);if(o!=null){const m=c.findSlot(o);if(m==null)throw new Error(`Clipping end slot not found: ${o}`);r.endSlot=m}const l=t.vertexCount;this.readVertices(t,r,l<<1);const u=this.getValue(t,"color",null);return u!=null&&r.color.setFromString(u),r}}return null}readVertices(t,n,s){const i=this.scale;n.worldVerticesLength=s;const c=t.vertices;if(s==c.length){const r=f.Utils.toFloatArray(c);if(i!=1)for(let o=0,l=c.length;o<l;o++)r[o]*=i;n.vertices=r;return}const d=new Array,a=new Array;for(let r=0,o=c.length;r<o;){const l=c[r++];a.push(l);for(let u=r+l*4;r<u;r+=4)a.push(c[r]),d.push(c[r+1]*i),d.push(c[r+2]*i),d.push(c[r+3])}n.bones=a,n.vertices=f.Utils.toFloatArray(d)}readAnimation(t,n,s){const i=this.scale,c=new Array;let d=0;if(t.slots)for(const r in t.slots){const o=t.slots[r],l=s.findSlotIndex(r);if(l==-1)throw new Error(`Slot not found: ${r}`);for(const u in o){const m=o[u];if(u=="attachment"){const h=new vt(m.length);h.slotIndex=l;let g=0;for(let M=0;M<m.length;M++){const x=m[M];h.setFrame(g++,this.getValue(x,"time",0),x.name)}c.push(h),d=Math.max(d,h.frames[h.getFrameCount()-1])}else if(u=="color"){const h=new nt(m.length);h.slotIndex=l;let g=0;for(let M=0;M<m.length;M++){const x=m[M],p=new f.Color;p.setFromString(x.color||"ffffffff"),h.setFrame(g,this.getValue(x,"time",0),p.r,p.g,p.b,p.a),this.readCurve(x,h,g),g++}c.push(h),d=Math.max(d,h.frames[(h.getFrameCount()-1)*nt.ENTRIES])}else if(u=="twoColor"){const h=new z(m.length);h.slotIndex=l;let g=0;for(let M=0;M<m.length;M++){const x=m[M],p=new f.Color,E=new f.Color;p.setFromString(x.light),E.setFromString(x.dark),h.setFrame(g,this.getValue(x,"time",0),p.r,p.g,p.b,p.a,E.r,E.g,E.b),this.readCurve(x,h,g),g++}c.push(h),d=Math.max(d,h.frames[(h.getFrameCount()-1)*z.ENTRIES])}else throw new Error(`Invalid timeline type for a slot: ${u} (${r})`)}}if(t.bones)for(const r in t.bones){const o=t.bones[r],l=s.findBoneIndex(r);if(l==-1)throw new Error(`Bone not found: ${r}`);for(const u in o){const m=o[u];if(u==="rotate"){const h=new J(m.length);h.boneIndex=l;let g=0;for(let M=0;M<m.length;M++){const x=m[M];h.setFrame(g,this.getValue(x,"time",0),this.getValue(x,"angle",0)),this.readCurve(x,h,g),g++}c.push(h),d=Math.max(d,h.frames[(h.getFrameCount()-1)*J.ENTRIES])}else if(u==="translate"||u==="scale"||u==="shear"){let h=null,g=1,M=0;u==="scale"?(h=new ct(m.length),M=1):u==="shear"?h=new ht(m.length):(h=new ut(m.length),g=i),h.boneIndex=l;let x=0;for(let p=0;p<m.length;p++){const E=m[p],w=this.getValue(E,"x",M),S=this.getValue(E,"y",M);h.setFrame(x,this.getValue(E,"time",0),w*g,S*g),this.readCurve(E,h,x),x++}c.push(h),d=Math.max(d,h.frames[(h.getFrameCount()-1)*ut.ENTRIES])}else throw new Error(`Invalid timeline type for a bone: ${u} (${r})`)}}if(t.ik)for(const r in t.ik){const o=t.ik[r],l=s.findIkConstraint(r),u=new tt(o.length);u.ikConstraintIndex=s.ikConstraints.indexOf(l);let m=0;for(let h=0;h<o.length;h++){const g=o[h];u.setFrame(m,this.getValue(g,"time",0),this.getValue(g,"mix",1),this.getValue(g,"softness",0)*i),this.readCurve(g,u,m),m++}c.push(u),d=Math.max(d,u.frames[(u.getFrameCount()-1)*tt.ENTRIES])}if(t.transform)for(const r in t.transform){const o=t.transform[r],l=s.findTransformConstraint(r),u=new st(o.length);u.transformConstraintIndex=s.transformConstraints.indexOf(l);let m=0;for(let h=0;h<o.length;h++){const g=o[h];u.setFrame(m,this.getValue(g,"time",0),this.getValue(g,"rotateMix",1),this.getValue(g,"translateMix",1),this.getValue(g,"scaleMix",1),this.getValue(g,"shearMix",1)),this.readCurve(g,u,m),m++}c.push(u),d=Math.max(d,u.frames[(u.getFrameCount()-1)*st.ENTRIES])}if(t.path)for(const r in t.path){const o=t.path[r],l=s.findPathConstraintIndex(r);if(l==-1)throw new Error(`Path constraint not found: ${r}`);const u=s.pathConstraints[l];for(const m in o){const h=o[m];if(m==="position"||m==="spacing"){let g=null,M=1;m==="spacing"?(g=new Mt(h.length),(u.spacingMode==K.Length||u.spacingMode==K.Fixed)&&(M=i)):(g=new Et(h.length),u.positionMode==f.PositionMode.Fixed&&(M=i)),g.pathConstraintIndex=l;let x=0;for(let p=0;p<h.length;p++){const E=h[p];g.setFrame(x,this.getValue(E,"time",0),this.getValue(E,m,0)*M),this.readCurve(E,g,x),x++}c.push(g),d=Math.max(d,g.frames[(g.getFrameCount()-1)*Et.ENTRIES])}else if(m==="mix"){const g=new pt(h.length);g.pathConstraintIndex=l;let M=0;for(let x=0;x<h.length;x++){const p=h[x];g.setFrame(M,this.getValue(p,"time",0),this.getValue(p,"rotateMix",1),this.getValue(p,"translateMix",1)),this.readCurve(p,g,M),M++}c.push(g),d=Math.max(d,g.frames[(g.getFrameCount()-1)*pt.ENTRIES])}}}if(t.deform)for(const r in t.deform){const o=t.deform[r],l=s.findSkin(r);if(l==null){if(f.settings.FAIL_ON_NON_EXISTING_SKIN)throw new Error(`Skin not found: ${r}`);continue}for(const u in o){const m=o[u],h=s.findSlotIndex(u);if(h==-1)throw new Error(`Slot not found: ${m.name}`);for(const g in m){const M=m[g],x=l.getAttachment(h,g);if(x==null)throw new Error(`Deform attachment not found: ${M.name}`);const p=x.bones!=null,E=x.vertices,w=p?E.length/3*2:E.length,S=new ee(M.length);S.slotIndex=h,S.attachment=x;let y=0;for(let A=0;A<M.length;A++){const R=M[A];let T;const I=this.getValue(R,"vertices",null);if(I==null)T=p?f.Utils.newFloatArray(w):E;else{T=f.Utils.newFloatArray(w);const C=this.getValue(R,"offset",0);if(f.Utils.arrayCopy(I,0,T,C,I.length),i!=1)for(let D=C,B=D+I.length;D<B;D++)T[D]*=i;if(!p)for(let D=0;D<w;D++)T[D]+=E[D]}S.setFrame(y,this.getValue(R,"time",0),T,l.name),this.readCurve(R,S,y),y++}c.push(S),d=Math.max(d,S.frames[S.getFrameCount()-1])}}}let a=t.drawOrder;if(a==null&&(a=t.draworder),a!=null){const r=new Bt(a.length),o=s.slots.length;let l=0;for(let u=0;u<a.length;u++){const m=a[u];let h=null;const g=this.getValue(m,"offsets",null);if(g!=null){h=f.Utils.newArray(o,-1);const M=f.Utils.newArray(o-g.length,0);let x=0,p=0;for(let E=0;E<g.length;E++){const w=g[E],S=s.findSlotIndex(w.slot);if(S==-1)throw new Error(`Slot not found: ${w.slot}`);for(;x!=S;)M[p++]=x++;h[x+w.offset]=x++}for(;x<o;)M[p++]=x++;for(let E=o-1;E>=0;E--)h[E]==-1&&(h[E]=M[--p])}r.setFrame(l++,this.getValue(m,"time",0),h)}c.push(r),d=Math.max(d,r.frames[r.getFrameCount()-1])}if(t.events){const r=new qt(t.events.length);let o=0;for(let l=0;l<t.events.length;l++){const u=t.events[l],m=s.findEvent(u.name);if(m==null)throw new Error(`Event not found: ${u.name}`);const h=new le(f.Utils.toSinglePrecision(this.getValue(u,"time",0)),m);h.intValue=this.getValue(u,"int",m.intValue),h.floatValue=this.getValue(u,"float",m.floatValue),h.stringValue=this.getValue(u,"string",m.stringValue),h.data.audioPath!=null&&(h.volume=this.getValue(u,"volume",1),h.balance=this.getValue(u,"balance",0)),r.setFrame(o++,h)}c.push(r),d=Math.max(d,r.frames[r.getFrameCount()-1])}if(isNaN(d))throw new Error("Error while parsing animation, duration is NaN");s.animations.push(new H(n,c,d))}readCurve(t,n,s){if(t.hasOwnProperty("curve"))if(t.curve==="stepped")n.setStepped(s);else{const i=t.curve;n.setCurve(s,i,this.getValue(t,"c2",0),this.getValue(t,"c3",1),this.getValue(t,"c4",1))}}getValue(t,n,s){return t[n]!==void 0?t[n]:s}static blendModeFromString(t){if(t=t.toLowerCase(),t=="normal")return wt.BLEND_MODES.NORMAL;if(t=="additive")return wt.BLEND_MODES.ADD;if(t=="multiply")return wt.BLEND_MODES.MULTIPLY;if(t=="screen")return wt.BLEND_MODES.SCREEN;throw new Error(`Unknown blend mode: ${t}`)}static positionModeFromString(t){if(t=t.toLowerCase(),t=="fixed")return f.PositionMode.Fixed;if(t=="percent")return f.PositionMode.Percent;throw new Error(`Unknown position mode: ${t}`)}static spacingModeFromString(t){if(t=t.toLowerCase(),t=="length")return K.Length;if(t=="fixed")return K.Fixed;if(t=="percent")return K.Percent;throw new Error(`Unknown position mode: ${t}`)}static rotateModeFromString(t){if(t=t.toLowerCase(),t=="tangent")return f.RotateMode.Tangent;if(t=="chain")return f.RotateMode.Chain;if(t=="chainscale")return f.RotateMode.ChainScale;throw new Error(`Unknown rotate mode: ${t}`)}static transformModeFromString(t){if(t=t.toLowerCase(),t=="normal")return f.TransformMode.Normal;if(t=="onlytranslation")return f.TransformMode.OnlyTranslation;if(t=="norotationorreflection")return f.TransformMode.NoRotationOrReflection;if(t=="noscale")return f.TransformMode.NoScale;if(t=="noscaleorreflection")return f.TransformMode.NoScaleOrReflection;throw new Error(`Unknown transform mode: ${t}`)}}class We{constructor(t,n,s,i,c){this.mesh=t,this.skin=n,this.slotIndex=s,this.parent=i,this.inheritDeform=c}}let qe=class extends f.SpineBase{createSkeleton(t){this.skeleton=new fe(t),this.skeleton.updateWorldTransform(),this.stateData=new re(t),this.state=new mt(this.stateData)}};var $e=Object.freeze({__proto__:null,Animation:H,AnimationState:mt,AnimationStateAdapter:Ye,AnimationStateData:re,AtlasAttachmentLoader:Re,Attachment:Jt,AttachmentTimeline:vt,Bone:oe,BoneData:ae,BoundingBoxAttachment:Xt,ClippingAttachment:bt,ColorTimeline:nt,ConstraintData:Ht,CurveTimeline:lt,DeformTimeline:ee,DrawOrderTimeline:Bt,Event:le,EventData:ce,EventQueue:se,EventTimeline:qt,EventType:dt,IkConstraint:Ie,IkConstraintData:he,IkConstraintTimeline:tt,JitterEffect:Le,MeshAttachment:Ct,PathAttachment:Vt,PathConstraint:Ft,PathConstraintData:de,PathConstraintMixTimeline:pt,PathConstraintPositionTimeline:Et,PathConstraintSpacingTimeline:Mt,PointAttachment:Wt,RegionAttachment:P,RotateTimeline:J,ScaleTimeline:ct,ShearTimeline:ht,Skeleton:fe,SkeletonBinary:G,SkeletonBounds:be,SkeletonData:ue,SkeletonJson:Pt,Skin:jt,SkinEntry:xe,Slot:te,SlotData:me,SpacingMode:K,Spine:qe,SwirlEffect:Se,TimelineType:Ae,TrackEntry:$t,TransformConstraint:Te,TransformConstraintData:ge,TransformConstraintTimeline:st,TranslateTimeline:ut,TwoColorTimeline:z,VertexAttachment:Rt}),rt=(e=>(e[e.UNKNOWN=0]="UNKNOWN",e[e.VER34=34]="VER34",e[e.VER37=37]="VER37",e[e.VER38=38]="VER38",e[e.VER40=40]="VER40",e[e.VER41=41]="VER41",e))(rt||{});function Yt(e){const t=e.substr(0,3),n=Math.floor(Number(t)*10+.001);return t==="3.3"||t==="3.4"?34:t==="3.7"?37:t==="3.8"?38:t==="4.0"?40:t==="4.1"?41:n<37?37:0}class He{constructor(){this.scale=1}readSkeletonData(t,n){let s=null,i=this.readVersionOldFormat(n),c=Yt(i);if(c===rt.VER34&&(s=new G(new Re(t))),c===rt.VER38&&(s=new Dt.SkeletonBinary(new Dt.AtlasAttachmentLoader(t))),i=this.readVersionNewFormat(n),c=Yt(i),(c===rt.VER40||c===rt.VER41)&&(s=new Ot.SkeletonBinary(new Ot.AtlasAttachmentLoader(t))),!s){const d=`Unsupported version of spine model ${i}, please update pixi-spine`;console.error(d)}return s.scale=this.scale,s.readSkeletonData(n)}readVersionOldFormat(t){const n=new f.BinaryInput(t);let s;try{n.readString(),s=n.readString()}catch(i){s=""}return s||""}readVersionNewFormat(t){const n=new f.BinaryInput(t);n.readInt32(),n.readInt32();let s;try{s=n.readString()}catch(i){s=""}return s||""}}class je{constructor(){this.scale=1}readSkeletonData(t,n){const s=n.skeleton.spine,i=Yt(s);let c=null;if(i===rt.VER37&&(c=new Kt.SkeletonJson(new Kt.AtlasAttachmentLoader(t))),i===rt.VER38&&(c=new Dt.SkeletonJson(new Dt.AtlasAttachmentLoader(t))),(i===rt.VER40||i===rt.VER41)&&(c=new Ot.SkeletonJson(new Ot.AtlasAttachmentLoader(t))),!c){const d=`Unsupported version of spine model ${s}, please update pixi-spine`;console.error(d)}return c.scale=this.scale,c.readSkeletonData(n)}}class Ge extends Ne.SpineLoaderAbstract{createBinaryParser(){return new He}createJsonParser(){return new je}parseData(t,n,s){return{spineData:t.readSkeletonData(n,s),spineAtlas:n}}}class Ze extends f.SpineBase{createSkeleton(t){const n=Yt(t.version);let s=null;if(n===rt.VER34&&(s=$e),n===rt.VER37&&(s=Kt),n===rt.VER38&&(s=Dt),(n===rt.VER40||n===rt.VER41)&&(s=Ot),!s){const i=`Cant detect version of spine model ${t.version}`;console.error(i)}this.skeleton=new s.Skeleton(t),this.skeleton.updateWorldTransform(),this.stateData=new s.AnimationStateData(t),this.state=new s.AnimationState(this.stateData)}}return new Ge().installLoader(),_t.SPINE_VERSION=rt,_t.Spine=Ze,_t.detectSpineVersion=Yt,_t}({},PIXI.spine,base,PIXI,PIXI.spine38,PIXI.spine37,PIXI.spine41);
//# sourceMappingURL=loader-uni.js.map
