{"version":3,"file":"SkeletonBoundsBase.mjs","sources":["../../src/core/SkeletonBoundsBase.ts"],"sourcesContent":["import { AttachmentType } from './AttachmentType';\r\nimport type { ISkeleton, IVertexAttachment } from './ISkeleton';\r\nimport { NumberArrayLike, Pool, Utils } from './Utils';\r\n\r\n/** Collects each visible BoundingBoxAttachment and computes the world vertices for its polygon. The polygon vertices are\r\n * provided along with convenience methods for doing hit detection.\r\n * @public\r\n * */\r\nexport class SkeletonBoundsBase<BoundingBoxAttachment extends IVertexAttachment> {\r\n    /** The left edge of the axis aligned bounding box. */\r\n    minX = 0;\r\n\r\n    /** The bottom edge of the axis aligned bounding box. */\r\n    minY = 0;\r\n\r\n    /** The right edge of the axis aligned bounding box. */\r\n    maxX = 0;\r\n\r\n    /** The top edge of the axis aligned bounding box. */\r\n    maxY = 0;\r\n\r\n    /** The visible bounding boxes. */\r\n    boundingBoxes = new Array<BoundingBoxAttachment>();\r\n\r\n    /** The world vertices for the bounding box polygons. */\r\n    polygons = new Array<NumberArrayLike>();\r\n\r\n    private polygonPool = new Pool<NumberArrayLike>(() => Utils.newFloatArray(16));\r\n\r\n    /** Clears any previous polygons, finds all visible bounding box attachments, and computes the world vertices for each bounding\r\n     * box's polygon.\r\n     * @param updateAabb If true, the axis aligned bounding box containing all the polygons is computed. If false, the\r\n     *           SkeletonBounds AABB methods will always return true. */\r\n    update(skeleton: ISkeleton, updateAabb: boolean) {\r\n        if (!skeleton) throw new Error('skeleton cannot be null.');\r\n        const boundingBoxes = this.boundingBoxes;\r\n        const polygons = this.polygons;\r\n        const polygonPool = this.polygonPool;\r\n        const slots = skeleton.slots;\r\n        const slotCount = slots.length;\r\n\r\n        boundingBoxes.length = 0;\r\n        polygonPool.freeAll(polygons);\r\n        polygons.length = 0;\r\n\r\n        for (let i = 0; i < slotCount; i++) {\r\n            const slot = slots[i];\r\n\r\n            if (!slot.bone.active) continue;\r\n            const attachment = slot.getAttachment();\r\n\r\n            if (attachment != null && attachment.type === AttachmentType.BoundingBox) {\r\n                const boundingBox = attachment as BoundingBoxAttachment;\r\n\r\n                boundingBoxes.push(boundingBox);\r\n\r\n                let polygon = polygonPool.obtain() as NumberArrayLike;\r\n\r\n                if (polygon.length != boundingBox.worldVerticesLength) {\r\n                    polygon = Utils.newFloatArray(boundingBox.worldVerticesLength);\r\n                }\r\n                polygons.push(polygon);\r\n                boundingBox.computeWorldVertices(slot, 0, boundingBox.worldVerticesLength, polygon, 0, 2);\r\n            }\r\n        }\r\n\r\n        if (updateAabb) {\r\n            this.aabbCompute();\r\n        } else {\r\n            this.minX = Number.POSITIVE_INFINITY;\r\n            this.minY = Number.POSITIVE_INFINITY;\r\n            this.maxX = Number.NEGATIVE_INFINITY;\r\n            this.maxY = Number.NEGATIVE_INFINITY;\r\n        }\r\n    }\r\n\r\n    aabbCompute() {\r\n        let minX = Number.POSITIVE_INFINITY;\r\n        let minY = Number.POSITIVE_INFINITY;\r\n        let maxX = Number.NEGATIVE_INFINITY;\r\n        let maxY = Number.NEGATIVE_INFINITY;\r\n        const polygons = this.polygons;\r\n\r\n        for (let i = 0, n = polygons.length; i < n; i++) {\r\n            const polygon = polygons[i];\r\n            const vertices = polygon;\r\n\r\n            for (let ii = 0, nn = polygon.length; ii < nn; ii += 2) {\r\n                const x = vertices[ii];\r\n                const y = vertices[ii + 1];\r\n\r\n                minX = Math.min(minX, x);\r\n                minY = Math.min(minY, y);\r\n                maxX = Math.max(maxX, x);\r\n                maxY = Math.max(maxY, y);\r\n            }\r\n        }\r\n        this.minX = minX;\r\n        this.minY = minY;\r\n        this.maxX = maxX;\r\n        this.maxY = maxY;\r\n    }\r\n\r\n    /** Returns true if the axis aligned bounding box contains the point. */\r\n    aabbContainsPoint(x: number, y: number) {\r\n        return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;\r\n    }\r\n\r\n    /** Returns true if the axis aligned bounding box intersects the line segment. */\r\n    aabbIntersectsSegment(x1: number, y1: number, x2: number, y2: number) {\r\n        const minX = this.minX;\r\n        const minY = this.minY;\r\n        const maxX = this.maxX;\r\n        const maxY = this.maxY;\r\n\r\n        if ((x1 <= minX && x2 <= minX) || (y1 <= minY && y2 <= minY) || (x1 >= maxX && x2 >= maxX) || (y1 >= maxY && y2 >= maxY)) {\r\n            return false;\r\n        }\r\n        const m = (y2 - y1) / (x2 - x1);\r\n        let y = m * (minX - x1) + y1;\r\n\r\n        if (y > minY && y < maxY) return true;\r\n        y = m * (maxX - x1) + y1;\r\n        if (y > minY && y < maxY) return true;\r\n        let x = (minY - y1) / m + x1;\r\n\r\n        if (x > minX && x < maxX) return true;\r\n        x = (maxY - y1) / m + x1;\r\n        if (x > minX && x < maxX) return true;\r\n\r\n        return false;\r\n    }\r\n\r\n    /** Returns true if the axis aligned bounding box intersects the axis aligned bounding box of the specified bounds. */\r\n    aabbIntersectsSkeleton(bounds: SkeletonBoundsBase<BoundingBoxAttachment>) {\r\n        return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;\r\n    }\r\n\r\n    /** Returns the first bounding box attachment that contains the point, or null. When doing many checks, it is usually more\r\n     * efficient to only call this method if {@link #aabbContainsPoint(float, float)} returns true.\r\n     * Cannot be done here because BoundingBoxAttachment is not a thing yet*/\r\n    containsPoint(x: number, y: number): BoundingBoxAttachment | null {\r\n        const polygons = this.polygons;\r\n\r\n        for (let i = 0, n = polygons.length; i < n; i++) {\r\n            if (this.containsPointPolygon(polygons[i], x, y)) return this.boundingBoxes[i];\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /** Returns true if the polygon contains the point. */\r\n    containsPointPolygon(polygon: NumberArrayLike, x: number, y: number) {\r\n        const vertices = polygon;\r\n        const nn = polygon.length;\r\n\r\n        let prevIndex = nn - 2;\r\n        let inside = false;\r\n\r\n        for (let ii = 0; ii < nn; ii += 2) {\r\n            const vertexY = vertices[ii + 1];\r\n            const prevY = vertices[prevIndex + 1];\r\n\r\n            if ((vertexY < y && prevY >= y) || (prevY < y && vertexY >= y)) {\r\n                const vertexX = vertices[ii];\r\n\r\n                if (vertexX + ((y - vertexY) / (prevY - vertexY)) * (vertices[prevIndex] - vertexX) < x) inside = !inside;\r\n            }\r\n            prevIndex = ii;\r\n        }\r\n\r\n        return inside;\r\n    }\r\n\r\n    /** Returns the first bounding box attachment that contains any part of the line segment, or null. When doing many checks, it\r\n     * is usually more efficient to only call this method if {@link #aabbIntersectsSegment()} returns\r\n     * true. */\r\n    intersectsSegment(x1: number, y1: number, x2: number, y2: number) {\r\n        const polygons = this.polygons;\r\n\r\n        for (let i = 0, n = polygons.length; i < n; i++) {\r\n            if (this.intersectsSegmentPolygon(polygons[i], x1, y1, x2, y2)) return this.boundingBoxes[i];\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /** Returns true if the polygon contains any part of the line segment. */\r\n    intersectsSegmentPolygon(polygon: NumberArrayLike, x1: number, y1: number, x2: number, y2: number) {\r\n        const vertices = polygon;\r\n        const nn = polygon.length;\r\n\r\n        const width12 = x1 - x2;\r\n        const height12 = y1 - y2;\r\n        const det1 = x1 * y2 - y1 * x2;\r\n        let x3 = vertices[nn - 2];\r\n        let y3 = vertices[nn - 1];\r\n\r\n        for (let ii = 0; ii < nn; ii += 2) {\r\n            const x4 = vertices[ii];\r\n            const y4 = vertices[ii + 1];\r\n            const det2 = x3 * y4 - y3 * x4;\r\n            const width34 = x3 - x4;\r\n            const height34 = y3 - y4;\r\n            const det3 = width12 * height34 - height12 * width34;\r\n            const x = (det1 * width34 - width12 * det2) / det3;\r\n\r\n            if (((x >= x3 && x <= x4) || (x >= x4 && x <= x3)) && ((x >= x1 && x <= x2) || (x >= x2 && x <= x1))) {\r\n                const y = (det1 * height34 - height12 * det2) / det3;\r\n\r\n                if (((y >= y3 && y <= y4) || (y >= y4 && y <= y3)) && ((y >= y1 && y <= y2) || (y >= y2 && y <= y1))) return true;\r\n            }\r\n            x3 = x4;\r\n            y3 = y4;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /** Returns the polygon for the specified bounding box, or null. */\r\n    getPolygon(boundingBox: BoundingBoxAttachment) {\r\n        if (!boundingBox) throw new Error('boundingBox cannot be null.');\r\n        const index = this.boundingBoxes.indexOf(boundingBox);\r\n\r\n        return index == -1 ? null : this.polygons[index];\r\n    }\r\n\r\n    /** The width of the axis aligned bounding box. */\r\n    getWidth() {\r\n        return this.maxX - this.minX;\r\n    }\r\n\r\n    /** The height of the axis aligned bounding box. */\r\n    getHeight() {\r\n        return this.maxY - this.minY;\r\n    }\r\n}\r\n"],"names":[],"mappings":"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"}