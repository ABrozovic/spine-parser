{"version":3,"file":"SpineBase.js","sources":["../src/SpineBase.ts"],"sourcesContent":["import { AttachmentType } from './core/AttachmentType';\r\nimport { TextureRegion } from './core/TextureRegion';\r\nimport { MathUtils } from './core/Utils';\r\nimport type { IAnimationState, IAnimationStateData } from './core/IAnimation';\r\nimport type { IAttachment, IClippingAttachment, IMeshAttachment, IRegionAttachment, ISkeleton, ISkeletonData, ISlot, IVertexAttachment } from './core/ISkeleton';\r\nimport { DRAW_MODES, Rectangle, Polygon, Transform, Texture, utils } from '@pixi/core';\r\nimport { Container, DisplayObject } from '@pixi/display';\r\nimport { Sprite } from '@pixi/sprite';\r\nimport { SimpleMesh } from '@pixi/mesh-extras';\r\nimport { Graphics } from '@pixi/graphics';\r\nimport { settings } from './settings';\r\nimport type { ISpineDebugRenderer } from './SpineDebugRenderer';\r\n\r\nconst tempRgb = [0, 0, 0];\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface ISpineDisplayObject extends DisplayObject {\r\n    region?: TextureRegion;\r\n    attachment?: IAttachment;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class SpineSprite extends Sprite implements ISpineDisplayObject {\r\n    region?: TextureRegion = null;\r\n    attachment?: IAttachment = null;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class SpineMesh extends SimpleMesh implements ISpineDisplayObject {\r\n    region?: TextureRegion = null;\r\n    attachment?: IAttachment = null;\r\n\r\n    constructor(texture: Texture, vertices?: Float32Array, uvs?: Float32Array, indices?: Uint16Array, drawMode?: number) {\r\n        super(texture, vertices, uvs, indices, drawMode);\r\n    }\r\n}\r\n\r\n/**\r\n * A class that enables the you to import and run your spine animations in pixi.\r\n * The Spine animation data needs to be loaded using either the Loader or a SpineLoader before it can be used by this class\r\n * See example 12 (http://www.goodboydigital.com/pixijs/examples/12/) to see a working example and check out the source\r\n *\r\n * ```js\r\n * let spineAnimation = new spine(spineData);\r\n * ```\r\n *\r\n * @public\r\n * @class\r\n * @extends Container\r\n * @memberof spine\r\n * @param spineData {object} The spine data loaded from a spine atlas.\r\n */\r\nexport abstract class SpineBase<\r\n        Skeleton extends ISkeleton,\r\n        SkeletonData extends ISkeletonData,\r\n        AnimationState extends IAnimationState,\r\n        AnimationStateData extends IAnimationStateData\r\n    >\r\n    extends Container\r\n    implements GlobalMixins.Spine\r\n{\r\n    tintRgb: ArrayLike<number>;\r\n    spineData: SkeletonData;\r\n    skeleton: Skeleton;\r\n    stateData: AnimationStateData;\r\n    state: AnimationState;\r\n    slotContainers: Array<Container>;\r\n    tempClipContainers: Array<Container>;\r\n    localDelayLimit: number;\r\n    private _autoUpdate: boolean;\r\n    protected _visible: boolean;\r\n    private _debug: ISpineDebugRenderer;\r\n    public get debug(): ISpineDebugRenderer {\r\n        return this._debug;\r\n    }\r\n    public set debug(value: ISpineDebugRenderer) {\r\n        if (value == this._debug) {\r\n            // soft equality allows null == undefined\r\n            return;\r\n        }\r\n        this._debug?.unregisterSpine(this);\r\n        value?.registerSpine(this);\r\n        this._debug = value;\r\n    }\r\n\r\n    abstract createSkeleton(spineData: ISkeletonData);\r\n\r\n    constructor(spineData: SkeletonData) {\r\n        super();\r\n\r\n        if (!spineData) {\r\n            throw new Error('The spineData param is required.');\r\n        }\r\n\r\n        if (typeof spineData === 'string') {\r\n            throw new Error('spineData param cant be string. Please use spine.Spine.fromAtlas(\"YOUR_RESOURCE_NAME\") from now on.');\r\n        }\r\n\r\n        /**\r\n         * The spineData object\r\n         *\r\n         * @member {object}\r\n         */\r\n        this.spineData = spineData;\r\n\r\n        /**\r\n         * A spine Skeleton object\r\n         *\r\n         * @member {object}\r\n         */\r\n        this.createSkeleton(spineData);\r\n\r\n        /**\r\n         * An array of containers\r\n         *\r\n         * @member {Container[]}\r\n         */\r\n        this.slotContainers = [];\r\n\r\n        this.tempClipContainers = [];\r\n\r\n        for (let i = 0, n = this.skeleton.slots.length; i < n; i++) {\r\n            const slot = this.skeleton.slots[i];\r\n            const attachment: any = slot.getAttachment();\r\n            const slotContainer = this.newContainer();\r\n\r\n            this.slotContainers.push(slotContainer);\r\n            this.addChild(slotContainer);\r\n            this.tempClipContainers.push(null);\r\n\r\n            if (!attachment) {\r\n                continue;\r\n            }\r\n            if (attachment.type === AttachmentType.Region) {\r\n                const spriteName = attachment.name;\r\n                const sprite = this.createSprite(slot, attachment as IRegionAttachment, spriteName);\r\n\r\n                slot.currentSprite = sprite;\r\n                slot.currentSpriteName = spriteName;\r\n                slotContainer.addChild(sprite);\r\n            } else if (attachment.type === AttachmentType.Mesh) {\r\n                const mesh = this.createMesh(slot, attachment);\r\n\r\n                slot.currentMesh = mesh;\r\n                slot.currentMeshId = attachment.id;\r\n                slot.currentMeshName = attachment.name;\r\n                slotContainer.addChild(mesh);\r\n            } else if (attachment.type === AttachmentType.Clipping) {\r\n                this.createGraphics(slot, attachment);\r\n                slotContainer.addChild(slot.clippingContainer);\r\n                slotContainer.addChild(slot.currentGraphics);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * The tint applied to all spine slots. This is a [r,g,b] value. A value of [1,1,1] will remove any tint effect.\r\n         *\r\n         * @member {number}\r\n         * @memberof spine.Spine#\r\n         */\r\n        this.tintRgb = new Float32Array([1, 1, 1]);\r\n\r\n        this.autoUpdate = true;\r\n        this.visible = true;\r\n    }\r\n\r\n    /**\r\n     * If this flag is set to true, the spine animation will be automatically updated every\r\n     * time the object id drawn. The down side of this approach is that the delta time is\r\n     * automatically calculated and you could miss out on cool effects like slow motion,\r\n     * pause, skip ahead and the sorts. Most of these effects can be achieved even with\r\n     * autoUpdate enabled but are harder to achieve.\r\n     *\r\n     * @member {boolean}\r\n     * @memberof spine.Spine#\r\n     * @default true\r\n     */\r\n    get autoUpdate(): boolean {\r\n        return this._autoUpdate;\r\n    }\r\n\r\n    set autoUpdate(value: boolean) {\r\n        if (value !== this._autoUpdate) {\r\n            this._autoUpdate = value;\r\n            this.updateTransform = value ? SpineBase.prototype.autoUpdateTransform : Container.prototype.updateTransform;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The tint applied to the spine object. This is a hex value. A value of 0xFFFFFF will remove any tint effect.\r\n     *\r\n     * @member {number}\r\n     * @memberof spine.Spine#\r\n     * @default 0xFFFFFF\r\n     */\r\n    get tint(): number {\r\n        return utils.rgb2hex(this.tintRgb as any);\r\n    }\r\n\r\n    set tint(value: number) {\r\n        this.tintRgb = utils.hex2rgb(value, this.tintRgb as any);\r\n    }\r\n\r\n    /**\r\n     * Limit value for the update dt with Spine.globalDelayLimit\r\n     * that can be overridden with localDelayLimit\r\n     * @return {number} - Maximum processed dt value for the update\r\n     */\r\n    get delayLimit(): number {\r\n        const limit = typeof this.localDelayLimit !== 'undefined' ? this.localDelayLimit : settings.GLOBAL_DELAY_LIMIT;\r\n\r\n        // If limit is 0, this means there is no limit for the delay\r\n        return limit || Number.MAX_VALUE;\r\n    }\r\n\r\n    /**\r\n     * Update the spine skeleton and its animations by delta time (dt)\r\n     *\r\n     * @param dt {number} Delta time. Time by which the animation should be updated\r\n     */\r\n    update(dt: number) {\r\n        // Limit delta value to avoid animation jumps\r\n        const delayLimit = this.delayLimit;\r\n\r\n        if (dt > delayLimit) dt = delayLimit;\r\n\r\n        this.state.update(dt);\r\n        this.state.apply(this.skeleton);\r\n\r\n        // check we haven't been destroyed via a spine event callback in state update\r\n        if (!this.skeleton) {\r\n            return;\r\n        }\r\n\r\n        this.skeleton.updateWorldTransform();\r\n\r\n        const slots = this.skeleton.slots;\r\n\r\n        // in case pixi has double tint\r\n        const globalClr = (this as any).color;\r\n        let light: ArrayLike<number> = null;\r\n        let dark: ArrayLike<number> = null;\r\n\r\n        if (globalClr) {\r\n            light = globalClr.light;\r\n            dark = globalClr.dark;\r\n        } else {\r\n            light = this.tintRgb;\r\n        }\r\n\r\n        // let thack = false;\r\n\r\n        for (let i = 0, n = slots.length; i < n; i++) {\r\n            const slot = slots[i];\r\n            const attachment = slot.getAttachment();\r\n            const slotContainer = this.slotContainers[i];\r\n\r\n            if (!attachment) {\r\n                slotContainer.visible = false;\r\n                continue;\r\n            }\r\n\r\n            let spriteColor: any = null;\r\n\r\n            if (attachment.sequence) {\r\n                attachment.sequence.apply(slot, attachment as any);\r\n            }\r\n            let region = (attachment as IRegionAttachment).region;\r\n\r\n            const attColor = (attachment as any).color;\r\n\r\n            switch (attachment != null && attachment.type) {\r\n                case AttachmentType.Region:\r\n                    const transform = slotContainer.transform;\r\n\r\n                    transform.setFromMatrix(slot.bone.matrix);\r\n\r\n                    region = (attachment as IRegionAttachment).region;\r\n                    if (slot.currentMesh) {\r\n                        slot.currentMesh.visible = false;\r\n                        slot.currentMesh = null;\r\n                        slot.currentMeshId = undefined;\r\n                        slot.currentMeshName = undefined;\r\n                    }\r\n                    if (!region) {\r\n                        if (slot.currentSprite) {\r\n                            slot.currentSprite.renderable = false;\r\n                        }\r\n                        break;\r\n                    }\r\n                    if (!slot.currentSpriteName || slot.currentSpriteName !== attachment.name) {\r\n                        const spriteName = attachment.name;\r\n\r\n                        if (slot.currentSprite) {\r\n                            slot.currentSprite.visible = false;\r\n                        }\r\n                        slot.sprites = slot.sprites || {};\r\n                        if (slot.sprites[spriteName] !== undefined) {\r\n                            slot.sprites[spriteName].visible = true;\r\n                        } else {\r\n                            const sprite = this.createSprite(slot, attachment as IRegionAttachment, spriteName);\r\n\r\n                            slotContainer.addChild(sprite);\r\n                        }\r\n                        slot.currentSprite = slot.sprites[spriteName];\r\n                        slot.currentSpriteName = spriteName;\r\n\r\n                        // force sprite update when attachment name is same.\r\n                        // issues https://github.com/pixijs/pixi-spine/issues/318\r\n                    }\r\n                    slot.currentSprite.renderable = true;\r\n                    if (!slot.hackRegion) {\r\n                        this.setSpriteRegion(attachment as IRegionAttachment, slot.currentSprite, region);\r\n                    }\r\n                    if (slot.currentSprite.color) {\r\n                        // YAY! double - tint!\r\n                        spriteColor = slot.currentSprite.color;\r\n                    } else {\r\n                        tempRgb[0] = light[0] * slot.color.r * attColor.r;\r\n                        tempRgb[1] = light[1] * slot.color.g * attColor.g;\r\n                        tempRgb[2] = light[2] * slot.color.b * attColor.b;\r\n                        slot.currentSprite.tint = utils.rgb2hex(tempRgb);\r\n                    }\r\n                    slot.currentSprite.blendMode = slot.blendMode;\r\n                    break;\r\n\r\n                case AttachmentType.Mesh:\r\n                    if (slot.currentSprite) {\r\n                        // TODO: refactor this thing, switch it on and off for container\r\n                        slot.currentSprite.visible = false;\r\n                        slot.currentSprite = null;\r\n                        slot.currentSpriteName = undefined;\r\n\r\n                        // TODO: refactor this shit\r\n                        const transform = new Transform();\r\n\r\n                        (transform as any)._parentID = -1;\r\n                        (transform as any)._worldID = (slotContainer.transform as any)._worldID;\r\n                        slotContainer.transform = transform;\r\n                    }\r\n                    if (!region) {\r\n                        if (slot.currentMesh) {\r\n                            slot.currentMesh.renderable = false;\r\n                        }\r\n                        break;\r\n                    }\r\n\r\n                    const id = (attachment as IVertexAttachment).id;\r\n\r\n                    if (slot.currentMeshId === undefined || slot.currentMeshId !== id) {\r\n                        const meshId = id;\r\n\r\n                        if (slot.currentMesh) {\r\n                            slot.currentMesh.visible = false;\r\n                        }\r\n\r\n                        slot.meshes = slot.meshes || {};\r\n\r\n                        if (slot.meshes[meshId] !== undefined) {\r\n                            slot.meshes[meshId].visible = true;\r\n                        } else {\r\n                            const mesh = this.createMesh(slot, attachment as IMeshAttachment);\r\n\r\n                            slotContainer.addChild(mesh);\r\n                        }\r\n\r\n                        slot.currentMesh = slot.meshes[meshId];\r\n                        slot.currentMeshName = attachment.name;\r\n                        slot.currentMeshId = meshId;\r\n                    }\r\n                    slot.currentMesh.renderable = true;\r\n                    (attachment as IVertexAttachment).computeWorldVerticesOld(slot, slot.currentMesh.vertices);\r\n                    if (slot.currentMesh.color) {\r\n                        // pixi-heaven\r\n                        spriteColor = slot.currentMesh.color;\r\n                    } else {\r\n                        tempRgb[0] = light[0] * slot.color.r * attColor.r;\r\n                        tempRgb[1] = light[1] * slot.color.g * attColor.g;\r\n                        tempRgb[2] = light[2] * slot.color.b * attColor.b;\r\n                        slot.currentMesh.tint = utils.rgb2hex(tempRgb);\r\n                    }\r\n                    slot.currentMesh.blendMode = slot.blendMode;\r\n                    if (!slot.hackRegion) {\r\n                        this.setMeshRegion(attachment as IMeshAttachment, slot.currentMesh, region);\r\n                    }\r\n                    break;\r\n                case AttachmentType.Clipping:\r\n                    if (!slot.currentGraphics) {\r\n                        this.createGraphics(slot, attachment as IClippingAttachment);\r\n                        slotContainer.addChild(slot.clippingContainer);\r\n                        slotContainer.addChild(slot.currentGraphics);\r\n                    }\r\n                    this.updateGraphics(slot, attachment as IClippingAttachment);\r\n                    slotContainer.alpha = 1.0;\r\n                    slotContainer.visible = true;\r\n                    continue;\r\n                default:\r\n                    slotContainer.visible = false;\r\n                    continue;\r\n            }\r\n            slotContainer.visible = true;\r\n\r\n            // pixi has double tint\r\n            if (spriteColor) {\r\n                let r0 = slot.color.r * attColor.r;\r\n                let g0 = slot.color.g * attColor.g;\r\n                let b0 = slot.color.b * attColor.b;\r\n\r\n                // YAY! double-tint!\r\n                spriteColor.setLight(light[0] * r0 + dark[0] * (1.0 - r0), light[1] * g0 + dark[1] * (1.0 - g0), light[2] * b0 + dark[2] * (1.0 - b0));\r\n                if (slot.darkColor) {\r\n                    r0 = slot.darkColor.r;\r\n                    g0 = slot.darkColor.g;\r\n                    b0 = slot.darkColor.b;\r\n                } else {\r\n                    r0 = 0.0;\r\n                    g0 = 0.0;\r\n                    b0 = 0.0;\r\n                }\r\n                spriteColor.setDark(light[0] * r0 + dark[0] * (1 - r0), light[1] * g0 + dark[1] * (1 - g0), light[2] * b0 + dark[2] * (1 - b0));\r\n            }\r\n\r\n            slotContainer.alpha = slot.color.a;\r\n        }\r\n\r\n        // == this is clipping implementation ===\r\n        // TODO: remove parent hacks when pixi masks allow it\r\n        const drawOrder = this.skeleton.drawOrder;\r\n        let clippingAttachment: IClippingAttachment = null;\r\n        let clippingContainer: Container = null;\r\n\r\n        for (let i = 0, n = drawOrder.length; i < n; i++) {\r\n            const slot = slots[drawOrder[i].data.index];\r\n            const slotContainer = this.slotContainers[drawOrder[i].data.index];\r\n\r\n            if (!clippingContainer) {\r\n                // Adding null check as it is possible for slotContainer.parent to be null in the event of a spine being disposed off in its loop callback\r\n                if (slotContainer.parent !== null && slotContainer.parent !== this) {\r\n                    slotContainer.parent.removeChild(slotContainer);\r\n                    // silend add hack\r\n                    (slotContainer as any).parent = this;\r\n                }\r\n            }\r\n            if (slot.currentGraphics && slot.getAttachment()) {\r\n                clippingContainer = slot.clippingContainer;\r\n                clippingAttachment = slot.getAttachment() as IClippingAttachment;\r\n                clippingContainer.children.length = 0;\r\n                this.children[i] = slotContainer;\r\n\r\n                if (clippingAttachment.endSlot === slot.data) {\r\n                    clippingAttachment.endSlot = null;\r\n                }\r\n            } else if (clippingContainer) {\r\n                let c = this.tempClipContainers[i];\r\n\r\n                if (!c) {\r\n                    c = this.tempClipContainers[i] = this.newContainer();\r\n                    c.visible = false;\r\n                }\r\n                this.children[i] = c;\r\n\r\n                // silent remove hack\r\n                (slotContainer as any).parent = null;\r\n                clippingContainer.addChild(slotContainer);\r\n                if (clippingAttachment.endSlot == slot.data) {\r\n                    clippingContainer.renderable = true;\r\n                    clippingContainer = null;\r\n                    clippingAttachment = null;\r\n                }\r\n            } else {\r\n                this.children[i] = slotContainer;\r\n            }\r\n        }\r\n\r\n        // if you can debug, then debug!\r\n        this._debug?.renderDebug(this);\r\n    }\r\n\r\n    private setSpriteRegion(attachment: IRegionAttachment, sprite: SpineSprite, region: TextureRegion) {\r\n        // prevent setters calling when attachment and region is same\r\n        if (sprite.attachment === attachment && sprite.region === region) {\r\n            return;\r\n        }\r\n\r\n        sprite.region = region;\r\n        sprite.attachment = attachment;\r\n\r\n        sprite.texture = region.texture;\r\n        sprite.rotation = attachment.rotation * MathUtils.degRad;\r\n        sprite.position.x = attachment.x;\r\n        sprite.position.y = attachment.y;\r\n        sprite.alpha = attachment.color.a;\r\n\r\n        if (!region.size) {\r\n            sprite.scale.x = (attachment.scaleX * attachment.width) / region.originalWidth;\r\n            sprite.scale.y = (-attachment.scaleY * attachment.height) / region.originalHeight;\r\n        } else {\r\n            // hacked!\r\n            sprite.scale.x = region.size.width / region.originalWidth;\r\n            sprite.scale.y = -region.size.height / region.originalHeight;\r\n        }\r\n    }\r\n\r\n    private setMeshRegion(attachment: IMeshAttachment, mesh: SpineMesh, region: TextureRegion) {\r\n        if (mesh.attachment === attachment && mesh.region === region) {\r\n            return;\r\n        }\r\n\r\n        mesh.region = region;\r\n        mesh.attachment = attachment;\r\n        mesh.texture = region.texture;\r\n        region.texture.updateUvs();\r\n        mesh.uvBuffer.update(attachment.regionUVs);\r\n    }\r\n\r\n    protected lastTime: number;\r\n\r\n    /**\r\n     * When autoupdate is set to yes this function is used as pixi's updateTransform function\r\n     *\r\n     * @private\r\n     */\r\n    autoUpdateTransform() {\r\n        if (settings.GLOBAL_AUTO_UPDATE) {\r\n            this.lastTime = this.lastTime || Date.now();\r\n            const timeDelta = (Date.now() - this.lastTime) * 0.001;\r\n\r\n            this.lastTime = Date.now();\r\n            this.update(timeDelta);\r\n        } else {\r\n            this.lastTime = 0;\r\n        }\r\n\r\n        Container.prototype.updateTransform.call(this);\r\n    }\r\n\r\n    /**\r\n     * Create a new sprite to be used with core.RegionAttachment\r\n     *\r\n     * @param slot {spine.Slot} The slot to which the attachment is parented\r\n     * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\r\n     * @private\r\n     */\r\n    createSprite(slot: ISlot, attachment: IRegionAttachment, defName: string) {\r\n        let region = attachment.region;\r\n\r\n        if (slot.hackAttachment === attachment) {\r\n            region = slot.hackRegion;\r\n        }\r\n        const texture = region ? region.texture : null;\r\n        const sprite = this.newSprite(texture);\r\n\r\n        sprite.anchor.set(0.5);\r\n        if (region) {\r\n            this.setSpriteRegion(attachment, sprite, attachment.region);\r\n        }\r\n\r\n        slot.sprites = slot.sprites || {};\r\n        slot.sprites[defName] = sprite;\r\n\r\n        return sprite;\r\n    }\r\n\r\n    /**\r\n     * Creates a Strip from the spine data\r\n     * @param slot {spine.Slot} The slot to which the attachment is parented\r\n     * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\r\n     * @private\r\n     */\r\n    createMesh(slot: ISlot, attachment: IMeshAttachment) {\r\n        let region = attachment.region;\r\n\r\n        if (slot.hackAttachment === attachment) {\r\n            region = slot.hackRegion;\r\n            slot.hackAttachment = null;\r\n            slot.hackRegion = null;\r\n        }\r\n        const strip = this.newMesh(\r\n            region ? region.texture : null,\r\n            new Float32Array(attachment.regionUVs.length),\r\n            attachment.regionUVs,\r\n            new Uint16Array(attachment.triangles),\r\n            DRAW_MODES.TRIANGLES\r\n        );\r\n\r\n        if (typeof (strip as any)._canvasPadding !== 'undefined') {\r\n            (strip as any)._canvasPadding = 1.5;\r\n        }\r\n\r\n        strip.alpha = attachment.color.a;\r\n\r\n        strip.region = attachment.region;\r\n        if (region) {\r\n            this.setMeshRegion(attachment, strip, region);\r\n        }\r\n\r\n        slot.meshes = slot.meshes || {};\r\n        slot.meshes[attachment.id] = strip;\r\n\r\n        return strip;\r\n    }\r\n\r\n    static clippingPolygon: Array<number> = [];\r\n\r\n    // @ts-ignore\r\n    createGraphics(slot: ISlot, clip: IClippingAttachment) {\r\n        const graphics = this.newGraphics();\r\n        const poly = new Polygon([]);\r\n\r\n        graphics.clear();\r\n        graphics.beginFill(0xffffff, 1);\r\n        graphics.drawPolygon(poly as any);\r\n        graphics.renderable = false;\r\n        slot.currentGraphics = graphics;\r\n        slot.clippingContainer = this.newContainer();\r\n        slot.clippingContainer.mask = slot.currentGraphics;\r\n\r\n        return graphics;\r\n    }\r\n\r\n    updateGraphics(slot: ISlot, clip: IClippingAttachment) {\r\n        const geom = slot.currentGraphics.geometry;\r\n        const vertices = (geom.graphicsData[0].shape as Polygon).points;\r\n        const n = clip.worldVerticesLength;\r\n\r\n        vertices.length = n;\r\n        clip.computeWorldVertices(slot, 0, n, vertices, 0, 2);\r\n        geom.invalidate();\r\n    }\r\n\r\n    /**\r\n     * Changes texture in attachment in specific slot.\r\n     *\r\n     * PIXI runtime feature, it was made to satisfy our users.\r\n     *\r\n     * @param slotIndex {number}\r\n     * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\r\n     * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\r\n     * @returns {boolean} Success flag\r\n     */\r\n    hackTextureBySlotIndex(slotIndex: number, texture: Texture = null, size: Rectangle = null) {\r\n        const slot = this.skeleton.slots[slotIndex];\r\n\r\n        if (!slot) {\r\n            return false;\r\n        }\r\n        const attachment: any = slot.getAttachment();\r\n        let region: TextureRegion = attachment.region;\r\n\r\n        if (texture) {\r\n            region = new TextureRegion();\r\n            region.texture = texture;\r\n            region.size = size;\r\n            slot.hackRegion = region;\r\n            slot.hackAttachment = attachment;\r\n        } else {\r\n            slot.hackRegion = null;\r\n            slot.hackAttachment = null;\r\n        }\r\n        if (slot.currentSprite) {\r\n            this.setSpriteRegion(attachment, slot.currentSprite, region);\r\n        } else if (slot.currentMesh) {\r\n            this.setMeshRegion(attachment, slot.currentMesh, region);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Changes texture in attachment in specific slot.\r\n     *\r\n     * PIXI runtime feature, it was made to satisfy our users.\r\n     *\r\n     * @param slotName {string}\r\n     * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\r\n     * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\r\n     * @returns {boolean} Success flag\r\n     */\r\n    hackTextureBySlotName(slotName: string, texture: Texture = null, size: Rectangle = null) {\r\n        const index = this.skeleton.findSlotIndex(slotName);\r\n\r\n        if (index == -1) {\r\n            return false;\r\n        }\r\n\r\n        return this.hackTextureBySlotIndex(index, texture, size);\r\n    }\r\n\r\n    /**\r\n     * Changes texture of an attachment\r\n     *\r\n     * PIXI runtime feature, it was made to satisfy our users.\r\n     *\r\n     * @param slotName {string}\r\n     * @param attachmentName {string}\r\n     * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\r\n     * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\r\n     * @returns {boolean} Success flag\r\n     */\r\n    hackTextureAttachment(slotName: string, attachmentName: string, texture, size: Rectangle = null) {\r\n        // changes the texture of an attachment at the skeleton level\r\n        const slotIndex = this.skeleton.findSlotIndex(slotName);\r\n        const attachment: any = this.skeleton.getAttachmentByName(slotName, attachmentName);\r\n\r\n        attachment.region.texture = texture;\r\n\r\n        const slot = this.skeleton.slots[slotIndex];\r\n\r\n        if (!slot) {\r\n            return false;\r\n        }\r\n\r\n        // gets the currently active attachment in this slot\r\n        const currentAttachment: any = slot.getAttachment();\r\n\r\n        if (attachmentName === currentAttachment.name) {\r\n            // if the attachment we are changing is currently active, change the the live texture\r\n            let region: TextureRegion = attachment.region;\r\n\r\n            if (texture) {\r\n                region = new TextureRegion();\r\n                region.texture = texture;\r\n                region.size = size;\r\n                slot.hackRegion = region;\r\n                slot.hackAttachment = currentAttachment;\r\n            } else {\r\n                slot.hackRegion = null;\r\n                slot.hackAttachment = null;\r\n            }\r\n            if (slot.currentSprite && slot.currentSprite.region != region) {\r\n                this.setSpriteRegion(currentAttachment, slot.currentSprite, region);\r\n                slot.currentSprite.region = region;\r\n            } else if (slot.currentMesh && slot.currentMesh.region != region) {\r\n                this.setMeshRegion(currentAttachment, slot.currentMesh, region);\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    // those methods can be overriden to spawn different classes\r\n    newContainer() {\r\n        return new Container();\r\n    }\r\n\r\n    newSprite(tex: Texture) {\r\n        return new SpineSprite(tex);\r\n    }\r\n\r\n    newGraphics() {\r\n        return new Graphics();\r\n    }\r\n\r\n    newMesh(texture: Texture, vertices?: Float32Array, uvs?: Float32Array, indices?: Uint16Array, drawMode?: number) {\r\n        return new SpineMesh(texture, vertices, uvs, indices, drawMode);\r\n    }\r\n\r\n    transformHack() {\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n     * Hack for pixi-display and pixi-lights. Every attachment name ending with a suffix will be added to different layer\r\n     * @param nameSuffix\r\n     * @param group\r\n     * @param outGroup\r\n     */\r\n    hackAttachmentGroups(nameSuffix: string, group: any, outGroup: any) {\r\n        if (!nameSuffix) {\r\n            return undefined;\r\n        }\r\n        const list_d = [];\r\n        const list_n = [];\r\n\r\n        for (let i = 0, len = this.skeleton.slots.length; i < len; i++) {\r\n            const slot = this.skeleton.slots[i];\r\n            const name = slot.currentSpriteName || slot.currentMeshName || '';\r\n            const target = slot.currentSprite || slot.currentMesh;\r\n\r\n            if (name.endsWith(nameSuffix)) {\r\n                target.parentGroup = group;\r\n                list_n.push(target);\r\n            } else if (outGroup && target) {\r\n                target.parentGroup = outGroup;\r\n                list_d.push(target);\r\n            }\r\n        }\r\n\r\n        return [list_d, list_n];\r\n    }\r\n\r\n    destroy(options?: any): void {\r\n        this.debug = null; // setter will do the cleanup\r\n\r\n        for (let i = 0, n = this.skeleton.slots.length; i < n; i++) {\r\n            const slot = this.skeleton.slots[i];\r\n\r\n            for (const name in slot.meshes) {\r\n                slot.meshes[name].destroy(options);\r\n            }\r\n            slot.meshes = null;\r\n\r\n            for (const name in slot.sprites) {\r\n                slot.sprites[name].destroy(options);\r\n            }\r\n            slot.sprites = null;\r\n        }\r\n\r\n        for (let i = 0, n = this.slotContainers.length; i < n; i++) {\r\n            this.slotContainers[i].destroy(options);\r\n        }\r\n        this.spineData = null;\r\n        this.skeleton = null;\r\n        this.slotContainers = null;\r\n        this.stateData = null;\r\n        this.state = null;\r\n        this.tempClipContainers = null;\r\n\r\n        super.destroy(options);\r\n    }\r\n}\r\n\r\n/**\r\n * The visibility of the spine object. If false the object will not be drawn,\r\n * the updateTransform function will not be called, and the spine will not be automatically updated.\r\n *\r\n * @member {boolean}\r\n * @memberof spine.Spine#\r\n * @default true\r\n */\r\nObject.defineProperty(SpineBase.prototype, 'visible', {\r\n    get() {\r\n        return this._visible;\r\n    },\r\n    set(value: boolean) {\r\n        if (value !== this._visible) {\r\n            this._visible = value;\r\n            if (value) {\r\n                this.lastTime = 0;\r\n            }\r\n        }\r\n    },\r\n});\r\n"],"names":["Sprite","SimpleMesh","Container","AttachmentType","utils","settings","transform","Transform","MathUtils","DRAW_MODES","Polygon","TextureRegion","Graphics"],"mappings":"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"}