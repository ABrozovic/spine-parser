{"version":3,"file":"base.mjs","sources":["../src/core/AttachmentType.ts","../src/core/BinaryInput.ts","../src/core/IAnimation.ts","../src/core/IConstraint.ts","../src/core/ISkeleton.ts","../src/core/TextureRegion.ts","../src/core/TextureAtlas.ts","../src/core/Utils.ts","../src/core/SkeletonBoundsBase.ts","../src/settings.ts","../src/SpineBase.ts","../src/SpineDebugRenderer.ts"],"sourcesContent":["/**\r\n * @public\r\n */\r\nexport enum AttachmentType {\r\n    Region,\r\n    BoundingBox,\r\n    Mesh,\r\n    LinkedMesh,\r\n    Path,\r\n    Point,\r\n    Clipping,\r\n}\r\n","/**\r\n * @public\r\n */\r\nexport class BinaryInput {\r\n    constructor(data: Uint8Array, public strings = new Array<string>(), private index: number = 0, private buffer = new DataView(data.buffer)) {}\r\n\r\n    readByte(): number {\r\n        return this.buffer.getInt8(this.index++);\r\n    }\r\n\r\n    readUnsignedByte(): number {\r\n        return this.buffer.getUint8(this.index++);\r\n    }\r\n\r\n    readShort(): number {\r\n        const value = this.buffer.getInt16(this.index);\r\n\r\n        this.index += 2;\r\n\r\n        return value;\r\n    }\r\n\r\n    readInt32(): number {\r\n        const value = this.buffer.getInt32(this.index);\r\n\r\n        this.index += 4;\r\n\r\n        return value;\r\n    }\r\n\r\n    readInt(optimizePositive: boolean) {\r\n        let b = this.readByte();\r\n        let result = b & 0x7f;\r\n\r\n        if ((b & 0x80) != 0) {\r\n            b = this.readByte();\r\n            result |= (b & 0x7f) << 7;\r\n            if ((b & 0x80) != 0) {\r\n                b = this.readByte();\r\n                result |= (b & 0x7f) << 14;\r\n                if ((b & 0x80) != 0) {\r\n                    b = this.readByte();\r\n                    result |= (b & 0x7f) << 21;\r\n                    if ((b & 0x80) != 0) {\r\n                        b = this.readByte();\r\n                        result |= (b & 0x7f) << 28;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return optimizePositive ? result : (result >>> 1) ^ -(result & 1);\r\n    }\r\n\r\n    readStringRef(): string | null {\r\n        const index = this.readInt(true);\r\n\r\n        return index == 0 ? null : this.strings[index - 1];\r\n    }\r\n\r\n    readString(): string | null {\r\n        let byteCount = this.readInt(true);\r\n\r\n        switch (byteCount) {\r\n            case 0:\r\n                return null;\r\n            case 1:\r\n                return '';\r\n        }\r\n        byteCount--;\r\n        let chars = '';\r\n\r\n        for (let i = 0; i < byteCount; ) {\r\n            const b = this.readUnsignedByte();\r\n\r\n            switch (b >> 4) {\r\n                case 12:\r\n                case 13:\r\n                    chars += String.fromCharCode(((b & 0x1f) << 6) | (this.readByte() & 0x3f));\r\n                    i += 2;\r\n                    break;\r\n                case 14:\r\n                    chars += String.fromCharCode(((b & 0x0f) << 12) | ((this.readByte() & 0x3f) << 6) | (this.readByte() & 0x3f));\r\n                    i += 3;\r\n                    break;\r\n                default:\r\n                    chars += String.fromCharCode(b);\r\n                    i++;\r\n            }\r\n        }\r\n\r\n        return chars;\r\n    }\r\n\r\n    readFloat(): number {\r\n        const value = this.buffer.getFloat32(this.index);\r\n\r\n        this.index += 4;\r\n\r\n        return value;\r\n    }\r\n\r\n    readBoolean(): boolean {\r\n        return this.readByte() != 0;\r\n    }\r\n}\r\n","import type { ISkeleton, ISkeletonData } from './ISkeleton';\r\nimport type { Map } from './Utils';\r\n\r\n// Those enums were moved from Animation.ts of spine 3.8 and 4.0\r\n\r\n/** Controls how a timeline value is mixed with the setup pose value or current pose value when a timeline's `alpha`\r\n * < 1.\r\n *\r\n * See Timeline {@link Timeline#apply(Skeleton, float, float, Array, float, MixBlend, MixDirection)}.\r\n * @public\r\n * */\r\nexport enum MixBlend {\r\n    /** Transitions from the setup value to the timeline value (the current value is not used). Before the first key, the setup\r\n     * value is set. */\r\n    setup,\r\n    /** Transitions from the current value to the timeline value. Before the first key, transitions from the current value to\r\n     * the setup value. Timelines which perform instant transitions, such as DrawOrderTimeline or\r\n     * AttachmentTimeline, use the setup value before the first key.\r\n     *\r\n     * `first` is intended for the first animations applied, not for animations layered on top of those. */\r\n    first,\r\n    /** Transitions from the current value to the timeline value. No change is made before the first key (the current value is\r\n     * kept until the first key).\r\n     *\r\n     * `replace` is intended for animations layered on top of others, not for the first animations applied. */\r\n    replace,\r\n    /** Transitions from the current value to the current value plus the timeline value. No change is made before the first key\r\n     * (the current value is kept until the first key).\r\n     *\r\n     * `add` is intended for animations layered on top of others, not for the first animations applied. Properties\r\n     * keyed by additive animations must be set manually or by another animation before applying the additive animations, else\r\n     * the property values will increase continually. */\r\n    add,\r\n}\r\n\r\n/** Indicates whether a timeline's `alpha` is mixing out over time toward 0 (the setup or current pose value) or\r\n * mixing in toward 1 (the timeline's value).\r\n *\r\n * See Timeline {@link Timeline#apply(Skeleton, float, float, Array, float, MixBlend, MixDirection)}.\r\n * @public\r\n * */\r\nexport enum MixDirection {\r\n    mixIn,\r\n    mixOut,\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface IAnimation<Timeline extends ITimeline = ITimeline> {\r\n    name: string;\r\n    timelines: Timeline[];\r\n    duration: number;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface IAnimationState<AnimationStateData extends IAnimationStateData = IAnimationStateData> {\r\n    data: AnimationStateData;\r\n    tracks: ITrackEntry[];\r\n    listeners: IAnimationStateListener[];\r\n    timeScale: number;\r\n\r\n    update(dt: number): void;\r\n    apply(skeleton: ISkeleton): boolean;\r\n\r\n    setAnimation(trackIndex: number, animationName: string, loop: boolean): ITrackEntry;\r\n    addAnimation(trackIndex: number, animationName: string, loop: boolean, delay: number): ITrackEntry;\r\n    addEmptyAnimation(trackIndex: number, mixDuration: number, delay: number): ITrackEntry;\r\n    setEmptyAnimation(trackIndex: number, mixDuration: number): ITrackEntry;\r\n    setEmptyAnimations(mixDuration: number): void;\r\n    hasAnimation(animationName: string): boolean;\r\n    addListener(listener: IAnimationStateListener): void;\r\n    removeListener(listener: IAnimationStateListener): void;\r\n    clearListeners(): void;\r\n    clearTracks(): void;\r\n    clearTrack(index: number): void;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface IAnimationStateData<SkeletonData extends ISkeletonData = ISkeletonData, Animation extends IAnimation = IAnimation> {\r\n    skeletonData: SkeletonData;\r\n    animationToMixTime: Map<number>;\r\n    defaultMix: number;\r\n    setMix(fromName: string, toName: string, duration: number): void;\r\n    setMixWith(from: Animation, to: Animation, duration: number): void;\r\n    getMix(from: Animation, to: Animation): number;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface IAnimationStateListener {\r\n    start?(entry: ITrackEntry): void;\r\n    interrupt?(entry: ITrackEntry): void;\r\n    end?(entry: ITrackEntry): void;\r\n    dispose?(entry: ITrackEntry): void;\r\n    complete?(entry: ITrackEntry): void;\r\n    event?(entry: ITrackEntry, event: IEvent): void;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface ITimeline {}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface ITrackEntry {\r\n    trackIndex: number;\r\n    loop: boolean;\r\n    animationEnd: number;\r\n    listener: IAnimationStateListener;\r\n\r\n    delay: number;\r\n    trackTime: number;\r\n    trackLast: number;\r\n    nextTrackLast: number;\r\n    trackEnd: number;\r\n    timeScale: number;\r\n    alpha: number;\r\n    mixTime: number;\r\n    mixDuration: number;\r\n    interruptAlpha: number;\r\n    totalAlpha: number;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface IEventData {\r\n    name: string;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface IEvent {\r\n    time: number;\r\n    data: IEventData;\r\n}\r\n","// These enums were moved from PathConstraintData.ts of spine 3.7, 3.8 and 4.0\r\n\r\n/** Controls how the first bone is positioned along the path.\r\n *\r\n * See [Position mode](http://esotericsoftware.com/spine-path-constraints#Position-mode) in the Spine User Guide.\r\n * @public\r\n * */\r\nexport enum PositionMode {\r\n    Fixed,\r\n    Percent,\r\n}\r\n\r\n/** Controls how bones are rotated, translated, and scaled to match the path.\r\n *\r\n * [Rotate mode](http://esotericsoftware.com/spine-path-constraints#Rotate-mod) in the Spine User Guide.\r\n * @public\r\n * */\r\nexport enum RotateMode {\r\n    Tangent,\r\n    Chain,\r\n    ChainScale,\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface IConstraintData {\r\n    name: string;\r\n    order: number;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface IIkConstraint {\r\n    data: IIkConstraintData;\r\n    /** -1 | 0 | 1 */\r\n    bendDirection: number;\r\n    compress: boolean;\r\n    stretch: boolean;\r\n\r\n    /** A percentage (0-1) */\r\n    mix: number;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface IIkConstraintData extends IConstraintData {\r\n    /** -1 | 0 | 1 */\r\n    bendDirection: number;\r\n    compress: boolean;\r\n    stretch: boolean;\r\n    uniform: boolean;\r\n\r\n    /** A percentage (0-1) */\r\n    mix: number;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface IPathConstraint {\r\n    data: IPathConstraintData;\r\n    position: number;\r\n    spacing: number;\r\n\r\n    spaces: number[];\r\n    positions: number[];\r\n    world: number[];\r\n    curves: number[];\r\n    lengths: number[];\r\n    segments: number[];\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface IPathConstraintData extends IConstraintData {\r\n    positionMode: PositionMode;\r\n    rotateMode: RotateMode;\r\n    offsetRotation: number;\r\n    position: number;\r\n    spacing: number;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface ITransformConstraint {\r\n    data: ITransformConstraintData;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface ITransformConstraintData extends IConstraintData {\r\n    offsetRotation: number;\r\n    offsetX: number;\r\n    offsetY: number;\r\n    offsetScaleX: number;\r\n    offsetScaleY: number;\r\n    offsetShearY: number;\r\n    relative: boolean;\r\n    local: boolean;\r\n}\r\n","import type { AttachmentType } from './AttachmentType';\r\nimport type { IAnimation, IEventData } from './IAnimation';\r\nimport type { IIkConstraintData, IPathConstraintData, ITransformConstraintData } from './IConstraint';\r\nimport type { Color, Vector2, Map } from './Utils';\r\nimport type { TextureRegion } from './TextureRegion';\r\nimport type { BLEND_MODES, Matrix } from '@pixi/core';\r\n\r\n// This enum was moved from BoneData.ts of spine 3.7, 3.8 and 4.0\r\n\r\n/** Determines how a bone inherits world transforms from parent bones.\r\n * @public\r\n * */\r\nexport enum TransformMode {\r\n    Normal,\r\n    OnlyTranslation,\r\n    NoRotationOrReflection,\r\n    NoScale,\r\n    NoScaleOrReflection,\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface IBone {\r\n    data: IBoneData;\r\n    matrix: Matrix;\r\n    active: boolean;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface ISkin {\r\n    name: string;\r\n    attachments: Array<Map<IAttachment>>;\r\n\r\n    getAttachment(slotIndex: number, name: string): IAttachment | null;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface IAttachment {\r\n    name: string;\r\n    type: AttachmentType;\r\n    readonly sequence?: ISequence;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface IHasTextureRegion {\r\n    /** The name used to find the {@link #region()}. */\r\n    path: string;\r\n\r\n    /** The region used to draw the attachment. After setting the region or if the region's properties are changed,\r\n     * {@link #updateRegion()} must be called. */\r\n    region: TextureRegion | null;\r\n\r\n    /** Updates any values the attachment calculates using the {@link #getRegion()}. Must be called after setting the\r\n     * {@link #getRegion()} or if the region's properties are changed. */\r\n    // updateRegion (): void;\r\n\r\n    /** The color to tint the attachment. */\r\n    color: Color;\r\n\r\n    readonly sequence: ISequence | null;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface ISequence {\r\n    id: number;\r\n    regions: TextureRegion[];\r\n    apply(slot: ISlot, attachment: IHasTextureRegion): void;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface IVertexAttachment<Slot extends ISlot = ISlot> extends IAttachment {\r\n    id: number;\r\n    computeWorldVerticesOld(slot: Slot, worldVertices: ArrayLike<number>): void;\r\n    computeWorldVertices(slot: Slot, start: number, count: number, worldVertices: ArrayLike<number>, offset: number, stride: number): void;\r\n    worldVerticesLength: number;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface IClippingAttachment extends IVertexAttachment {\r\n    endSlot?: ISlotData;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface IRegionAttachment extends IAttachment {\r\n    region: TextureRegion;\r\n    color: Color;\r\n    x;\r\n    y;\r\n    scaleX;\r\n    scaleY;\r\n    rotation;\r\n    width;\r\n    height: number;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface IMeshAttachment extends IVertexAttachment {\r\n    region: TextureRegion;\r\n    color: Color;\r\n    regionUVs: Float32Array;\r\n    triangles: number[];\r\n    hullLength: number;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface ISlotData {\r\n    index: number;\r\n    name: string;\r\n    boneData: IBoneData;\r\n    color: Color;\r\n    darkColor: Color;\r\n    attachmentName: string;\r\n    blendMode: BLEND_MODES;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface IBoneData {\r\n    index: number;\r\n    name: string;\r\n    parent: IBoneData;\r\n    length: number;\r\n    x: number;\r\n    y: number;\r\n    rotation: number;\r\n    scaleX: number;\r\n    scaleY: number;\r\n    shearX: number;\r\n    shearY: number;\r\n    transformMode: TransformMode;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface ISlot {\r\n    getAttachment(): IAttachment;\r\n    data: ISlotData;\r\n    color: Color;\r\n    darkColor: Color;\r\n    blendMode: number;\r\n    bone: IBone;\r\n\r\n    sprites?: any;\r\n    currentSprite?: any;\r\n    currentSpriteName?: string;\r\n\r\n    meshes?: any;\r\n    currentMesh?: any;\r\n    currentMeshName?: string;\r\n    currentMeshId?: number;\r\n\r\n    currentGraphics?: any;\r\n    clippingContainer?: any;\r\n\r\n    hackRegion?: TextureRegion;\r\n    hackAttachment?: IAttachment;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface ISkeleton<SkeletonData extends ISkeletonData = ISkeletonData, Bone extends IBone = IBone, Slot extends ISlot = ISlot, Skin extends ISkin = ISkin> {\r\n    bones: Bone[];\r\n    slots: Slot[];\r\n    drawOrder: Slot[];\r\n    skin: Skin;\r\n    data: SkeletonData;\r\n    x: number; // added for debug purposes\r\n    y: number; // added for debug purposes\r\n    updateWorldTransform(): void;\r\n    setToSetupPose(): void;\r\n    findSlotIndex(slotName: string): number;\r\n    getAttachmentByName(slotName: string, attachmentName: string): IAttachment;\r\n\r\n    setBonesToSetupPose(): void;\r\n    setSlotsToSetupPose(): void;\r\n    findBone(boneName: string): Bone;\r\n    findSlot(slotName: string): Slot;\r\n    findBoneIndex(boneName: string): number;\r\n    findSlotIndex(slotName: string): number;\r\n    setSkinByName(skinName: string): void;\r\n    setAttachment(slotName: string, attachmentName: string): void;\r\n    getBounds(offset: Vector2, size: Vector2, temp: Array<number>): void;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface ISkeletonParser {\r\n    scale: number;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface ISkeletonData<\r\n    BoneData extends IBoneData = IBoneData,\r\n    SlotData extends ISlotData = ISlotData,\r\n    Skin extends ISkin = ISkin,\r\n    Animation extends IAnimation = IAnimation,\r\n    EventData extends IEventData = IEventData,\r\n    IkConstraintData extends IIkConstraintData = IIkConstraintData,\r\n    TransformConstraintData extends ITransformConstraintData = ITransformConstraintData,\r\n    PathConstraintData extends IPathConstraintData = IPathConstraintData\r\n> {\r\n    name: string;\r\n    bones: BoneData[];\r\n    slots: SlotData[];\r\n    skins: Skin[];\r\n    defaultSkin: Skin;\r\n    events: EventData[];\r\n    animations: Animation[];\r\n    version: string;\r\n    hash: string;\r\n    width: number;\r\n    height: number;\r\n    ikConstraints: IkConstraintData[];\r\n    transformConstraints: TransformConstraintData[];\r\n    pathConstraints: PathConstraintData[];\r\n\r\n    findBone(boneName: string): BoneData | null;\r\n    findBoneIndex(boneName: string): number;\r\n    findSlot(slotName: string): SlotData | null;\r\n    findSlotIndex(slotName: string): number;\r\n    findSkin(skinName: string): Skin | null;\r\n\r\n    findEvent(eventDataName: string): EventData | null;\r\n    findAnimation(animationName: string): Animation | null;\r\n    findIkConstraint(constraintName: string): IkConstraintData | null;\r\n    findTransformConstraint(constraintName: string): TransformConstraintData | null;\r\n    findPathConstraint(constraintName: string): PathConstraintData | null;\r\n}\r\n","import type { Texture, Rectangle } from '@pixi/core';\r\n\r\n/**\r\n * @public\r\n */\r\nexport function filterFromString(text: string): TextureFilter {\r\n    switch (text.toLowerCase()) {\r\n        case 'nearest':\r\n            return TextureFilter.Nearest;\r\n        case 'linear':\r\n            return TextureFilter.Linear;\r\n        case 'mipmap':\r\n            return TextureFilter.MipMap;\r\n        case 'mipmapnearestnearest':\r\n            return TextureFilter.MipMapNearestNearest;\r\n        case 'mipmaplinearnearest':\r\n            return TextureFilter.MipMapLinearNearest;\r\n        case 'mipmapnearestlinear':\r\n            return TextureFilter.MipMapNearestLinear;\r\n        case 'mipmaplinearlinear':\r\n            return TextureFilter.MipMapLinearLinear;\r\n        default:\r\n            throw new Error(`Unknown texture filter ${text}`);\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport function wrapFromString(text: string): TextureWrap {\r\n    switch (text.toLowerCase()) {\r\n        case 'mirroredtepeat':\r\n            return TextureWrap.MirroredRepeat;\r\n        case 'clamptoedge':\r\n            return TextureWrap.ClampToEdge;\r\n        case 'repeat':\r\n            return TextureWrap.Repeat;\r\n        default:\r\n            throw new Error(`Unknown texture wrap ${text}`);\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport enum TextureFilter {\r\n    Nearest = 9728, // WebGLRenderingContext.NEAREST\r\n    Linear = 9729, // WebGLRenderingContext.LINEAR\r\n    MipMap = 9987, // WebGLRenderingContext.LINEAR_MIPMAP_LINEAR\r\n    MipMapNearestNearest = 9984, // WebGLRenderingContext.NEAREST_MIPMAP_NEAREST\r\n    MipMapLinearNearest = 9985, // WebGLRenderingContext.LINEAR_MIPMAP_NEAREST\r\n    MipMapNearestLinear = 9986, // WebGLRenderingContext.NEAREST_MIPMAP_LINEAR\r\n    MipMapLinearLinear = 9987, // WebGLRenderingContext.LINEAR_MIPMAP_LINEAR\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport enum TextureWrap {\r\n    MirroredRepeat = 33648, // WebGLRenderingContext.MIRRORED_REPEAT\r\n    ClampToEdge = 33071, // WebGLRenderingContext.CLAMP_TO_EDGE\r\n    Repeat = 10497, // WebGLRenderingContext.REPEAT\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class TextureRegion {\r\n    texture: Texture;\r\n\r\n    // thats for overrides\r\n    size: Rectangle = null;\r\n\r\n    names: string[] = null;\r\n    values: number[][] = null;\r\n\r\n    renderObject: any = null;\r\n\r\n    get width(): number {\r\n        const tex = this.texture;\r\n\r\n        if (tex.trim) {\r\n            return tex.trim.width;\r\n        }\r\n\r\n        return tex.orig.width;\r\n    }\r\n\r\n    get height(): number {\r\n        const tex = this.texture;\r\n\r\n        if (tex.trim) {\r\n            return tex.trim.height;\r\n        }\r\n\r\n        return tex.orig.height;\r\n    }\r\n\r\n    get u(): number {\r\n        return (this.texture as any)._uvs.x0;\r\n    }\r\n\r\n    get v(): number {\r\n        return (this.texture as any)._uvs.y0;\r\n    }\r\n\r\n    get u2(): number {\r\n        return (this.texture as any)._uvs.x2;\r\n    }\r\n\r\n    get v2(): number {\r\n        return (this.texture as any)._uvs.y2;\r\n    }\r\n\r\n    get offsetX(): number {\r\n        const tex = this.texture;\r\n\r\n        return tex.trim ? tex.trim.x : 0;\r\n    }\r\n\r\n    get offsetY(): number {\r\n        // console.warn(\"Deprecation Warning: @Hackerham: I guess, if you are using PIXI-SPINE ATLAS region.offsetY, you want a texture, right? Use region.texture from now on.\");\r\n        return this.spineOffsetY;\r\n    }\r\n\r\n    get pixiOffsetY(): number {\r\n        const tex = this.texture;\r\n\r\n        return tex.trim ? tex.trim.y : 0;\r\n    }\r\n\r\n    get spineOffsetY(): number {\r\n        const tex = this.texture;\r\n\r\n        return this.originalHeight - this.height - (tex.trim ? tex.trim.y : 0);\r\n    }\r\n\r\n    get originalWidth(): number {\r\n        return this.texture.orig.width;\r\n    }\r\n\r\n    get originalHeight(): number {\r\n        return this.texture.orig.height;\r\n    }\r\n\r\n    get x(): number {\r\n        return this.texture.frame.x;\r\n    }\r\n\r\n    get y(): number {\r\n        return this.texture.frame.y;\r\n    }\r\n\r\n    get rotate(): boolean {\r\n        return this.texture.rotate !== 0;\r\n    }\r\n\r\n    get degrees() {\r\n        return (360 - this.texture.rotate * 45) % 360;\r\n    }\r\n}\r\n","import { Texture, SCALE_MODES, MIPMAP_MODES, ALPHA_MODES, Rectangle } from '@pixi/core';\r\nimport { TextureRegion, TextureWrap, TextureFilter, filterFromString } from './TextureRegion';\r\nimport type { Map, Disposable } from './Utils';\r\nimport type { BaseTexture } from '@pixi/core';\r\n\r\nclass RegionFields {\r\n    x = 0;\r\n    y = 0;\r\n    width = 0;\r\n    height = 0;\r\n    offsetX = 0;\r\n    offsetY = 0;\r\n    originalWidth = 0;\r\n    originalHeight = 0;\r\n    rotate = 0;\r\n    index = 0;\r\n}\r\n/**\r\n * @public\r\n */\r\nexport class TextureAtlas implements Disposable {\r\n    pages = new Array<TextureAtlasPage>();\r\n    regions = new Array<TextureAtlasRegion>();\r\n\r\n    constructor(atlasText?: string, textureLoader?: (path: string, loaderFunction: (tex: BaseTexture) => any) => any, callback?: (obj: TextureAtlas) => any) {\r\n        if (atlasText) {\r\n            this.addSpineAtlas(atlasText, textureLoader, callback);\r\n        }\r\n    }\r\n\r\n    addTexture(name: string, texture: Texture) {\r\n        const pages = this.pages;\r\n        let page: TextureAtlasPage = null;\r\n\r\n        for (let i = 0; i < pages.length; i++) {\r\n            if (pages[i].baseTexture === texture.baseTexture) {\r\n                page = pages[i];\r\n                break;\r\n            }\r\n        }\r\n        if (page === null) {\r\n            page = new TextureAtlasPage();\r\n            page.name = 'texturePage';\r\n            const baseTexture = texture.baseTexture;\r\n\r\n            page.width = baseTexture.realWidth;\r\n            page.height = baseTexture.realHeight;\r\n            page.baseTexture = baseTexture;\r\n            // those fields are not relevant in Pixi\r\n            page.minFilter = page.magFilter = TextureFilter.Nearest;\r\n            page.uWrap = TextureWrap.ClampToEdge;\r\n            page.vWrap = TextureWrap.ClampToEdge;\r\n            pages.push(page);\r\n        }\r\n        const region = new TextureAtlasRegion();\r\n\r\n        region.name = name;\r\n        region.page = page;\r\n        region.texture = texture;\r\n        region.index = -1;\r\n        this.regions.push(region);\r\n\r\n        return region;\r\n    }\r\n\r\n    addTextureHash(textures: Map<Texture>, stripExtension: boolean) {\r\n        for (const key in textures) {\r\n            if (textures.hasOwnProperty(key)) {\r\n                this.addTexture(stripExtension && key.indexOf('.') !== -1 ? key.substr(0, key.lastIndexOf('.')) : key, textures[key]);\r\n            }\r\n        }\r\n    }\r\n\r\n    public addSpineAtlas(atlasText: string, textureLoader: (path: string, loaderFunction: (tex: BaseTexture) => any) => any, callback: (obj: TextureAtlas) => any) {\r\n        return this.load(atlasText, textureLoader, callback);\r\n    }\r\n\r\n    private load(atlasText: string, textureLoader: (path: string, loaderFunction: (tex: BaseTexture) => any) => any, callback: (obj: TextureAtlas) => any) {\r\n        if (textureLoader == null) {\r\n            throw new Error('textureLoader cannot be null.');\r\n        }\r\n\r\n        const reader = new TextureAtlasReader(atlasText);\r\n        const entry = new Array<string>(4);\r\n        let page: TextureAtlasPage = null;\r\n        const pageFields: Map<Function> = {};\r\n        let region: RegionFields = null;\r\n\r\n        pageFields.size = () => {\r\n            page.width = parseInt(entry[1]);\r\n            page.height = parseInt(entry[2]);\r\n        };\r\n        pageFields.format = () => {\r\n            // page.format = Format[tuple[0]]; we don't need format in WebGL\r\n        };\r\n        pageFields.filter = () => {\r\n            page.minFilter = filterFromString(entry[1]);\r\n            page.magFilter = filterFromString(entry[2]);\r\n        };\r\n        pageFields.repeat = () => {\r\n            if (entry[1].indexOf('x') != -1) page.uWrap = TextureWrap.Repeat;\r\n            if (entry[1].indexOf('y') != -1) page.vWrap = TextureWrap.Repeat;\r\n        };\r\n        pageFields.pma = () => {\r\n            page.pma = entry[1] == 'true';\r\n        };\r\n\r\n        const regionFields: Map<Function> = {};\r\n\r\n        regionFields.xy = () => {\r\n            // Deprecated, use bounds.\r\n            region.x = parseInt(entry[1]);\r\n            region.y = parseInt(entry[2]);\r\n        };\r\n        regionFields.size = () => {\r\n            // Deprecated, use bounds.\r\n            region.width = parseInt(entry[1]);\r\n            region.height = parseInt(entry[2]);\r\n        };\r\n        regionFields.bounds = () => {\r\n            region.x = parseInt(entry[1]);\r\n            region.y = parseInt(entry[2]);\r\n            region.width = parseInt(entry[3]);\r\n            region.height = parseInt(entry[4]);\r\n        };\r\n        regionFields.offset = () => {\r\n            // Deprecated, use offsets.\r\n            region.offsetX = parseInt(entry[1]);\r\n            region.offsetY = parseInt(entry[2]);\r\n        };\r\n        regionFields.orig = () => {\r\n            // Deprecated, use offsets.\r\n            region.originalWidth = parseInt(entry[1]);\r\n            region.originalHeight = parseInt(entry[2]);\r\n        };\r\n        regionFields.offsets = () => {\r\n            region.offsetX = parseInt(entry[1]);\r\n            region.offsetY = parseInt(entry[2]);\r\n            region.originalWidth = parseInt(entry[3]);\r\n            region.originalHeight = parseInt(entry[4]);\r\n        };\r\n        regionFields.rotate = () => {\r\n            const rotateValue = entry[1];\r\n            let rotate = 0;\r\n\r\n            if (rotateValue.toLocaleLowerCase() == 'true') {\r\n                rotate = 6;\r\n            } else if (rotateValue.toLocaleLowerCase() == 'false') {\r\n                rotate = 0;\r\n            } else {\r\n                rotate = ((720 - parseFloat(rotateValue)) % 360) / 45;\r\n            }\r\n            region.rotate = rotate;\r\n        };\r\n        regionFields.index = () => {\r\n            region.index = parseInt(entry[1]);\r\n        };\r\n\r\n        let line = reader.readLine();\r\n        // Ignore empty lines before first entry.\r\n\r\n        while (line != null && line.trim().length == 0) {\r\n            line = reader.readLine();\r\n        }\r\n        // Header entries.\r\n        while (true) {\r\n            if (line == null || line.trim().length == 0) break;\r\n            if (reader.readEntry(entry, line) == 0) break; // Silently ignore all header fields.\r\n            line = reader.readLine();\r\n        }\r\n\r\n        const iterateParser = () => {\r\n            while (true) {\r\n                if (line == null) {\r\n                    return callback && callback(this);\r\n                }\r\n                if (line.trim().length == 0) {\r\n                    page = null;\r\n                    line = reader.readLine();\r\n                } else if (page === null) {\r\n                    page = new TextureAtlasPage();\r\n                    page.name = line.trim();\r\n\r\n                    while (true) {\r\n                        if (reader.readEntry(entry, (line = reader.readLine())) == 0) break;\r\n                        const field: Function = pageFields[entry[0]];\r\n\r\n                        if (field) field();\r\n                    }\r\n                    this.pages.push(page);\r\n\r\n                    textureLoader(page.name, (texture: BaseTexture) => {\r\n                        if (texture === null) {\r\n                            this.pages.splice(this.pages.indexOf(page), 1);\r\n\r\n                            return callback && callback(null);\r\n                        }\r\n                        page.baseTexture = texture;\r\n                        // TODO: set scaleMode and mipmapMode from spine\r\n                        if (page.pma) {\r\n                            texture.alphaMode = ALPHA_MODES.PMA;\r\n                        }\r\n                        if (!texture.valid) {\r\n                            texture.setSize(page.width, page.height);\r\n                        }\r\n                        page.setFilters();\r\n\r\n                        if (!page.width || !page.height) {\r\n                            page.width = texture.realWidth;\r\n                            page.height = texture.realHeight;\r\n                            if (!page.width || !page.height) {\r\n                                console.log(\r\n                                    `ERROR spine atlas page ${page.name}: meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)`\r\n                                );\r\n                            }\r\n                        }\r\n                        iterateParser();\r\n                    });\r\n                    break;\r\n                } else {\r\n                    region = new RegionFields();\r\n                    const atlasRegion = new TextureAtlasRegion();\r\n\r\n                    atlasRegion.name = line;\r\n                    atlasRegion.page = page;\r\n                    let names: string[] = null;\r\n                    let values: number[][] = null;\r\n\r\n                    while (true) {\r\n                        const count = reader.readEntry(entry, (line = reader.readLine()));\r\n\r\n                        if (count == 0) break;\r\n                        const field: Function = regionFields[entry[0]];\r\n\r\n                        if (field) {\r\n                            field();\r\n                        } else {\r\n                            if (names == null) {\r\n                                names = [];\r\n                                values = [];\r\n                            }\r\n                            names.push(entry[0]);\r\n                            const entryValues: number[] = [];\r\n\r\n                            for (let i = 0; i < count; i++) {\r\n                                entryValues.push(parseInt(entry[i + 1]));\r\n                            }\r\n                            values.push(entryValues);\r\n                        }\r\n                    }\r\n                    if (region.originalWidth == 0 && region.originalHeight == 0) {\r\n                        region.originalWidth = region.width;\r\n                        region.originalHeight = region.height;\r\n                    }\r\n\r\n                    const resolution = page.baseTexture.resolution;\r\n\r\n                    region.x /= resolution;\r\n                    region.y /= resolution;\r\n                    region.width /= resolution;\r\n                    region.height /= resolution;\r\n                    region.originalWidth /= resolution;\r\n                    region.originalHeight /= resolution;\r\n                    region.offsetX /= resolution;\r\n                    region.offsetY /= resolution;\r\n\r\n                    const swapWH = region.rotate % 4 !== 0;\r\n                    const frame = new Rectangle(region.x, region.y, swapWH ? region.height : region.width, swapWH ? region.width : region.height);\r\n\r\n                    const orig = new Rectangle(0, 0, region.originalWidth, region.originalHeight);\r\n                    const trim = new Rectangle(region.offsetX, region.originalHeight - region.height - region.offsetY, region.width, region.height);\r\n\r\n                    atlasRegion.texture = new Texture(atlasRegion.page.baseTexture, frame, orig, trim, region.rotate);\r\n                    atlasRegion.index = region.index;\r\n                    atlasRegion.texture.updateUvs();\r\n\r\n                    this.regions.push(atlasRegion);\r\n                }\r\n            }\r\n        };\r\n\r\n        iterateParser();\r\n    }\r\n\r\n    findRegion(name: string): TextureAtlasRegion {\r\n        for (let i = 0; i < this.regions.length; i++) {\r\n            if (this.regions[i].name == name) {\r\n                return this.regions[i];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    dispose() {\r\n        for (let i = 0; i < this.pages.length; i++) {\r\n            this.pages[i].baseTexture.dispose();\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nclass TextureAtlasReader {\r\n    lines: Array<string>;\r\n    index = 0;\r\n\r\n    constructor(text: string) {\r\n        this.lines = text.split(/\\r\\n|\\r|\\n/);\r\n    }\r\n\r\n    readLine(): string {\r\n        if (this.index >= this.lines.length) {\r\n            return null;\r\n        }\r\n\r\n        return this.lines[this.index++];\r\n    }\r\n\r\n    readEntry(entry: string[], line: string): number {\r\n        if (line == null) return 0;\r\n        line = line.trim();\r\n        if (line.length == 0) return 0;\r\n\r\n        const colon = line.indexOf(':');\r\n\r\n        if (colon == -1) return 0;\r\n        entry[0] = line.substr(0, colon).trim();\r\n        for (let i = 1, lastMatch = colon + 1; ; i++) {\r\n            const comma = line.indexOf(',', lastMatch);\r\n\r\n            if (comma == -1) {\r\n                entry[i] = line.substr(lastMatch).trim();\r\n\r\n                return i;\r\n            }\r\n            entry[i] = line.substr(lastMatch, comma - lastMatch).trim();\r\n            lastMatch = comma + 1;\r\n            if (i == 4) return 4;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class TextureAtlasPage {\r\n    name: string;\r\n    minFilter: TextureFilter = TextureFilter.Nearest;\r\n    magFilter: TextureFilter = TextureFilter.Nearest;\r\n    uWrap: TextureWrap = TextureWrap.ClampToEdge;\r\n    vWrap: TextureWrap = TextureWrap.ClampToEdge;\r\n    baseTexture: BaseTexture;\r\n    width: number;\r\n    height: number;\r\n    pma: boolean;\r\n\r\n    public setFilters() {\r\n        const tex = this.baseTexture;\r\n        const filter = this.minFilter;\r\n\r\n        if (filter == TextureFilter.Linear) {\r\n            tex.scaleMode = SCALE_MODES.LINEAR;\r\n        } else if (this.minFilter == TextureFilter.Nearest) {\r\n            tex.scaleMode = SCALE_MODES.NEAREST;\r\n        } else {\r\n            tex.mipmap = MIPMAP_MODES.POW2;\r\n            if (filter == TextureFilter.MipMapNearestNearest) {\r\n                tex.scaleMode = SCALE_MODES.NEAREST;\r\n            } else {\r\n                tex.scaleMode = SCALE_MODES.LINEAR;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class TextureAtlasRegion extends TextureRegion {\r\n    page: TextureAtlasPage;\r\n    name: string;\r\n    index: number;\r\n}\r\n","import type { ISkeleton } from './ISkeleton';\r\n\r\n/**\r\n * @public\r\n */\r\n\r\nexport interface Map<T> {\r\n    [key: string]: T;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface StringMap<T> {\r\n    [key: string]: T;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class IntSet {\r\n    array = new Array<number>();\r\n\r\n    add(value: number): boolean {\r\n        const contains = this.contains(value);\r\n\r\n        this.array[value | 0] = value | 0;\r\n\r\n        return !contains;\r\n    }\r\n\r\n    contains(value: number) {\r\n        return this.array[value | 0] != undefined;\r\n    }\r\n\r\n    remove(value: number) {\r\n        this.array[value | 0] = undefined;\r\n    }\r\n\r\n    clear() {\r\n        this.array.length = 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class StringSet {\r\n    entries: StringMap<boolean> = {};\r\n    size = 0;\r\n\r\n    add(value: string): boolean {\r\n        const contains = this.entries[value];\r\n\r\n        this.entries[value] = true;\r\n        if (!contains) {\r\n            this.size++;\r\n\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    addAll(values: string[]): boolean {\r\n        const oldSize = this.size;\r\n\r\n        for (let i = 0, n = values.length; i < n; i++) {\r\n            this.add(values[i]);\r\n        }\r\n\r\n        return oldSize != this.size;\r\n    }\r\n\r\n    contains(value: string) {\r\n        return this.entries[value];\r\n    }\r\n\r\n    clear() {\r\n        this.entries = {};\r\n        this.size = 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface NumberArrayLike {\r\n    readonly length: number;\r\n    [n: number]: number;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface Disposable {\r\n    dispose(): void;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface Restorable {\r\n    restore(): void;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class Color {\r\n    public static WHITE = new Color(1, 1, 1, 1);\r\n    public static RED = new Color(1, 0, 0, 1);\r\n    public static GREEN = new Color(0, 1, 0, 1);\r\n    public static BLUE = new Color(0, 0, 1, 1);\r\n    public static MAGENTA = new Color(1, 0, 1, 1);\r\n\r\n    constructor(public r: number = 0, public g: number = 0, public b: number = 0, public a: number = 0) {}\r\n\r\n    set(r: number, g: number, b: number, a: number) {\r\n        this.r = r;\r\n        this.g = g;\r\n        this.b = b;\r\n        this.a = a;\r\n\r\n        return this.clamp();\r\n    }\r\n\r\n    setFromColor(c: Color) {\r\n        this.r = c.r;\r\n        this.g = c.g;\r\n        this.b = c.b;\r\n        this.a = c.a;\r\n\r\n        return this;\r\n    }\r\n\r\n    setFromString(hex: string) {\r\n        hex = hex.charAt(0) == '#' ? hex.substr(1) : hex;\r\n        this.r = parseInt(hex.substr(0, 2), 16) / 255;\r\n        this.g = parseInt(hex.substr(2, 2), 16) / 255;\r\n        this.b = parseInt(hex.substr(4, 2), 16) / 255;\r\n        this.a = hex.length != 8 ? 1 : parseInt(hex.substr(6, 2), 16) / 255;\r\n\r\n        return this;\r\n    }\r\n\r\n    add(r: number, g: number, b: number, a: number) {\r\n        this.r += r;\r\n        this.g += g;\r\n        this.b += b;\r\n        this.a += a;\r\n\r\n        return this.clamp();\r\n    }\r\n\r\n    clamp() {\r\n        if (this.r < 0) this.r = 0;\r\n        else if (this.r > 1) this.r = 1;\r\n\r\n        if (this.g < 0) this.g = 0;\r\n        else if (this.g > 1) this.g = 1;\r\n\r\n        if (this.b < 0) this.b = 0;\r\n        else if (this.b > 1) this.b = 1;\r\n\r\n        if (this.a < 0) this.a = 0;\r\n        else if (this.a > 1) this.a = 1;\r\n\r\n        return this;\r\n    }\r\n\r\n    static rgba8888ToColor(color: Color, value: number) {\r\n        color.r = ((value & 0xff000000) >>> 24) / 255;\r\n        color.g = ((value & 0x00ff0000) >>> 16) / 255;\r\n        color.b = ((value & 0x0000ff00) >>> 8) / 255;\r\n        color.a = (value & 0x000000ff) / 255;\r\n    }\r\n\r\n    static rgb888ToColor(color: Color, value: number) {\r\n        color.r = ((value & 0x00ff0000) >>> 16) / 255;\r\n        color.g = ((value & 0x0000ff00) >>> 8) / 255;\r\n        color.b = (value & 0x000000ff) / 255;\r\n    }\r\n\r\n    static fromString(hex: string): Color {\r\n        return new Color().setFromString(hex);\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class MathUtils {\r\n    static PI = 3.1415927;\r\n    static PI2 = MathUtils.PI * 2;\r\n    static radiansToDegrees = 180 / MathUtils.PI;\r\n    static radDeg = MathUtils.radiansToDegrees;\r\n    static degreesToRadians = MathUtils.PI / 180;\r\n    static degRad = MathUtils.degreesToRadians;\r\n\r\n    static clamp(value: number, min: number, max: number) {\r\n        if (value < min) return min;\r\n        if (value > max) return max;\r\n\r\n        return value;\r\n    }\r\n\r\n    static cosDeg(degrees: number) {\r\n        return Math.cos(degrees * MathUtils.degRad);\r\n    }\r\n\r\n    static sinDeg(degrees: number) {\r\n        return Math.sin(degrees * MathUtils.degRad);\r\n    }\r\n\r\n    static signum(value: number): number {\r\n        return Math.sign(value);\r\n    }\r\n\r\n    static toInt(x: number) {\r\n        return x > 0 ? Math.floor(x) : Math.ceil(x);\r\n    }\r\n\r\n    static cbrt(x: number) {\r\n        const y = Math.pow(Math.abs(x), 1 / 3);\r\n\r\n        return x < 0 ? -y : y;\r\n    }\r\n\r\n    static randomTriangular(min: number, max: number): number {\r\n        return MathUtils.randomTriangularWith(min, max, (min + max) * 0.5);\r\n    }\r\n\r\n    static randomTriangularWith(min: number, max: number, mode: number): number {\r\n        const u = Math.random();\r\n        const d = max - min;\r\n\r\n        if (u <= (mode - min) / d) return min + Math.sqrt(u * d * (mode - min));\r\n\r\n        return max - Math.sqrt((1 - u) * d * (max - mode));\r\n    }\r\n\r\n    static isPowerOfTwo(value: number) {\r\n        return value && (value & (value - 1)) === 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport abstract class Interpolation {\r\n    protected abstract applyInternal(a: number): number;\r\n    apply(start: number, end: number, a: number): number {\r\n        return start + (end - start) * this.applyInternal(a);\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class Pow extends Interpolation {\r\n    protected power = 2;\r\n\r\n    constructor(power: number) {\r\n        super();\r\n        this.power = power;\r\n    }\r\n\r\n    applyInternal(a: number): number {\r\n        if (a <= 0.5) return Math.pow(a * 2, this.power) / 2;\r\n\r\n        return Math.pow((a - 1) * 2, this.power) / (this.power % 2 == 0 ? -2 : 2) + 1;\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class PowOut extends Pow {\r\n    applyInternal(a: number): number {\r\n        return Math.pow(a - 1, this.power) * (this.power % 2 == 0 ? -1 : 1) + 1;\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class Utils {\r\n    static SUPPORTS_TYPED_ARRAYS = typeof Float32Array !== 'undefined';\r\n\r\n    static arrayCopy<T>(source: ArrayLike<T>, sourceStart: number, dest: ArrayLike<T>, destStart: number, numElements: number) {\r\n        for (let i = sourceStart, j = destStart; i < sourceStart + numElements; i++, j++) {\r\n            dest[j] = source[i];\r\n        }\r\n    }\r\n\r\n    static arrayFill<T>(array: ArrayLike<T>, fromIndex: number, toIndex: number, value: T) {\r\n        for (let i = fromIndex; i < toIndex; i++) {\r\n            array[i] = value;\r\n        }\r\n    }\r\n\r\n    static setArraySize<T>(array: Array<T>, size: number, value: any = 0): Array<T> {\r\n        const oldSize = array.length;\r\n\r\n        if (oldSize == size) return array;\r\n        array.length = size;\r\n        if (oldSize < size) {\r\n            for (let i = oldSize; i < size; i++) array[i] = value;\r\n        }\r\n\r\n        return array;\r\n    }\r\n\r\n    static ensureArrayCapacity<T>(array: Array<T>, size: number, value: any = 0): Array<T> {\r\n        if (array.length >= size) return array;\r\n\r\n        return Utils.setArraySize(array, size, value);\r\n    }\r\n\r\n    static newArray<T>(size: number, defaultValue: T): Array<T> {\r\n        const array = new Array<T>(size);\r\n\r\n        for (let i = 0; i < size; i++) array[i] = defaultValue;\r\n\r\n        return array;\r\n    }\r\n\r\n    static newFloatArray(size: number): NumberArrayLike {\r\n        if (Utils.SUPPORTS_TYPED_ARRAYS) {\r\n            return new Float32Array(size);\r\n        }\r\n\r\n        const array = new Array<number>(size);\r\n\r\n        for (let i = 0; i < array.length; i++) array[i] = 0;\r\n\r\n        return array;\r\n    }\r\n\r\n    static newShortArray(size: number): NumberArrayLike {\r\n        if (Utils.SUPPORTS_TYPED_ARRAYS) {\r\n            return new Int16Array(size);\r\n        }\r\n\r\n        const array = new Array<number>(size);\r\n\r\n        for (let i = 0; i < array.length; i++) array[i] = 0;\r\n\r\n        return array;\r\n    }\r\n\r\n    static toFloatArray(array: Array<number>) {\r\n        return Utils.SUPPORTS_TYPED_ARRAYS ? new Float32Array(array) : array;\r\n    }\r\n\r\n    static toSinglePrecision(value: number) {\r\n        return Utils.SUPPORTS_TYPED_ARRAYS ? Math.fround(value) : value;\r\n    }\r\n\r\n    // This function is used to fix WebKit 602 specific issue described at http://esotericsoftware.com/forum/iOS-10-disappearing-graphics-10109\r\n    static webkit602BugfixHelper(alpha: number, blend: any) {}\r\n\r\n    static contains<T>(array: Array<T>, element: T, identity = true) {\r\n        for (let i = 0; i < array.length; i++) {\r\n            if (array[i] == element) return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    static enumValue(type: any, name: string) {\r\n        return type[name[0].toUpperCase() + name.slice(1)];\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class DebugUtils {\r\n    static logBones(skeleton: ISkeleton) {\r\n        for (let i = 0; i < skeleton.bones.length; i++) {\r\n            const bone = skeleton.bones[i];\r\n            const mat = bone.matrix;\r\n\r\n            console.log(`${bone.data.name}, ${mat.a}, ${mat.b}, ${mat.c}, ${mat.d}, ${mat.tx}, ${mat.ty}`);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class Pool<T> {\r\n    private items = new Array<T>();\r\n    private instantiator: () => T;\r\n\r\n    constructor(instantiator: () => T) {\r\n        this.instantiator = instantiator;\r\n    }\r\n\r\n    obtain() {\r\n        return this.items.length > 0 ? this.items.pop() : this.instantiator();\r\n    }\r\n\r\n    free(item: T) {\r\n        if ((item as any).reset) (item as any).reset();\r\n        this.items.push(item);\r\n    }\r\n\r\n    freeAll(items: ArrayLike<T>) {\r\n        for (let i = 0; i < items.length; i++) {\r\n            this.free(items[i]);\r\n        }\r\n    }\r\n\r\n    clear() {\r\n        this.items.length = 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class Vector2 {\r\n    constructor(public x = 0, public y = 0) {}\r\n\r\n    set(x: number, y: number): Vector2 {\r\n        this.x = x;\r\n        this.y = y;\r\n\r\n        return this;\r\n    }\r\n\r\n    length() {\r\n        const x = this.x;\r\n        const y = this.y;\r\n\r\n        return Math.sqrt(x * x + y * y);\r\n    }\r\n\r\n    normalize() {\r\n        const len = this.length();\r\n\r\n        if (len != 0) {\r\n            this.x /= len;\r\n            this.y /= len;\r\n        }\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class TimeKeeper {\r\n    maxDelta = 0.064;\r\n    framesPerSecond = 0;\r\n    delta = 0;\r\n    totalTime = 0;\r\n\r\n    private lastTime = Date.now() / 1000;\r\n    private frameCount = 0;\r\n    private frameTime = 0;\r\n\r\n    update() {\r\n        const now = Date.now() / 1000;\r\n\r\n        this.delta = now - this.lastTime;\r\n        this.frameTime += this.delta;\r\n        this.totalTime += this.delta;\r\n        if (this.delta > this.maxDelta) this.delta = this.maxDelta;\r\n        this.lastTime = now;\r\n\r\n        this.frameCount++;\r\n        if (this.frameTime > 1) {\r\n            this.framesPerSecond = this.frameCount / this.frameTime;\r\n            this.frameTime = 0;\r\n            this.frameCount = 0;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface ArrayLike<T> {\r\n    length: number;\r\n    [n: number]: T;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class WindowedMean {\r\n    values: Array<number>;\r\n    addedValues = 0;\r\n    lastValue = 0;\r\n    mean = 0;\r\n    dirty = true;\r\n\r\n    constructor(windowSize = 32) {\r\n        this.values = new Array<number>(windowSize);\r\n    }\r\n\r\n    hasEnoughData() {\r\n        return this.addedValues >= this.values.length;\r\n    }\r\n\r\n    addValue(value: number) {\r\n        if (this.addedValues < this.values.length) this.addedValues++;\r\n        this.values[this.lastValue++] = value;\r\n        if (this.lastValue > this.values.length - 1) this.lastValue = 0;\r\n        this.dirty = true;\r\n    }\r\n\r\n    getMean() {\r\n        if (this.hasEnoughData()) {\r\n            if (this.dirty) {\r\n                let mean = 0;\r\n\r\n                for (let i = 0; i < this.values.length; i++) {\r\n                    mean += this.values[i];\r\n                }\r\n                this.mean = mean / this.values.length;\r\n                this.dirty = false;\r\n            }\r\n\r\n            return this.mean;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n}\r\n","import { AttachmentType } from './AttachmentType';\r\nimport type { ISkeleton, IVertexAttachment } from './ISkeleton';\r\nimport { NumberArrayLike, Pool, Utils } from './Utils';\r\n\r\n/** Collects each visible BoundingBoxAttachment and computes the world vertices for its polygon. The polygon vertices are\r\n * provided along with convenience methods for doing hit detection.\r\n * @public\r\n * */\r\nexport class SkeletonBoundsBase<BoundingBoxAttachment extends IVertexAttachment> {\r\n    /** The left edge of the axis aligned bounding box. */\r\n    minX = 0;\r\n\r\n    /** The bottom edge of the axis aligned bounding box. */\r\n    minY = 0;\r\n\r\n    /** The right edge of the axis aligned bounding box. */\r\n    maxX = 0;\r\n\r\n    /** The top edge of the axis aligned bounding box. */\r\n    maxY = 0;\r\n\r\n    /** The visible bounding boxes. */\r\n    boundingBoxes = new Array<BoundingBoxAttachment>();\r\n\r\n    /** The world vertices for the bounding box polygons. */\r\n    polygons = new Array<NumberArrayLike>();\r\n\r\n    private polygonPool = new Pool<NumberArrayLike>(() => Utils.newFloatArray(16));\r\n\r\n    /** Clears any previous polygons, finds all visible bounding box attachments, and computes the world vertices for each bounding\r\n     * box's polygon.\r\n     * @param updateAabb If true, the axis aligned bounding box containing all the polygons is computed. If false, the\r\n     *           SkeletonBounds AABB methods will always return true. */\r\n    update(skeleton: ISkeleton, updateAabb: boolean) {\r\n        if (!skeleton) throw new Error('skeleton cannot be null.');\r\n        const boundingBoxes = this.boundingBoxes;\r\n        const polygons = this.polygons;\r\n        const polygonPool = this.polygonPool;\r\n        const slots = skeleton.slots;\r\n        const slotCount = slots.length;\r\n\r\n        boundingBoxes.length = 0;\r\n        polygonPool.freeAll(polygons);\r\n        polygons.length = 0;\r\n\r\n        for (let i = 0; i < slotCount; i++) {\r\n            const slot = slots[i];\r\n\r\n            if (!slot.bone.active) continue;\r\n            const attachment = slot.getAttachment();\r\n\r\n            if (attachment != null && attachment.type === AttachmentType.BoundingBox) {\r\n                const boundingBox = attachment as BoundingBoxAttachment;\r\n\r\n                boundingBoxes.push(boundingBox);\r\n\r\n                let polygon = polygonPool.obtain() as NumberArrayLike;\r\n\r\n                if (polygon.length != boundingBox.worldVerticesLength) {\r\n                    polygon = Utils.newFloatArray(boundingBox.worldVerticesLength);\r\n                }\r\n                polygons.push(polygon);\r\n                boundingBox.computeWorldVertices(slot, 0, boundingBox.worldVerticesLength, polygon, 0, 2);\r\n            }\r\n        }\r\n\r\n        if (updateAabb) {\r\n            this.aabbCompute();\r\n        } else {\r\n            this.minX = Number.POSITIVE_INFINITY;\r\n            this.minY = Number.POSITIVE_INFINITY;\r\n            this.maxX = Number.NEGATIVE_INFINITY;\r\n            this.maxY = Number.NEGATIVE_INFINITY;\r\n        }\r\n    }\r\n\r\n    aabbCompute() {\r\n        let minX = Number.POSITIVE_INFINITY;\r\n        let minY = Number.POSITIVE_INFINITY;\r\n        let maxX = Number.NEGATIVE_INFINITY;\r\n        let maxY = Number.NEGATIVE_INFINITY;\r\n        const polygons = this.polygons;\r\n\r\n        for (let i = 0, n = polygons.length; i < n; i++) {\r\n            const polygon = polygons[i];\r\n            const vertices = polygon;\r\n\r\n            for (let ii = 0, nn = polygon.length; ii < nn; ii += 2) {\r\n                const x = vertices[ii];\r\n                const y = vertices[ii + 1];\r\n\r\n                minX = Math.min(minX, x);\r\n                minY = Math.min(minY, y);\r\n                maxX = Math.max(maxX, x);\r\n                maxY = Math.max(maxY, y);\r\n            }\r\n        }\r\n        this.minX = minX;\r\n        this.minY = minY;\r\n        this.maxX = maxX;\r\n        this.maxY = maxY;\r\n    }\r\n\r\n    /** Returns true if the axis aligned bounding box contains the point. */\r\n    aabbContainsPoint(x: number, y: number) {\r\n        return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;\r\n    }\r\n\r\n    /** Returns true if the axis aligned bounding box intersects the line segment. */\r\n    aabbIntersectsSegment(x1: number, y1: number, x2: number, y2: number) {\r\n        const minX = this.minX;\r\n        const minY = this.minY;\r\n        const maxX = this.maxX;\r\n        const maxY = this.maxY;\r\n\r\n        if ((x1 <= minX && x2 <= minX) || (y1 <= minY && y2 <= minY) || (x1 >= maxX && x2 >= maxX) || (y1 >= maxY && y2 >= maxY)) {\r\n            return false;\r\n        }\r\n        const m = (y2 - y1) / (x2 - x1);\r\n        let y = m * (minX - x1) + y1;\r\n\r\n        if (y > minY && y < maxY) return true;\r\n        y = m * (maxX - x1) + y1;\r\n        if (y > minY && y < maxY) return true;\r\n        let x = (minY - y1) / m + x1;\r\n\r\n        if (x > minX && x < maxX) return true;\r\n        x = (maxY - y1) / m + x1;\r\n        if (x > minX && x < maxX) return true;\r\n\r\n        return false;\r\n    }\r\n\r\n    /** Returns true if the axis aligned bounding box intersects the axis aligned bounding box of the specified bounds. */\r\n    aabbIntersectsSkeleton(bounds: SkeletonBoundsBase<BoundingBoxAttachment>) {\r\n        return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;\r\n    }\r\n\r\n    /** Returns the first bounding box attachment that contains the point, or null. When doing many checks, it is usually more\r\n     * efficient to only call this method if {@link #aabbContainsPoint(float, float)} returns true.\r\n     * Cannot be done here because BoundingBoxAttachment is not a thing yet*/\r\n    containsPoint(x: number, y: number): BoundingBoxAttachment | null {\r\n        const polygons = this.polygons;\r\n\r\n        for (let i = 0, n = polygons.length; i < n; i++) {\r\n            if (this.containsPointPolygon(polygons[i], x, y)) return this.boundingBoxes[i];\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /** Returns true if the polygon contains the point. */\r\n    containsPointPolygon(polygon: NumberArrayLike, x: number, y: number) {\r\n        const vertices = polygon;\r\n        const nn = polygon.length;\r\n\r\n        let prevIndex = nn - 2;\r\n        let inside = false;\r\n\r\n        for (let ii = 0; ii < nn; ii += 2) {\r\n            const vertexY = vertices[ii + 1];\r\n            const prevY = vertices[prevIndex + 1];\r\n\r\n            if ((vertexY < y && prevY >= y) || (prevY < y && vertexY >= y)) {\r\n                const vertexX = vertices[ii];\r\n\r\n                if (vertexX + ((y - vertexY) / (prevY - vertexY)) * (vertices[prevIndex] - vertexX) < x) inside = !inside;\r\n            }\r\n            prevIndex = ii;\r\n        }\r\n\r\n        return inside;\r\n    }\r\n\r\n    /** Returns the first bounding box attachment that contains any part of the line segment, or null. When doing many checks, it\r\n     * is usually more efficient to only call this method if {@link #aabbIntersectsSegment()} returns\r\n     * true. */\r\n    intersectsSegment(x1: number, y1: number, x2: number, y2: number) {\r\n        const polygons = this.polygons;\r\n\r\n        for (let i = 0, n = polygons.length; i < n; i++) {\r\n            if (this.intersectsSegmentPolygon(polygons[i], x1, y1, x2, y2)) return this.boundingBoxes[i];\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /** Returns true if the polygon contains any part of the line segment. */\r\n    intersectsSegmentPolygon(polygon: NumberArrayLike, x1: number, y1: number, x2: number, y2: number) {\r\n        const vertices = polygon;\r\n        const nn = polygon.length;\r\n\r\n        const width12 = x1 - x2;\r\n        const height12 = y1 - y2;\r\n        const det1 = x1 * y2 - y1 * x2;\r\n        let x3 = vertices[nn - 2];\r\n        let y3 = vertices[nn - 1];\r\n\r\n        for (let ii = 0; ii < nn; ii += 2) {\r\n            const x4 = vertices[ii];\r\n            const y4 = vertices[ii + 1];\r\n            const det2 = x3 * y4 - y3 * x4;\r\n            const width34 = x3 - x4;\r\n            const height34 = y3 - y4;\r\n            const det3 = width12 * height34 - height12 * width34;\r\n            const x = (det1 * width34 - width12 * det2) / det3;\r\n\r\n            if (((x >= x3 && x <= x4) || (x >= x4 && x <= x3)) && ((x >= x1 && x <= x2) || (x >= x2 && x <= x1))) {\r\n                const y = (det1 * height34 - height12 * det2) / det3;\r\n\r\n                if (((y >= y3 && y <= y4) || (y >= y4 && y <= y3)) && ((y >= y1 && y <= y2) || (y >= y2 && y <= y1))) return true;\r\n            }\r\n            x3 = x4;\r\n            y3 = y4;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /** Returns the polygon for the specified bounding box, or null. */\r\n    getPolygon(boundingBox: BoundingBoxAttachment) {\r\n        if (!boundingBox) throw new Error('boundingBox cannot be null.');\r\n        const index = this.boundingBoxes.indexOf(boundingBox);\r\n\r\n        return index == -1 ? null : this.polygons[index];\r\n    }\r\n\r\n    /** The width of the axis aligned bounding box. */\r\n    getWidth() {\r\n        return this.maxX - this.minX;\r\n    }\r\n\r\n    /** The height of the axis aligned bounding box. */\r\n    getHeight() {\r\n        return this.maxY - this.minY;\r\n    }\r\n}\r\n","/**\r\n * @public\r\n */\r\nexport const settings = {\r\n    yDown: true,\r\n    /**\r\n     * pixi-spine gives option to not fail at certain parsing errors\r\n     * spine-ts fails here\r\n     */\r\n    FAIL_ON_NON_EXISTING_SKIN: false,\r\n\r\n    /**\r\n     * past Spine.globalAutoUpdate\r\n     */\r\n    GLOBAL_AUTO_UPDATE: true,\r\n\r\n    /**\r\n     * past Spine.globalDelayLimit\r\n     */\r\n    GLOBAL_DELAY_LIMIT: 0,\r\n};\r\n","import { AttachmentType } from './core/AttachmentType';\r\nimport { TextureRegion } from './core/TextureRegion';\r\nimport { MathUtils } from './core/Utils';\r\nimport type { IAnimationState, IAnimationStateData } from './core/IAnimation';\r\nimport type { IAttachment, IClippingAttachment, IMeshAttachment, IRegionAttachment, ISkeleton, ISkeletonData, ISlot, IVertexAttachment } from './core/ISkeleton';\r\nimport { DRAW_MODES, Rectangle, Polygon, Transform, Texture, utils } from '@pixi/core';\r\nimport { Container, DisplayObject } from '@pixi/display';\r\nimport { Sprite } from '@pixi/sprite';\r\nimport { SimpleMesh } from '@pixi/mesh-extras';\r\nimport { Graphics } from '@pixi/graphics';\r\nimport { settings } from './settings';\r\nimport type { ISpineDebugRenderer } from './SpineDebugRenderer';\r\n\r\nconst tempRgb = [0, 0, 0];\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface ISpineDisplayObject extends DisplayObject {\r\n    region?: TextureRegion;\r\n    attachment?: IAttachment;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class SpineSprite extends Sprite implements ISpineDisplayObject {\r\n    region?: TextureRegion = null;\r\n    attachment?: IAttachment = null;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class SpineMesh extends SimpleMesh implements ISpineDisplayObject {\r\n    region?: TextureRegion = null;\r\n    attachment?: IAttachment = null;\r\n\r\n    constructor(texture: Texture, vertices?: Float32Array, uvs?: Float32Array, indices?: Uint16Array, drawMode?: number) {\r\n        super(texture, vertices, uvs, indices, drawMode);\r\n    }\r\n}\r\n\r\n/**\r\n * A class that enables the you to import and run your spine animations in pixi.\r\n * The Spine animation data needs to be loaded using either the Loader or a SpineLoader before it can be used by this class\r\n * See example 12 (http://www.goodboydigital.com/pixijs/examples/12/) to see a working example and check out the source\r\n *\r\n * ```js\r\n * let spineAnimation = new spine(spineData);\r\n * ```\r\n *\r\n * @public\r\n * @class\r\n * @extends Container\r\n * @memberof spine\r\n * @param spineData {object} The spine data loaded from a spine atlas.\r\n */\r\nexport abstract class SpineBase<\r\n        Skeleton extends ISkeleton,\r\n        SkeletonData extends ISkeletonData,\r\n        AnimationState extends IAnimationState,\r\n        AnimationStateData extends IAnimationStateData\r\n    >\r\n    extends Container\r\n    implements GlobalMixins.Spine\r\n{\r\n    tintRgb: ArrayLike<number>;\r\n    spineData: SkeletonData;\r\n    skeleton: Skeleton;\r\n    stateData: AnimationStateData;\r\n    state: AnimationState;\r\n    slotContainers: Array<Container>;\r\n    tempClipContainers: Array<Container>;\r\n    localDelayLimit: number;\r\n    private _autoUpdate: boolean;\r\n    protected _visible: boolean;\r\n    private _debug: ISpineDebugRenderer;\r\n    public get debug(): ISpineDebugRenderer {\r\n        return this._debug;\r\n    }\r\n    public set debug(value: ISpineDebugRenderer) {\r\n        if (value == this._debug) {\r\n            // soft equality allows null == undefined\r\n            return;\r\n        }\r\n        this._debug?.unregisterSpine(this);\r\n        value?.registerSpine(this);\r\n        this._debug = value;\r\n    }\r\n\r\n    abstract createSkeleton(spineData: ISkeletonData);\r\n\r\n    constructor(spineData: SkeletonData) {\r\n        super();\r\n\r\n        if (!spineData) {\r\n            throw new Error('The spineData param is required.');\r\n        }\r\n\r\n        if (typeof spineData === 'string') {\r\n            throw new Error('spineData param cant be string. Please use spine.Spine.fromAtlas(\"YOUR_RESOURCE_NAME\") from now on.');\r\n        }\r\n\r\n        /**\r\n         * The spineData object\r\n         *\r\n         * @member {object}\r\n         */\r\n        this.spineData = spineData;\r\n\r\n        /**\r\n         * A spine Skeleton object\r\n         *\r\n         * @member {object}\r\n         */\r\n        this.createSkeleton(spineData);\r\n\r\n        /**\r\n         * An array of containers\r\n         *\r\n         * @member {Container[]}\r\n         */\r\n        this.slotContainers = [];\r\n\r\n        this.tempClipContainers = [];\r\n\r\n        for (let i = 0, n = this.skeleton.slots.length; i < n; i++) {\r\n            const slot = this.skeleton.slots[i];\r\n            const attachment: any = slot.getAttachment();\r\n            const slotContainer = this.newContainer();\r\n\r\n            this.slotContainers.push(slotContainer);\r\n            this.addChild(slotContainer);\r\n            this.tempClipContainers.push(null);\r\n\r\n            if (!attachment) {\r\n                continue;\r\n            }\r\n            if (attachment.type === AttachmentType.Region) {\r\n                const spriteName = attachment.name;\r\n                const sprite = this.createSprite(slot, attachment as IRegionAttachment, spriteName);\r\n\r\n                slot.currentSprite = sprite;\r\n                slot.currentSpriteName = spriteName;\r\n                slotContainer.addChild(sprite);\r\n            } else if (attachment.type === AttachmentType.Mesh) {\r\n                const mesh = this.createMesh(slot, attachment);\r\n\r\n                slot.currentMesh = mesh;\r\n                slot.currentMeshId = attachment.id;\r\n                slot.currentMeshName = attachment.name;\r\n                slotContainer.addChild(mesh);\r\n            } else if (attachment.type === AttachmentType.Clipping) {\r\n                this.createGraphics(slot, attachment);\r\n                slotContainer.addChild(slot.clippingContainer);\r\n                slotContainer.addChild(slot.currentGraphics);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * The tint applied to all spine slots. This is a [r,g,b] value. A value of [1,1,1] will remove any tint effect.\r\n         *\r\n         * @member {number}\r\n         * @memberof spine.Spine#\r\n         */\r\n        this.tintRgb = new Float32Array([1, 1, 1]);\r\n\r\n        this.autoUpdate = true;\r\n        this.visible = true;\r\n    }\r\n\r\n    /**\r\n     * If this flag is set to true, the spine animation will be automatically updated every\r\n     * time the object id drawn. The down side of this approach is that the delta time is\r\n     * automatically calculated and you could miss out on cool effects like slow motion,\r\n     * pause, skip ahead and the sorts. Most of these effects can be achieved even with\r\n     * autoUpdate enabled but are harder to achieve.\r\n     *\r\n     * @member {boolean}\r\n     * @memberof spine.Spine#\r\n     * @default true\r\n     */\r\n    get autoUpdate(): boolean {\r\n        return this._autoUpdate;\r\n    }\r\n\r\n    set autoUpdate(value: boolean) {\r\n        if (value !== this._autoUpdate) {\r\n            this._autoUpdate = value;\r\n            this.updateTransform = value ? SpineBase.prototype.autoUpdateTransform : Container.prototype.updateTransform;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The tint applied to the spine object. This is a hex value. A value of 0xFFFFFF will remove any tint effect.\r\n     *\r\n     * @member {number}\r\n     * @memberof spine.Spine#\r\n     * @default 0xFFFFFF\r\n     */\r\n    get tint(): number {\r\n        return utils.rgb2hex(this.tintRgb as any);\r\n    }\r\n\r\n    set tint(value: number) {\r\n        this.tintRgb = utils.hex2rgb(value, this.tintRgb as any);\r\n    }\r\n\r\n    /**\r\n     * Limit value for the update dt with Spine.globalDelayLimit\r\n     * that can be overridden with localDelayLimit\r\n     * @return {number} - Maximum processed dt value for the update\r\n     */\r\n    get delayLimit(): number {\r\n        const limit = typeof this.localDelayLimit !== 'undefined' ? this.localDelayLimit : settings.GLOBAL_DELAY_LIMIT;\r\n\r\n        // If limit is 0, this means there is no limit for the delay\r\n        return limit || Number.MAX_VALUE;\r\n    }\r\n\r\n    /**\r\n     * Update the spine skeleton and its animations by delta time (dt)\r\n     *\r\n     * @param dt {number} Delta time. Time by which the animation should be updated\r\n     */\r\n    update(dt: number) {\r\n        // Limit delta value to avoid animation jumps\r\n        const delayLimit = this.delayLimit;\r\n\r\n        if (dt > delayLimit) dt = delayLimit;\r\n\r\n        this.state.update(dt);\r\n        this.state.apply(this.skeleton);\r\n\r\n        // check we haven't been destroyed via a spine event callback in state update\r\n        if (!this.skeleton) {\r\n            return;\r\n        }\r\n\r\n        this.skeleton.updateWorldTransform();\r\n\r\n        const slots = this.skeleton.slots;\r\n\r\n        // in case pixi has double tint\r\n        const globalClr = (this as any).color;\r\n        let light: ArrayLike<number> = null;\r\n        let dark: ArrayLike<number> = null;\r\n\r\n        if (globalClr) {\r\n            light = globalClr.light;\r\n            dark = globalClr.dark;\r\n        } else {\r\n            light = this.tintRgb;\r\n        }\r\n\r\n        // let thack = false;\r\n\r\n        for (let i = 0, n = slots.length; i < n; i++) {\r\n            const slot = slots[i];\r\n            const attachment = slot.getAttachment();\r\n            const slotContainer = this.slotContainers[i];\r\n\r\n            if (!attachment) {\r\n                slotContainer.visible = false;\r\n                continue;\r\n            }\r\n\r\n            let spriteColor: any = null;\r\n\r\n            if (attachment.sequence) {\r\n                attachment.sequence.apply(slot, attachment as any);\r\n            }\r\n            let region = (attachment as IRegionAttachment).region;\r\n\r\n            const attColor = (attachment as any).color;\r\n\r\n            switch (attachment != null && attachment.type) {\r\n                case AttachmentType.Region:\r\n                    const transform = slotContainer.transform;\r\n\r\n                    transform.setFromMatrix(slot.bone.matrix);\r\n\r\n                    region = (attachment as IRegionAttachment).region;\r\n                    if (slot.currentMesh) {\r\n                        slot.currentMesh.visible = false;\r\n                        slot.currentMesh = null;\r\n                        slot.currentMeshId = undefined;\r\n                        slot.currentMeshName = undefined;\r\n                    }\r\n                    if (!region) {\r\n                        if (slot.currentSprite) {\r\n                            slot.currentSprite.renderable = false;\r\n                        }\r\n                        break;\r\n                    }\r\n                    if (!slot.currentSpriteName || slot.currentSpriteName !== attachment.name) {\r\n                        const spriteName = attachment.name;\r\n\r\n                        if (slot.currentSprite) {\r\n                            slot.currentSprite.visible = false;\r\n                        }\r\n                        slot.sprites = slot.sprites || {};\r\n                        if (slot.sprites[spriteName] !== undefined) {\r\n                            slot.sprites[spriteName].visible = true;\r\n                        } else {\r\n                            const sprite = this.createSprite(slot, attachment as IRegionAttachment, spriteName);\r\n\r\n                            slotContainer.addChild(sprite);\r\n                        }\r\n                        slot.currentSprite = slot.sprites[spriteName];\r\n                        slot.currentSpriteName = spriteName;\r\n\r\n                        // force sprite update when attachment name is same.\r\n                        // issues https://github.com/pixijs/pixi-spine/issues/318\r\n                    }\r\n                    slot.currentSprite.renderable = true;\r\n                    if (!slot.hackRegion) {\r\n                        this.setSpriteRegion(attachment as IRegionAttachment, slot.currentSprite, region);\r\n                    }\r\n                    if (slot.currentSprite.color) {\r\n                        // YAY! double - tint!\r\n                        spriteColor = slot.currentSprite.color;\r\n                    } else {\r\n                        tempRgb[0] = light[0] * slot.color.r * attColor.r;\r\n                        tempRgb[1] = light[1] * slot.color.g * attColor.g;\r\n                        tempRgb[2] = light[2] * slot.color.b * attColor.b;\r\n                        slot.currentSprite.tint = utils.rgb2hex(tempRgb);\r\n                    }\r\n                    slot.currentSprite.blendMode = slot.blendMode;\r\n                    break;\r\n\r\n                case AttachmentType.Mesh:\r\n                    if (slot.currentSprite) {\r\n                        // TODO: refactor this thing, switch it on and off for container\r\n                        slot.currentSprite.visible = false;\r\n                        slot.currentSprite = null;\r\n                        slot.currentSpriteName = undefined;\r\n\r\n                        // TODO: refactor this shit\r\n                        const transform = new Transform();\r\n\r\n                        (transform as any)._parentID = -1;\r\n                        (transform as any)._worldID = (slotContainer.transform as any)._worldID;\r\n                        slotContainer.transform = transform;\r\n                    }\r\n                    if (!region) {\r\n                        if (slot.currentMesh) {\r\n                            slot.currentMesh.renderable = false;\r\n                        }\r\n                        break;\r\n                    }\r\n\r\n                    const id = (attachment as IVertexAttachment).id;\r\n\r\n                    if (slot.currentMeshId === undefined || slot.currentMeshId !== id) {\r\n                        const meshId = id;\r\n\r\n                        if (slot.currentMesh) {\r\n                            slot.currentMesh.visible = false;\r\n                        }\r\n\r\n                        slot.meshes = slot.meshes || {};\r\n\r\n                        if (slot.meshes[meshId] !== undefined) {\r\n                            slot.meshes[meshId].visible = true;\r\n                        } else {\r\n                            const mesh = this.createMesh(slot, attachment as IMeshAttachment);\r\n\r\n                            slotContainer.addChild(mesh);\r\n                        }\r\n\r\n                        slot.currentMesh = slot.meshes[meshId];\r\n                        slot.currentMeshName = attachment.name;\r\n                        slot.currentMeshId = meshId;\r\n                    }\r\n                    slot.currentMesh.renderable = true;\r\n                    (attachment as IVertexAttachment).computeWorldVerticesOld(slot, slot.currentMesh.vertices);\r\n                    if (slot.currentMesh.color) {\r\n                        // pixi-heaven\r\n                        spriteColor = slot.currentMesh.color;\r\n                    } else {\r\n                        tempRgb[0] = light[0] * slot.color.r * attColor.r;\r\n                        tempRgb[1] = light[1] * slot.color.g * attColor.g;\r\n                        tempRgb[2] = light[2] * slot.color.b * attColor.b;\r\n                        slot.currentMesh.tint = utils.rgb2hex(tempRgb);\r\n                    }\r\n                    slot.currentMesh.blendMode = slot.blendMode;\r\n                    if (!slot.hackRegion) {\r\n                        this.setMeshRegion(attachment as IMeshAttachment, slot.currentMesh, region);\r\n                    }\r\n                    break;\r\n                case AttachmentType.Clipping:\r\n                    if (!slot.currentGraphics) {\r\n                        this.createGraphics(slot, attachment as IClippingAttachment);\r\n                        slotContainer.addChild(slot.clippingContainer);\r\n                        slotContainer.addChild(slot.currentGraphics);\r\n                    }\r\n                    this.updateGraphics(slot, attachment as IClippingAttachment);\r\n                    slotContainer.alpha = 1.0;\r\n                    slotContainer.visible = true;\r\n                    continue;\r\n                default:\r\n                    slotContainer.visible = false;\r\n                    continue;\r\n            }\r\n            slotContainer.visible = true;\r\n\r\n            // pixi has double tint\r\n            if (spriteColor) {\r\n                let r0 = slot.color.r * attColor.r;\r\n                let g0 = slot.color.g * attColor.g;\r\n                let b0 = slot.color.b * attColor.b;\r\n\r\n                // YAY! double-tint!\r\n                spriteColor.setLight(light[0] * r0 + dark[0] * (1.0 - r0), light[1] * g0 + dark[1] * (1.0 - g0), light[2] * b0 + dark[2] * (1.0 - b0));\r\n                if (slot.darkColor) {\r\n                    r0 = slot.darkColor.r;\r\n                    g0 = slot.darkColor.g;\r\n                    b0 = slot.darkColor.b;\r\n                } else {\r\n                    r0 = 0.0;\r\n                    g0 = 0.0;\r\n                    b0 = 0.0;\r\n                }\r\n                spriteColor.setDark(light[0] * r0 + dark[0] * (1 - r0), light[1] * g0 + dark[1] * (1 - g0), light[2] * b0 + dark[2] * (1 - b0));\r\n            }\r\n\r\n            slotContainer.alpha = slot.color.a;\r\n        }\r\n\r\n        // == this is clipping implementation ===\r\n        // TODO: remove parent hacks when pixi masks allow it\r\n        const drawOrder = this.skeleton.drawOrder;\r\n        let clippingAttachment: IClippingAttachment = null;\r\n        let clippingContainer: Container = null;\r\n\r\n        for (let i = 0, n = drawOrder.length; i < n; i++) {\r\n            const slot = slots[drawOrder[i].data.index];\r\n            const slotContainer = this.slotContainers[drawOrder[i].data.index];\r\n\r\n            if (!clippingContainer) {\r\n                // Adding null check as it is possible for slotContainer.parent to be null in the event of a spine being disposed off in its loop callback\r\n                if (slotContainer.parent !== null && slotContainer.parent !== this) {\r\n                    slotContainer.parent.removeChild(slotContainer);\r\n                    // silend add hack\r\n                    (slotContainer as any).parent = this;\r\n                }\r\n            }\r\n            if (slot.currentGraphics && slot.getAttachment()) {\r\n                clippingContainer = slot.clippingContainer;\r\n                clippingAttachment = slot.getAttachment() as IClippingAttachment;\r\n                clippingContainer.children.length = 0;\r\n                this.children[i] = slotContainer;\r\n\r\n                if (clippingAttachment.endSlot === slot.data) {\r\n                    clippingAttachment.endSlot = null;\r\n                }\r\n            } else if (clippingContainer) {\r\n                let c = this.tempClipContainers[i];\r\n\r\n                if (!c) {\r\n                    c = this.tempClipContainers[i] = this.newContainer();\r\n                    c.visible = false;\r\n                }\r\n                this.children[i] = c;\r\n\r\n                // silent remove hack\r\n                (slotContainer as any).parent = null;\r\n                clippingContainer.addChild(slotContainer);\r\n                if (clippingAttachment.endSlot == slot.data) {\r\n                    clippingContainer.renderable = true;\r\n                    clippingContainer = null;\r\n                    clippingAttachment = null;\r\n                }\r\n            } else {\r\n                this.children[i] = slotContainer;\r\n            }\r\n        }\r\n\r\n        // if you can debug, then debug!\r\n        this._debug?.renderDebug(this);\r\n    }\r\n\r\n    private setSpriteRegion(attachment: IRegionAttachment, sprite: SpineSprite, region: TextureRegion) {\r\n        // prevent setters calling when attachment and region is same\r\n        if (sprite.attachment === attachment && sprite.region === region) {\r\n            return;\r\n        }\r\n\r\n        sprite.region = region;\r\n        sprite.attachment = attachment;\r\n\r\n        sprite.texture = region.texture;\r\n        sprite.rotation = attachment.rotation * MathUtils.degRad;\r\n        sprite.position.x = attachment.x;\r\n        sprite.position.y = attachment.y;\r\n        sprite.alpha = attachment.color.a;\r\n\r\n        if (!region.size) {\r\n            sprite.scale.x = (attachment.scaleX * attachment.width) / region.originalWidth;\r\n            sprite.scale.y = (-attachment.scaleY * attachment.height) / region.originalHeight;\r\n        } else {\r\n            // hacked!\r\n            sprite.scale.x = region.size.width / region.originalWidth;\r\n            sprite.scale.y = -region.size.height / region.originalHeight;\r\n        }\r\n    }\r\n\r\n    private setMeshRegion(attachment: IMeshAttachment, mesh: SpineMesh, region: TextureRegion) {\r\n        if (mesh.attachment === attachment && mesh.region === region) {\r\n            return;\r\n        }\r\n\r\n        mesh.region = region;\r\n        mesh.attachment = attachment;\r\n        mesh.texture = region.texture;\r\n        region.texture.updateUvs();\r\n        mesh.uvBuffer.update(attachment.regionUVs);\r\n    }\r\n\r\n    protected lastTime: number;\r\n\r\n    /**\r\n     * When autoupdate is set to yes this function is used as pixi's updateTransform function\r\n     *\r\n     * @private\r\n     */\r\n    autoUpdateTransform() {\r\n        if (settings.GLOBAL_AUTO_UPDATE) {\r\n            this.lastTime = this.lastTime || Date.now();\r\n            const timeDelta = (Date.now() - this.lastTime) * 0.001;\r\n\r\n            this.lastTime = Date.now();\r\n            this.update(timeDelta);\r\n        } else {\r\n            this.lastTime = 0;\r\n        }\r\n\r\n        Container.prototype.updateTransform.call(this);\r\n    }\r\n\r\n    /**\r\n     * Create a new sprite to be used with core.RegionAttachment\r\n     *\r\n     * @param slot {spine.Slot} The slot to which the attachment is parented\r\n     * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\r\n     * @private\r\n     */\r\n    createSprite(slot: ISlot, attachment: IRegionAttachment, defName: string) {\r\n        let region = attachment.region;\r\n\r\n        if (slot.hackAttachment === attachment) {\r\n            region = slot.hackRegion;\r\n        }\r\n        const texture = region ? region.texture : null;\r\n        const sprite = this.newSprite(texture);\r\n\r\n        sprite.anchor.set(0.5);\r\n        if (region) {\r\n            this.setSpriteRegion(attachment, sprite, attachment.region);\r\n        }\r\n\r\n        slot.sprites = slot.sprites || {};\r\n        slot.sprites[defName] = sprite;\r\n\r\n        return sprite;\r\n    }\r\n\r\n    /**\r\n     * Creates a Strip from the spine data\r\n     * @param slot {spine.Slot} The slot to which the attachment is parented\r\n     * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\r\n     * @private\r\n     */\r\n    createMesh(slot: ISlot, attachment: IMeshAttachment) {\r\n        let region = attachment.region;\r\n\r\n        if (slot.hackAttachment === attachment) {\r\n            region = slot.hackRegion;\r\n            slot.hackAttachment = null;\r\n            slot.hackRegion = null;\r\n        }\r\n        const strip = this.newMesh(\r\n            region ? region.texture : null,\r\n            new Float32Array(attachment.regionUVs.length),\r\n            attachment.regionUVs,\r\n            new Uint16Array(attachment.triangles),\r\n            DRAW_MODES.TRIANGLES\r\n        );\r\n\r\n        if (typeof (strip as any)._canvasPadding !== 'undefined') {\r\n            (strip as any)._canvasPadding = 1.5;\r\n        }\r\n\r\n        strip.alpha = attachment.color.a;\r\n\r\n        strip.region = attachment.region;\r\n        if (region) {\r\n            this.setMeshRegion(attachment, strip, region);\r\n        }\r\n\r\n        slot.meshes = slot.meshes || {};\r\n        slot.meshes[attachment.id] = strip;\r\n\r\n        return strip;\r\n    }\r\n\r\n    static clippingPolygon: Array<number> = [];\r\n\r\n    // @ts-ignore\r\n    createGraphics(slot: ISlot, clip: IClippingAttachment) {\r\n        const graphics = this.newGraphics();\r\n        const poly = new Polygon([]);\r\n\r\n        graphics.clear();\r\n        graphics.beginFill(0xffffff, 1);\r\n        graphics.drawPolygon(poly as any);\r\n        graphics.renderable = false;\r\n        slot.currentGraphics = graphics;\r\n        slot.clippingContainer = this.newContainer();\r\n        slot.clippingContainer.mask = slot.currentGraphics;\r\n\r\n        return graphics;\r\n    }\r\n\r\n    updateGraphics(slot: ISlot, clip: IClippingAttachment) {\r\n        const geom = slot.currentGraphics.geometry;\r\n        const vertices = (geom.graphicsData[0].shape as Polygon).points;\r\n        const n = clip.worldVerticesLength;\r\n\r\n        vertices.length = n;\r\n        clip.computeWorldVertices(slot, 0, n, vertices, 0, 2);\r\n        geom.invalidate();\r\n    }\r\n\r\n    /**\r\n     * Changes texture in attachment in specific slot.\r\n     *\r\n     * PIXI runtime feature, it was made to satisfy our users.\r\n     *\r\n     * @param slotIndex {number}\r\n     * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\r\n     * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\r\n     * @returns {boolean} Success flag\r\n     */\r\n    hackTextureBySlotIndex(slotIndex: number, texture: Texture = null, size: Rectangle = null) {\r\n        const slot = this.skeleton.slots[slotIndex];\r\n\r\n        if (!slot) {\r\n            return false;\r\n        }\r\n        const attachment: any = slot.getAttachment();\r\n        let region: TextureRegion = attachment.region;\r\n\r\n        if (texture) {\r\n            region = new TextureRegion();\r\n            region.texture = texture;\r\n            region.size = size;\r\n            slot.hackRegion = region;\r\n            slot.hackAttachment = attachment;\r\n        } else {\r\n            slot.hackRegion = null;\r\n            slot.hackAttachment = null;\r\n        }\r\n        if (slot.currentSprite) {\r\n            this.setSpriteRegion(attachment, slot.currentSprite, region);\r\n        } else if (slot.currentMesh) {\r\n            this.setMeshRegion(attachment, slot.currentMesh, region);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Changes texture in attachment in specific slot.\r\n     *\r\n     * PIXI runtime feature, it was made to satisfy our users.\r\n     *\r\n     * @param slotName {string}\r\n     * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\r\n     * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\r\n     * @returns {boolean} Success flag\r\n     */\r\n    hackTextureBySlotName(slotName: string, texture: Texture = null, size: Rectangle = null) {\r\n        const index = this.skeleton.findSlotIndex(slotName);\r\n\r\n        if (index == -1) {\r\n            return false;\r\n        }\r\n\r\n        return this.hackTextureBySlotIndex(index, texture, size);\r\n    }\r\n\r\n    /**\r\n     * Changes texture of an attachment\r\n     *\r\n     * PIXI runtime feature, it was made to satisfy our users.\r\n     *\r\n     * @param slotName {string}\r\n     * @param attachmentName {string}\r\n     * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\r\n     * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\r\n     * @returns {boolean} Success flag\r\n     */\r\n    hackTextureAttachment(slotName: string, attachmentName: string, texture, size: Rectangle = null) {\r\n        // changes the texture of an attachment at the skeleton level\r\n        const slotIndex = this.skeleton.findSlotIndex(slotName);\r\n        const attachment: any = this.skeleton.getAttachmentByName(slotName, attachmentName);\r\n\r\n        attachment.region.texture = texture;\r\n\r\n        const slot = this.skeleton.slots[slotIndex];\r\n\r\n        if (!slot) {\r\n            return false;\r\n        }\r\n\r\n        // gets the currently active attachment in this slot\r\n        const currentAttachment: any = slot.getAttachment();\r\n\r\n        if (attachmentName === currentAttachment.name) {\r\n            // if the attachment we are changing is currently active, change the the live texture\r\n            let region: TextureRegion = attachment.region;\r\n\r\n            if (texture) {\r\n                region = new TextureRegion();\r\n                region.texture = texture;\r\n                region.size = size;\r\n                slot.hackRegion = region;\r\n                slot.hackAttachment = currentAttachment;\r\n            } else {\r\n                slot.hackRegion = null;\r\n                slot.hackAttachment = null;\r\n            }\r\n            if (slot.currentSprite && slot.currentSprite.region != region) {\r\n                this.setSpriteRegion(currentAttachment, slot.currentSprite, region);\r\n                slot.currentSprite.region = region;\r\n            } else if (slot.currentMesh && slot.currentMesh.region != region) {\r\n                this.setMeshRegion(currentAttachment, slot.currentMesh, region);\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    // those methods can be overriden to spawn different classes\r\n    newContainer() {\r\n        return new Container();\r\n    }\r\n\r\n    newSprite(tex: Texture) {\r\n        return new SpineSprite(tex);\r\n    }\r\n\r\n    newGraphics() {\r\n        return new Graphics();\r\n    }\r\n\r\n    newMesh(texture: Texture, vertices?: Float32Array, uvs?: Float32Array, indices?: Uint16Array, drawMode?: number) {\r\n        return new SpineMesh(texture, vertices, uvs, indices, drawMode);\r\n    }\r\n\r\n    transformHack() {\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n     * Hack for pixi-display and pixi-lights. Every attachment name ending with a suffix will be added to different layer\r\n     * @param nameSuffix\r\n     * @param group\r\n     * @param outGroup\r\n     */\r\n    hackAttachmentGroups(nameSuffix: string, group: any, outGroup: any) {\r\n        if (!nameSuffix) {\r\n            return undefined;\r\n        }\r\n        const list_d = [];\r\n        const list_n = [];\r\n\r\n        for (let i = 0, len = this.skeleton.slots.length; i < len; i++) {\r\n            const slot = this.skeleton.slots[i];\r\n            const name = slot.currentSpriteName || slot.currentMeshName || '';\r\n            const target = slot.currentSprite || slot.currentMesh;\r\n\r\n            if (name.endsWith(nameSuffix)) {\r\n                target.parentGroup = group;\r\n                list_n.push(target);\r\n            } else if (outGroup && target) {\r\n                target.parentGroup = outGroup;\r\n                list_d.push(target);\r\n            }\r\n        }\r\n\r\n        return [list_d, list_n];\r\n    }\r\n\r\n    destroy(options?: any): void {\r\n        this.debug = null; // setter will do the cleanup\r\n\r\n        for (let i = 0, n = this.skeleton.slots.length; i < n; i++) {\r\n            const slot = this.skeleton.slots[i];\r\n\r\n            for (const name in slot.meshes) {\r\n                slot.meshes[name].destroy(options);\r\n            }\r\n            slot.meshes = null;\r\n\r\n            for (const name in slot.sprites) {\r\n                slot.sprites[name].destroy(options);\r\n            }\r\n            slot.sprites = null;\r\n        }\r\n\r\n        for (let i = 0, n = this.slotContainers.length; i < n; i++) {\r\n            this.slotContainers[i].destroy(options);\r\n        }\r\n        this.spineData = null;\r\n        this.skeleton = null;\r\n        this.slotContainers = null;\r\n        this.stateData = null;\r\n        this.state = null;\r\n        this.tempClipContainers = null;\r\n\r\n        super.destroy(options);\r\n    }\r\n}\r\n\r\n/**\r\n * The visibility of the spine object. If false the object will not be drawn,\r\n * the updateTransform function will not be called, and the spine will not be automatically updated.\r\n *\r\n * @member {boolean}\r\n * @memberof spine.Spine#\r\n * @default true\r\n */\r\nObject.defineProperty(SpineBase.prototype, 'visible', {\r\n    get() {\r\n        return this._visible;\r\n    },\r\n    set(value: boolean) {\r\n        if (value !== this._visible) {\r\n            this._visible = value;\r\n            if (value) {\r\n                this.lastTime = 0;\r\n            }\r\n        }\r\n    },\r\n});\r\n","import { Container } from '@pixi/display';\r\nimport { Graphics } from '@pixi/graphics';\r\nimport type { IAnimationState, IAnimationStateData } from './core/IAnimation';\r\nimport type { IClippingAttachment, IMeshAttachment, IRegionAttachment, ISkeleton, ISkeletonData, IVertexAttachment } from './core/ISkeleton';\r\nimport type { SpineBase } from './SpineBase';\r\nimport { AttachmentType } from './core/AttachmentType';\r\nimport { SkeletonBoundsBase } from './core/SkeletonBoundsBase';\r\n\r\n/**\r\n * Make a class that extends from this interface to create your own debug renderer.\r\n * @public\r\n */\r\nexport interface ISpineDebugRenderer {\r\n    /**\r\n     * This will be called every frame, after the spine has been updated.\r\n     */\r\n    renderDebug(spine: SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>): void;\r\n\r\n    /**\r\n     *  This is called when the `spine.debug` object is set to null or when the spine is destroyed.\r\n     */\r\n    unregisterSpine(spine: SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>): void;\r\n\r\n    /**\r\n     * This is called when the `spine.debug` object is set to a new instance of a debug renderer.\r\n     */\r\n    registerSpine(spine: SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>): void;\r\n}\r\n\r\ntype DebugDisplayObjects = {\r\n    bones: Container;\r\n    skeletonXY: Graphics;\r\n    regionAttachmentsShape: Graphics;\r\n    meshTrianglesLine: Graphics;\r\n    meshHullLine: Graphics;\r\n    clippingPolygon: Graphics;\r\n    boundingBoxesRect: Graphics;\r\n    boundingBoxesCircle: Graphics;\r\n    boundingBoxesPolygon: Graphics;\r\n    pathsCurve: Graphics;\r\n    pathsLine: Graphics;\r\n    parentDebugContainer: Container;\r\n};\r\n\r\n/**\r\n * This is a debug renderer that uses PixiJS Graphics under the hood.\r\n * @public\r\n */\r\nexport class SpineDebugRenderer implements ISpineDebugRenderer {\r\n    private registeredSpines: Map<SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>, DebugDisplayObjects> = new Map();\r\n\r\n    public drawDebug = true;\r\n    public drawMeshHull = true;\r\n    public drawMeshTriangles = true;\r\n    public drawBones = true;\r\n    public drawPaths = true;\r\n    public drawBoundingBoxes = true;\r\n    public drawClipping = true;\r\n    public drawRegionAttachments = true;\r\n\r\n    public lineWidth = 1;\r\n    public regionAttachmentsColor = 0x0078ff;\r\n    public meshHullColor = 0x0078ff;\r\n    public meshTrianglesColor = 0xffcc00;\r\n    public clippingPolygonColor = 0xff00ff;\r\n    public boundingBoxesRectColor = 0x00ff00;\r\n    public boundingBoxesPolygonColor = 0x00ff00;\r\n    public boundingBoxesCircleColor = 0x00ff00;\r\n    public pathsCurveColor = 0xff0000;\r\n    public pathsLineColor = 0xff00ff;\r\n    public skeletonXYColor = 0xff0000;\r\n    public bonesColor = 0x00eecc;\r\n\r\n    /**\r\n     * The debug is attached by force to each spine object. So we need to create it inside the spine when we get the first update\r\n     */\r\n    public registerSpine(spine: SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>) {\r\n        if (this.registeredSpines.has(spine)) {\r\n            console.warn('SpineDebugRenderer.registerSpine() - this spine is already registered!', spine);\r\n        }\r\n        const debugDisplayObjects = {\r\n            parentDebugContainer: new Container(),\r\n            bones: new Container(),\r\n            skeletonXY: new Graphics(),\r\n            regionAttachmentsShape: new Graphics(),\r\n            meshTrianglesLine: new Graphics(),\r\n            meshHullLine: new Graphics(),\r\n            clippingPolygon: new Graphics(),\r\n            boundingBoxesRect: new Graphics(),\r\n            boundingBoxesCircle: new Graphics(),\r\n            boundingBoxesPolygon: new Graphics(),\r\n            pathsCurve: new Graphics(),\r\n            pathsLine: new Graphics(),\r\n        };\r\n\r\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.bones);\r\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.skeletonXY);\r\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.regionAttachmentsShape);\r\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.meshTrianglesLine);\r\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.meshHullLine);\r\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.clippingPolygon);\r\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.boundingBoxesRect);\r\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.boundingBoxesCircle);\r\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.boundingBoxesPolygon);\r\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.pathsCurve);\r\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.pathsLine);\r\n\r\n        spine.addChild(debugDisplayObjects.parentDebugContainer);\r\n\r\n        this.registeredSpines.set(spine, debugDisplayObjects);\r\n    }\r\n    public renderDebug(spine: SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>): void {\r\n        if (!this.registeredSpines.has(spine)) {\r\n            // This should never happen. Spines are registered when you assign spine.debug\r\n            this.registerSpine(spine);\r\n        }\r\n\r\n        const debugDisplayObjects = this.registeredSpines.get(spine);\r\n\r\n        debugDisplayObjects.skeletonXY.clear();\r\n        debugDisplayObjects.regionAttachmentsShape.clear();\r\n        debugDisplayObjects.meshTrianglesLine.clear();\r\n        debugDisplayObjects.meshHullLine.clear();\r\n        debugDisplayObjects.clippingPolygon.clear();\r\n        debugDisplayObjects.boundingBoxesRect.clear();\r\n        debugDisplayObjects.boundingBoxesCircle.clear();\r\n        debugDisplayObjects.boundingBoxesPolygon.clear();\r\n        debugDisplayObjects.pathsCurve.clear();\r\n        debugDisplayObjects.pathsLine.clear();\r\n\r\n        for (let len = debugDisplayObjects.bones.children.length; len > 0; len--) {\r\n            debugDisplayObjects.bones.children[len - 1].destroy({ children: true, texture: true, baseTexture: true });\r\n        }\r\n\r\n        const scale = spine.scale.x || spine.scale.y || 1;\r\n        const lineWidth = this.lineWidth / scale;\r\n\r\n        if (this.drawBones) {\r\n            this.drawBonesFunc(spine, debugDisplayObjects, lineWidth, scale);\r\n        }\r\n\r\n        if (this.drawPaths) {\r\n            this.drawPathsFunc(spine, debugDisplayObjects, lineWidth);\r\n        }\r\n\r\n        if (this.drawBoundingBoxes) {\r\n            this.drawBoundingBoxesFunc(spine, debugDisplayObjects, lineWidth);\r\n        }\r\n\r\n        if (this.drawClipping) {\r\n            this.drawClippingFunc(spine, debugDisplayObjects, lineWidth);\r\n        }\r\n\r\n        if (this.drawMeshHull || this.drawMeshTriangles) {\r\n            this.drawMeshHullAndMeshTriangles(spine, debugDisplayObjects, lineWidth);\r\n        }\r\n\r\n        if (this.drawRegionAttachments) {\r\n            this.drawRegionAttachmentsFunc(spine, debugDisplayObjects, lineWidth);\r\n        }\r\n    }\r\n\r\n    private drawBonesFunc(\r\n        spine: SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>,\r\n        debugDisplayObjects: DebugDisplayObjects,\r\n        lineWidth: number,\r\n        scale: number\r\n    ): void {\r\n        const skeleton = spine.skeleton;\r\n        const skeletonX = skeleton.x;\r\n        const skeletonY = skeleton.y;\r\n        const bones = skeleton.bones;\r\n\r\n        debugDisplayObjects.skeletonXY.lineStyle(lineWidth, this.skeletonXYColor, 1);\r\n\r\n        for (let i = 0, len = bones.length; i < len; i++) {\r\n            const bone = bones[i];\r\n            const boneLen = bone.data.length;\r\n            const starX = skeletonX + bone.matrix.tx;\r\n            const starY = skeletonY + bone.matrix.ty;\r\n            const endX = skeletonX + boneLen * bone.matrix.a + bone.matrix.tx;\r\n            const endY = skeletonY + boneLen * bone.matrix.b + bone.matrix.ty;\r\n\r\n            if (bone.data.name === 'root' || bone.data.parent === null) {\r\n                continue;\r\n            }\r\n\r\n            // Triangle calculation formula\r\n            // area: A=sqrt((a+b+c)*(-a+b+c)*(a-b+c)*(a+b-c))/4\r\n            // alpha: alpha=acos((pow(b, 2)+pow(c, 2)-pow(a, 2))/(2*b*c))\r\n            // beta: beta=acos((pow(a, 2)+pow(c, 2)-pow(b, 2))/(2*a*c))\r\n            // gamma: gamma=acos((pow(a, 2)+pow(b, 2)-pow(c, 2))/(2*a*b))\r\n\r\n            const w = Math.abs(starX - endX);\r\n            const h = Math.abs(starY - endY);\r\n            // a = w, // side length a\r\n            const a2 = Math.pow(w, 2); // square root of side length a\r\n            const b = h; // side length b\r\n            const b2 = Math.pow(h, 2); // square root of side length b\r\n            const c = Math.sqrt(a2 + b2); // side length c\r\n            const c2 = Math.pow(c, 2); // square root of side length c\r\n            const rad = Math.PI / 180;\r\n            // A = Math.acos([a2 + c2 - b2] / [2 * a * c]) || 0, // Angle A\r\n            // C = Math.acos([a2 + b2 - c2] / [2 * a * b]) || 0, // C angle\r\n            const B = Math.acos((c2 + b2 - a2) / (2 * b * c)) || 0; // angle of corner B\r\n\r\n            if (c === 0) {\r\n                continue;\r\n            }\r\n\r\n            const gp = new Graphics();\r\n\r\n            debugDisplayObjects.bones.addChild(gp);\r\n\r\n            // draw bone\r\n            const refRation = c / 50 / scale;\r\n\r\n            gp.beginFill(this.bonesColor, 1);\r\n            gp.drawPolygon(0, 0, 0 - refRation, c - refRation * 3, 0, c - refRation, 0 + refRation, c - refRation * 3);\r\n            gp.endFill();\r\n            gp.x = starX;\r\n            gp.y = starY;\r\n            gp.pivot.y = c;\r\n\r\n            // Calculate bone rotation angle\r\n            let rotation = 0;\r\n\r\n            if (starX < endX && starY < endY) {\r\n                // bottom right\r\n                rotation = -B + 180 * rad;\r\n            } else if (starX > endX && starY < endY) {\r\n                // bottom left\r\n                rotation = 180 * rad + B;\r\n            } else if (starX > endX && starY > endY) {\r\n                // top left\r\n                rotation = -B;\r\n            } else if (starX < endX && starY > endY) {\r\n                // bottom left\r\n                rotation = B;\r\n            } else if (starY === endY && starX < endX) {\r\n                // To the right\r\n                rotation = 90 * rad;\r\n            } else if (starY === endY && starX > endX) {\r\n                // go left\r\n                rotation = -90 * rad;\r\n            } else if (starX === endX && starY < endY) {\r\n                // down\r\n                rotation = 180 * rad;\r\n            } else if (starX === endX && starY > endY) {\r\n                // up\r\n                rotation = 0;\r\n            }\r\n            gp.rotation = rotation;\r\n\r\n            // Draw the starting rotation point of the bone\r\n            gp.lineStyle(lineWidth + refRation / 2.4, this.bonesColor, 1);\r\n            gp.beginFill(0x000000, 0.6);\r\n            gp.drawCircle(0, c, refRation * 1.2);\r\n            gp.endFill();\r\n        }\r\n\r\n        // Draw the skeleton starting point \"X\" form\r\n        const startDotSize = lineWidth * 3;\r\n\r\n        debugDisplayObjects.skeletonXY.moveTo(skeletonX - startDotSize, skeletonY - startDotSize);\r\n        debugDisplayObjects.skeletonXY.lineTo(skeletonX + startDotSize, skeletonY + startDotSize);\r\n        debugDisplayObjects.skeletonXY.moveTo(skeletonX + startDotSize, skeletonY - startDotSize);\r\n        debugDisplayObjects.skeletonXY.lineTo(skeletonX - startDotSize, skeletonY + startDotSize);\r\n    }\r\n\r\n    private drawRegionAttachmentsFunc(\r\n        spine: SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>,\r\n        debugDisplayObjects: DebugDisplayObjects,\r\n        lineWidth: number\r\n    ): void {\r\n        const skeleton = spine.skeleton;\r\n        const slots = skeleton.slots;\r\n\r\n        debugDisplayObjects.regionAttachmentsShape.lineStyle(lineWidth, this.regionAttachmentsColor, 1);\r\n\r\n        for (let i = 0, len = slots.length; i < len; i++) {\r\n            const slot = slots[i];\r\n            const attachment = slot.getAttachment();\r\n\r\n            if (attachment == null || attachment.type !== AttachmentType.Region) {\r\n                continue;\r\n            }\r\n\r\n            const regionAttachment = attachment as IRegionAttachment & {\r\n                computeWorldVertices: (slot: unknown, worldVertices: unknown, offset: unknown, stride: unknown) => void;\r\n                updateOffset?: () => void;\r\n            };\r\n\r\n            const vertices = new Float32Array(8);\r\n\r\n            if (regionAttachment.updateOffset) regionAttachment.updateOffset(); // We don't need this on all versions\r\n\r\n            regionAttachment.computeWorldVertices(slot, vertices, 0, 2);\r\n            debugDisplayObjects.regionAttachmentsShape.drawPolygon(Array.from(vertices.slice(0, 8)));\r\n        }\r\n    }\r\n\r\n    private drawMeshHullAndMeshTriangles(\r\n        spine: SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>,\r\n        debugDisplayObjects: DebugDisplayObjects,\r\n        lineWidth: number\r\n    ): void {\r\n        const skeleton = spine.skeleton;\r\n        const slots = skeleton.slots;\r\n\r\n        debugDisplayObjects.meshHullLine.lineStyle(lineWidth, this.meshHullColor, 1);\r\n        debugDisplayObjects.meshTrianglesLine.lineStyle(lineWidth, this.meshTrianglesColor, 1);\r\n\r\n        for (let i = 0, len = slots.length; i < len; i++) {\r\n            const slot = slots[i];\r\n\r\n            if (!slot.bone.active) {\r\n                continue;\r\n            }\r\n            const attachment = slot.getAttachment();\r\n\r\n            if (attachment == null || attachment.type !== AttachmentType.Mesh) {\r\n                continue;\r\n            }\r\n\r\n            const meshAttachment: IMeshAttachment = attachment as IMeshAttachment;\r\n\r\n            const vertices = new Float32Array(meshAttachment.worldVerticesLength);\r\n            const triangles = meshAttachment.triangles;\r\n            let hullLength = meshAttachment.hullLength;\r\n\r\n            meshAttachment.computeWorldVertices(slot, 0, meshAttachment.worldVerticesLength, vertices, 0, 2);\r\n            // draw the skinned mesh (triangle)\r\n            if (this.drawMeshTriangles) {\r\n                for (let i = 0, len = triangles.length; i < len; i += 3) {\r\n                    const v1 = triangles[i] * 2;\r\n                    const v2 = triangles[i + 1] * 2;\r\n                    const v3 = triangles[i + 2] * 2;\r\n\r\n                    debugDisplayObjects.meshTrianglesLine.moveTo(vertices[v1], vertices[v1 + 1]);\r\n                    debugDisplayObjects.meshTrianglesLine.lineTo(vertices[v2], vertices[v2 + 1]);\r\n                    debugDisplayObjects.meshTrianglesLine.lineTo(vertices[v3], vertices[v3 + 1]);\r\n                }\r\n            }\r\n\r\n            // draw skin border\r\n            if (this.drawMeshHull && hullLength > 0) {\r\n                hullLength = (hullLength >> 1) * 2;\r\n                let lastX = vertices[hullLength - 2];\r\n                let lastY = vertices[hullLength - 1];\r\n\r\n                for (let i = 0, len = hullLength; i < len; i += 2) {\r\n                    const x = vertices[i];\r\n                    const y = vertices[i + 1];\r\n\r\n                    debugDisplayObjects.meshHullLine.moveTo(x, y);\r\n                    debugDisplayObjects.meshHullLine.lineTo(lastX, lastY);\r\n                    lastX = x;\r\n                    lastY = y;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private drawClippingFunc(spine: SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>, debugDisplayObjects: DebugDisplayObjects, lineWidth: number): void {\r\n        const skeleton = spine.skeleton;\r\n        const slots = skeleton.slots;\r\n\r\n        debugDisplayObjects.clippingPolygon.lineStyle(lineWidth, this.clippingPolygonColor, 1);\r\n        for (let i = 0, len = slots.length; i < len; i++) {\r\n            const slot = slots[i];\r\n\r\n            if (!slot.bone.active) {\r\n                continue;\r\n            }\r\n            const attachment = slot.getAttachment();\r\n\r\n            if (attachment == null || attachment.type !== AttachmentType.Clipping) {\r\n                continue;\r\n            }\r\n\r\n            const clippingAttachment: IClippingAttachment = attachment as IClippingAttachment;\r\n\r\n            const nn = clippingAttachment.worldVerticesLength;\r\n            const world = new Float32Array(nn);\r\n\r\n            clippingAttachment.computeWorldVertices(slot, 0, nn, world, 0, 2);\r\n            debugDisplayObjects.clippingPolygon.drawPolygon(Array.from(world));\r\n        }\r\n    }\r\n\r\n    private drawBoundingBoxesFunc(\r\n        spine: SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>,\r\n        debugDisplayObjects: DebugDisplayObjects,\r\n        lineWidth: number\r\n    ): void {\r\n        // draw the total outline of the bounding box\r\n        debugDisplayObjects.boundingBoxesRect.lineStyle(lineWidth, this.boundingBoxesRectColor, 5);\r\n\r\n        const bounds = new SkeletonBoundsBase();\r\n\r\n        bounds.update(spine.skeleton, true);\r\n        debugDisplayObjects.boundingBoxesRect.drawRect(bounds.minX, bounds.minY, bounds.getWidth(), bounds.getHeight());\r\n\r\n        const polygons = bounds.polygons;\r\n        const drawPolygon = (polygonVertices: ArrayLike<number>, _offset: unknown, count: number): void => {\r\n            debugDisplayObjects.boundingBoxesPolygon.lineStyle(lineWidth, this.boundingBoxesPolygonColor, 1);\r\n            debugDisplayObjects.boundingBoxesPolygon.beginFill(this.boundingBoxesPolygonColor, 0.1);\r\n\r\n            if (count < 3) {\r\n                throw new Error('Polygon must contain at least 3 vertices');\r\n            }\r\n            const paths = [];\r\n            const dotSize = lineWidth * 2;\r\n\r\n            for (let i = 0, len = polygonVertices.length; i < len; i += 2) {\r\n                const x1 = polygonVertices[i];\r\n                const y1 = polygonVertices[i + 1];\r\n\r\n                // draw the bounding box node\r\n                debugDisplayObjects.boundingBoxesCircle.lineStyle(0);\r\n                debugDisplayObjects.boundingBoxesCircle.beginFill(this.boundingBoxesCircleColor);\r\n                debugDisplayObjects.boundingBoxesCircle.drawCircle(x1, y1, dotSize);\r\n                debugDisplayObjects.boundingBoxesCircle.endFill();\r\n\r\n                paths.push(x1, y1);\r\n            }\r\n\r\n            // draw the bounding box area\r\n            debugDisplayObjects.boundingBoxesPolygon.drawPolygon(paths);\r\n            debugDisplayObjects.boundingBoxesPolygon.endFill();\r\n        };\r\n\r\n        for (let i = 0, len = polygons.length; i < len; i++) {\r\n            const polygon = polygons[i];\r\n\r\n            drawPolygon(polygon, 0, polygon.length);\r\n        }\r\n    }\r\n\r\n    private drawPathsFunc(spine: SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>, debugDisplayObjects: DebugDisplayObjects, lineWidth: number): void {\r\n        const skeleton = spine.skeleton;\r\n        const slots = skeleton.slots;\r\n\r\n        debugDisplayObjects.pathsCurve.lineStyle(lineWidth, this.pathsCurveColor, 1);\r\n        debugDisplayObjects.pathsLine.lineStyle(lineWidth, this.pathsLineColor, 1);\r\n\r\n        for (let i = 0, len = slots.length; i < len; i++) {\r\n            const slot = slots[i];\r\n\r\n            if (!slot.bone.active) {\r\n                continue;\r\n            }\r\n            const attachment = slot.getAttachment();\r\n\r\n            if (attachment == null || attachment.type !== AttachmentType.Path) {\r\n                continue;\r\n            }\r\n\r\n            const pathAttachment = attachment as IVertexAttachment & { closed: boolean };\r\n            let nn = pathAttachment.worldVerticesLength;\r\n            const world = new Float32Array(nn);\r\n\r\n            pathAttachment.computeWorldVertices(slot, 0, nn, world, 0, 2);\r\n            let x1 = world[2];\r\n            let y1 = world[3];\r\n            let x2 = 0;\r\n            let y2 = 0;\r\n\r\n            if (pathAttachment.closed) {\r\n                const cx1 = world[0];\r\n                const cy1 = world[1];\r\n                const cx2 = world[nn - 2];\r\n                const cy2 = world[nn - 1];\r\n\r\n                x2 = world[nn - 4];\r\n                y2 = world[nn - 3];\r\n\r\n                // curve\r\n                debugDisplayObjects.pathsCurve.moveTo(x1, y1);\r\n                debugDisplayObjects.pathsCurve.bezierCurveTo(cx1, cy1, cx2, cy2, x2, y2);\r\n\r\n                // handle\r\n                debugDisplayObjects.pathsLine.moveTo(x1, y1);\r\n                debugDisplayObjects.pathsLine.lineTo(cx1, cy1);\r\n                debugDisplayObjects.pathsLine.moveTo(x2, y2);\r\n                debugDisplayObjects.pathsLine.lineTo(cx2, cy2);\r\n            }\r\n            nn -= 4;\r\n            for (let ii = 4; ii < nn; ii += 6) {\r\n                const cx1 = world[ii];\r\n                const cy1 = world[ii + 1];\r\n                const cx2 = world[ii + 2];\r\n                const cy2 = world[ii + 3];\r\n\r\n                x2 = world[ii + 4];\r\n                y2 = world[ii + 5];\r\n                // curve\r\n                debugDisplayObjects.pathsCurve.moveTo(x1, y1);\r\n                debugDisplayObjects.pathsCurve.bezierCurveTo(cx1, cy1, cx2, cy2, x2, y2);\r\n\r\n                // handle\r\n                debugDisplayObjects.pathsLine.moveTo(x1, y1);\r\n                debugDisplayObjects.pathsLine.lineTo(cx1, cy1);\r\n                debugDisplayObjects.pathsLine.moveTo(x2, y2);\r\n                debugDisplayObjects.pathsLine.lineTo(cx2, cy2);\r\n                x1 = x2;\r\n                y1 = y2;\r\n            }\r\n        }\r\n    }\r\n\r\n    public unregisterSpine(spine: SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>): void {\r\n        if (!this.registeredSpines.has(spine)) {\r\n            console.warn(\"SpineDebugRenderer.unregisterSpine() - spine is not registered, can't unregister!\", spine);\r\n        }\r\n        const debugDisplayObjects = this.registeredSpines.get(spine);\r\n\r\n        debugDisplayObjects.parentDebugContainer.destroy({ baseTexture: true, children: true, texture: true });\r\n        this.registeredSpines.delete(spine);\r\n    }\r\n}\r\n"],"names":["AttachmentType","i","BinaryInput","data","strings","index","buffer","value","optimizePositive","b","result","byteCount","chars","MixBlend","t","MixDirection","PositionMode","RotateMode","TransformMode","filterFromString","text","TextureFilter","wrapFromString","TextureWrap","n","TextureRegion","tex","RegionFields","TextureAtlas","atlasText","textureLoader","callback","name","texture","pages","page","TextureAtlasPage","baseTexture","region","TextureAtlasRegion","textures","stripExtension","key","reader","TextureAtlasReader","entry","pageFields","regionFields","rotateValue","rotate","line","iterateParser","field","ALPHA_MODES","atlasRegion","names","values","count","entryValues","resolution","swapWH","frame","Rectangle","orig","trim","Texture","colon","lastMatch","comma","filter","SCALE_MODES","MIPMAP_MODES","IntSet","contains","StringSet","oldSize","_Color","r","g","a","c","hex","color","Color","_MathUtils","min","max","degrees","x","y","mode","u","d","MathUtils","Interpolation","start","end","Pow","power","PowOut","_Utils","source","sourceStart","dest","destStart","numElements","j","array","fromIndex","toIndex","size","defaultValue","alpha","blend","element","identity","type","Utils","DebugUtils","skeleton","bone","mat","Pool","instantiator","item","items","Vector2","len","TimeKeeper","now","WindowedMean","windowSize","mean","SkeletonBoundsBase","updateAabb","boundingBoxes","polygons","polygonPool","slots","slotCount","slot","attachment","boundingBox","polygon","minX","minY","maxX","maxY","vertices","ii","nn","x1","y1","x2","y2","m","bounds","prevIndex","inside","vertexY","prevY","vertexX","width12","height12","det1","x3","y3","x4","y4","det2","width34","height34","det3","settings","tempRgb","SpineSprite","Sprite","SpineMesh","SimpleMesh","uvs","indices","drawMode","_SpineBase","Container","spineData","slotContainer","spriteName","sprite","mesh","_a","utils","dt","delayLimit","globalClr","light","dark","spriteColor","attColor","transform","Transform","id","meshId","r0","g0","b0","drawOrder","clippingAttachment","clippingContainer","timeDelta","defName","strip","DRAW_MODES","clip","graphics","poly","Polygon","geom","slotIndex","slotName","attachmentName","currentAttachment","Graphics","nameSuffix","group","outGroup","list_d","list_n","target","options","SpineBase","SpineDebugRenderer","spine","debugDisplayObjects","scale","lineWidth","skeletonX","skeletonY","bones","boneLen","starX","starY","endX","endY","w","h","a2","b2","c2","rad","B","gp","refRation","rotation","startDotSize","regionAttachment","meshAttachment","triangles","hullLength","v1","v2","v3","lastX","lastY","world","drawPolygon","polygonVertices","_offset","paths","dotSize","pathAttachment","cx1","cy1","cx2","cy2"],"mappings":"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"}