/*!
 * @pixi-spine/runtime-3.4 - v4.0.3
 * Compiled Tue, 13 Jun 2023 12:45:15 UTC
 *
 * @pixi-spine/runtime-3.4 is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 * 
 * Copyright 2023, Ivan Igorevich Popelyshev <ivan.popelyshev@gmail.com>, All Rights Reserved
 */this.PIXI=this.PIXI||{},this.PIXI.spine34=function(C,u,wt){"use strict";class Gt{constructor(t){if(t==null)throw new Error("name cannot be null.");this.name=t}}const me=class extends Gt{constructor(e){super(e),this.id=(me.nextID++&65535)<<11,this.worldVerticesLength=0,this.deformAttachment=this}computeWorldVerticesOld(e,t){this.computeWorldVertices(e,0,this.worldVerticesLength,t,0,2)}computeWorldVertices(e,t,n,s,a,h){n=a+(n>>1)*h;const d=e.bone.skeleton,o=e.deform;let i=this.vertices;const r=this.bones;if(r==null){o.length>0&&(i=o);const c=e.bone.matrix,g=c.tx,M=c.ty,p=c.a,x=c.c,E=c.b,w=c.d;for(let S=t,T=a;T<n;S+=2,T+=h){const I=i[S],A=i[S+1];s[T]=I*p+A*x+g,s[T+1]=I*E+A*w+M}return}let l=0,m=0;for(let c=0;c<t;c+=2){const g=r[l];l+=g+1,m+=g}const f=d.bones;if(o.length==0)for(let c=a,g=m*3;c<n;c+=h){let M=0,p=0,x=r[l++];for(x+=l;l<x;l++,g+=3){const E=f[r[l]].matrix,w=i[g],S=i[g+1],T=i[g+2];M+=(w*E.a+S*E.c+E.tx)*T,p+=(w*E.b+S*E.d+E.ty)*T}s[c]=M,s[c+1]=p}else{const c=o;for(let g=a,M=m*3,p=m<<1;g<n;g+=h){let x=0,E=0,w=r[l++];for(w+=l;l<w;l++,M+=3,p+=2){const S=f[r[l]].matrix,T=i[M]+c[p],I=i[M+1]+c[p+1],A=i[M+2];x+=(T*S.a+I*S.c+S.tx)*A,E+=(T*S.b+I*S.d+S.ty)*A}s[g]=x,s[g+1]=E}}}copyTo(e){this.bones!=null?(e.bones=new Array(this.bones.length),u.Utils.arrayCopy(this.bones,0,e.bones,0,this.bones.length)):e.bones=null,this.vertices!=null?(e.vertices=u.Utils.newFloatArray(this.vertices.length),u.Utils.arrayCopy(this.vertices,0,e.vertices,0,this.vertices.length)):e.vertices=null,e.worldVerticesLength=this.worldVerticesLength,e.deformAttachment=this.deformAttachment}};let At=me;At.nextID=0;class Xt extends At{constructor(t){super(t),this.type=u.AttachmentType.BoundingBox,this.color=new u.Color(1,1,1,1)}copy(){const t=new Xt(this.name);return this.copyTo(t),t.color.setFromColor(this.color),t}}class Yt extends At{constructor(t){super(t),this.type=u.AttachmentType.Clipping,this.color=new u.Color(.2275,.2275,.8078,1)}copy(){const t=new Yt(this.name);return this.copyTo(t),t.endSlot=this.endSlot,t.color.setFromColor(this.color),t}}class Ct extends At{constructor(t){super(t),this.type=u.AttachmentType.Mesh,this.color=new u.Color(1,1,1,1),this.tempColor=new u.Color(0,0,0,0)}getParentMesh(){return this.parentMesh}setParentMesh(t){this.parentMesh=t,t!=null&&(this.bones=t.bones,this.vertices=t.vertices,this.worldVerticesLength=t.worldVerticesLength,this.regionUVs=t.regionUVs,this.triangles=t.triangles,this.hullLength=t.hullLength,this.worldVerticesLength=t.worldVerticesLength)}copy(){if(this.parentMesh!=null)return this.newLinkedMesh();const t=new Ct(this.name);return t.region=this.region,t.path=this.path,t.color.setFromColor(this.color),this.copyTo(t),t.regionUVs=new Float32Array(this.regionUVs.length),u.Utils.arrayCopy(this.regionUVs,0,t.regionUVs,0,this.regionUVs.length),t.triangles=new Array(this.triangles.length),u.Utils.arrayCopy(this.triangles,0,t.triangles,0,this.triangles.length),t.hullLength=this.hullLength,this.edges!=null&&(t.edges=new Array(this.edges.length),u.Utils.arrayCopy(this.edges,0,t.edges,0,this.edges.length)),t.width=this.width,t.height=this.height,t}newLinkedMesh(){const t=new Ct(this.name);return t.region=this.region,t.path=this.path,t.color.setFromColor(this.color),t.deformAttachment=this.deformAttachment,t.setParentMesh(this.parentMesh!=null?this.parentMesh:this),t}}class kt extends At{constructor(t){super(t),this.type=u.AttachmentType.Path,this.closed=!1,this.constantSpeed=!1,this.color=new u.Color(1,1,1,1)}copy(){const t=new kt(this.name);return this.copyTo(t),t.lengths=new Array(this.lengths.length),u.Utils.arrayCopy(this.lengths,0,t.lengths,0,this.lengths.length),t.closed=closed,t.constantSpeed=this.constantSpeed,t.color.setFromColor(this.color),t}}class Lt extends At{constructor(t){super(t),this.type=u.AttachmentType.Point,this.color=new u.Color(.38,.94,0,1)}computeWorldPosition(t,n){const s=t.matrix;return n.x=this.x*s.a+this.y*s.c+t.worldX,n.y=this.x*s.b+this.y*s.d+t.worldY,n}computeWorldRotation(t){const n=t.matrix,s=u.MathUtils.cosDeg(this.rotation),a=u.MathUtils.sinDeg(this.rotation),h=s*n.a+a*n.c,d=s*n.b+a*n.d;return Math.atan2(d,h)*u.MathUtils.radDeg}copy(){const t=new Lt(this.name);return t.x=this.x,t.y=this.y,t.rotation=this.rotation,t.color.setFromColor(this.color),t}}class jt{constructor(t,n){if(this.deform=new Array,t==null)throw new Error("data cannot be null.");if(n==null)throw new Error("bone cannot be null.");this.data=t,this.bone=n,this.color=new u.Color,this.darkColor=t.darkColor==null?null:new u.Color,this.setToSetupPose(),this.blendMode=this.data.blendMode}getAttachment(){return this.attachment}setAttachment(t){this.attachment!=t&&(this.attachment=t,this.attachmentTime=this.bone.skeleton.time,this.deform.length=0)}setAttachmentTime(t){this.attachmentTime=this.bone.skeleton.time-t}getAttachmentTime(){return this.bone.skeleton.time-this.attachmentTime}setToSetupPose(){this.color.setFromColor(this.data.color),this.darkColor!=null&&this.darkColor.setFromColor(this.data.darkColor),this.data.attachmentName==null?this.attachment=null:(this.attachment=null,this.setAttachment(this.bone.skeleton.getAttachment(this.data.index,this.data.attachmentName)))}}const K=class extends Gt{constructor(e){super(e),this.type=u.AttachmentType.Region,this.x=0,this.y=0,this.scaleX=1,this.scaleY=1,this.rotation=0,this.width=0,this.height=0,this.color=new u.Color(1,1,1,1),this.offset=u.Utils.newFloatArray(8),this.uvs=u.Utils.newFloatArray(8),this.tempColor=new u.Color(1,1,1,1)}updateOffset(){const e=this.width/this.region.originalWidth*this.scaleX,t=this.height/this.region.originalHeight*this.scaleY,n=-this.width/2*this.scaleX+this.region.offsetX*e,s=-this.height/2*this.scaleY+this.region.offsetY*t,a=n+this.region.width*e,h=s+this.region.height*t,d=this.rotation*Math.PI/180,o=Math.cos(d),i=Math.sin(d),r=n*o+this.x,l=n*i,m=s*o+this.y,f=s*i,c=a*o+this.x,g=a*i,M=h*o+this.y,p=h*i,x=this.offset;x[K.OX1]=r-f,x[K.OY1]=m+l,x[K.OX2]=r-p,x[K.OY2]=M+l,x[K.OX3]=c-p,x[K.OY3]=M+g,x[K.OX4]=c-f,x[K.OY4]=m+g}setRegion(e){this.region=e;const t=this.uvs;e.rotate?(t[2]=e.u,t[3]=e.v2,t[4]=e.u,t[5]=e.v,t[6]=e.u2,t[7]=e.v,t[0]=e.u2,t[1]=e.v2):(t[0]=e.u,t[1]=e.v2,t[2]=e.u,t[3]=e.v,t[4]=e.u2,t[5]=e.v,t[6]=e.u2,t[7]=e.v2)}computeWorldVertices(e,t,n,s){const a=this.offset,h=e instanceof jt?e.bone.matrix:e.matrix,d=h.tx,o=h.ty,i=h.a,r=h.c,l=h.b,m=h.d;let f=0,c=0;f=a[K.OX1],c=a[K.OY1],t[n]=f*i+c*r+d,t[n+1]=f*l+c*m+o,n+=s,f=a[K.OX2],c=a[K.OY2],t[n]=f*i+c*r+d,t[n+1]=f*l+c*m+o,n+=s,f=a[K.OX3],c=a[K.OY3],t[n]=f*i+c*r+d,t[n+1]=f*l+c*m+o,n+=s,f=a[K.OX4],c=a[K.OY4],t[n]=f*i+c*r+d,t[n+1]=f*l+c*m+o}copy(){const e=new K(this.name);return e.region=this.region,e.rendererObject=this.rendererObject,e.path=this.path,e.x=this.x,e.y=this.y,e.scaleX=this.scaleX,e.scaleY=this.scaleY,e.rotation=this.rotation,e.width=this.width,e.height=this.height,u.Utils.arrayCopy(this.uvs,0,e.uvs,0,8),u.Utils.arrayCopy(this.offset,0,e.offset,0,8),e.color.setFromColor(this.color),e}};let B=K;B.OX1=0,B.OY1=1,B.OX2=2,B.OY2=3,B.OX3=4,B.OY3=5,B.OX4=6,B.OY4=7,B.X1=0,B.Y1=1,B.C1R=2,B.C1G=3,B.C1B=4,B.C1A=5,B.U1=6,B.V1=7,B.X2=8,B.Y2=9,B.C2R=10,B.C2G=11,B.C2B=12,B.C2A=13,B.U2=14,B.V2=15,B.X3=16,B.Y3=17,B.C3R=18,B.C3G=19,B.C3B=20,B.C3A=21,B.U3=22,B.V3=23,B.X4=24,B.Y4=25,B.C4R=26,B.C4G=27,B.C4B=28,B.C4A=29,B.U4=30,B.V4=31;class Ce{constructor(t,n){this.jitterX=0,this.jitterY=0,this.jitterX=t,this.jitterY=n}begin(t){}transform(t,n,s,a){t.x+=u.MathUtils.randomTriangular(-this.jitterX,this.jitterY),t.y+=u.MathUtils.randomTriangular(-this.jitterX,this.jitterY)}end(){}}const fe=class{constructor(e){this.centerX=0,this.centerY=0,this.radius=0,this.angle=0,this.worldX=0,this.worldY=0,this.radius=e}begin(e){this.worldX=e.x+this.centerX,this.worldY=e.y+this.centerY}transform(e,t,n,s){const a=this.angle*u.MathUtils.degreesToRadians,h=e.x-this.worldX,d=e.y-this.worldY,o=Math.sqrt(h*h+d*d);if(o<this.radius){const i=fe.interpolation.apply(0,a,(this.radius-o)/this.radius),r=Math.cos(i),l=Math.sin(i);e.x=r*h-l*d+this.worldX,e.y=l*h+r*d+this.worldY}}end(){}};let ge=fe;ge.interpolation=new u.PowOut(2);class G{constructor(t,n,s){if(t==null)throw new Error("name cannot be null.");if(n==null)throw new Error("timelines cannot be null.");this.name=t,this.timelines=n,this.timelineIds=[];for(let a=0;a<n.length;a++)this.timelineIds[n[a].getPropertyId()]=!0;this.duration=s}hasTimeline(t){return this.timelineIds[t]==!0}apply(t,n,s,a,h,d,o,i){if(t==null)throw new Error("skeleton cannot be null.");a&&this.duration!=0&&(s%=this.duration,n>0&&(n%=this.duration));const r=this.timelines;for(let l=0,m=r.length;l<m;l++)r[l].apply(t,n,s,h,d,o,i)}static binarySearch(t,n,s=1){let a=0,h=t.length/s-2;if(h==0)return s;let d=h>>>1;for(;;){if(t[(d+1)*s]<=n?a=d+1:h=d,a==h)return(a+1)*s;d=a+h>>>1}}static linearSearch(t,n,s){for(let a=0,h=t.length-s;a<=h;a+=s)if(t[a]>n)return a;return-1}}var pe=(e=>(e[e.rotate=0]="rotate",e[e.translate=1]="translate",e[e.scale=2]="scale",e[e.shear=3]="shear",e[e.attachment=4]="attachment",e[e.color=5]="color",e[e.deform=6]="deform",e[e.event=7]="event",e[e.drawOrder=8]="drawOrder",e[e.ikConstraint=9]="ikConstraint",e[e.transformConstraint=10]="transformConstraint",e[e.pathConstraintPosition=11]="pathConstraintPosition",e[e.pathConstraintSpacing=12]="pathConstraintSpacing",e[e.pathConstraintMix=13]="pathConstraintMix",e[e.twoColor=14]="twoColor",e))(pe||{});const j=class{constructor(e){if(this.curveData=[],e<=0)throw new Error(`frameCount must be > 0: ${e}`);this.curves=u.Utils.newFloatArray((e-1)*j.BEZIER_SIZE)}getFrameCount(){return this.curves.length/j.BEZIER_SIZE+1}setLinear(e){this.curves[e*j.BEZIER_SIZE]=j.LINEAR}setStepped(e){this.curves[e*j.BEZIER_SIZE]=j.STEPPED}getCurveType(e){const t=e*j.BEZIER_SIZE;if(t==this.curves.length)return j.LINEAR;const n=this.curves[t];return n==j.LINEAR?j.LINEAR:n==j.STEPPED?j.STEPPED:j.BEZIER}setCurve(e,t,n,s,a){this.curveData.push({frameIndex:e,cx1:t,cy1:n,cx2:s,cy2:a});const h=(-t*2+s)*.03,d=(-n*2+a)*.03,o=((t-s)*3+1)*.006,i=((n-a)*3+1)*.006;let r=h*2+o,l=d*2+i,m=t*.3+h+o*.16666667,f=n*.3+d+i*.16666667,c=e*j.BEZIER_SIZE;const g=this.curves;g[c++]=j.BEZIER;let M=m,p=f;for(let x=c+j.BEZIER_SIZE-1;c<x;c+=2)g[c]=M,g[c+1]=p,m+=r,f+=l,r+=o,l+=i,M+=m,p+=f}getCurvePercent(e,t){t=u.MathUtils.clamp(t,0,1);const n=this.curves;let s=e*j.BEZIER_SIZE;const a=n[s];if(a==j.LINEAR)return t;if(a==j.STEPPED)return 0;s++;let h=0;for(let o=s,i=s+j.BEZIER_SIZE-1;s<i;s+=2)if(h=n[s],h>=t){let r,l;return s==o?(r=0,l=0):(r=n[s-2],l=n[s-1]),l+(n[s+1]-l)*(t-r)/(h-r)}const d=n[s-1];return d+(1-d)*(t-h)/(1-h)}};let lt=j;lt.LINEAR=0,lt.STEPPED=1,lt.BEZIER=2,lt.BEZIER_SIZE=10*2-1;const yt=class extends lt{constructor(t){super(t),this.data=[],this.frames=u.Utils.newFloatArray(t<<1)}getPropertyId(){return(0<<24)+this.boneIndex}setFrame(t,n,s){this.data.push({frameIndex:t,time:n,degrees:s}),t<<=1,this.frames[t]=n,this.frames[t+yt.ROTATION]=s}apply(t,n,s,a,h,d,o){const i=this.frames,r=t.bones[this.boneIndex];if(!r.active)return;if(s<i[0]){switch(d){case u.MixBlend.setup:r.rotation=r.data.rotation;return;case u.MixBlend.first:const M=r.data.rotation-r.rotation;r.rotation+=(M-(16384-(16384.499999999996-M/360|0))*360)*h}return}if(s>=i[i.length-yt.ENTRIES]){let M=i[i.length+yt.PREV_ROTATION];switch(d){case u.MixBlend.setup:r.rotation=r.data.rotation+M*h;break;case u.MixBlend.first:case u.MixBlend.replace:M+=r.data.rotation-r.rotation,M-=(16384-(16384.499999999996-M/360|0))*360;case u.MixBlend.add:r.rotation+=M*h}return}const l=G.binarySearch(i,s,yt.ENTRIES),m=i[l+yt.PREV_ROTATION],f=i[l],c=this.getCurvePercent((l>>1)-1,1-(s-f)/(i[l+yt.PREV_TIME]-f));let g=i[l+yt.ROTATION]-m;switch(g=m+(g-(16384-(16384.499999999996-g/360|0))*360)*c,d){case u.MixBlend.setup:r.rotation=r.data.rotation+(g-(16384-(16384.499999999996-g/360|0))*360)*h;break;case u.MixBlend.first:case u.MixBlend.replace:g+=r.data.rotation-r.rotation;case u.MixBlend.add:r.rotation+=(g-(16384-(16384.499999999996-g/360|0))*360)*h}}};let tt=yt;tt.ENTRIES=2,tt.PREV_TIME=-2,tt.PREV_ROTATION=-1,tt.ROTATION=1;const nt=class extends lt{constructor(e){super(e),this.data=[],this.frames=u.Utils.newFloatArray(e*nt.ENTRIES)}getPropertyId(){return(1<<24)+this.boneIndex}setFrame(e,t,n,s){this.data.push({frameIndex:e,time:t,x:n,y:s}),e*=nt.ENTRIES,this.frames[e]=t,this.frames[e+nt.X]=n,this.frames[e+nt.Y]=s}apply(e,t,n,s,a,h,d){const o=this.frames,i=e.bones[this.boneIndex];if(!i.active)return;if(n<o[0]){switch(h){case u.MixBlend.setup:i.x=i.data.x,i.y=i.data.y;return;case u.MixBlend.first:i.x+=(i.data.x-i.x)*a,i.y+=(i.data.y-i.y)*a}return}let r=0,l=0;if(n>=o[o.length-nt.ENTRIES])r=o[o.length+nt.PREV_X],l=o[o.length+nt.PREV_Y];else{const m=G.binarySearch(o,n,nt.ENTRIES);r=o[m+nt.PREV_X],l=o[m+nt.PREV_Y];const f=o[m],c=this.getCurvePercent(m/nt.ENTRIES-1,1-(n-f)/(o[m+nt.PREV_TIME]-f));r+=(o[m+nt.X]-r)*c,l+=(o[m+nt.Y]-l)*c}switch(h){case u.MixBlend.setup:i.x=i.data.x+r*a,i.y=i.data.y+l*a;break;case u.MixBlend.first:case u.MixBlend.replace:i.x+=(i.data.x+r-i.x)*a,i.y+=(i.data.y+l-i.y)*a;break;case u.MixBlend.add:i.x+=r*a,i.y+=l*a}}};let mt=nt;mt.ENTRIES=3,mt.PREV_TIME=-3,mt.PREV_X=-2,mt.PREV_Y=-1,mt.X=1,mt.Y=2;class ht extends mt{constructor(t){super(t)}getPropertyId(){return(2<<24)+this.boneIndex}apply(t,n,s,a,h,d,o){const i=this.frames,r=t.bones[this.boneIndex];if(!r.active)return;if(s<i[0]){switch(d){case u.MixBlend.setup:r.scaleX=r.data.scaleX,r.scaleY=r.data.scaleY;return;case u.MixBlend.first:r.scaleX+=(r.data.scaleX-r.scaleX)*h,r.scaleY+=(r.data.scaleY-r.scaleY)*h}return}let l=0,m=0;if(s>=i[i.length-ht.ENTRIES])l=i[i.length+ht.PREV_X]*r.data.scaleX,m=i[i.length+ht.PREV_Y]*r.data.scaleY;else{const f=G.binarySearch(i,s,ht.ENTRIES);l=i[f+ht.PREV_X],m=i[f+ht.PREV_Y];const c=i[f],g=this.getCurvePercent(f/ht.ENTRIES-1,1-(s-c)/(i[f+ht.PREV_TIME]-c));l=(l+(i[f+ht.X]-l)*g)*r.data.scaleX,m=(m+(i[f+ht.Y]-m)*g)*r.data.scaleY}if(h==1)d==u.MixBlend.add?(r.scaleX+=l-r.data.scaleX,r.scaleY+=m-r.data.scaleY):(r.scaleX=l,r.scaleY=m);else{let f=0,c=0;if(o==u.MixDirection.mixOut)switch(d){case u.MixBlend.setup:f=r.data.scaleX,c=r.data.scaleY,r.scaleX=f+(Math.abs(l)*u.MathUtils.signum(f)-f)*h,r.scaleY=c+(Math.abs(m)*u.MathUtils.signum(c)-c)*h;break;case u.MixBlend.first:case u.MixBlend.replace:f=r.scaleX,c=r.scaleY,r.scaleX=f+(Math.abs(l)*u.MathUtils.signum(f)-f)*h,r.scaleY=c+(Math.abs(m)*u.MathUtils.signum(c)-c)*h;break;case u.MixBlend.add:f=r.scaleX,c=r.scaleY,r.scaleX=f+(Math.abs(l)*u.MathUtils.signum(f)-r.data.scaleX)*h,r.scaleY=c+(Math.abs(m)*u.MathUtils.signum(c)-r.data.scaleY)*h}else switch(d){case u.MixBlend.setup:f=Math.abs(r.data.scaleX)*u.MathUtils.signum(l),c=Math.abs(r.data.scaleY)*u.MathUtils.signum(m),r.scaleX=f+(l-f)*h,r.scaleY=c+(m-c)*h;break;case u.MixBlend.first:case u.MixBlend.replace:f=Math.abs(r.scaleX)*u.MathUtils.signum(l),c=Math.abs(r.scaleY)*u.MathUtils.signum(m),r.scaleX=f+(l-f)*h,r.scaleY=c+(m-c)*h;break;case u.MixBlend.add:f=u.MathUtils.signum(l),c=u.MathUtils.signum(m),r.scaleX=Math.abs(r.scaleX)*f+(l-Math.abs(r.data.scaleX)*f)*h,r.scaleY=Math.abs(r.scaleY)*c+(m-Math.abs(r.data.scaleY)*c)*h}}}}class ct extends mt{constructor(t){super(t)}getPropertyId(){return(3<<24)+this.boneIndex}apply(t,n,s,a,h,d,o){const i=this.frames,r=t.bones[this.boneIndex];if(!r.active)return;if(s<i[0]){switch(d){case u.MixBlend.setup:r.shearX=r.data.shearX,r.shearY=r.data.shearY;return;case u.MixBlend.first:r.shearX+=(r.data.shearX-r.shearX)*h,r.shearY+=(r.data.shearY-r.shearY)*h}return}let l=0,m=0;if(s>=i[i.length-ct.ENTRIES])l=i[i.length+ct.PREV_X],m=i[i.length+ct.PREV_Y];else{const f=G.binarySearch(i,s,ct.ENTRIES);l=i[f+ct.PREV_X],m=i[f+ct.PREV_Y];const c=i[f],g=this.getCurvePercent(f/ct.ENTRIES-1,1-(s-c)/(i[f+ct.PREV_TIME]-c));l=l+(i[f+ct.X]-l)*g,m=m+(i[f+ct.Y]-m)*g}switch(d){case u.MixBlend.setup:r.shearX=r.data.shearX+l*h,r.shearY=r.data.shearY+m*h;break;case u.MixBlend.first:case u.MixBlend.replace:r.shearX+=(r.data.shearX+l-r.shearX)*h,r.shearY+=(r.data.shearY+m-r.shearY)*h;break;case u.MixBlend.add:r.shearX+=l*h,r.shearY+=m*h}}}const _=class extends lt{constructor(e){super(e),this.data=[],this.frames=u.Utils.newFloatArray(e*_.ENTRIES)}getPropertyId(){return(5<<24)+this.slotIndex}setFrame(e,t,n,s,a,h){this.data.push({frameIndex:e,time:t,r:n,g:s,b:a,a:h}),e*=_.ENTRIES,this.frames[e]=t,this.frames[e+_.R]=n,this.frames[e+_.G]=s,this.frames[e+_.B]=a,this.frames[e+_.A]=h}apply(e,t,n,s,a,h,d){const o=e.slots[this.slotIndex];if(!o.bone.active)return;const i=this.frames;if(n<i[0]){switch(h){case u.MixBlend.setup:o.color.setFromColor(o.data.color);return;case u.MixBlend.first:const c=o.color,g=o.data.color;c.add((g.r-c.r)*a,(g.g-c.g)*a,(g.b-c.b)*a,(g.a-c.a)*a)}return}let r=0,l=0,m=0,f=0;if(n>=i[i.length-_.ENTRIES]){const c=i.length;r=i[c+_.PREV_R],l=i[c+_.PREV_G],m=i[c+_.PREV_B],f=i[c+_.PREV_A]}else{const c=G.binarySearch(i,n,_.ENTRIES);r=i[c+_.PREV_R],l=i[c+_.PREV_G],m=i[c+_.PREV_B],f=i[c+_.PREV_A];const g=i[c],M=this.getCurvePercent(c/_.ENTRIES-1,1-(n-g)/(i[c+_.PREV_TIME]-g));r+=(i[c+_.R]-r)*M,l+=(i[c+_.G]-l)*M,m+=(i[c+_.B]-m)*M,f+=(i[c+_.A]-f)*M}if(a==1)o.color.set(r,l,m,f);else{const c=o.color;h==u.MixBlend.setup&&c.setFromColor(o.data.color),c.add((r-c.r)*a,(l-c.g)*a,(m-c.b)*a,(f-c.a)*a)}}};let st=_;st.ENTRIES=5,st.PREV_TIME=-5,st.PREV_R=-4,st.PREV_G=-3,st.PREV_B=-2,st.PREV_A=-1,st.R=1,st.G=2,st.B=3,st.A=4;const Y=class extends lt{constructor(e){super(e),this.data=[],this.frames=u.Utils.newFloatArray(e*Y.ENTRIES)}getPropertyId(){return(14<<24)+this.slotIndex}setFrame(e,t,n,s,a,h,d,o,i){this.data.push({frameIndex:e,time:t,r:n,g:s,b:a,a:h,r2:d,g2:o,b2:i}),e*=Y.ENTRIES,this.frames[e]=t,this.frames[e+Y.R]=n,this.frames[e+Y.G]=s,this.frames[e+Y.B]=a,this.frames[e+Y.A]=h,this.frames[e+Y.R2]=d,this.frames[e+Y.G2]=o,this.frames[e+Y.B2]=i}apply(e,t,n,s,a,h,d){const o=e.slots[this.slotIndex];if(!o.bone.active)return;const i=this.frames;if(n<i[0]){switch(h){case u.MixBlend.setup:o.color.setFromColor(o.data.color),o.darkColor.setFromColor(o.data.darkColor);return;case u.MixBlend.first:const p=o.color,x=o.darkColor,E=o.data.color,w=o.data.darkColor;p.add((E.r-p.r)*a,(E.g-p.g)*a,(E.b-p.b)*a,(E.a-p.a)*a),x.add((w.r-x.r)*a,(w.g-x.g)*a,(w.b-x.b)*a,0)}return}let r=0,l=0,m=0,f=0,c=0,g=0,M=0;if(n>=i[i.length-Y.ENTRIES]){const p=i.length;r=i[p+Y.PREV_R],l=i[p+Y.PREV_G],m=i[p+Y.PREV_B],f=i[p+Y.PREV_A],c=i[p+Y.PREV_R2],g=i[p+Y.PREV_G2],M=i[p+Y.PREV_B2]}else{const p=G.binarySearch(i,n,Y.ENTRIES);r=i[p+Y.PREV_R],l=i[p+Y.PREV_G],m=i[p+Y.PREV_B],f=i[p+Y.PREV_A],c=i[p+Y.PREV_R2],g=i[p+Y.PREV_G2],M=i[p+Y.PREV_B2];const x=i[p],E=this.getCurvePercent(p/Y.ENTRIES-1,1-(n-x)/(i[p+Y.PREV_TIME]-x));r+=(i[p+Y.R]-r)*E,l+=(i[p+Y.G]-l)*E,m+=(i[p+Y.B]-m)*E,f+=(i[p+Y.A]-f)*E,c+=(i[p+Y.R2]-c)*E,g+=(i[p+Y.G2]-g)*E,M+=(i[p+Y.B2]-M)*E}if(a==1)o.color.set(r,l,m,f),o.darkColor.set(c,g,M,1);else{const p=o.color,x=o.darkColor;h==u.MixBlend.setup&&(p.setFromColor(o.data.color),x.setFromColor(o.data.darkColor)),p.add((r-p.r)*a,(l-p.g)*a,(m-p.b)*a,(f-p.a)*a),x.add((c-x.r)*a,(g-x.g)*a,(M-x.b)*a,0)}}};let Q=Y;Q.ENTRIES=8,Q.PREV_TIME=-8,Q.PREV_R=-7,Q.PREV_G=-6,Q.PREV_B=-5,Q.PREV_A=-4,Q.PREV_R2=-3,Q.PREV_G2=-2,Q.PREV_B2=-1,Q.R=1,Q.G=2,Q.B=3,Q.A=4,Q.R2=5,Q.G2=6,Q.B2=7;class Vt{constructor(t){this.data=[],this.frames=u.Utils.newFloatArray(t),this.attachmentNames=new Array(t)}getPropertyId(){return(4<<24)+this.slotIndex}getFrameCount(){return this.frames.length}setFrame(t,n,s){this.data.push({frameIndex:t,time:n,attachmentName:s}),this.frames[t]=n,this.attachmentNames[t]=s}apply(t,n,s,a,h,d,o){const i=t.slots[this.slotIndex];if(!i.bone.active)return;if(o==u.MixDirection.mixOut){d==u.MixBlend.setup&&this.setAttachment(t,i,i.data.attachmentName);return}const r=this.frames;if(s<r[0]){(d==u.MixBlend.setup||d==u.MixBlend.first)&&this.setAttachment(t,i,i.data.attachmentName);return}let l=0;s>=r[r.length-1]?l=r.length-1:l=G.binarySearch(r,s,1)-1;const m=this.attachmentNames[l];t.slots[this.slotIndex].setAttachment(m==null?null:t.getAttachment(this.slotIndex,m))}setAttachment(t,n,s){n.setAttachment(s==null?null:t.getAttachment(this.slotIndex,s))}}let Me=null;class Zt extends lt{constructor(t){super(t),this.data=[],this.frames=u.Utils.newFloatArray(t),this.frameVertices=new Array(t),Me==null&&(Me=u.Utils.newFloatArray(64))}getPropertyId(){return(6<<27)+Number(this.attachment.id)+this.slotIndex}setFrame(t,n,s,a){this.data.push({frameIndex:t,time:n,vertices:s,skin:a}),this.frames[t]=n,this.frameVertices[t]=s}apply(t,n,s,a,h,d,o){const i=t.slots[this.slotIndex];if(!i.bone.active)return;const r=i.getAttachment();if(!(r instanceof At)||r.deformAttachment!=this.attachment)return;const l=i.deform||[];l.length==0&&(d=u.MixBlend.setup);const m=this.frameVertices,f=m[0].length,c=this.frames;if(s<c[0]){const S=r;switch(d){case u.MixBlend.setup:l.length=0;return;case u.MixBlend.first:if(h==1){l.length=0;break}const T=u.Utils.setArraySize(l,f);if(S.bones==null){const I=S.vertices;for(let A=0;A<f;A++)T[A]+=(I[A]-T[A])*h}else{h=1-h;for(let I=0;I<f;I++)T[I]*=h}}return}const g=u.Utils.setArraySize(l,f);if(s>=c[c.length-1]){const S=m[c.length-1];if(h==1)if(d==u.MixBlend.add){const T=r;if(T.bones==null){const I=T.vertices;for(let A=0;A<f;A++)g[A]+=S[A]-I[A]}else for(let I=0;I<f;I++)g[I]+=S[I]}else u.Utils.arrayCopy(S,0,g,0,f);else switch(d){case u.MixBlend.setup:{const I=r;if(I.bones==null){const A=I.vertices;for(let R=0;R<f;R++){const y=A[R];g[R]=y+(S[R]-y)*h}}else for(let A=0;A<f;A++)g[A]=S[A]*h;break}case u.MixBlend.first:case u.MixBlend.replace:for(let I=0;I<f;I++)g[I]+=(S[I]-g[I])*h;break;case u.MixBlend.add:const T=r;if(T.bones==null){const I=T.vertices;for(let A=0;A<f;A++)g[A]+=(S[A]-I[A])*h}else for(let I=0;I<f;I++)g[I]+=S[I]*h}return}const M=G.binarySearch(c,s),p=m[M-1],x=m[M],E=c[M],w=this.getCurvePercent(M-1,1-(s-E)/(c[M-1]-E));if(h==1)if(d==u.MixBlend.add){const S=r;if(S.bones==null){const T=S.vertices;for(let I=0;I<f;I++){const A=p[I];g[I]+=A+(x[I]-A)*w-T[I]}}else for(let T=0;T<f;T++){const I=p[T];g[T]+=I+(x[T]-I)*w}}else for(let S=0;S<f;S++){const T=p[S];g[S]=T+(x[S]-T)*w}else switch(d){case u.MixBlend.setup:{const T=r;if(T.bones==null){const I=T.vertices;for(let A=0;A<f;A++){const R=p[A],y=I[A];g[A]=y+(R+(x[A]-R)*w-y)*h}}else for(let I=0;I<f;I++){const A=p[I];g[I]=(A+(x[I]-A)*w)*h}break}case u.MixBlend.first:case u.MixBlend.replace:for(let T=0;T<f;T++){const I=p[T];g[T]+=(I+(x[T]-I)*w-g[T])*h}break;case u.MixBlend.add:const S=r;if(S.bones==null){const T=S.vertices;for(let I=0;I<f;I++){const A=p[I];g[I]+=(A+(x[I]-A)*w-T[I])*h}}else for(let T=0;T<f;T++){const I=p[T];g[T]+=(I+(x[T]-I)*w)*h}}}}class Ot{constructor(t){this.data=[],this.frames=u.Utils.newFloatArray(t),this.events=new Array(t)}getPropertyId(){return 7<<24}getFrameCount(){return this.frames.length}setFrame(t,n){this.data.push({frameIndex:t,event:n}),this.frames[t]=n.time,this.events[t]=n}apply(t,n,s,a,h,d,o){if(a==null)return;const i=this.frames,r=this.frames.length;if(n>s)this.apply(t,n,Number.MAX_VALUE,a,h,d,o),n=-1;else if(n>=i[r-1])return;if(s<i[0])return;let l=0;if(n<i[0])l=0;else{l=G.binarySearch(i,n);const m=i[l];for(;l>0&&i[l-1]==m;)l--}for(;l<r&&s>=i[l];l++)a.push(this.events[l])}}class Bt{constructor(t){this.data=[],this.frames=u.Utils.newFloatArray(t),this.drawOrders=new Array(t)}getPropertyId(){return 8<<24}getFrameCount(){return this.frames.length}setFrame(t,n,s){this.data.push({frameIndex:t,time:n,drawOrder:s}),this.frames[t]=n,this.drawOrders[t]=s}apply(t,n,s,a,h,d,o){const i=t.drawOrder,r=t.slots;if(o==u.MixDirection.mixOut&&d==u.MixBlend.setup){u.Utils.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}const l=this.frames;if(s<l[0]){(d==u.MixBlend.setup||d==u.MixBlend.first)&&u.Utils.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}let m=0;s>=l[l.length-1]?m=l.length-1:m=G.binarySearch(l,s)-1;const f=this.drawOrders[m];if(f==null)u.Utils.arrayCopy(r,0,i,0,r.length);else for(let c=0,g=f.length;c<g;c++)i[c]=r[f[c]]}}const q=class extends lt{constructor(e){super(e),this.data=[],this.frames=u.Utils.newFloatArray(e*q.ENTRIES)}getPropertyId(){return(9<<24)+this.ikConstraintIndex}setFrame(e,t,n,s){this.data.push({frameIndex:e,time:t,mix:n,bendDirection:s}),e*=q.ENTRIES,this.frames[e]=t,this.frames[e+q.MIX]=n,this.frames[e+q.BEND_DIRECTION]=s}apply(e,t,n,s,a,h,d){const o=this.frames,i=e.ikConstraints[this.ikConstraintIndex];if(!i.active)return;if(n<o[0]){switch(h){case u.MixBlend.setup:i.mix=i.data.mix,i.softness=i.data.softness,i.bendDirection=i.data.bendDirection,i.compress=i.data.compress,i.stretch=i.data.stretch;return;case u.MixBlend.first:i.mix+=(i.data.mix-i.mix)*a,i.softness+=(i.data.softness-i.softness)*a,i.bendDirection=i.data.bendDirection,i.compress=i.data.compress,i.stretch=i.data.stretch}return}if(n>=o[o.length-q.ENTRIES]){h===u.MixBlend.setup?(i.mix=i.data.mix+(o[o.length+q.PREV_MIX]-i.data.mix)*a,i.softness=i.data.softness+(o[o.length+q.PREV_SOFTNESS]-i.data.softness)*a,d===u.MixDirection.mixOut?(i.bendDirection=i.data.bendDirection,i.compress=i.data.compress,i.stretch=i.data.stretch):(i.bendDirection=o[o.length+q.PREV_BEND_DIRECTION],i.compress=o[o.length+q.PREV_COMPRESS]!==0,i.stretch=o[o.length+q.PREV_STRETCH]!==0)):(i.mix+=(o[o.length+q.PREV_MIX]-i.mix)*a,i.softness+=(o[o.length+q.PREV_SOFTNESS]-i.softness)*a,d===u.MixDirection.mixIn&&(i.bendDirection=o[o.length+q.PREV_BEND_DIRECTION],i.compress=o[o.length+q.PREV_COMPRESS]!==0,i.stretch=o[o.length+q.PREV_STRETCH]!==0));return}const r=G.binarySearch(o,n,q.ENTRIES),l=o[r+q.PREV_MIX],m=o[r],f=this.getCurvePercent(r/q.ENTRIES-1,1-(n-m)/(o[r+q.PREV_TIME]-m));i.mix+=(l+(o[r+q.MIX]-l)*f-i.mix)*a,i.bendDirection=Math.floor(o[r+q.PREV_BEND_DIRECTION])}};let et=q;et.ENTRIES=6,et.PREV_TIME=-6,et.PREV_MIX=-5,et.PREV_SOFTNESS=-4,et.PREV_BEND_DIRECTION=-3,et.PREV_COMPRESS=-2,et.PREV_STRETCH=-1,et.MIX=1,et.SOFTNESS=2,et.BEND_DIRECTION=3,et.COMPRESS=4,et.STRETCH=5;const b=class extends lt{constructor(e){super(e),this.data=[],this.frames=u.Utils.newFloatArray(e*b.ENTRIES)}getPropertyId(){return(10<<24)+this.transformConstraintIndex}setFrame(e,t,n,s,a,h){this.data.push({frameIndex:e,time:t,rotateMix:n,translateMix:s,scaleMix:a,shearMix:h}),e*=b.ENTRIES,this.frames[e]=t,this.frames[e+b.ROTATE]=n,this.frames[e+b.TRANSLATE]=s,this.frames[e+b.SCALE]=a,this.frames[e+b.SHEAR]=h}apply(e,t,n,s,a,h,d){const o=this.frames,i=e.transformConstraints[this.transformConstraintIndex];if(!i.active)return;if(n<o[0]){const c=i.data;switch(h){case u.MixBlend.setup:i.rotateMix=c.rotateMix,i.translateMix=c.translateMix,i.scaleMix=c.scaleMix,i.shearMix=c.shearMix;return;case u.MixBlend.first:i.rotateMix+=(c.rotateMix-i.rotateMix)*a,i.translateMix+=(c.translateMix-i.translateMix)*a,i.scaleMix+=(c.scaleMix-i.scaleMix)*a,i.shearMix+=(c.shearMix-i.shearMix)*a}return}let r=0,l=0,m=0,f=0;if(n>=o[o.length-b.ENTRIES]){const c=o.length;r=o[c+b.PREV_ROTATE],l=o[c+b.PREV_TRANSLATE],m=o[c+b.PREV_SCALE],f=o[c+b.PREV_SHEAR]}else{const c=G.binarySearch(o,n,b.ENTRIES);r=o[c+b.PREV_ROTATE],l=o[c+b.PREV_TRANSLATE],m=o[c+b.PREV_SCALE],f=o[c+b.PREV_SHEAR];const g=o[c],M=this.getCurvePercent(c/b.ENTRIES-1,1-(n-g)/(o[c+b.PREV_TIME]-g));r+=(o[c+b.ROTATE]-r)*M,l+=(o[c+b.TRANSLATE]-l)*M,m+=(o[c+b.SCALE]-m)*M,f+=(o[c+b.SHEAR]-f)*M}if(h==u.MixBlend.setup){const c=i.data;i.rotateMix=c.rotateMix+(r-c.rotateMix)*a,i.translateMix=c.translateMix+(l-c.translateMix)*a,i.scaleMix=c.scaleMix+(m-c.scaleMix)*a,i.shearMix=c.shearMix+(f-c.shearMix)*a}else i.rotateMix+=(r-i.rotateMix)*a,i.translateMix+=(l-i.translateMix)*a,i.scaleMix+=(m-i.scaleMix)*a,i.shearMix+=(f-i.shearMix)*a}};let it=b;it.ENTRIES=5,it.PREV_TIME=-5,it.PREV_ROTATE=-4,it.PREV_TRANSLATE=-3,it.PREV_SCALE=-2,it.PREV_SHEAR=-1,it.ROTATE=1,it.TRANSLATE=2,it.SCALE=3,it.SHEAR=4;const pt=class extends lt{constructor(e){super(e),this.data=[],this.frames=u.Utils.newFloatArray(e*pt.ENTRIES)}getPropertyId(){return(11<<24)+this.pathConstraintIndex}setFrame(e,t,n){this.data.push({frameIndex:e,time:t,value:n}),e*=pt.ENTRIES,this.frames[e]=t,this.frames[e+pt.VALUE]=n}apply(e,t,n,s,a,h,d){const o=this.frames,i=e.pathConstraints[this.pathConstraintIndex];if(!i.active)return;if(n<o[0]){switch(h){case u.MixBlend.setup:i.position=i.data.position;return;case u.MixBlend.first:i.position+=(i.data.position-i.position)*a}return}let r=0;if(n>=o[o.length-pt.ENTRIES])r=o[o.length+pt.PREV_VALUE];else{const l=G.binarySearch(o,n,pt.ENTRIES);r=o[l+pt.PREV_VALUE];const m=o[l],f=this.getCurvePercent(l/pt.ENTRIES-1,1-(n-m)/(o[l+pt.PREV_TIME]-m));r+=(o[l+pt.VALUE]-r)*f}h==u.MixBlend.setup?i.position=i.data.position+(r-i.data.position)*a:i.position+=(r-i.position)*a}};let Et=pt;Et.ENTRIES=2,Et.PREV_TIME=-2,Et.PREV_VALUE=-1,Et.VALUE=1;class Mt extends Et{constructor(t){super(t)}getPropertyId(){return(12<<24)+this.pathConstraintIndex}apply(t,n,s,a,h,d,o){const i=this.frames,r=t.pathConstraints[this.pathConstraintIndex];if(!r.active)return;if(s<i[0]){switch(d){case u.MixBlend.setup:r.spacing=r.data.spacing;return;case u.MixBlend.first:r.spacing+=(r.data.spacing-r.spacing)*h}return}let l=0;if(s>=i[i.length-Mt.ENTRIES])l=i[i.length+Mt.PREV_VALUE];else{const m=G.binarySearch(i,s,Mt.ENTRIES);l=i[m+Mt.PREV_VALUE];const f=i[m],c=this.getCurvePercent(m/Mt.ENTRIES-1,1-(s-f)/(i[m+Mt.PREV_TIME]-f));l+=(i[m+Mt.VALUE]-l)*c}d==u.MixBlend.setup?r.spacing=r.data.spacing+(l-r.data.spacing)*h:r.spacing+=(l-r.spacing)*h}}const at=class extends lt{constructor(e){super(e),this.data=[],this.frames=u.Utils.newFloatArray(e*at.ENTRIES)}getPropertyId(){return(13<<24)+this.pathConstraintIndex}setFrame(e,t,n,s){this.data.push({frameIndex:e,time:t,rotateMix:n,translateMix:s}),e*=at.ENTRIES,this.frames[e]=t,this.frames[e+at.ROTATE]=n,this.frames[e+at.TRANSLATE]=s}apply(e,t,n,s,a,h,d){const o=this.frames,i=e.pathConstraints[this.pathConstraintIndex];if(!i.active)return;if(n<o[0]){switch(h){case u.MixBlend.setup:i.rotateMix=i.data.rotateMix,i.translateMix=i.data.translateMix;return;case u.MixBlend.first:i.rotateMix+=(i.data.rotateMix-i.rotateMix)*a,i.translateMix+=(i.data.translateMix-i.translateMix)*a}return}let r=0,l=0;if(n>=o[o.length-at.ENTRIES])r=o[o.length+at.PREV_ROTATE],l=o[o.length+at.PREV_TRANSLATE];else{const m=G.binarySearch(o,n,at.ENTRIES);r=o[m+at.PREV_ROTATE],l=o[m+at.PREV_TRANSLATE];const f=o[m],c=this.getCurvePercent(m/at.ENTRIES-1,1-(n-f)/(o[m+at.PREV_TIME]-f));r+=(o[m+at.ROTATE]-r)*c,l+=(o[m+at.TRANSLATE]-l)*c}h==u.MixBlend.setup?(i.rotateMix=i.data.rotateMix+(r-i.data.rotateMix)*a,i.translateMix=i.data.translateMix+(l-i.data.translateMix)*a):(i.rotateMix+=(r-i.rotateMix)*a,i.translateMix+=(l-i.translateMix)*a)}};let xt=at;xt.ENTRIES=3,xt.PREV_TIME=-3,xt.PREV_ROTATE=-2,xt.PREV_TRANSLATE=-1,xt.ROTATE=1,xt.TRANSLATE=2;const W=class{constructor(e){this.tracks=new Array,this.timeScale=1,this.unkeyedState=0,this.events=new Array,this.listeners=new Array,this.queue=new Qt(this),this.propertyIDs=new u.IntSet,this.animationsChanged=!1,this.trackEntryPool=new u.Pool(()=>new _t),this.data=e}update(e){e*=this.timeScale;const t=this.tracks;for(let n=0,s=t.length;n<s;n++){const a=t[n];if(a==null)continue;a.animationLast=a.nextAnimationLast,a.trackLast=a.nextTrackLast;let h=e*a.timeScale;if(a.delay>0){if(a.delay-=h,a.delay>0)continue;h=-a.delay,a.delay=0}let d=a.next;if(d!=null){const o=a.trackLast-d.delay;if(o>=0){for(d.delay=0,d.trackTime+=a.timeScale==0?0:(o/a.timeScale+e)*d.timeScale,a.trackTime+=h,this.setCurrent(n,d,!0);d.mixingFrom!=null;)d.mixTime+=e,d=d.mixingFrom;continue}}else if(a.trackLast>=a.trackEnd&&a.mixingFrom==null){t[n]=null,this.queue.end(a),this.disposeNext(a);continue}if(a.mixingFrom!=null&&this.updateMixingFrom(a,e)){let o=a.mixingFrom;for(a.mixingFrom=null,o!=null&&(o.mixingTo=null);o!=null;)this.queue.end(o),o=o.mixingFrom}a.trackTime+=h}this.queue.drain()}updateMixingFrom(e,t){const n=e.mixingFrom;if(n==null)return!0;const s=this.updateMixingFrom(n,t);return n.animationLast=n.nextAnimationLast,n.trackLast=n.nextTrackLast,e.mixTime>0&&e.mixTime>=e.mixDuration?((n.totalAlpha==0||e.mixDuration==0)&&(e.mixingFrom=n.mixingFrom,n.mixingFrom!=null&&(n.mixingFrom.mixingTo=e),e.interruptAlpha=n.interruptAlpha,this.queue.end(n)),s):(n.trackTime+=t*n.timeScale,e.mixTime+=t,!1)}apply(e){if(e==null)throw new Error("skeleton cannot be null.");this.animationsChanged&&this._animationsChanged();const t=this.events,n=this.tracks;let s=!1;for(let d=0,o=n.length;d<o;d++){const i=n[d];if(i==null||i.delay>0)continue;s=!0;const r=d==0?u.MixBlend.first:i.mixBlend;let l=i.alpha;i.mixingFrom!=null?l*=this.applyMixingFrom(i,e,r):i.trackTime>=i.trackEnd&&i.next==null&&(l=0);const m=i.animationLast,f=i.getAnimationTime(),c=i.animation.timelines.length,g=i.animation.timelines;if(d==0&&l==1||r==u.MixBlend.add)for(let M=0;M<c;M++){u.Utils.webkit602BugfixHelper(l,r);const p=g[M];p instanceof Vt?this.applyAttachmentTimeline(p,e,f,r,!0):p.apply(e,m,f,t,l,r,u.MixDirection.mixIn)}else{const M=i.timelineMode,p=i.timelinesRotation.length==0;p&&u.Utils.setArraySize(i.timelinesRotation,c<<1,null);const x=i.timelinesRotation;for(let E=0;E<c;E++){const w=g[E],S=M[E]==W.SUBSEQUENT?r:u.MixBlend.setup;w instanceof tt?this.applyRotateTimeline(w,e,f,l,S,x,E<<1,p):w instanceof Vt?this.applyAttachmentTimeline(w,e,f,r,!0):(u.Utils.webkit602BugfixHelper(l,r),w.apply(e,m,f,t,l,S,u.MixDirection.mixIn))}}this.queueEvents(i,f),t.length=0,i.nextAnimationLast=f,i.nextTrackLast=i.trackTime}const a=this.unkeyedState+W.SETUP,h=e.slots;for(let d=0,o=e.slots.length;d<o;d++){const i=h[d];if(i.attachmentState==a){const r=i.data.attachmentName;i.setAttachment(r==null?null:e.getAttachment(i.data.index,r))}}return this.unkeyedState+=2,this.queue.drain(),s}applyMixingFrom(e,t,n){const s=e.mixingFrom;s.mixingFrom!=null&&this.applyMixingFrom(s,t,n);let a=0;e.mixDuration==0?(a=1,n==u.MixBlend.first&&(n=u.MixBlend.setup)):(a=e.mixTime/e.mixDuration,a>1&&(a=1),n!=u.MixBlend.first&&(n=s.mixBlend));const h=a<s.eventThreshold?this.events:null,d=a<s.attachmentThreshold,o=a<s.drawOrderThreshold,i=s.animationLast,r=s.getAnimationTime(),l=s.animation.timelines.length,m=s.animation.timelines,f=s.alpha*e.interruptAlpha,c=f*(1-a);if(n==u.MixBlend.add)for(let g=0;g<l;g++)m[g].apply(t,i,r,h,c,n,u.MixDirection.mixOut);else{const g=s.timelineMode,M=s.timelineHoldMix,p=s.timelinesRotation.length==0;p&&u.Utils.setArraySize(s.timelinesRotation,l<<1,null);const x=s.timelinesRotation;s.totalAlpha=0;for(let E=0;E<l;E++){const w=m[E];let S=u.MixDirection.mixOut,T,I=0;switch(g[E]){case W.SUBSEQUENT:if(!o&&w instanceof Bt)continue;T=n,I=c;break;case W.FIRST:T=u.MixBlend.setup,I=c;break;case W.HOLD_SUBSEQUENT:T=n,I=f;break;case W.HOLD_FIRST:T=u.MixBlend.setup,I=f;break;default:T=u.MixBlend.setup;const A=M[E];I=f*Math.max(0,1-A.mixTime/A.mixDuration);break}s.totalAlpha+=I,w instanceof tt?this.applyRotateTimeline(w,t,r,I,T,x,E<<1,p):w instanceof Vt?this.applyAttachmentTimeline(w,t,r,T,d):(u.Utils.webkit602BugfixHelper(I,n),o&&w instanceof Bt&&T==u.MixBlend.setup&&(S=u.MixDirection.mixIn),w.apply(t,i,r,h,I,T,S))}}return e.mixDuration>0&&this.queueEvents(s,r),this.events.length=0,s.nextAnimationLast=r,s.nextTrackLast=s.trackTime,a}applyAttachmentTimeline(e,t,n,s,a){const h=t.slots[e.slotIndex];if(!h.bone.active)return;const d=e.frames;if(n<d[0])(s==u.MixBlend.setup||s==u.MixBlend.first)&&this.setAttachment(t,h,h.data.attachmentName,a);else{let o;n>=d[d.length-1]?o=d.length-1:o=G.binarySearch(d,n)-1,this.setAttachment(t,h,e.attachmentNames[o],a)}h.attachmentState<=this.unkeyedState&&(h.attachmentState=this.unkeyedState+W.SETUP)}setAttachment(e,t,n,s){t.setAttachment(n==null?null:e.getAttachment(t.data.index,n)),s&&(t.attachmentState=this.unkeyedState+W.CURRENT)}applyRotateTimeline(e,t,n,s,a,h,d,o){if(o&&(h[d]=0),s==1){e.apply(t,0,n,null,1,a,u.MixDirection.mixIn);return}const i=e,r=i.frames,l=t.bones[i.boneIndex];if(!l.active)return;let m=0,f=0;if(n<r[0])switch(a){case u.MixBlend.setup:l.rotation=l.data.rotation;default:return;case u.MixBlend.first:m=l.rotation,f=l.data.rotation}else if(m=a==u.MixBlend.setup?l.data.rotation:l.rotation,n>=r[r.length-tt.ENTRIES])f=l.data.rotation+r[r.length+tt.PREV_ROTATION];else{const M=G.binarySearch(r,n,tt.ENTRIES),p=r[M+tt.PREV_ROTATION],x=r[M],E=i.getCurvePercent((M>>1)-1,1-(n-x)/(r[M+tt.PREV_TIME]-x));f=r[M+tt.ROTATION]-p,f-=(16384-(16384.499999999996-f/360|0))*360,f=p+f*E+l.data.rotation,f-=(16384-(16384.499999999996-f/360|0))*360}let c=0,g=f-m;if(g-=(16384-(16384.499999999996-g/360|0))*360,g==0)c=h[d];else{let M=0,p=0;o?(M=0,p=g):(M=h[d],p=h[d+1]);const x=g>0;let E=M>=0;u.MathUtils.signum(p)!=u.MathUtils.signum(g)&&Math.abs(p)<=90&&(Math.abs(M)>180&&(M+=360*u.MathUtils.signum(M)),E=x),c=g+M-M%360,E!=x&&(c+=360*u.MathUtils.signum(M)),h[d]=c}h[d+1]=g,m+=c*s,l.rotation=m-(16384-(16384.499999999996-m/360|0))*360}queueEvents(e,t){const n=e.animationStart,s=e.animationEnd,a=s-n,h=e.trackLast%a,d=this.events;let o=0;const i=d.length;for(;o<i;o++){const l=d[o];if(l.time<h)break;l.time>s||this.queue.event(e,l)}let r=!1;for(e.loop?r=a==0||h>e.trackTime%a:r=t>=s&&e.animationLast<s,r&&this.queue.complete(e);o<i;o++)d[o].time<n||this.queue.event(e,d[o])}clearTracks(){const e=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let t=0,n=this.tracks.length;t<n;t++)this.clearTrack(t);this.tracks.length=0,this.queue.drainDisabled=e,this.queue.drain()}clearTrack(e){if(e>=this.tracks.length)return;const t=this.tracks[e];if(t==null)return;this.queue.end(t),this.disposeNext(t);let n=t;for(;;){const s=n.mixingFrom;if(s==null)break;this.queue.end(s),n.mixingFrom=null,n.mixingTo=null,n=s}this.tracks[t.trackIndex]=null,this.queue.drain()}setCurrent(e,t,n){const s=this.expandToIndex(e);this.tracks[e]=t,s!=null&&(n&&this.queue.interrupt(s),t.mixingFrom=s,s.mixingTo=t,t.mixTime=0,s.mixingFrom!=null&&s.mixDuration>0&&(t.interruptAlpha*=Math.min(1,s.mixTime/s.mixDuration)),s.timelinesRotation.length=0),this.queue.start(t)}setAnimation(e,t,n){const s=this.data.skeletonData.findAnimation(t);if(s==null)throw new Error(`Animation not found: ${t}`);return this.setAnimationWith(e,s,n)}setAnimationWith(e,t,n){if(t==null)throw new Error("animation cannot be null.");let s=!0,a=this.expandToIndex(e);a!=null&&(a.nextTrackLast==-1?(this.tracks[e]=a.mixingFrom,this.queue.interrupt(a),this.queue.end(a),this.disposeNext(a),a=a.mixingFrom,s=!1):this.disposeNext(a));const h=this.trackEntry(e,t,n,a);return this.setCurrent(e,h,s),this.queue.drain(),h}addAnimation(e,t,n,s){const a=this.data.skeletonData.findAnimation(t);if(a==null)throw new Error(`Animation not found: ${t}`);return this.addAnimationWith(e,a,n,s)}addAnimationWith(e,t,n,s){if(t==null)throw new Error("animation cannot be null.");let a=this.expandToIndex(e);if(a!=null)for(;a.next!=null;)a=a.next;const h=this.trackEntry(e,t,n,a);if(a==null)this.setCurrent(e,h,!0),this.queue.drain();else if(a.next=h,s<=0){const d=a.animationEnd-a.animationStart;d!=0?(a.loop?s+=d*(1+(a.trackTime/d|0)):s+=Math.max(d,a.trackTime),s-=this.data.getMix(a.animation,t)):s=a.trackTime}return h.delay=s,h}setEmptyAnimation(e,t){const n=this.setAnimationWith(e,W.emptyAnimation,!1);return n.mixDuration=t,n.trackEnd=t,n}addEmptyAnimation(e,t,n){n<=0&&(n-=t);const s=this.addAnimationWith(e,W.emptyAnimation,!1,n);return s.mixDuration=t,s.trackEnd=t,s}setEmptyAnimations(e){const t=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let n=0,s=this.tracks.length;n<s;n++){const a=this.tracks[n];a!=null&&this.setEmptyAnimation(a.trackIndex,e)}this.queue.drainDisabled=t,this.queue.drain()}expandToIndex(e){return e<this.tracks.length?this.tracks[e]:(u.Utils.ensureArrayCapacity(this.tracks,e+1,null),this.tracks.length=e+1,null)}trackEntry(e,t,n,s){const a=this.trackEntryPool.obtain();return a.trackIndex=e,a.animation=t,a.loop=n,a.holdPrevious=!1,a.eventThreshold=0,a.attachmentThreshold=0,a.drawOrderThreshold=0,a.animationStart=0,a.animationEnd=t.duration,a.animationLast=-1,a.nextAnimationLast=-1,a.delay=0,a.trackTime=0,a.trackLast=-1,a.nextTrackLast=-1,a.trackEnd=Number.MAX_VALUE,a.timeScale=1,a.alpha=1,a.interruptAlpha=1,a.mixTime=0,a.mixDuration=s==null?0:this.data.getMix(s.animation,t),a.mixBlend=u.MixBlend.replace,a}disposeNext(e){let t=e.next;for(;t!=null;)this.queue.dispose(t),t=t.next;e.next=null}_animationsChanged(){this.animationsChanged=!1,this.propertyIDs.clear();for(let e=0,t=this.tracks.length;e<t;e++){let n=this.tracks[e];if(n!=null){for(;n.mixingFrom!=null;)n=n.mixingFrom;do(n.mixingFrom==null||n.mixBlend!=u.MixBlend.add)&&this.computeHold(n),n=n.mixingTo;while(n!=null)}}}computeHold(e){const t=e.mixingTo,n=e.animation.timelines,s=e.animation.timelines.length,a=u.Utils.setArraySize(e.timelineMode,s);e.timelineHoldMix.length=0;const h=u.Utils.setArraySize(e.timelineHoldMix,s),d=this.propertyIDs;if(t!=null&&t.holdPrevious){for(let o=0;o<s;o++)a[o]=d.add(n[o].getPropertyId())?W.HOLD_FIRST:W.HOLD_SUBSEQUENT;return}t:for(let o=0;o<s;o++){const i=n[o],r=i.getPropertyId();if(!d.add(r))a[o]=W.SUBSEQUENT;else if(t==null||i instanceof Vt||i instanceof Bt||i instanceof Ot||!t.animation.hasTimeline(r))a[o]=W.FIRST;else{for(let l=t.mixingTo;l!=null;l=l.mixingTo)if(!l.animation.hasTimeline(r)){if(e.mixDuration>0){a[o]=W.HOLD_MIX,h[o]=l;continue t}break}a[o]=W.HOLD_FIRST}}}getCurrent(e){return e>=this.tracks.length?null:this.tracks[e]}addListener(e){if(e==null)throw new Error("listener cannot be null.");this.listeners.push(e)}removeListener(e){const t=this.listeners.indexOf(e);t>=0&&this.listeners.splice(t,1)}clearListeners(){this.listeners.length=0}clearListenerNotifications(){this.queue.clear()}setAnimationByName(e,t,n){W.deprecatedWarning1||(W.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.")),this.setAnimation(e,t,n)}addAnimationByName(e,t,n,s){W.deprecatedWarning2||(W.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.")),this.addAnimation(e,t,n,s)}hasAnimation(e){return this.data.skeletonData.findAnimation(e)!==null}hasAnimationByName(e){return W.deprecatedWarning3||(W.deprecatedWarning3=!0,console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.")),this.hasAnimation(e)}};let ft=W;ft.emptyAnimation=new G("<empty>",[],0),ft.SUBSEQUENT=0,ft.FIRST=1,ft.HOLD_SUBSEQUENT=2,ft.HOLD_FIRST=3,ft.HOLD_MIX=4,ft.SETUP=1,ft.CURRENT=2,ft.deprecatedWarning1=!1,ft.deprecatedWarning2=!1,ft.deprecatedWarning3=!1;const St=class{constructor(){this.mixBlend=u.MixBlend.replace,this.timelineMode=new Array,this.timelineHoldMix=new Array,this.timelinesRotation=new Array}reset(){this.next=null,this.mixingFrom=null,this.mixingTo=null,this.animation=null,this.listener=null,this.timelineMode.length=0,this.timelineHoldMix.length=0,this.timelinesRotation.length=0}getAnimationTime(){if(this.loop){const e=this.animationEnd-this.animationStart;return e==0?this.animationStart:this.trackTime%e+this.animationStart}return Math.min(this.trackTime+this.animationStart,this.animationEnd)}setAnimationLast(e){this.animationLast=e,this.nextAnimationLast=e}isComplete(){return this.trackTime>=this.animationEnd-this.animationStart}resetRotationDirections(){this.timelinesRotation.length=0}get time(){return St.deprecatedWarning1||(St.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime}set time(e){St.deprecatedWarning1||(St.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime=e}get endTime(){return St.deprecatedWarning2||(St.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime}set endTime(e){St.deprecatedWarning2||(St.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime=e}loopsCount(){return Math.floor(this.trackTime/this.trackEnd)}};let _t=St;_t.deprecatedWarning1=!1,_t.deprecatedWarning2=!1;const zt=class{constructor(e){this.objects=[],this.drainDisabled=!1,this.animState=e}start(e){this.objects.push(dt.start),this.objects.push(e),this.animState.animationsChanged=!0}interrupt(e){this.objects.push(dt.interrupt),this.objects.push(e)}end(e){this.objects.push(dt.end),this.objects.push(e),this.animState.animationsChanged=!0}dispose(e){this.objects.push(dt.dispose),this.objects.push(e)}complete(e){this.objects.push(dt.complete),this.objects.push(e)}event(e,t){this.objects.push(dt.event),this.objects.push(e),this.objects.push(t)}deprecateStuff(){return zt.deprecatedWarning1||(zt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'")),!0}drain(){if(this.drainDisabled)return;this.drainDisabled=!0;const e=this.objects,t=this.animState.listeners;for(let n=0;n<e.length;n+=2){const s=e[n],a=e[n+1];switch(s){case dt.start:a.listener!=null&&a.listener.start&&a.listener.start(a);for(let o=0;o<t.length;o++)t[o].start&&t[o].start(a);a.onStart&&this.deprecateStuff()&&a.onStart(a.trackIndex),this.animState.onStart&&this.deprecateStuff()&&this.deprecateStuff&&this.animState.onStart(a.trackIndex);break;case dt.interrupt:a.listener!=null&&a.listener.interrupt&&a.listener.interrupt(a);for(let o=0;o<t.length;o++)t[o].interrupt&&t[o].interrupt(a);break;case dt.end:a.listener!=null&&a.listener.end&&a.listener.end(a);for(let o=0;o<t.length;o++)t[o].end&&t[o].end(a);a.onEnd&&this.deprecateStuff()&&a.onEnd(a.trackIndex),this.animState.onEnd&&this.deprecateStuff()&&this.animState.onEnd(a.trackIndex);case dt.dispose:a.listener!=null&&a.listener.dispose&&a.listener.dispose(a);for(let o=0;o<t.length;o++)t[o].dispose&&t[o].dispose(a);this.animState.trackEntryPool.free(a);break;case dt.complete:a.listener!=null&&a.listener.complete&&a.listener.complete(a);for(let o=0;o<t.length;o++)t[o].complete&&t[o].complete(a);const h=u.MathUtils.toInt(a.loopsCount());a.onComplete&&this.deprecateStuff()&&a.onComplete(a.trackIndex,h),this.animState.onComplete&&this.deprecateStuff()&&this.animState.onComplete(a.trackIndex,h);break;case dt.event:const d=e[n+++2];a.listener!=null&&a.listener.event&&a.listener.event(a,d);for(let o=0;o<t.length;o++)t[o].event&&t[o].event(a,d);a.onEvent&&this.deprecateStuff()&&a.onEvent(a.trackIndex,d),this.animState.onEvent&&this.deprecateStuff()&&this.animState.onEvent(a.trackIndex,d);break}}this.clear(),this.drainDisabled=!1}clear(){this.objects.length=0}};let Qt=zt;Qt.deprecatedWarning1=!1;var dt=(e=>(e[e.start=0]="start",e[e.interrupt=1]="interrupt",e[e.end=2]="end",e[e.dispose=3]="dispose",e[e.complete=4]="complete",e[e.event=5]="event",e))(dt||{});class ke{start(t){}interrupt(t){}end(t){}dispose(t){}complete(t){}event(t,n){}}const Kt=class{constructor(e){if(this.animationToMixTime={},this.defaultMix=0,e==null)throw new Error("skeletonData cannot be null.");this.skeletonData=e}setMix(e,t,n){const s=this.skeletonData.findAnimation(e);if(s==null)throw new Error(`Animation not found: ${e}`);const a=this.skeletonData.findAnimation(t);if(a==null)throw new Error(`Animation not found: ${t}`);this.setMixWith(s,a,n)}setMixByName(e,t,n){Kt.deprecatedWarning1||(Kt.deprecatedWarning1=!0,console.warn("Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.")),this.setMix(e,t,n)}setMixWith(e,t,n){if(e==null)throw new Error("from cannot be null.");if(t==null)throw new Error("to cannot be null.");const s=`${e.name}.${t.name}`;this.animationToMixTime[s]=n}getMix(e,t){const n=`${e.name}.${t.name}`,s=this.animationToMixTime[n];return s===void 0?this.defaultMix:s}};let Jt=Kt;Jt.deprecatedWarning1=!1;class Ve{constructor(t){this.atlas=t}newRegionAttachment(t,n,s){const a=this.atlas.findRegion(s);if(a==null)throw new Error(`Region not found in atlas: ${s} (region attachment: ${n})`);const h=new B(n);return h.region=a,h}newMeshAttachment(t,n,s){const a=this.atlas.findRegion(s);if(a==null)throw new Error(`Region not found in atlas: ${s} (mesh attachment: ${n})`);const h=new Ct(n);return h.region=a,h}newBoundingBoxAttachment(t,n){return new Xt(n)}newPathAttachment(t,n){return new kt(n)}newPointAttachment(t,n){return new Lt(n)}newClippingAttachment(t,n){return new Yt(n)}}class te{constructor(t,n,s){if(this.matrix=new wt.Matrix,this.children=new Array,this.x=0,this.y=0,this.rotation=0,this.scaleX=0,this.scaleY=0,this.shearX=0,this.shearY=0,this.ax=0,this.ay=0,this.arotation=0,this.ascaleX=0,this.ascaleY=0,this.ashearX=0,this.ashearY=0,this.appliedValid=!1,this.sorted=!1,this.active=!1,t==null)throw new Error("data cannot be null.");if(n==null)throw new Error("skeleton cannot be null.");this.data=t,this.skeleton=n,this.parent=s,this.setToSetupPose()}get worldX(){return this.matrix.tx}get worldY(){return this.matrix.ty}isActive(){return this.active}update(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransform(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransformWith(t,n,s,a,h,d,o){this.ax=t,this.ay=n,this.arotation=s,this.ascaleX=a,this.ascaleY=h,this.ashearX=d,this.ashearY=o,this.appliedValid=!0;const i=this.parent,r=this.matrix,l=this.skeleton.scaleX,m=u.settings.yDown?-this.skeleton.scaleY:this.skeleton.scaleY;if(i==null){const p=this.skeleton,x=s+90+o;r.a=u.MathUtils.cosDeg(s+d)*a*l,r.c=u.MathUtils.cosDeg(x)*h*l,r.b=u.MathUtils.sinDeg(s+d)*a*m,r.d=u.MathUtils.sinDeg(x)*h*m,r.tx=t*l+p.x,r.ty=n*m+p.y;return}let f=i.matrix.a,c=i.matrix.c,g=i.matrix.b,M=i.matrix.d;switch(r.tx=f*t+c*n+i.matrix.tx,r.ty=g*t+M*n+i.matrix.ty,this.data.transformMode){case u.TransformMode.Normal:{const p=s+90+o,x=u.MathUtils.cosDeg(s+d)*a,E=u.MathUtils.cosDeg(p)*h,w=u.MathUtils.sinDeg(s+d)*a,S=u.MathUtils.sinDeg(p)*h;r.a=f*x+c*w,r.c=f*E+c*S,r.b=g*x+M*w,r.d=g*E+M*S;return}case u.TransformMode.OnlyTranslation:{const p=s+90+o;r.a=u.MathUtils.cosDeg(s+d)*a,r.c=u.MathUtils.cosDeg(p)*h,r.b=u.MathUtils.sinDeg(s+d)*a,r.d=u.MathUtils.sinDeg(p)*h;break}case u.TransformMode.NoRotationOrReflection:{let p=f*f+g*g,x=0;p>1e-4?(p=Math.abs(f*M-c*g)/p,f/=this.skeleton.scaleX,g/=this.skeleton.scaleY,c=g*p,M=f*p,x=Math.atan2(g,f)*u.MathUtils.radDeg):(f=0,g=0,x=90-Math.atan2(M,c)*u.MathUtils.radDeg);const E=s+d-x,w=s+o-x+90,S=u.MathUtils.cosDeg(E)*a,T=u.MathUtils.cosDeg(w)*h,I=u.MathUtils.sinDeg(E)*a,A=u.MathUtils.sinDeg(w)*h;r.a=f*S-c*I,r.c=f*T-c*A,r.b=g*S+M*I,r.d=g*T+M*A;break}case u.TransformMode.NoScale:case u.TransformMode.NoScaleOrReflection:{const p=u.MathUtils.cosDeg(s),x=u.MathUtils.sinDeg(s);let E=(f*p+c*x)/l,w=(g*p+M*x)/m,S=Math.sqrt(E*E+w*w);S>1e-5&&(S=1/S),E*=S,w*=S,S=Math.sqrt(E*E+w*w),this.data.transformMode==u.TransformMode.NoScale&&f*M-c*g<0!=(u.settings.yDown?this.skeleton.scaleX<0!=this.skeleton.scaleY>0:this.skeleton.scaleX<0!=this.skeleton.scaleY<0)&&(S=-S);const T=Math.PI/2+Math.atan2(w,E),I=Math.cos(T)*S,A=Math.sin(T)*S,R=u.MathUtils.cosDeg(d)*a,y=u.MathUtils.cosDeg(90+o)*h,k=u.MathUtils.sinDeg(d)*a,X=u.MathUtils.sinDeg(90+o)*h;r.a=E*R+I*k,r.c=E*y+I*X,r.b=w*R+A*k,r.d=w*y+A*X;break}}r.a*=l,r.c*=l,r.b*=m,r.d*=m}setToSetupPose(){const t=this.data;this.x=t.x,this.y=t.y,this.rotation=t.rotation,this.scaleX=t.scaleX,this.scaleY=t.scaleY,this.shearX=t.shearX,this.shearY=t.shearY}getWorldRotationX(){return Math.atan2(this.matrix.b,this.matrix.a)*u.MathUtils.radDeg}getWorldRotationY(){return Math.atan2(this.matrix.d,this.matrix.c)*u.MathUtils.radDeg}getWorldScaleX(){const t=this.matrix;return Math.sqrt(t.a*t.a+t.c*t.c)}getWorldScaleY(){const t=this.matrix;return Math.sqrt(t.b*t.b+t.d*t.d)}updateAppliedTransform(){this.appliedValid=!0;const t=this.parent,n=this.matrix;if(t==null){this.ax=n.tx,this.ay=n.ty,this.arotation=Math.atan2(n.b,n.a)*u.MathUtils.radDeg,this.ascaleX=Math.sqrt(n.a*n.a+n.b*n.b),this.ascaleY=Math.sqrt(n.c*n.c+n.d*n.d),this.ashearX=0,this.ashearY=Math.atan2(n.a*n.c+n.b*n.d,n.a*n.d-n.b*n.c)*u.MathUtils.radDeg;return}const s=t.matrix,a=1/(s.a*s.d-s.b*s.c),h=n.tx-s.tx,d=n.ty-s.ty;this.ax=h*s.d*a-d*s.c*a,this.ay=d*s.a*a-h*s.b*a;const o=a*s.d,i=a*s.a,r=a*s.c,l=a*s.b,m=o*n.a-r*n.b,f=o*n.c-r*n.d,c=i*n.b-l*n.a,g=i*n.d-l*n.c;if(this.ashearX=0,this.ascaleX=Math.sqrt(m*m+c*c),this.ascaleX>1e-4){const M=m*g-f*c;this.ascaleY=M/this.ascaleX,this.ashearY=Math.atan2(m*f+c*g,M)*u.MathUtils.radDeg,this.arotation=Math.atan2(c,m)*u.MathUtils.radDeg}else this.ascaleX=0,this.ascaleY=Math.sqrt(f*f+g*g),this.ashearY=0,this.arotation=90-Math.atan2(g,f)*u.MathUtils.radDeg}worldToLocal(t){const n=this.matrix,s=n.a,a=n.c,h=n.b,d=n.d,o=1/(s*d-a*h),i=t.x-n.tx,r=t.y-n.ty;return t.x=i*d*o-r*a*o,t.y=r*s*o-i*h*o,t}localToWorld(t){const n=this.matrix,s=t.x,a=t.y;return t.x=s*n.a+a*n.c+n.tx,t.y=s*n.b+a*n.d+n.ty,t}worldToLocalRotation(t){const n=u.MathUtils.sinDeg(t),s=u.MathUtils.cosDeg(t),a=this.matrix;return Math.atan2(a.a*n-a.b*s,a.d*s-a.c*n)*u.MathUtils.radDeg}localToWorldRotation(t){const n=u.MathUtils.sinDeg(t),s=u.MathUtils.cosDeg(t),a=this.matrix;return Math.atan2(s*a.b+n*a.d,s*a.a+n*a.c)*u.MathUtils.radDeg}rotateWorld(t){const n=this.matrix,s=n.a,a=n.c,h=n.b,d=n.d,o=u.MathUtils.cosDeg(t),i=u.MathUtils.sinDeg(t);n.a=o*s-i*h,n.c=o*a-i*d,n.b=i*s+o*h,n.d=i*a+o*d,this.appliedValid=!1}}class ee{constructor(t,n,s){if(this.x=0,this.y=0,this.rotation=0,this.scaleX=1,this.scaleY=1,this.shearX=0,this.shearY=0,this.transformMode=u.TransformMode.Normal,this.skinRequired=!1,this.inheritRotation=!0,this.inheritScale=!0,this.color=new u.Color,t<0)throw new Error("index must be >= 0.");if(n==null)throw new Error("name cannot be null.");this.index=t,this.name=n,this.parent=s}}class bt{constructor(t,n,s){this.name=t,this.order=n,this.skinRequired=s}}class ne{constructor(t,n){if(n==null)throw new Error("data cannot be null.");this.time=t,this.data=n}}class se{constructor(t){this.name=t}}class xe{constructor(t,n){if(this.bendDirection=0,this.compress=!1,this.stretch=!1,this.mix=1,this.softness=0,this.active=!1,t==null)throw new Error("data cannot be null.");if(n==null)throw new Error("skeleton cannot be null.");this.data=t,this.mix=t.mix,this.softness=t.softness,this.bendDirection=t.bendDirection,this.compress=t.compress,this.stretch=t.stretch,this.bones=new Array;for(let s=0;s<t.bones.length;s++)this.bones.push(n.findBone(t.bones[s].name));this.target=n.findBone(t.target.name)}isActive(){return this.active}apply(){this.update()}update(){const t=this.target,n=this.bones;switch(n.length){case 1:this.apply1(n[0],t.worldX,t.worldY,this.compress,this.stretch,this.data.uniform,this.mix);break;case 2:this.apply2(n[0],n[1],t.worldX,t.worldY,this.bendDirection,this.stretch,this.softness,this.mix);break}}apply1(t,n,s,a,h,d,o){t.appliedValid||t.updateAppliedTransform();const i=t.parent.matrix,r=i.a;let l=i.c;const m=i.b;let f=i.d,c=-t.ashearX-t.arotation,g=0,M=0;switch(t.data.transformMode){case u.TransformMode.OnlyTranslation:g=n-t.worldX,M=s-t.worldY;break;case u.TransformMode.NoRotationOrReflection:const E=Math.abs(r*f-l*m)/(r*r+m*m),w=r/t.skeleton.scaleX,S=m/t.skeleton.scaleY;l=-S*E*t.skeleton.scaleX,f=w*E*t.skeleton.scaleY,c+=Math.atan2(S,w)*u.MathUtils.radDeg;default:const T=n-i.tx,I=s-i.ty,A=r*f-l*m;g=(T*f-I*l)/A-t.ax,M=(I*r-T*m)/A-t.ay}c+=Math.atan2(M,g)*u.MathUtils.radDeg,t.ascaleX<0&&(c+=180),c>180?c-=360:c<-180&&(c+=360);let p=t.ascaleX,x=t.ascaleY;if(a||h){switch(t.data.transformMode){case u.TransformMode.NoScale:case u.TransformMode.NoScaleOrReflection:g=n-t.worldX,M=s-t.worldY}const E=t.data.length*p,w=Math.sqrt(g*g+M*M);if(a&&w<E||h&&w>E&&E>1e-4){const S=(w/E-1)*o+1;p*=S,d&&(x*=S)}}t.updateWorldTransformWith(t.ax,t.ay,t.arotation+c*o,p,x,t.ashearX,t.ashearY)}apply2(t,n,s,a,h,d,o,i){if(i==0){n.updateWorldTransform();return}t.appliedValid||t.updateAppliedTransform(),n.appliedValid||n.updateAppliedTransform();const r=t.ax,l=t.ay;let m=t.ascaleX,f=m,c=t.ascaleY,g=n.ascaleX;const M=t.matrix;let p=0,x=0,E=0;m<0?(m=-m,p=180,E=-1):(p=0,E=1),c<0&&(c=-c,E=-E),g<0?(g=-g,x=180):x=0;const w=n.ax;let S=0,T=0,I=0,A=M.a,R=M.c,y=M.b,k=M.d;const X=Math.abs(m-c)<=1e-4;X?(S=n.ay,T=A*w+R*S+M.tx,I=y*w+k*S+M.ty):(S=0,T=A*w+M.tx,I=y*w+M.ty);const N=t.parent.matrix;A=N.a,R=N.c,y=N.b,k=N.d;const $=1/(A*k-R*y);let P=T-N.tx,F=I-N.ty;const rt=(P*k-F*R)*$-r,ot=(F*A-P*y)*$-l,V=Math.sqrt(rt*rt+ot*ot);let U=n.data.length*g,D,O;if(V<1e-4){this.apply1(t,s,a,!1,d,!1,i),n.updateWorldTransformWith(w,S,0,n.ascaleX,n.ascaleY,n.ashearX,n.ashearY);return}P=s-N.tx,F=a-N.ty;let H=(P*k-F*R)*$-r,L=(F*A-P*y)*$-l,v=H*H+L*L;if(o!=0){o*=m*(g+1)/2;const ut=Math.sqrt(v),It=ut-V-U*m+o;if(It>0){let Tt=Math.min(1,It/(o*2))-1;Tt=(It-o*(1-Tt*Tt))/ut,H-=Tt*H,L-=Tt*L,v=H*H+L*L}}t:if(X){U*=m;let ut=(v-V*V-U*U)/(2*V*U);ut<-1?ut=-1:ut>1&&(ut=1,d&&(f*=(Math.sqrt(v)/(V+U)-1)*i+1)),O=Math.acos(ut)*h,A=V+U*ut,R=U*Math.sin(O),D=Math.atan2(L*A-H*R,H*A+L*R)}else{A=m*U,R=c*U;const ut=A*A,It=R*R,Tt=Math.atan2(L,H);y=It*V*V+ut*v-ut*It;const qt=-2*It*V,we=It-ut;if(k=qt*qt-4*we*y,k>=0){let vt=Math.sqrt(k);qt<0&&(vt=-vt),vt=-(qt+vt)/2;const ye=vt/we,Re=y/vt,Ut=Math.abs(ye)<Math.abs(Re)?ye:Re;if(Ut*Ut<=v){F=Math.sqrt(v-Ut*Ut)*h,D=Tt-Math.atan2(F,Ut),O=Math.atan2(F/c,(Ut-V)/m);break t}}let Se=u.MathUtils.PI,$t=V-A,de=$t*$t,Ie=0,Te=0,Ht=V+A,ue=Ht*Ht,Ae=0;y=-A*V/(ut-It),y>=-1&&y<=1&&(y=Math.acos(y),P=A*Math.cos(y)+V,F=R*Math.sin(y),k=P*P+F*F,k<de&&(Se=y,de=k,$t=P,Ie=F),k>ue&&(Te=y,ue=k,Ht=P,Ae=F)),v<=(de+ue)/2?(D=Tt-Math.atan2(Ie*h,$t),O=Se*h):(D=Tt-Math.atan2(Ae*h,Ht),O=Te*h)}const gt=Math.atan2(S,w)*E;let Rt=t.arotation;D=(D-gt)*u.MathUtils.radDeg+p-Rt,D>180?D-=360:D<-180&&(D+=360),t.updateWorldTransformWith(r,l,Rt+D*i,f,t.ascaleY,0,0),Rt=n.arotation,O=((O+gt)*u.MathUtils.radDeg-n.ashearX)*E+x-Rt,O>180?O-=360:O<-180&&(O+=360),n.updateWorldTransformWith(w,S,Rt+O*i,n.ascaleX,n.ascaleY,n.ashearX,n.ashearY)}}class ie extends bt{constructor(t){super(t,0,!1),this.bones=new Array,this.bendDirection=1,this.compress=!1,this.stretch=!1,this.uniform=!1,this.mix=1,this.softness=0}}class ae extends bt{constructor(t){super(t,0,!1),this.bones=new Array}}var J=(e=>(e[e.Length=0]="Length",e[e.Fixed=1]="Fixed",e[e.Percent=2]="Percent",e))(J||{});const Pt=class{constructor(e,t){if(this.position=0,this.spacing=0,this.rotateMix=0,this.translateMix=0,this.spaces=new Array,this.positions=new Array,this.world=new Array,this.curves=new Array,this.lengths=new Array,this.segments=new Array,this.active=!1,e==null)throw new Error("data cannot be null.");if(t==null)throw new Error("skeleton cannot be null.");this.data=e,this.bones=new Array;for(let n=0,s=e.bones.length;n<s;n++)this.bones.push(t.findBone(e.bones[n].name));this.target=t.findSlot(e.target.name),this.position=e.position,this.spacing=e.spacing,this.rotateMix=e.rotateMix,this.translateMix=e.translateMix}isActive(){return this.active}apply(){this.update()}update(){const e=this.target.getAttachment();if(!(e instanceof kt))return;const t=this.rotateMix,n=this.translateMix,s=n>0,a=t>0;if(!s&&!a)return;const h=this.data,d=h.spacingMode,o=d==J.Length,i=h.rotateMode,r=i==u.RotateMode.Tangent,l=i==u.RotateMode.ChainScale,m=this.bones.length,f=r?m:m+1,c=this.bones,g=u.Utils.setArraySize(this.spaces,f);let M=null;const p=this.spacing;if(l||o){l&&(M=u.Utils.setArraySize(this.lengths,m));for(let I=0,A=f-1;I<A;){const R=c[I],y=R.data.length;if(y<Pt.epsilon)l&&(M[I]=0),g[++I]=0;else{const k=y*R.matrix.a,X=y*R.matrix.b,N=Math.sqrt(k*k+X*X);l&&(M[I]=N),g[++I]=(o?y+p:p)*N/y}}}else for(let I=1;I<f;I++)g[I]=p;const x=this.computeWorldPositions(e,f,r,h.positionMode==u.PositionMode.Percent,d==J.Percent);let E=x[0],w=x[1],S=h.offsetRotation,T=!1;if(S==0)T=i==u.RotateMode.Chain;else{T=!1;const I=this.target.bone.matrix;S*=I.a*I.d-I.b*I.c>0?u.MathUtils.degRad:-u.MathUtils.degRad}for(let I=0,A=3;I<m;I++,A+=3){const R=c[I],y=R.matrix;y.tx+=(E-y.tx)*n,y.ty+=(w-y.ty)*n;const k=x[A],X=x[A+1],N=k-E,$=X-w;if(l){const P=M[I];if(P!=0){const F=(Math.sqrt(N*N+$*$)/P-1)*t+1;y.a*=F,y.b*=F}}if(E=k,w=X,a){const P=y.a,F=y.c,rt=y.b,ot=y.d;let V=0,U=0,D=0;if(r&&(r?V=x[A-1]:g[I+1]==0?V=x[A+2]:V=Math.atan2($,N)),V-=Math.atan2(rt,P),T){U=Math.cos(V),D=Math.sin(V);const O=R.data.length;E+=(O*(U*P-D*rt)-N)*t,w+=(O*(D*P+U*rt)-$)*t}else V+=S;V>u.MathUtils.PI?V-=u.MathUtils.PI2:V<-u.MathUtils.PI&&(V+=u.MathUtils.PI2),V*=t,U=Math.cos(V),D=Math.sin(V),y.a=U*P-D*rt,y.c=U*F-D*ot,y.b=D*P+U*rt,y.d=D*F+U*ot}R.appliedValid=!1}}computeWorldPositions(e,t,n,s,a){const h=this.target;let d=this.position;const o=this.spaces,i=u.Utils.setArraySize(this.positions,t*3+2);let r=null;const l=e.closed;let m=e.worldVerticesLength,f=m/6,c=Pt.NONE;if(!e.constantSpeed){const V=e.lengths;f-=l?1:2;const U=V[f];if(s&&(d*=U),a)for(let D=0;D<t;D++)o[D]*=U;r=u.Utils.setArraySize(this.world,8);for(let D=0,O=0,H=0;D<t;D++,O+=3){const L=o[D];d+=L;let v=d;if(l)v%=U,v<0&&(v+=U),H=0;else if(v<0){c!=Pt.BEFORE&&(c=Pt.BEFORE,e.computeWorldVertices(h,2,4,r,0,2)),this.addBeforePosition(v,r,0,i,O);continue}else if(v>U){c!=Pt.AFTER&&(c=Pt.AFTER,e.computeWorldVertices(h,m-6,4,r,0,2)),this.addAfterPosition(v-U,r,0,i,O);continue}for(;;H++){const gt=V[H];if(!(v>gt)){if(H==0)v/=gt;else{const Rt=V[H-1];v=(v-Rt)/(gt-Rt)}break}}H!=c&&(c=H,l&&H==f?(e.computeWorldVertices(h,m-4,4,r,0,2),e.computeWorldVertices(h,0,4,r,4,2)):e.computeWorldVertices(h,H*6+2,8,r,0,2)),this.addCurvePosition(v,r[0],r[1],r[2],r[3],r[4],r[5],r[6],r[7],i,O,n||D>0&&L==0)}return i}l?(m+=2,r=u.Utils.setArraySize(this.world,m),e.computeWorldVertices(h,2,m-4,r,0,2),e.computeWorldVertices(h,0,2,r,m-4,2),r[m-2]=r[0],r[m-1]=r[1]):(f--,m-=4,r=u.Utils.setArraySize(this.world,m),e.computeWorldVertices(h,2,m,r,0,2));const g=u.Utils.setArraySize(this.curves,f);let M=0,p=r[0],x=r[1],E=0,w=0,S=0,T=0,I=0,A=0,R=0,y=0,k=0,X=0,N=0,$=0,P=0,F=0;for(let V=0,U=2;V<f;V++,U+=6)E=r[U],w=r[U+1],S=r[U+2],T=r[U+3],I=r[U+4],A=r[U+5],R=(p-E*2+S)*.1875,y=(x-w*2+T)*.1875,k=((E-S)*3-p+I)*.09375,X=((w-T)*3-x+A)*.09375,N=R*2+k,$=y*2+X,P=(E-p)*.75+R+k*.16666667,F=(w-x)*.75+y+X*.16666667,M+=Math.sqrt(P*P+F*F),P+=N,F+=$,N+=k,$+=X,M+=Math.sqrt(P*P+F*F),P+=N,F+=$,M+=Math.sqrt(P*P+F*F),P+=N+k,F+=$+X,M+=Math.sqrt(P*P+F*F),g[V]=M,p=I,x=A;if(s&&(d*=M),a)for(let V=0;V<t;V++)o[V]*=M;const rt=this.segments;let ot=0;for(let V=0,U=0,D=0,O=0;V<t;V++,U+=3){const H=o[V];d+=H;let L=d;if(l)L%=M,L<0&&(L+=M),D=0;else if(L<0){this.addBeforePosition(L,r,0,i,U);continue}else if(L>M){this.addAfterPosition(L-M,r,m-4,i,U);continue}for(;;D++){const v=g[D];if(!(L>v)){if(D==0)L/=v;else{const gt=g[D-1];L=(L-gt)/(v-gt)}break}}if(D!=c){c=D;let v=D*6;for(p=r[v],x=r[v+1],E=r[v+2],w=r[v+3],S=r[v+4],T=r[v+5],I=r[v+6],A=r[v+7],R=(p-E*2+S)*.03,y=(x-w*2+T)*.03,k=((E-S)*3-p+I)*.006,X=((w-T)*3-x+A)*.006,N=R*2+k,$=y*2+X,P=(E-p)*.3+R+k*.16666667,F=(w-x)*.3+y+X*.16666667,ot=Math.sqrt(P*P+F*F),rt[0]=ot,v=1;v<8;v++)P+=N,F+=$,N+=k,$+=X,ot+=Math.sqrt(P*P+F*F),rt[v]=ot;P+=N,F+=$,ot+=Math.sqrt(P*P+F*F),rt[8]=ot,P+=N+k,F+=$+X,ot+=Math.sqrt(P*P+F*F),rt[9]=ot,O=0}for(L*=ot;;O++){const v=rt[O];if(!(L>v)){if(O==0)L/=v;else{const gt=rt[O-1];L=O+(L-gt)/(v-gt)}break}}this.addCurvePosition(L*.1,p,x,E,w,S,T,I,A,i,U,n||V>0&&H==0)}return i}addBeforePosition(e,t,n,s,a){const h=t[n],d=t[n+1],o=t[n+2]-h,i=t[n+3]-d,r=Math.atan2(i,o);s[a]=h+e*Math.cos(r),s[a+1]=d+e*Math.sin(r),s[a+2]=r}addAfterPosition(e,t,n,s,a){const h=t[n+2],d=t[n+3],o=h-t[n],i=d-t[n+1],r=Math.atan2(i,o);s[a]=h+e*Math.cos(r),s[a+1]=d+e*Math.sin(r),s[a+2]=r}addCurvePosition(e,t,n,s,a,h,d,o,i,r,l,m){(e==0||isNaN(e))&&(e=1e-4);const f=e*e,c=f*e,g=1-e,M=g*g,p=M*g,x=g*e,E=x*3,w=g*E,S=E*e,T=t*p+s*w+h*S+o*c,I=n*p+a*w+d*S+i*c;r[l]=T,r[l+1]=I,m&&(r[l+2]=Math.atan2(I-(n*M+a*x*2+d*f),T-(t*M+s*x*2+h*f)))}};let Nt=Pt;Nt.NONE=-1,Nt.BEFORE=-2,Nt.AFTER=-3,Nt.epsilon=1e-5;class Ee{constructor(t,n){if(this.rotateMix=0,this.translateMix=0,this.scaleMix=0,this.shearMix=0,this.temp=new u.Vector2,this.active=!1,t==null)throw new Error("data cannot be null.");if(n==null)throw new Error("skeleton cannot be null.");this.data=t,this.rotateMix=t.rotateMix,this.translateMix=t.translateMix,this.scaleMix=t.scaleMix,this.shearMix=t.shearMix,this.bones=new Array;for(let s=0;s<t.bones.length;s++)this.bones.push(n.findBone(t.bones[s].name));this.target=n.findBone(t.target.name)}isActive(){return this.active}apply(){this.update()}update(){this.data.local?this.data.relative?this.applyRelativeLocal():this.applyAbsoluteLocal():this.data.relative?this.applyRelativeWorld():this.applyAbsoluteWorld()}applyAbsoluteWorld(){const t=this.rotateMix,n=this.translateMix,s=this.scaleMix,a=this.shearMix,h=this.target,d=h.matrix,o=d.a,i=d.c,r=d.b,l=d.d,m=o*l-i*r>0?u.MathUtils.degRad:-u.MathUtils.degRad,f=this.data.offsetRotation*m,c=this.data.offsetShearY*m,g=this.bones;for(let M=0,p=g.length;M<p;M++){const x=g[M];let E=!1;const w=x.matrix;if(t!=0){const S=w.a,T=w.c,I=w.b,A=w.d;let R=Math.atan2(r,o)-Math.atan2(I,S)+f;R>u.MathUtils.PI?R-=u.MathUtils.PI2:R<-u.MathUtils.PI&&(R+=u.MathUtils.PI2),R*=t;const y=Math.cos(R),k=Math.sin(R);w.a=y*S-k*I,w.c=y*T-k*A,w.b=k*S+y*I,w.d=k*T+y*A,E=!0}if(n!=0){const S=this.temp;h.localToWorld(S.set(this.data.offsetX,this.data.offsetY)),w.tx+=(S.x-w.tx)*n,w.ty+=(S.y-w.ty)*n,E=!0}if(s>0){let S=Math.sqrt(w.a*w.a+w.b*w.b),T=Math.sqrt(o*o+r*r);S>1e-5&&(S=(S+(T-S+this.data.offsetScaleX)*s)/S),w.a*=S,w.b*=S,S=Math.sqrt(w.c*w.c+w.d*w.d),T=Math.sqrt(i*i+l*l),S>1e-5&&(S=(S+(T-S+this.data.offsetScaleY)*s)/S),w.c*=S,w.d*=S,E=!0}if(a>0){const S=w.c,T=w.d,I=Math.atan2(T,S);let A=Math.atan2(l,i)-Math.atan2(r,o)-(I-Math.atan2(w.b,w.a));A>u.MathUtils.PI?A-=u.MathUtils.PI2:A<-u.MathUtils.PI&&(A+=u.MathUtils.PI2),A=I+(A+c)*a;const R=Math.sqrt(S*S+T*T);w.c=Math.cos(A)*R,w.d=Math.sin(A)*R,E=!0}E&&(x.appliedValid=!1)}}applyRelativeWorld(){const t=this.rotateMix,n=this.translateMix,s=this.scaleMix,a=this.shearMix,h=this.target,d=h.matrix,o=d.a,i=d.c,r=d.b,l=d.d,m=o*l-i*r>0?u.MathUtils.degRad:-u.MathUtils.degRad,f=this.data.offsetRotation*m,c=this.data.offsetShearY*m,g=this.bones;for(let M=0,p=g.length;M<p;M++){const x=g[M];let E=!1;const w=x.matrix;if(t!=0){const S=w.a,T=w.c,I=w.b,A=w.d;let R=Math.atan2(r,o)+f;R>u.MathUtils.PI?R-=u.MathUtils.PI2:R<-u.MathUtils.PI&&(R+=u.MathUtils.PI2),R*=t;const y=Math.cos(R),k=Math.sin(R);w.a=y*S-k*I,w.c=y*T-k*A,w.b=k*S+y*I,w.d=k*T+y*A,E=!0}if(n!=0){const S=this.temp;h.localToWorld(S.set(this.data.offsetX,this.data.offsetY)),w.tx+=S.x*n,w.ty+=S.y*n,E=!0}if(s>0){let S=(Math.sqrt(o*o+r*r)-1+this.data.offsetScaleX)*s+1;w.a*=S,w.b*=S,S=(Math.sqrt(i*i+l*l)-1+this.data.offsetScaleY)*s+1,w.c*=S,w.d*=S,E=!0}if(a>0){let S=Math.atan2(l,i)-Math.atan2(r,o);S>u.MathUtils.PI?S-=u.MathUtils.PI2:S<-u.MathUtils.PI&&(S+=u.MathUtils.PI2);const T=w.c,I=w.d;S=Math.atan2(I,T)+(S-u.MathUtils.PI/2+c)*a;const A=Math.sqrt(T*T+I*I);w.c=Math.cos(S)*A,w.d=Math.sin(S)*A,E=!0}E&&(x.appliedValid=!1)}}applyAbsoluteLocal(){const t=this.rotateMix,n=this.translateMix,s=this.scaleMix,a=this.shearMix,h=this.target;h.appliedValid||h.updateAppliedTransform();const d=this.bones;for(let o=0,i=d.length;o<i;o++){const r=d[o];r.appliedValid||r.updateAppliedTransform();let l=r.arotation;if(t!=0){let p=h.arotation-l+this.data.offsetRotation;p-=(16384-(16384.499999999996-p/360|0))*360,l+=p*t}let m=r.ax,f=r.ay;n!=0&&(m+=(h.ax-m+this.data.offsetX)*n,f+=(h.ay-f+this.data.offsetY)*n);let c=r.ascaleX,g=r.ascaleY;s>0&&(c>1e-5&&(c=(c+(h.ascaleX-c+this.data.offsetScaleX)*s)/c),g>1e-5&&(g=(g+(h.ascaleY-g+this.data.offsetScaleY)*s)/g));const M=r.ashearY;if(a>0){let p=h.ashearY-M+this.data.offsetShearY;p-=(16384-(16384.499999999996-p/360|0))*360,r.shearY+=p*a}r.updateWorldTransformWith(m,f,l,c,g,r.ashearX,M)}}applyRelativeLocal(){const t=this.rotateMix,n=this.translateMix,s=this.scaleMix,a=this.shearMix,h=this.target;h.appliedValid||h.updateAppliedTransform();const d=this.bones;for(let o=0,i=d.length;o<i;o++){const r=d[o];r.appliedValid||r.updateAppliedTransform();let l=r.arotation;t!=0&&(l+=(h.arotation+this.data.offsetRotation)*t);let m=r.ax,f=r.ay;n!=0&&(m+=(h.ax+this.data.offsetX)*n,f+=(h.ay+this.data.offsetY)*n);let c=r.ascaleX,g=r.ascaleY;s>0&&(c>1e-5&&(c*=(h.ascaleX-1+this.data.offsetScaleX)*s+1),g>1e-5&&(g*=(h.ascaleY-1+this.data.offsetScaleY)*s+1));let M=r.ashearY;a>0&&(M+=(h.ashearY+this.data.offsetShearY)*a),r.updateWorldTransformWith(m,f,l,c,g,r.ashearX,M)}}}const Dt=class{constructor(e){if(this._updateCache=new Array,this.updateCacheReset=new Array,this.time=0,this.scaleX=1,this.scaleY=1,this.x=0,this.y=0,e==null)throw new Error("data cannot be null.");this.data=e,this.bones=new Array;for(let t=0;t<e.bones.length;t++){const n=e.bones[t];let s;if(n.parent==null)s=new te(n,this,null);else{const a=this.bones[n.parent.index];s=new te(n,this,a),a.children.push(s)}this.bones.push(s)}this.slots=new Array,this.drawOrder=new Array;for(let t=0;t<e.slots.length;t++){const n=e.slots[t],s=this.bones[n.boneData.index],a=new jt(n,s);this.slots.push(a),this.drawOrder.push(a)}this.ikConstraints=new Array;for(let t=0;t<e.ikConstraints.length;t++){const n=e.ikConstraints[t];this.ikConstraints.push(new xe(n,this))}this.transformConstraints=new Array;for(let t=0;t<e.transformConstraints.length;t++){const n=e.transformConstraints[t];this.transformConstraints.push(new Ee(n,this))}this.pathConstraints=new Array;for(let t=0;t<e.pathConstraints.length;t++){const n=e.pathConstraints[t];this.pathConstraints.push(new Nt(n,this))}this.color=new u.Color(1,1,1,1),this.updateCache()}updateCache(){const e=this._updateCache;e.length=0,this.updateCacheReset.length=0;const t=this.bones;for(let r=0,l=t.length;r<l;r++){const m=t[r];m.sorted=m.data.skinRequired,m.active=!m.sorted}if(this.skin!=null){const r=this.skin.bones;for(let l=0,m=this.skin.bones.length;l<m;l++){let f=this.bones[r[l].index];do f.sorted=!1,f.active=!0,f=f.parent;while(f!=null)}}const n=this.ikConstraints,s=this.transformConstraints,a=this.pathConstraints,h=n.length,d=s.length,o=a.length,i=h+d+o;t:for(let r=0;r<i;r++){for(let l=0;l<h;l++){const m=n[l];if(m.data.order==r){this.sortIkConstraint(m);continue t}}for(let l=0;l<d;l++){const m=s[l];if(m.data.order==r){this.sortTransformConstraint(m);continue t}}for(let l=0;l<o;l++){const m=a[l];if(m.data.order==r){this.sortPathConstraint(m);continue t}}}for(let r=0,l=t.length;r<l;r++)this.sortBone(t[r])}sortIkConstraint(e){if(e.active=e.target.isActive()&&(!e.data.skinRequired||this.skin!=null&&u.Utils.contains(this.skin.constraints,e.data,!0)),!e.active)return;const t=e.target;this.sortBone(t);const n=e.bones,s=n[0];if(this.sortBone(s),n.length>1){const a=n[n.length-1];this._updateCache.indexOf(a)>-1||this.updateCacheReset.push(a)}this._updateCache.push(e),this.sortReset(s.children),n[n.length-1].sorted=!0}sortPathConstraint(e){if(e.active=e.target.bone.isActive()&&(!e.data.skinRequired||this.skin!=null&&u.Utils.contains(this.skin.constraints,e.data,!0)),!e.active)return;const t=e.target,n=t.data.index,s=t.bone;this.skin!=null&&this.sortPathConstraintAttachment(this.skin,n,s),this.data.defaultSkin!=null&&this.data.defaultSkin!=this.skin&&this.sortPathConstraintAttachment(this.data.defaultSkin,n,s);for(let o=0,i=this.data.skins.length;o<i;o++)this.sortPathConstraintAttachment(this.data.skins[o],n,s);const a=t.getAttachment();a instanceof kt&&this.sortPathConstraintAttachmentWith(a,s);const h=e.bones,d=h.length;for(let o=0;o<d;o++)this.sortBone(h[o]);this._updateCache.push(e);for(let o=0;o<d;o++)this.sortReset(h[o].children);for(let o=0;o<d;o++)h[o].sorted=!0}sortTransformConstraint(e){if(e.active=e.target.isActive()&&(!e.data.skinRequired||this.skin!=null&&u.Utils.contains(this.skin.constraints,e.data,!0)),!e.active)return;this.sortBone(e.target);const t=e.bones,n=t.length;if(e.data.local)for(let s=0;s<n;s++){const a=t[s];this.sortBone(a.parent),this._updateCache.indexOf(a)>-1||this.updateCacheReset.push(a)}else for(let s=0;s<n;s++)this.sortBone(t[s]);this._updateCache.push(e);for(let s=0;s<n;s++)this.sortReset(t[s].children);for(let s=0;s<n;s++)t[s].sorted=!0}sortPathConstraintAttachment(e,t,n){const s=e.attachments[t];if(s)for(const a in s)this.sortPathConstraintAttachmentWith(s[a],n)}sortPathConstraintAttachmentWith(e,t){if(!(e instanceof kt))return;const n=e.bones;if(n==null)this.sortBone(t);else{const s=this.bones;let a=0;for(;a<n.length;){const h=n[a++];for(let d=a+h;a<d;a++){const o=n[a];this.sortBone(s[o])}}}}sortBone(e){if(e.sorted)return;const t=e.parent;t!=null&&this.sortBone(t),e.sorted=!0,this._updateCache.push(e)}sortReset(e){for(let t=0,n=e.length;t<n;t++){const s=e[t];s.active&&(s.sorted&&this.sortReset(s.children),s.sorted=!1)}}updateWorldTransform(){const e=this.updateCacheReset;for(let n=0,s=e.length;n<s;n++){const a=e[n];a.ax=a.x,a.ay=a.y,a.arotation=a.rotation,a.ascaleX=a.scaleX,a.ascaleY=a.scaleY,a.ashearX=a.shearX,a.ashearY=a.shearY,a.appliedValid=!0}const t=this._updateCache;for(let n=0,s=t.length;n<s;n++)t[n].update()}setToSetupPose(){this.setBonesToSetupPose(),this.setSlotsToSetupPose()}setBonesToSetupPose(){const e=this.bones;for(let a=0,h=e.length;a<h;a++)e[a].setToSetupPose();const t=this.ikConstraints;for(let a=0,h=t.length;a<h;a++){const d=t[a];d.mix=d.data.mix,d.softness=d.data.softness,d.bendDirection=d.data.bendDirection,d.compress=d.data.compress,d.stretch=d.data.stretch}const n=this.transformConstraints;for(let a=0,h=n.length;a<h;a++){const d=n[a],o=d.data;d.rotateMix=o.rotateMix,d.translateMix=o.translateMix,d.scaleMix=o.scaleMix,d.shearMix=o.shearMix}const s=this.pathConstraints;for(let a=0,h=s.length;a<h;a++){const d=s[a],o=d.data;d.position=o.position,d.spacing=o.spacing,d.rotateMix=o.rotateMix,d.translateMix=o.translateMix}}setSlotsToSetupPose(){const e=this.slots;u.Utils.arrayCopy(e,0,this.drawOrder,0,e.length);for(let t=0,n=e.length;t<n;t++)e[t].setToSetupPose()}getRootBone(){return this.bones.length==0?null:this.bones[0]}findBone(e){if(e==null)throw new Error("boneName cannot be null.");const t=this.bones;for(let n=0,s=t.length;n<s;n++){const a=t[n];if(a.data.name==e)return a}return null}findBoneIndex(e){if(e==null)throw new Error("boneName cannot be null.");const t=this.bones;for(let n=0,s=t.length;n<s;n++)if(t[n].data.name==e)return n;return-1}findSlot(e){if(e==null)throw new Error("slotName cannot be null.");const t=this.slots;for(let n=0,s=t.length;n<s;n++){const a=t[n];if(a.data.name==e)return a}return null}findSlotIndex(e){if(e==null)throw new Error("slotName cannot be null.");const t=this.slots;for(let n=0,s=t.length;n<s;n++)if(t[n].data.name==e)return n;return-1}setSkinByName(e){const t=this.data.findSkin(e);if(t==null)throw new Error(`Skin not found: ${e}`);this.setSkin(t)}setSkin(e){if(e!=this.skin){if(e!=null)if(this.skin!=null)e.attachAll(this,this.skin);else{const t=this.slots;for(let n=0,s=t.length;n<s;n++){const a=t[n],h=a.data.attachmentName;if(h!=null){const d=e.getAttachment(n,h);d!=null&&a.setAttachment(d)}}}this.skin=e,this.updateCache()}}getAttachmentByName(e,t){return this.getAttachment(this.data.findSlotIndex(e),t)}getAttachment(e,t){if(t==null)throw new Error("attachmentName cannot be null.");if(this.skin!=null){const n=this.skin.getAttachment(e,t);if(n!=null)return n}return this.data.defaultSkin!=null?this.data.defaultSkin.getAttachment(e,t):null}setAttachment(e,t){if(e==null)throw new Error("slotName cannot be null.");const n=this.slots;for(let s=0,a=n.length;s<a;s++){const h=n[s];if(h.data.name==e){let d=null;if(t!=null&&(d=this.getAttachment(s,t),d==null))throw new Error(`Attachment not found: ${t}, for slot: ${e}`);h.setAttachment(d);return}}throw new Error(`Slot not found: ${e}`)}findIkConstraint(e){if(e==null)throw new Error("constraintName cannot be null.");const t=this.ikConstraints;for(let n=0,s=t.length;n<s;n++){const a=t[n];if(a.data.name==e)return a}return null}findTransformConstraint(e){if(e==null)throw new Error("constraintName cannot be null.");const t=this.transformConstraints;for(let n=0,s=t.length;n<s;n++){const a=t[n];if(a.data.name==e)return a}return null}findPathConstraint(e){if(e==null)throw new Error("constraintName cannot be null.");const t=this.pathConstraints;for(let n=0,s=t.length;n<s;n++){const a=t[n];if(a.data.name==e)return a}return null}getBounds(e,t,n=new Array(2)){if(e==null)throw new Error("offset cannot be null.");if(t==null)throw new Error("size cannot be null.");const s=this.drawOrder;let a=Number.POSITIVE_INFINITY,h=Number.POSITIVE_INFINITY,d=Number.NEGATIVE_INFINITY,o=Number.NEGATIVE_INFINITY;for(let i=0,r=s.length;i<r;i++){const l=s[i];if(!l.bone.active)continue;let m=0,f=null;const c=l.getAttachment();if(c instanceof B)m=8,f=u.Utils.setArraySize(n,m,0),c.computeWorldVertices(l.bone,f,0,2);else if(c instanceof Ct){const g=c;m=g.worldVerticesLength,f=u.Utils.setArraySize(n,m,0),g.computeWorldVertices(l,0,m,f,0,2)}if(f!=null)for(let g=0,M=f.length;g<M;g+=2){const p=f[g],x=f[g+1];a=Math.min(a,p),h=Math.min(h,x),d=Math.max(d,p),o=Math.max(o,x)}}e.set(a,h),t.set(d-a,o-h)}update(e){this.time+=e}get flipX(){return this.scaleX==-1}set flipX(e){Dt.deprecatedWarning1||(Dt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleX=e?1:-1}get flipY(){return this.scaleY==-1}set flipY(e){Dt.deprecatedWarning1||(Dt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleY=e?1:-1}};let re=Dt;re.deprecatedWarning1=!1;class oe{constructor(){this.bones=new Array,this.slots=new Array,this.skins=new Array,this.events=new Array,this.animations=new Array,this.ikConstraints=new Array,this.transformConstraints=new Array,this.pathConstraints=new Array,this.fps=0}findBone(t){if(t==null)throw new Error("boneName cannot be null.");const n=this.bones;for(let s=0,a=n.length;s<a;s++){const h=n[s];if(h.name==t)return h}return null}findBoneIndex(t){if(t==null)throw new Error("boneName cannot be null.");const n=this.bones;for(let s=0,a=n.length;s<a;s++)if(n[s].name==t)return s;return-1}findSlot(t){if(t==null)throw new Error("slotName cannot be null.");const n=this.slots;for(let s=0,a=n.length;s<a;s++){const h=n[s];if(h.name==t)return h}return null}findSlotIndex(t){if(t==null)throw new Error("slotName cannot be null.");const n=this.slots;for(let s=0,a=n.length;s<a;s++)if(n[s].name==t)return s;return-1}findSkin(t){if(t==null)throw new Error("skinName cannot be null.");const n=this.skins;for(let s=0,a=n.length;s<a;s++){const h=n[s];if(h.name==t)return h}return null}findEvent(t){if(t==null)throw new Error("eventDataName cannot be null.");const n=this.events;for(let s=0,a=n.length;s<a;s++){const h=n[s];if(h.name==t)return h}return null}findAnimation(t){if(t==null)throw new Error("animationName cannot be null.");const n=this.animations;for(let s=0,a=n.length;s<a;s++){const h=n[s];if(h.name==t)return h}return null}findIkConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const n=this.ikConstraints;for(let s=0,a=n.length;s<a;s++){const h=n[s];if(h.name==t)return h}return null}findTransformConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const n=this.transformConstraints;for(let s=0,a=n.length;s<a;s++){const h=n[s];if(h.name==t)return h}return null}findPathConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const n=this.pathConstraints;for(let s=0,a=n.length;s<a;s++){const h=n[s];if(h.name==t)return h}return null}findPathConstraintIndex(t){if(t==null)throw new Error("pathConstraintName cannot be null.");const n=this.pathConstraints;for(let s=0,a=n.length;s<a;s++)if(n[s].name==t)return s;return-1}}class le{constructor(t,n,s){if(this.color=new u.Color(1,1,1,1),t<0)throw new Error("index must be >= 0.");if(n==null)throw new Error("name cannot be null.");if(s==null)throw new Error("boneData cannot be null.");this.index=t,this.name=n,this.boneData=s}}class he extends bt{constructor(t){super(t,0,!1),this.bones=new Array,this.rotateMix=0,this.translateMix=0,this.scaleMix=0,this.shearMix=0,this.offsetRotation=0,this.offsetX=0,this.offsetY=0,this.offsetScaleX=0,this.offsetScaleY=0,this.offsetShearY=0,this.relative=!1,this.local=!1}}class ce{constructor(t,n,s){this.slotIndex=t,this.name=n,this.attachment=s}}class Wt{constructor(t){if(this.attachments=new Array,this.bones=Array(),this.constraints=new Array,t==null)throw new Error("name cannot be null.");this.name=t}setAttachment(t,n,s){if(s==null)throw new Error("attachment cannot be null.");const a=this.attachments;t>=a.length&&(a.length=t+1),a[t]||(a[t]={}),a[t][n]=s}addSkin(t){for(let s=0;s<t.bones.length;s++){const a=t.bones[s];let h=!1;for(let d=0;d<this.bones.length;d++)if(this.bones[d]==a){h=!0;break}h||this.bones.push(a)}for(let s=0;s<t.constraints.length;s++){const a=t.constraints[s];let h=!1;for(let d=0;d<this.constraints.length;d++)if(this.constraints[d]==a){h=!0;break}h||this.constraints.push(a)}const n=t.getAttachments();for(let s=0;s<n.length;s++){const a=n[s];this.setAttachment(a.slotIndex,a.name,a.attachment)}}copySkin(t){for(let s=0;s<t.bones.length;s++){const a=t.bones[s];let h=!1;for(let d=0;d<this.bones.length;d++)if(this.bones[d]==a){h=!0;break}h||this.bones.push(a)}for(let s=0;s<t.constraints.length;s++){const a=t.constraints[s];let h=!1;for(let d=0;d<this.constraints.length;d++)if(this.constraints[d]==a){h=!0;break}h||this.constraints.push(a)}const n=t.getAttachments();for(let s=0;s<n.length;s++){const a=n[s];a.attachment!=null&&(a.attachment instanceof Ct?(a.attachment=a.attachment.newLinkedMesh(),this.setAttachment(a.slotIndex,a.name,a.attachment)):(a.attachment=a.attachment.copy(),this.setAttachment(a.slotIndex,a.name,a.attachment)))}}getAttachment(t,n){const s=this.attachments[t];return s?s[n]:null}removeAttachment(t,n){const s=this.attachments[t];s&&(s[n]=null)}getAttachments(){const t=new Array;for(let n=0;n<this.attachments.length;n++){const s=this.attachments[n];if(s)for(const a in s){const h=s[a];h&&t.push(new ce(n,a,h))}}return t}getAttachmentsForSlot(t,n){const s=this.attachments[t];if(s)for(const a in s){const h=s[a];h&&n.push(new ce(t,a,h))}}clear(){this.attachments.length=0,this.bones.length=0,this.constraints.length=0}attachAll(t,n){let s=0;for(let a=0;a<t.slots.length;a++){const h=t.slots[a],d=h.getAttachment();if(d&&s<n.attachments.length){const o=n.attachments[s];for(const i in o){const r=o[i];if(d==r){const l=this.getAttachment(s,i);l!=null&&h.setAttachment(l);break}}}s++}}}const Z=class{constructor(e){this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=e}readSkeletonData(e){const t=this.scale,n=new oe;n.name="";const s=new u.BinaryInput(e);n.hash=s.readString(),n.version=s.readString(),n.version==="3.8.75"&&console.error("Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine."),n.width=s.readFloat(),n.height=s.readFloat();const a=s.readBoolean();a&&(n.imagesPath=s.readString());let h=0;h=s.readInt(!0);for(let o=0;o<h;o++){const i=s.readString(),r=o==0?null:n.bones[s.readInt(!0)],l=new ee(o,i,r);l.rotation=s.readFloat(),l.x=s.readFloat()*t,l.y=s.readFloat()*t,l.scaleX=s.readFloat(),l.scaleY=s.readFloat(),l.shearX=s.readFloat(),l.shearY=s.readFloat(),l.length=s.readFloat()*t,l.inheritRotation=s.readBoolean(),l.inheritScale=s.readBoolean(),a&&u.Color.rgba8888ToColor(l.color,s.readInt32()),n.bones.push(l)}h=s.readInt(!0);for(let o=0;o<h;o++){const i=s.readString(),r=n.bones[s.readInt(!0)],l=new le(o,i,r);u.Color.rgba8888ToColor(l.color,s.readInt32()),l.attachmentName=s.readString(),l.blendMode=Z.BlendModeValues[s.readInt(!0)],n.slots.push(l)}h=s.readInt(!0);for(let o=0,i;o<h;o++){const r=s.readString(),l=new ie(r);i=s.readInt(!0);for(let m=0;m<i;m++)l.bones.push(n.bones[s.readInt(!0)]);l.target=n.bones[s.readInt(!0)],l.mix=s.readFloat(),l.bendDirection=s.readByte(),n.ikConstraints.push(l)}h=s.readInt(!0);for(let o=0,i;o<h;o++){const r=s.readString(),l=new he(r);i=s.readInt(!0);for(let m=0;m<i;m++)l.bones.push(n.bones[s.readInt(!0)]);l.target=n.bones[s.readInt(!0)],l.offsetRotation=s.readFloat(),l.offsetX=s.readFloat()*t,l.offsetY=s.readFloat()*t,l.offsetScaleX=s.readFloat(),l.offsetScaleY=s.readFloat(),l.offsetShearY=s.readFloat(),l.rotateMix=s.readFloat(),l.translateMix=s.readFloat(),l.scaleMix=s.readFloat(),l.shearMix=s.readFloat(),n.transformConstraints.push(l)}h=s.readInt(!0);for(let o=0,i;o<h;o++){const r=s.readString(),l=new ae(r);i=s.readInt(!0);for(let m=0;m<i;m++)l.bones.push(n.bones[s.readInt(!0)]);l.target=n.slots[s.readInt(!0)],l.positionMode=Z.PositionModeValues[s.readInt(!0)],l.spacingMode=Z.SpacingModeValues[s.readInt(!0)],l.rotateMode=Z.RotateModeValues[s.readInt(!0)],l.offsetRotation=s.readFloat(),l.position=s.readFloat(),l.positionMode==u.PositionMode.Fixed&&(l.position*=t),l.spacing=s.readFloat(),(l.spacingMode==J.Length||l.spacingMode==J.Fixed)&&(l.spacing*=t),l.rotateMix=s.readFloat(),l.translateMix=s.readFloat(),n.pathConstraints.push(l)}const d=this.readSkin(s,n,!0,a);d!=null&&(n.defaultSkin=d,n.skins.push(d));{let o=n.skins.length;for(u.Utils.setArraySize(n.skins,h=o+s.readInt(!0));o<h;o++)n.skins[o]=this.readSkin(s,n,!1,a)}h=this.linkedMeshes.length;for(let o=0;o<h;o++){const i=this.linkedMeshes[o],r=i.skin==null?n.defaultSkin:n.findSkin(i.skin);if(r==null)throw new Error(`Skin not found: ${i.skin}`);const l=r.getAttachment(i.slotIndex,i.parent);if(l==null)throw new Error(`Parent mesh not found: ${i.parent}`);i.mesh.deformAttachment=i.inheritDeform?l:i.mesh,i.mesh.setParentMesh(l)}this.linkedMeshes.length=0,h=s.readInt(!0);for(let o=0;o<h;o++){const i=new se(s.readStringRef());i.intValue=s.readInt(!1),i.floatValue=s.readFloat(),i.stringValue=s.readString(),i.audioPath=s.readString(),i.audioPath!=null&&(i.volume=s.readFloat(),i.balance=s.readFloat()),n.events.push(i)}h=s.readInt(!0);for(let o=0;o<h;o++)n.animations.push(this.readAnimation(s,s.readString(),n));return n}readSkin(e,t,n,s){let a=null,h=0;if(n){if(h=e.readInt(!0),h==0)return null;a=new Wt("default")}else{a=new Wt(e.readString()),a.bones.length=e.readInt(!0);for(let d=0,o=a.bones.length;d<o;d++)a.bones[d]=t.bones[e.readInt(!0)];for(let d=0,o=e.readInt(!0);d<o;d++)a.constraints.push(t.ikConstraints[e.readInt(!0)]);for(let d=0,o=e.readInt(!0);d<o;d++)a.constraints.push(t.transformConstraints[e.readInt(!0)]);for(let d=0,o=e.readInt(!0);d<o;d++)a.constraints.push(t.pathConstraints[e.readInt(!0)]);h=e.readInt(!0)}for(let d=0;d<h;d++){const o=e.readInt(!0);for(let i=0,r=e.readInt(!0);i<r;i++){const l=e.readString(),m=this.readAttachment(e,t,a,o,l,s);m!=null&&a.setAttachment(o,l,m)}}return a}readAttachment(e,t,n,s,a,h){const d=this.scale;let o=e.readStringRef();o==null&&(o=a);const i=e.readByte();switch(Z.AttachmentTypeValues[i]){case u.AttachmentType.Region:{let r=e.readString();const l=e.readFloat(),m=e.readFloat(),f=e.readFloat(),c=e.readFloat(),g=e.readFloat(),M=e.readFloat(),p=e.readFloat(),x=e.readInt32();r==null&&(r=o);const E=this.attachmentLoader.newRegionAttachment(n,o,r);return E==null?null:(E.path=r,E.x=m*d,E.y=f*d,E.scaleX=c,E.scaleY=g,E.rotation=l,E.width=M*d,E.height=p*d,u.Color.rgba8888ToColor(E.color,x),E)}case u.AttachmentType.BoundingBox:{const r=e.readInt(!0),l=this.readVertices(e,r),m=h?e.readInt32():0,f=this.attachmentLoader.newBoundingBoxAttachment(n,o);return f==null?null:(f.worldVerticesLength=r<<1,f.vertices=l.vertices,f.bones=l.bones,f.cVertices=l.cVertices,h&&u.Color.rgba8888ToColor(f.color,m),f)}case u.AttachmentType.Mesh:{let r=e.readStringRef();const l=e.readInt32(),m=e.readInt(!0),f=this.readFloatArray(e,m<<1,1),c=this.readShortArray(e),g=this.readVertices(e,m),M=e.readInt(!0);let p=null,x=0,E=0;h&&(p=this.readShortArray(e),x=e.readFloat(),E=e.readFloat()),r==null&&(r=o);const w=this.attachmentLoader.newMeshAttachment(n,o,r);return w==null?null:(w.path=r,u.Color.rgba8888ToColor(w.color,l),w.bones=g.bones,w.vertices=g.vertices,w.worldVerticesLength=m<<1,w.triangles=c,w.regionUVs=new Float32Array(f),w.cVertices=g.cVertices,w.hullLength=M<<1,h&&(w.edges=p,w.width=x*d,w.height=E*d),w)}case u.AttachmentType.LinkedMesh:{let r=e.readStringRef();const l=e.readInt32(),m=e.readStringRef(),f=e.readStringRef(),c=e.readBoolean();let g=0,M=0;h&&(g=e.readFloat(),M=e.readFloat()),r==null&&(r=o);const p=this.attachmentLoader.newMeshAttachment(n,o,r);return p==null?null:(p.path=r,u.Color.rgba8888ToColor(p.color,l),h&&(p.width=g*d,p.height=M*d),this.linkedMeshes.push(new Pe(p,m,s,f,c)),p)}case u.AttachmentType.Path:{const r=e.readBoolean(),l=e.readBoolean(),m=e.readInt(!0),f=this.readVertices(e,m),c=u.Utils.newArray(m/3,0);for(let p=0,x=c.length;p<x;p++)c[p]=e.readFloat()*d;const g=h?e.readInt32():0,M=this.attachmentLoader.newPathAttachment(n,o);return M==null?null:(M.closed=r,M.constantSpeed=l,M.worldVerticesLength=m<<1,M.vertices=f.vertices,M.bones=f.bones,M.lengths=c,M.cVertices=f.cVertices,h&&u.Color.rgba8888ToColor(M.color,g),M)}case u.AttachmentType.Point:{const r=e.readFloat(),l=e.readFloat(),m=e.readFloat(),f=h?e.readInt32():0,c=this.attachmentLoader.newPointAttachment(n,o);return c==null?null:(c.x=l*d,c.y=m*d,c.rotation=r,h&&u.Color.rgba8888ToColor(c.color,f),c)}case u.AttachmentType.Clipping:{const r=e.readInt(!0),l=e.readInt(!0),m=this.readVertices(e,l),f=h?e.readInt32():0,c=this.attachmentLoader.newClippingAttachment(n,o);return c==null?null:(c.endSlot=t.slots[r],c.worldVerticesLength=l<<1,c.vertices=m.vertices,c.bones=m.bones,c.cVertices=m.cVertices,h&&u.Color.rgba8888ToColor(c.color,f),c)}}return null}readVertices(e,t){const n=t<<1,s=new Fe,a=this.scale;if(!e.readBoolean())return s.vertices=this.readFloatArray(e,n,a),s;const h=new Array,d=new Array,o=new Array;for(let i=0;i<t;i++){const r=e.readInt(!0);o.push(r),h.push(r);for(let l=0;l<r;l++){const m=e.readInt(!0);o.push(m),h.push(m);const f=e.readFloat()*a,c=e.readFloat()*a,g=e.readFloat();d.push(f),d.push(c),d.push(g),h.push(f),h.push(c),h.push(g)}}return s.vertices=u.Utils.toFloatArray(d),s.bones=o,s.cVertices=h,s}readFloatArray(e,t,n){const s=new Array(t);if(n==1)for(let a=0;a<t;a++)s[a]=e.readFloat();else for(let a=0;a<t;a++)s[a]=e.readFloat()*n;return s}readShortArray(e){const t=e.readInt(!0),n=new Array(t);for(let s=0;s<t;s++)n[s]=e.readShort();return n}readAnimation(e,t,n){const s=new Array,a=this.scale;let h=0;const d=new u.Color;for(let r=0,l=e.readInt(!0);r<l;r++){const m=e.readInt(!0);for(let f=0,c=e.readInt(!0);f<c;f++){const g=e.readByte(),M=e.readInt(!0);switch(g){case Z.SLOT_ATTACHMENT:{const p=new Vt(M);p.slotIndex=m;for(let x=0;x<M;x++){const E=e.readFloat(),w=e.readString();p.setFrame(x,E,w)}s.push(p),h=Math.max(h,p.frames[M-1]);break}case Z.SLOT_COLOR:{const p=new st(M);p.slotIndex=m;for(let x=0;x<M;x++){const E=e.readFloat();u.Color.rgba8888ToColor(d,e.readInt32()),p.setFrame(x,E,d.r,d.g,d.b,d.a),x<M-1&&this.readCurve(e,x,p)}s.push(p),h=Math.max(h,p.frames[(M-1)*st.ENTRIES]);break}}}}for(let r=0,l=e.readInt(!0);r<l;r++){const m=e.readInt(!0);for(let f=0,c=e.readInt(!0);f<c;f++){const g=e.readByte(),M=e.readInt(!0);switch(g){case Z.BONE_ROTATE:{const p=new tt(M);p.boneIndex=m;for(let x=0;x<M;x++)p.setFrame(x,e.readFloat(),e.readFloat()),x<M-1&&this.readCurve(e,x,p);s.push(p),h=Math.max(h,p.frames[(M-1)*tt.ENTRIES]);break}case Z.BONE_TRANSLATE:case Z.BONE_SCALE:case Z.BONE_SHEAR:{let p,x=1;g==Z.BONE_SCALE?p=new ht(M):g==Z.BONE_SHEAR?p=new ct(M):(p=new mt(M),x=a),p.boneIndex=m;for(let E=0;E<M;E++){const w=e.readFloat(),S=e.readFloat(),T=e.readFloat();p.setFrame(E,w,S*x,T*x),E<M-1&&this.readCurve(e,E,p)}s.push(p),h=Math.max(h,p.frames[(M-1)*mt.ENTRIES]);break}}}}for(let r=0,l=e.readInt(!0);r<l;r++){const m=e.readInt(!0),f=e.readInt(!0),c=new et(f);c.ikConstraintIndex=m;for(let g=0;g<f;g++){const M=e.readFloat(),p=e.readFloat(),x=e.readByte();c.setFrame(g,M,p,x),g<f-1&&this.readCurve(e,g,c)}s.push(c),h=Math.max(h,c.frames[(f-1)*et.ENTRIES])}for(let r=0,l=e.readInt(!0);r<l;r++){const m=e.readInt(!0),f=e.readInt(!0),c=new it(f);c.transformConstraintIndex=m;for(let g=0;g<f;g++)c.setFrame(g,e.readFloat(),e.readFloat(),e.readFloat(),e.readFloat(),e.readFloat()),g<f-1&&this.readCurve(e,g,c);s.push(c),h=Math.max(h,c.frames[(f-1)*it.ENTRIES])}for(let r=0,l=e.readInt(!0);r<l;r++){const m=e.readInt(!0),f=n.pathConstraints[m];for(let c=0,g=e.readInt(!0);c<g;c++){const M=e.readByte(),p=e.readInt(!0);switch(M){case Z.PATH_POSITION:case Z.PATH_SPACING:{let x,E=1;M==Z.PATH_SPACING?(x=new Mt(p),(f.spacingMode==J.Length||f.spacingMode==J.Fixed)&&(E=a)):(x=new Et(p),f.positionMode==u.PositionMode.Fixed&&(E=a)),x.pathConstraintIndex=m;for(let w=0;w<p;w++){const S=e.readFloat(),T=e.readFloat()*E;x.setFrame(w,S,T),w<p-1&&this.readCurve(e,w,x)}s.push(x),h=Math.max(h,x.frames[(p-1)*Et.ENTRIES]);break}case Z.PATH_MIX:{const x=new xt(p);x.pathConstraintIndex=m;for(let E=0;E<p;E++){const w=e.readFloat(),S=e.readFloat(),T=e.readFloat();x.setFrame(E,w,S,T),E<p-1&&this.readCurve(e,E,x)}s.push(x),h=Math.max(h,x.frames[(p-1)*xt.ENTRIES]);break}}}}for(let r=0,l=e.readInt(!0);r<l;r++){const m=n.skins[e.readInt(!0)];for(let f=0,c=e.readInt(!0);f<c;f++){const g=e.readInt(!0);for(let M=0,p=e.readInt(!0);M<p;M++){const x=m==null?void 0:m.getAttachment(g,e.readString()),E=x.bones!=null,w=x.vertices,S=E?w.length/3*2:w.length,T=e.readInt(!0),I=new Zt(T);I.slotIndex=g,I.attachment=x;for(let A=0;A<T;A++){const R=e.readFloat();let y,k=e.readInt(!0);if(k==0)y=E?u.Utils.newFloatArray(S):w;else{y=u.Utils.newFloatArray(S);const X=e.readInt(!0);if(k+=X,a==1)for(let N=X;N<k;N++)y[N]=e.readFloat();else for(let N=X;N<k;N++)y[N]=e.readFloat()*a;if(!E)for(let N=0,$=y.length;N<$;N++)y[N]+=w[N]}I.setFrame(A,R,y,m.name),A<T-1&&this.readCurve(e,A,I)}s.push(I),h=Math.max(h,I.frames[T-1])}}}const o=e.readInt(!0);if(o>0){const r=new Bt(o),l=n.slots.length;for(let m=0;m<o;m++){const f=e.readFloat(),c=e.readInt(!0),g=u.Utils.newArray(l,0);for(let E=l-1;E>=0;E--)g[E]=-1;const M=u.Utils.newArray(l-c,0);let p=0,x=0;for(let E=0;E<c;E++){const w=e.readInt(!0);for(;p!=w;)M[x++]=p++;g[p+e.readInt(!0)]=p++}for(;p<l;)M[x++]=p++;for(let E=l-1;E>=0;E--)g[E]==-1&&(g[E]=M[--x]);r.setFrame(m,f,g)}s.push(r),h=Math.max(h,r.frames[o-1])}const i=e.readInt(!0);if(i>0){const r=new Ot(i);for(let l=0;l<i;l++){const m=e.readFloat(),f=n.events[e.readInt(!0)],c=new ne(m,f);c.intValue=e.readInt(!1),c.floatValue=e.readFloat(),c.stringValue=e.readBoolean()?e.readString():f.stringValue,c.data.audioPath!=null&&(c.volume=e.readFloat(),c.balance=e.readFloat()),r.setFrame(l,c)}s.push(r),h=Math.max(h,r.frames[i-1])}return new G(t,s,h)}readCurve(e,t,n){switch(e.readByte()){case Z.CURVE_STEPPED:n.setStepped(t);break;case Z.CURVE_BEZIER:this.setCurve(n,t,e.readFloat(),e.readFloat(),e.readFloat(),e.readFloat());break}}setCurve(e,t,n,s,a,h){e.setCurve(t,n,s,a,h)}};let z=Z;z.AttachmentTypeValues=[0,1,2,3,4,5,6],z.TransformModeValues=[u.TransformMode.Normal,u.TransformMode.OnlyTranslation,u.TransformMode.NoRotationOrReflection,u.TransformMode.NoScale,u.TransformMode.NoScaleOrReflection],z.PositionModeValues=[u.PositionMode.Fixed,u.PositionMode.Percent],z.SpacingModeValues=[J.Length,J.Fixed,J.Percent],z.RotateModeValues=[u.RotateMode.Tangent,u.RotateMode.Chain,u.RotateMode.ChainScale],z.BlendModeValues=[wt.BLEND_MODES.NORMAL,wt.BLEND_MODES.ADD,wt.BLEND_MODES.MULTIPLY,wt.BLEND_MODES.SCREEN],z.BONE_ROTATE=0,z.BONE_TRANSLATE=1,z.BONE_SCALE=2,z.BONE_SHEAR=3,z.SLOT_ATTACHMENT=0,z.SLOT_COLOR=1,z.SLOT_TWO_COLOR=2,z.PATH_POSITION=0,z.PATH_SPACING=1,z.PATH_MIX=2,z.CURVE_LINEAR=0,z.CURVE_STEPPED=1,z.CURVE_BEZIER=2;class Pe{constructor(t,n,s,a,h){this.mesh=t,this.skin=n,this.slotIndex=s,this.parent=a,this.inheritDeform=h}}class Fe{constructor(t=null,n=null,s=null){this.bones=t,this.vertices=n,this.cVertices=s}}class Be extends u.SkeletonBoundsBase{}class Ft{constructor(t){this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=t}readSkeletonData(t){const n=this.scale,s=new oe,a=typeof t=="string"?JSON.parse(t):t,h=a.skeleton;if(h!=null){if(s.hash=h.hash,s.version=h.spine,s.version.substr(0,3)!=="3.4"){const d=`Spine 3.4 loader cant load version ${h.spine}. Please configure your pixi-spine bundle`;console.error(d)}s.version==="3.4.75"&&console.error("Unsupported skeleton data, 3.4.75 is deprecated, please export with a newer version of Spine."),s.x=h.x,s.y=h.y,s.width=h.width,s.height=h.height,s.fps=h.fps,s.imagesPath=h.images}if(a.bones)for(let d=0;d<a.bones.length;d++){const o=a.bones[d];let i=null;const r=this.getValue(o,"parent",null);if(r!=null&&(i=s.findBone(r),i==null))throw new Error(`Parent bone not found: ${r}`);const l=new ee(s.bones.length,o.name,i);l.length=this.getValue(o,"length",0)*n,l.x=this.getValue(o,"x",0)*n,l.y=this.getValue(o,"y",0)*n,l.rotation=this.getValue(o,"rotation",0),l.scaleX=this.getValue(o,"scaleX",1),l.scaleY=this.getValue(o,"scaleY",1),l.shearX=this.getValue(o,"shearX",0),l.shearY=this.getValue(o,"shearY",0),l.transformMode=Ft.transformModeFromString(this.getValue(o,"transform","normal")),l.skinRequired=this.getValue(o,"skin",!1),s.bones.push(l)}if(a.slots)for(let d=0;d<a.slots.length;d++){const o=a.slots[d],i=o.name,r=o.bone,l=s.findBone(r);if(l==null)throw new Error(`Slot bone not found: ${r}`);const m=new le(s.slots.length,i,l),f=this.getValue(o,"color",null);f!=null&&m.color.setFromString(f);const c=this.getValue(o,"dark",null);c!=null&&(m.darkColor=new u.Color(1,1,1,1),m.darkColor.setFromString(c)),m.attachmentName=this.getValue(o,"attachment",null),m.blendMode=Ft.blendModeFromString(this.getValue(o,"blend","normal")),s.slots.push(m)}if(a.ik)for(let d=0;d<a.ik.length;d++){const o=a.ik[d],i=new ie(o.name);i.order=this.getValue(o,"order",0),i.skinRequired=this.getValue(o,"skin",!1);for(let l=0;l<o.bones.length;l++){const m=o.bones[l],f=s.findBone(m);if(f==null)throw new Error(`IK bone not found: ${m}`);i.bones.push(f)}const r=o.target;if(i.target=s.findBone(r),i.target==null)throw new Error(`IK target bone not found: ${r}`);i.mix=this.getValue(o,"mix",1),i.softness=this.getValue(o,"softness",0)*n,i.bendDirection=this.getValue(o,"bendPositive",!0)?1:-1,i.compress=this.getValue(o,"compress",!1),i.stretch=this.getValue(o,"stretch",!1),i.uniform=this.getValue(o,"uniform",!1),s.ikConstraints.push(i)}if(a.transform)for(let d=0;d<a.transform.length;d++){const o=a.transform[d],i=new he(o.name);i.order=this.getValue(o,"order",0),i.skinRequired=this.getValue(o,"skin",!1);for(let l=0;l<o.bones.length;l++){const m=o.bones[l],f=s.findBone(m);if(f==null)throw new Error(`Transform constraint bone not found: ${m}`);i.bones.push(f)}const r=o.target;if(i.target=s.findBone(r),i.target==null)throw new Error(`Transform constraint target bone not found: ${r}`);i.local=this.getValue(o,"local",!1),i.relative=this.getValue(o,"relative",!1),i.offsetRotation=this.getValue(o,"rotation",0),i.offsetX=this.getValue(o,"x",0)*n,i.offsetY=this.getValue(o,"y",0)*n,i.offsetScaleX=this.getValue(o,"scaleX",0),i.offsetScaleY=this.getValue(o,"scaleY",0),i.offsetShearY=this.getValue(o,"shearY",0),i.rotateMix=this.getValue(o,"rotateMix",1),i.translateMix=this.getValue(o,"translateMix",1),i.scaleMix=this.getValue(o,"scaleMix",1),i.shearMix=this.getValue(o,"shearMix",1),s.transformConstraints.push(i)}if(a.path)for(let d=0;d<a.path.length;d++){const o=a.path[d],i=new ae(o.name);i.order=this.getValue(o,"order",0),i.skinRequired=this.getValue(o,"skin",!1);for(let l=0;l<o.bones.length;l++){const m=o.bones[l],f=s.findBone(m);if(f==null)throw new Error(`Transform constraint bone not found: ${m}`);i.bones.push(f)}const r=o.target;if(i.target=s.findSlot(r),i.target==null)throw new Error(`Path target slot not found: ${r}`);i.positionMode=Ft.positionModeFromString(this.getValue(o,"positionMode","percent")),i.spacingMode=Ft.spacingModeFromString(this.getValue(o,"spacingMode","length")),i.rotateMode=Ft.rotateModeFromString(this.getValue(o,"rotateMode","tangent")),i.offsetRotation=this.getValue(o,"rotation",0),i.position=this.getValue(o,"position",0),i.positionMode==u.PositionMode.Fixed&&(i.position*=n),i.spacing=this.getValue(o,"spacing",0),(i.spacingMode==J.Length||i.spacingMode==J.Fixed)&&(i.spacing*=n),i.rotateMix=this.getValue(o,"rotateMix",1),i.translateMix=this.getValue(o,"translateMix",1),s.pathConstraints.push(i)}if(a.skins)for(let d=0;d<a.skins.length;d++){const o=a.skins[d],i=new Wt(o.name);if(o.bones)for(let r=0;r<o.bones.length;r++){const l=s.findBone(o.bones[r]);if(l==null)throw new Error(`Skin bone not found: ${o.bones[d]}`);i.bones.push(l)}if(o.ik)for(let r=0;r<o.ik.length;r++){const l=s.findIkConstraint(o.ik[r]);if(l==null)throw new Error(`Skin IK constraint not found: ${o.ik[d]}`);i.constraints.push(l)}if(o.transform)for(let r=0;r<o.transform.length;r++){const l=s.findTransformConstraint(o.transform[r]);if(l==null)throw new Error(`Skin transform constraint not found: ${o.transform[d]}`);i.constraints.push(l)}if(o.path)for(let r=0;r<o.path.length;r++){const l=s.findPathConstraint(o.path[r]);if(l==null)throw new Error(`Skin path constraint not found: ${o.path[d]}`);i.constraints.push(l)}for(const r in o.attachments){const l=s.findSlot(r);if(l==null)throw new Error(`Slot not found: ${r}`);const m=o.attachments[r];for(const f in m){const c=this.readAttachment(m[f],i,l.index,f,s);c!=null&&i.setAttachment(l.index,f,c)}}s.skins.push(i),i.name=="default"&&(s.defaultSkin=i)}for(let d=0,o=this.linkedMeshes.length;d<o;d++){const i=this.linkedMeshes[d],r=i.skin==null?s.defaultSkin:s.findSkin(i.skin);if(r==null)throw new Error(`Skin not found: ${i.skin}`);const l=r.getAttachment(i.slotIndex,i.parent);if(l==null)throw new Error(`Parent mesh not found: ${i.parent}`);i.mesh.deformAttachment=i.inheritDeform?l:i.mesh,i.mesh.setParentMesh(l)}if(this.linkedMeshes.length=0,a.events)for(const d in a.events){const o=a.events[d],i=new se(d);i.intValue=this.getValue(o,"int",0),i.floatValue=this.getValue(o,"float",0),i.stringValue=this.getValue(o,"string",""),i.audioPath=this.getValue(o,"audio",null),i.audioPath!=null&&(i.volume=this.getValue(o,"volume",1),i.balance=this.getValue(o,"balance",0)),s.events.push(i)}if(a.animations)for(const d in a.animations){const o=a.animations[d];this.readAnimation(o,d,s)}return s}readAttachment(t,n,s,a,h){const d=this.scale;switch(a=this.getValue(t,"name",a),this.getValue(t,"type","region")){case"region":{const o=this.getValue(t,"path",a),i=this.attachmentLoader.newRegionAttachment(n,a,o);if(i==null)return null;i.path=o,i.x=this.getValue(t,"x",0)*d,i.y=this.getValue(t,"y",0)*d,i.scaleX=this.getValue(t,"scaleX",1),i.scaleY=this.getValue(t,"scaleY",1),i.rotation=this.getValue(t,"rotation",0),i.width=t.width*d,i.height=t.height*d;const r=this.getValue(t,"color",null);return r!=null&&i.color.setFromString(r),i}case"boundingbox":{const o=this.attachmentLoader.newBoundingBoxAttachment(n,a);if(o==null)return null;this.readVertices(t,o,t.vertexCount<<1);const i=this.getValue(t,"color",null);return i!=null&&o.color.setFromString(i),o}case"mesh":case"linkedmesh":{const o=this.getValue(t,"path",a),i=this.attachmentLoader.newMeshAttachment(n,a,o);if(i==null)return null;i.path=o;const r=this.getValue(t,"color",null);r!=null&&i.color.setFromString(r),i.width=this.getValue(t,"width",0)*d,i.height=this.getValue(t,"height",0)*d;const l=this.getValue(t,"parent",null);if(l!=null)return this.linkedMeshes.push(new Ne(i,this.getValue(t,"skin",null),s,l,this.getValue(t,"deform",!0))),i;const m=t.uvs;return this.readVertices(t,i,m.length),i.triangles=t.triangles,i.regionUVs=new Float32Array(m),i.edges=this.getValue(t,"edges",null),i.hullLength=this.getValue(t,"hull",0)*2,i}case"path":{const o=this.attachmentLoader.newPathAttachment(n,a);if(o==null)return null;o.closed=this.getValue(t,"closed",!1),o.constantSpeed=this.getValue(t,"constantSpeed",!0);const i=t.vertexCount;this.readVertices(t,o,i<<1);const r=u.Utils.newArray(i/3,0);for(let m=0;m<t.lengths.length;m++)r[m]=t.lengths[m]*d;o.lengths=r;const l=this.getValue(t,"color",null);return l!=null&&o.color.setFromString(l),o}case"point":{const o=this.attachmentLoader.newPointAttachment(n,a);if(o==null)return null;o.x=this.getValue(t,"x",0)*d,o.y=this.getValue(t,"y",0)*d,o.rotation=this.getValue(t,"rotation",0);const i=this.getValue(t,"color",null);return i!=null&&o.color.setFromString(i),o}case"clipping":{const o=this.attachmentLoader.newClippingAttachment(n,a);if(o==null)return null;const i=this.getValue(t,"end",null);if(i!=null){const m=h.findSlot(i);if(m==null)throw new Error(`Clipping end slot not found: ${i}`);o.endSlot=m}const r=t.vertexCount;this.readVertices(t,o,r<<1);const l=this.getValue(t,"color",null);return l!=null&&o.color.setFromString(l),o}}return null}readVertices(t,n,s){const a=this.scale;n.worldVerticesLength=s;const h=t.vertices;if(s==h.length){const i=u.Utils.toFloatArray(h);if(a!=1)for(let r=0,l=h.length;r<l;r++)i[r]*=a;n.vertices=i;return}const d=new Array,o=new Array;for(let i=0,r=h.length;i<r;){const l=h[i++];o.push(l);for(let m=i+l*4;i<m;i+=4)o.push(h[i]),d.push(h[i+1]*a),d.push(h[i+2]*a),d.push(h[i+3])}n.bones=o,n.vertices=u.Utils.toFloatArray(d)}readAnimation(t,n,s){const a=this.scale,h=new Array;let d=0;if(t.slots)for(const i in t.slots){const r=t.slots[i],l=s.findSlotIndex(i);if(l==-1)throw new Error(`Slot not found: ${i}`);for(const m in r){const f=r[m];if(m=="attachment"){const c=new Vt(f.length);c.slotIndex=l;let g=0;for(let M=0;M<f.length;M++){const p=f[M];c.setFrame(g++,this.getValue(p,"time",0),p.name)}h.push(c),d=Math.max(d,c.frames[c.getFrameCount()-1])}else if(m=="color"){const c=new st(f.length);c.slotIndex=l;let g=0;for(let M=0;M<f.length;M++){const p=f[M],x=new u.Color;x.setFromString(p.color||"ffffffff"),c.setFrame(g,this.getValue(p,"time",0),x.r,x.g,x.b,x.a),this.readCurve(p,c,g),g++}h.push(c),d=Math.max(d,c.frames[(c.getFrameCount()-1)*st.ENTRIES])}else if(m=="twoColor"){const c=new Q(f.length);c.slotIndex=l;let g=0;for(let M=0;M<f.length;M++){const p=f[M],x=new u.Color,E=new u.Color;x.setFromString(p.light),E.setFromString(p.dark),c.setFrame(g,this.getValue(p,"time",0),x.r,x.g,x.b,x.a,E.r,E.g,E.b),this.readCurve(p,c,g),g++}h.push(c),d=Math.max(d,c.frames[(c.getFrameCount()-1)*Q.ENTRIES])}else throw new Error(`Invalid timeline type for a slot: ${m} (${i})`)}}if(t.bones)for(const i in t.bones){const r=t.bones[i],l=s.findBoneIndex(i);if(l==-1)throw new Error(`Bone not found: ${i}`);for(const m in r){const f=r[m];if(m==="rotate"){const c=new tt(f.length);c.boneIndex=l;let g=0;for(let M=0;M<f.length;M++){const p=f[M];c.setFrame(g,this.getValue(p,"time",0),this.getValue(p,"angle",0)),this.readCurve(p,c,g),g++}h.push(c),d=Math.max(d,c.frames[(c.getFrameCount()-1)*tt.ENTRIES])}else if(m==="translate"||m==="scale"||m==="shear"){let c=null,g=1,M=0;m==="scale"?(c=new ht(f.length),M=1):m==="shear"?c=new ct(f.length):(c=new mt(f.length),g=a),c.boneIndex=l;let p=0;for(let x=0;x<f.length;x++){const E=f[x],w=this.getValue(E,"x",M),S=this.getValue(E,"y",M);c.setFrame(p,this.getValue(E,"time",0),w*g,S*g),this.readCurve(E,c,p),p++}h.push(c),d=Math.max(d,c.frames[(c.getFrameCount()-1)*mt.ENTRIES])}else throw new Error(`Invalid timeline type for a bone: ${m} (${i})`)}}if(t.ik)for(const i in t.ik){const r=t.ik[i],l=s.findIkConstraint(i),m=new et(r.length);m.ikConstraintIndex=s.ikConstraints.indexOf(l);let f=0;for(let c=0;c<r.length;c++){const g=r[c];m.setFrame(f,this.getValue(g,"time",0),this.getValue(g,"mix",1),this.getValue(g,"softness",0)*a),this.readCurve(g,m,f),f++}h.push(m),d=Math.max(d,m.frames[(m.getFrameCount()-1)*et.ENTRIES])}if(t.transform)for(const i in t.transform){const r=t.transform[i],l=s.findTransformConstraint(i),m=new it(r.length);m.transformConstraintIndex=s.transformConstraints.indexOf(l);let f=0;for(let c=0;c<r.length;c++){const g=r[c];m.setFrame(f,this.getValue(g,"time",0),this.getValue(g,"rotateMix",1),this.getValue(g,"translateMix",1),this.getValue(g,"scaleMix",1),this.getValue(g,"shearMix",1)),this.readCurve(g,m,f),f++}h.push(m),d=Math.max(d,m.frames[(m.getFrameCount()-1)*it.ENTRIES])}if(t.path)for(const i in t.path){const r=t.path[i],l=s.findPathConstraintIndex(i);if(l==-1)throw new Error(`Path constraint not found: ${i}`);const m=s.pathConstraints[l];for(const f in r){const c=r[f];if(f==="position"||f==="spacing"){let g=null,M=1;f==="spacing"?(g=new Mt(c.length),(m.spacingMode==J.Length||m.spacingMode==J.Fixed)&&(M=a)):(g=new Et(c.length),m.positionMode==u.PositionMode.Fixed&&(M=a)),g.pathConstraintIndex=l;let p=0;for(let x=0;x<c.length;x++){const E=c[x];g.setFrame(p,this.getValue(E,"time",0),this.getValue(E,f,0)*M),this.readCurve(E,g,p),p++}h.push(g),d=Math.max(d,g.frames[(g.getFrameCount()-1)*Et.ENTRIES])}else if(f==="mix"){const g=new xt(c.length);g.pathConstraintIndex=l;let M=0;for(let p=0;p<c.length;p++){const x=c[p];g.setFrame(M,this.getValue(x,"time",0),this.getValue(x,"rotateMix",1),this.getValue(x,"translateMix",1)),this.readCurve(x,g,M),M++}h.push(g),d=Math.max(d,g.frames[(g.getFrameCount()-1)*xt.ENTRIES])}}}if(t.deform)for(const i in t.deform){const r=t.deform[i],l=s.findSkin(i);if(l==null){if(u.settings.FAIL_ON_NON_EXISTING_SKIN)throw new Error(`Skin not found: ${i}`);continue}for(const m in r){const f=r[m],c=s.findSlotIndex(m);if(c==-1)throw new Error(`Slot not found: ${f.name}`);for(const g in f){const M=f[g],p=l.getAttachment(c,g);if(p==null)throw new Error(`Deform attachment not found: ${M.name}`);const x=p.bones!=null,E=p.vertices,w=x?E.length/3*2:E.length,S=new Zt(M.length);S.slotIndex=c,S.attachment=p;let T=0;for(let I=0;I<M.length;I++){const A=M[I];let R;const y=this.getValue(A,"vertices",null);if(y==null)R=x?u.Utils.newFloatArray(w):E;else{R=u.Utils.newFloatArray(w);const k=this.getValue(A,"offset",0);if(u.Utils.arrayCopy(y,0,R,k,y.length),a!=1)for(let X=k,N=X+y.length;X<N;X++)R[X]*=a;if(!x)for(let X=0;X<w;X++)R[X]+=E[X]}S.setFrame(T,this.getValue(A,"time",0),R,l.name),this.readCurve(A,S,T),T++}h.push(S),d=Math.max(d,S.frames[S.getFrameCount()-1])}}}let o=t.drawOrder;if(o==null&&(o=t.draworder),o!=null){const i=new Bt(o.length),r=s.slots.length;let l=0;for(let m=0;m<o.length;m++){const f=o[m];let c=null;const g=this.getValue(f,"offsets",null);if(g!=null){c=u.Utils.newArray(r,-1);const M=u.Utils.newArray(r-g.length,0);let p=0,x=0;for(let E=0;E<g.length;E++){const w=g[E],S=s.findSlotIndex(w.slot);if(S==-1)throw new Error(`Slot not found: ${w.slot}`);for(;p!=S;)M[x++]=p++;c[p+w.offset]=p++}for(;p<r;)M[x++]=p++;for(let E=r-1;E>=0;E--)c[E]==-1&&(c[E]=M[--x])}i.setFrame(l++,this.getValue(f,"time",0),c)}h.push(i),d=Math.max(d,i.frames[i.getFrameCount()-1])}if(t.events){const i=new Ot(t.events.length);let r=0;for(let l=0;l<t.events.length;l++){const m=t.events[l],f=s.findEvent(m.name);if(f==null)throw new Error(`Event not found: ${m.name}`);const c=new ne(u.Utils.toSinglePrecision(this.getValue(m,"time",0)),f);c.intValue=this.getValue(m,"int",f.intValue),c.floatValue=this.getValue(m,"float",f.floatValue),c.stringValue=this.getValue(m,"string",f.stringValue),c.data.audioPath!=null&&(c.volume=this.getValue(m,"volume",1),c.balance=this.getValue(m,"balance",0)),i.setFrame(r++,c)}h.push(i),d=Math.max(d,i.frames[i.getFrameCount()-1])}if(isNaN(d))throw new Error("Error while parsing animation, duration is NaN");s.animations.push(new G(n,h,d))}readCurve(t,n,s){if(t.hasOwnProperty("curve"))if(t.curve==="stepped")n.setStepped(s);else{const a=t.curve;n.setCurve(s,a,this.getValue(t,"c2",0),this.getValue(t,"c3",1),this.getValue(t,"c4",1))}}getValue(t,n,s){return t[n]!==void 0?t[n]:s}static blendModeFromString(t){if(t=t.toLowerCase(),t=="normal")return wt.BLEND_MODES.NORMAL;if(t=="additive")return wt.BLEND_MODES.ADD;if(t=="multiply")return wt.BLEND_MODES.MULTIPLY;if(t=="screen")return wt.BLEND_MODES.SCREEN;throw new Error(`Unknown blend mode: ${t}`)}static positionModeFromString(t){if(t=t.toLowerCase(),t=="fixed")return u.PositionMode.Fixed;if(t=="percent")return u.PositionMode.Percent;throw new Error(`Unknown position mode: ${t}`)}static spacingModeFromString(t){if(t=t.toLowerCase(),t=="length")return J.Length;if(t=="fixed")return J.Fixed;if(t=="percent")return J.Percent;throw new Error(`Unknown position mode: ${t}`)}static rotateModeFromString(t){if(t=t.toLowerCase(),t=="tangent")return u.RotateMode.Tangent;if(t=="chain")return u.RotateMode.Chain;if(t=="chainscale")return u.RotateMode.ChainScale;throw new Error(`Unknown rotate mode: ${t}`)}static transformModeFromString(t){if(t=t.toLowerCase(),t=="normal")return u.TransformMode.Normal;if(t=="onlytranslation")return u.TransformMode.OnlyTranslation;if(t=="norotationorreflection")return u.TransformMode.NoRotationOrReflection;if(t=="noscale")return u.TransformMode.NoScale;if(t=="noscaleorreflection")return u.TransformMode.NoScaleOrReflection;throw new Error(`Unknown transform mode: ${t}`)}}class Ne{constructor(t,n,s,a,h){this.mesh=t,this.skin=n,this.slotIndex=s,this.parent=a,this.inheritDeform=h}}class ve extends u.SpineBase{createSkeleton(t){this.skeleton=new re(t),this.skeleton.updateWorldTransform(),this.stateData=new Jt(t),this.state=new ft(this.stateData)}}return C.Animation=G,C.AnimationState=ft,C.AnimationStateAdapter=ke,C.AnimationStateData=Jt,C.AtlasAttachmentLoader=Ve,C.Attachment=Gt,C.AttachmentTimeline=Vt,C.Bone=te,C.BoneData=ee,C.BoundingBoxAttachment=Xt,C.ClippingAttachment=Yt,C.ColorTimeline=st,C.ConstraintData=bt,C.CurveTimeline=lt,C.DeformTimeline=Zt,C.DrawOrderTimeline=Bt,C.Event=ne,C.EventData=se,C.EventQueue=Qt,C.EventTimeline=Ot,C.EventType=dt,C.IkConstraint=xe,C.IkConstraintData=ie,C.IkConstraintTimeline=et,C.JitterEffect=Ce,C.MeshAttachment=Ct,C.PathAttachment=kt,C.PathConstraint=Nt,C.PathConstraintData=ae,C.PathConstraintMixTimeline=xt,C.PathConstraintPositionTimeline=Et,C.PathConstraintSpacingTimeline=Mt,C.PointAttachment=Lt,C.RegionAttachment=B,C.RotateTimeline=tt,C.ScaleTimeline=ht,C.ShearTimeline=ct,C.Skeleton=re,C.SkeletonBinary=z,C.SkeletonBounds=Be,C.SkeletonData=oe,C.SkeletonJson=Ft,C.Skin=Wt,C.SkinEntry=ce,C.Slot=jt,C.SlotData=le,C.SpacingMode=J,C.Spine=ve,C.SwirlEffect=ge,C.TimelineType=pe,C.TrackEntry=_t,C.TransformConstraint=Ee,C.TransformConstraintData=he,C.TransformConstraintTimeline=it,C.TranslateTimeline=mt,C.TwoColorTimeline=Q,C.VertexAttachment=At,C}({},PIXI.spine,PIXI);
//# sourceMappingURL=runtime-3.4.js.map
