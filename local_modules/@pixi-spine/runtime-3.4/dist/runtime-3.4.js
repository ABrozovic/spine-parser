/*!
 * @pixi-spine/runtime-3.4 - v4.0.3
 * Compiled Fri, 16 Jun 2023 01:12:21 UTC
 *
 * @pixi-spine/runtime-3.4 is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 * 
 * Copyright 2023, Ivan Igorevich Popelyshev <ivan.popelyshev@gmail.com>, All Rights Reserved
 */this.PIXI=this.PIXI||{},this.PIXI.spine34=function(C,u,wt){"use strict";class Gt{constructor(t){if(t==null)throw new Error("name cannot be null.");this.name=t}}const me=class extends Gt{constructor(t){super(t),this.id=(me.nextID++&65535)<<11,this.worldVerticesLength=0,this.deformAttachment=this}computeWorldVerticesOld(t,s){this.computeWorldVertices(t,0,this.worldVerticesLength,s,0,2)}computeWorldVertices(t,s,n,i,h,c){n=h+(n>>1)*c;const o=t.bone.skeleton,a=t.deform;let r=this.vertices;const l=this.bones;if(l==null){a.length>0&&(r=a);const g=t.bone.matrix,M=g.tx,p=g.ty,x=g.a,E=g.c,w=g.b,T=g.d;for(let I=s,S=h;S<n;I+=2,S+=c){const A=r[I],R=r[I+1];i[S]=A*x+R*E+M,i[S+1]=A*w+R*T+p}return}let d=0,f=0;for(let g=0;g<s;g+=2){const M=l[d];d+=M+1,f+=M}const m=o.bones;if(a.length==0)for(let g=h,M=f*3;g<n;g+=c){let p=0,x=0,E=l[d++];for(E+=d;d<E;d++,M+=3){const w=m[l[d]].matrix,T=r[M],I=r[M+1],S=r[M+2];p+=(T*w.a+I*w.c+w.tx)*S,x+=(T*w.b+I*w.d+w.ty)*S}i[g]=p,i[g+1]=x}else{const g=a;for(let M=h,p=f*3,x=f<<1;M<n;M+=c){let E=0,w=0,T=l[d++];for(T+=d;d<T;d++,p+=3,x+=2){const I=m[l[d]].matrix,S=r[p]+g[x],A=r[p+1]+g[x+1],R=r[p+2];E+=(S*I.a+A*I.c+I.tx)*R,w+=(S*I.b+A*I.d+I.ty)*R}i[M]=E,i[M+1]=w}}}copyTo(t){this.bones!=null?(t.bones=new Array(this.bones.length),u.Utils.arrayCopy(this.bones,0,t.bones,0,this.bones.length)):t.bones=null,this.vertices!=null?(t.vertices=u.Utils.newFloatArray(this.vertices.length),u.Utils.arrayCopy(this.vertices,0,t.vertices,0,this.vertices.length)):t.vertices=null,t.worldVerticesLength=this.worldVerticesLength,t.deformAttachment=this.deformAttachment}};let At=me;At.nextID=0;class Xt extends At{constructor(t){super(t),this.type=u.AttachmentType.BoundingBox,this.color=new u.Color(1,1,1,1)}copy(){const t=new Xt(this.name);return this.copyTo(t),t.color.setFromColor(this.color),t}}class Yt extends At{constructor(t){super(t),this.type=u.AttachmentType.Clipping,this.color=new u.Color(.2275,.2275,.8078,1)}copy(){const t=new Yt(this.name);return this.copyTo(t),t.endSlot=this.endSlot,t.color.setFromColor(this.color),t}}class Ct extends At{constructor(t){super(t),this.type=u.AttachmentType.Mesh,this.color=new u.Color(1,1,1,1),this.tempColor=new u.Color(0,0,0,0)}getParentMesh(){return this.parentMesh}setParentMesh(t){this.parentMesh=t,t!=null&&(this.bones=t.bones,this.vertices=t.vertices,this.worldVerticesLength=t.worldVerticesLength,this.regionUVs=t.regionUVs,this.triangles=t.triangles,this.hullLength=t.hullLength,this.worldVerticesLength=t.worldVerticesLength)}copy(){if(this.parentMesh!=null)return this.newLinkedMesh();const t=new Ct(this.name);return t.region=this.region,t.path=this.path,t.color.setFromColor(this.color),this.copyTo(t),t.regionUVs=new Float32Array(this.regionUVs.length),u.Utils.arrayCopy(this.regionUVs,0,t.regionUVs,0,this.regionUVs.length),t.triangles=new Array(this.triangles.length),u.Utils.arrayCopy(this.triangles,0,t.triangles,0,this.triangles.length),t.hullLength=this.hullLength,this.edges!=null&&(t.edges=new Array(this.edges.length),u.Utils.arrayCopy(this.edges,0,t.edges,0,this.edges.length)),t.width=this.width,t.height=this.height,t}newLinkedMesh(){const t=new Ct(this.name);return t.region=this.region,t.path=this.path,t.color.setFromColor(this.color),t.deformAttachment=this.deformAttachment,t.setParentMesh(this.parentMesh!=null?this.parentMesh:this),t}}class kt extends At{constructor(t){super(t),this.type=u.AttachmentType.Path,this.closed=!1,this.constantSpeed=!1,this.color=new u.Color(1,1,1,1)}copy(){const t=new kt(this.name);return this.copyTo(t),t.lengths=new Array(this.lengths.length),u.Utils.arrayCopy(this.lengths,0,t.lengths,0,this.lengths.length),t.closed=closed,t.constantSpeed=this.constantSpeed,t.color.setFromColor(this.color),t}}class Ot extends At{constructor(t){super(t),this.type=u.AttachmentType.Point,this.color=new u.Color(.38,.94,0,1)}computeWorldPosition(t,s){const n=t.matrix;return s.x=this.x*n.a+this.y*n.c+t.worldX,s.y=this.x*n.b+this.y*n.d+t.worldY,s}computeWorldRotation(t){const s=t.matrix,n=u.MathUtils.cosDeg(this.rotation),i=u.MathUtils.sinDeg(this.rotation),h=n*s.a+i*s.c,c=n*s.b+i*s.d;return Math.atan2(c,h)*u.MathUtils.radDeg}copy(){const t=new Ot(this.name);return t.x=this.x,t.y=this.y,t.rotation=this.rotation,t.color.setFromColor(this.color),t}}class jt{constructor(t,s){if(this.deform=new Array,t==null)throw new Error("data cannot be null.");if(s==null)throw new Error("bone cannot be null.");this.data=t,this.bone=s,this.color=new u.Color,this.darkColor=t.darkColor==null?null:new u.Color,this.setToSetupPose(),this.blendMode=this.data.blendMode}getAttachment(){return this.attachment}setAttachment(t){this.attachment!=t&&(this.attachment=t,this.attachmentTime=this.bone.skeleton.time,this.deform.length=0)}setAttachmentTime(t){this.attachmentTime=this.bone.skeleton.time-t}getAttachmentTime(){return this.bone.skeleton.time-this.attachmentTime}setToSetupPose(){this.color.setFromColor(this.data.color),this.darkColor!=null&&this.darkColor.setFromColor(this.data.darkColor),this.data.attachmentName==null?this.attachment=null:(this.attachment=null,this.setAttachment(this.bone.skeleton.getAttachment(this.data.index,this.data.attachmentName)))}}const K=class extends Gt{constructor(e){super(e),this.type=u.AttachmentType.Region,this.x=0,this.y=0,this.scaleX=1,this.scaleY=1,this.rotation=0,this.width=0,this.height=0,this.color=new u.Color(1,1,1,1),this.offset=u.Utils.newFloatArray(8),this.uvs=u.Utils.newFloatArray(8),this.tempColor=new u.Color(1,1,1,1)}updateOffset(){const e=this.width/this.region.originalWidth*this.scaleX,t=this.height/this.region.originalHeight*this.scaleY,s=-this.width/2*this.scaleX+this.region.offsetX*e,n=-this.height/2*this.scaleY+this.region.offsetY*t,i=s+this.region.width*e,h=n+this.region.height*t,c=this.rotation*Math.PI/180,o=Math.cos(c),a=Math.sin(c),r=s*o+this.x,l=s*a,d=n*o+this.y,f=n*a,m=i*o+this.x,g=i*a,M=h*o+this.y,p=h*a,x=this.offset;x[K.OX1]=r-f,x[K.OY1]=d+l,x[K.OX2]=r-p,x[K.OY2]=M+l,x[K.OX3]=m-p,x[K.OY3]=M+g,x[K.OX4]=m-f,x[K.OY4]=d+g}setRegion(e){this.region=e;const t=this.uvs;e.rotate?(t[2]=e.u,t[3]=e.v2,t[4]=e.u,t[5]=e.v,t[6]=e.u2,t[7]=e.v,t[0]=e.u2,t[1]=e.v2):(t[0]=e.u,t[1]=e.v2,t[2]=e.u,t[3]=e.v,t[4]=e.u2,t[5]=e.v,t[6]=e.u2,t[7]=e.v2)}computeWorldVertices(e,t,s,n){const i=this.offset,h=e instanceof jt?e.bone.matrix:e.matrix,c=h.tx,o=h.ty,a=h.a,r=h.c,l=h.b,d=h.d;let f=0,m=0;f=i[K.OX1],m=i[K.OY1],t[s]=f*a+m*r+c,t[s+1]=f*l+m*d+o,s+=n,f=i[K.OX2],m=i[K.OY2],t[s]=f*a+m*r+c,t[s+1]=f*l+m*d+o,s+=n,f=i[K.OX3],m=i[K.OY3],t[s]=f*a+m*r+c,t[s+1]=f*l+m*d+o,s+=n,f=i[K.OX4],m=i[K.OY4],t[s]=f*a+m*r+c,t[s+1]=f*l+m*d+o}copy(){const e=new K(this.name);return e.region=this.region,e.rendererObject=this.rendererObject,e.path=this.path,e.x=this.x,e.y=this.y,e.scaleX=this.scaleX,e.scaleY=this.scaleY,e.rotation=this.rotation,e.width=this.width,e.height=this.height,u.Utils.arrayCopy(this.uvs,0,e.uvs,0,8),u.Utils.arrayCopy(this.offset,0,e.offset,0,8),e.color.setFromColor(this.color),e}};let B=K;B.OX1=0,B.OY1=1,B.OX2=2,B.OY2=3,B.OX3=4,B.OY3=5,B.OX4=6,B.OY4=7,B.X1=0,B.Y1=1,B.C1R=2,B.C1G=3,B.C1B=4,B.C1A=5,B.U1=6,B.V1=7,B.X2=8,B.Y2=9,B.C2R=10,B.C2G=11,B.C2B=12,B.C2A=13,B.U2=14,B.V2=15,B.X3=16,B.Y3=17,B.C3R=18,B.C3G=19,B.C3B=20,B.C3A=21,B.U3=22,B.V3=23,B.X4=24,B.Y4=25,B.C4R=26,B.C4G=27,B.C4B=28,B.C4A=29,B.U4=30,B.V4=31;class Ce{constructor(t,s){this.jitterX=0,this.jitterY=0,this.jitterX=t,this.jitterY=s}begin(t){}transform(t,s,n,i){t.x+=u.MathUtils.randomTriangular(-this.jitterX,this.jitterY),t.y+=u.MathUtils.randomTriangular(-this.jitterX,this.jitterY)}end(){}}const fe=class{constructor(e){this.centerX=0,this.centerY=0,this.radius=0,this.angle=0,this.worldX=0,this.worldY=0,this.radius=e}begin(e){this.worldX=e.x+this.centerX,this.worldY=e.y+this.centerY}transform(e,t,s,n){const i=this.angle*u.MathUtils.degreesToRadians,h=e.x-this.worldX,c=e.y-this.worldY,o=Math.sqrt(h*h+c*c);if(o<this.radius){const a=fe.interpolation.apply(0,i,(this.radius-o)/this.radius),r=Math.cos(a),l=Math.sin(a);e.x=r*h-l*c+this.worldX,e.y=l*h+r*c+this.worldY}}end(){}};let ge=fe;ge.interpolation=new u.PowOut(2);class G{constructor(t,s,n){if(t==null)throw new Error("name cannot be null.");if(s==null)throw new Error("timelines cannot be null.");this.name=t,this.timelines=s,this.timelineIds=[];for(let i=0;i<s.length;i++)this.timelineIds[s[i].getPropertyId()]=!0;this.duration=n}hasTimeline(t){return this.timelineIds[t]==!0}apply(t,s,n,i,h,c,o,a){if(t==null)throw new Error("skeleton cannot be null.");i&&this.duration!=0&&(n%=this.duration,s>0&&(s%=this.duration));const r=this.timelines;for(let l=0,d=r.length;l<d;l++)r[l].apply(t,s,n,h,c,o,a)}static binarySearch(t,s,n=1){let i=0,h=t.length/n-2;if(h==0)return n;let c=h>>>1;for(;;){if(t[(c+1)*n]<=s?i=c+1:h=c,i==h)return(i+1)*n;c=i+h>>>1}}static linearSearch(t,s,n){for(let i=0,h=t.length-n;i<=h;i+=n)if(t[i]>s)return i;return-1}}var pe=(e=>(e[e.rotate=0]="rotate",e[e.translate=1]="translate",e[e.scale=2]="scale",e[e.shear=3]="shear",e[e.attachment=4]="attachment",e[e.color=5]="color",e[e.deform=6]="deform",e[e.event=7]="event",e[e.drawOrder=8]="drawOrder",e[e.ikConstraint=9]="ikConstraint",e[e.transformConstraint=10]="transformConstraint",e[e.pathConstraintPosition=11]="pathConstraintPosition",e[e.pathConstraintSpacing=12]="pathConstraintSpacing",e[e.pathConstraintMix=13]="pathConstraintMix",e[e.twoColor=14]="twoColor",e))(pe||{});const j=class{constructor(e){if(this.curveData=[],e<=0)throw new Error(`frameCount must be > 0: ${e}`);this.curves=u.Utils.newFloatArray((e-1)*j.BEZIER_SIZE)}getFrameCount(){return this.curves.length/j.BEZIER_SIZE+1}setLinear(e){this.curves[e*j.BEZIER_SIZE]=j.LINEAR}setStepped(e){this.curves[e*j.BEZIER_SIZE]=j.STEPPED}getCurveType(e){const t=e*j.BEZIER_SIZE;if(t==this.curves.length)return j.LINEAR;const s=this.curves[t];return s==j.LINEAR?j.LINEAR:s==j.STEPPED?j.STEPPED:j.BEZIER}setCurve(e,t,s,n,i){this.curveData.push({frameIndex:e,cx1:t,cy1:s,cx2:n,cy2:i});const h=(-t*2+n)*.03,c=(-s*2+i)*.03,o=((t-n)*3+1)*.006,a=((s-i)*3+1)*.006;let r=h*2+o,l=c*2+a,d=t*.3+h+o*.16666667,f=s*.3+c+a*.16666667,m=e*j.BEZIER_SIZE;const g=this.curves;g[m++]=j.BEZIER;let M=d,p=f;for(let x=m+j.BEZIER_SIZE-1;m<x;m+=2)g[m]=M,g[m+1]=p,d+=r,f+=l,r+=o,l+=a,M+=d,p+=f}getCurvePercent(e,t){t=u.MathUtils.clamp(t,0,1);const s=this.curves;let n=e*j.BEZIER_SIZE;const i=s[n];if(i==j.LINEAR)return t;if(i==j.STEPPED)return 0;n++;let h=0;for(let o=n,a=n+j.BEZIER_SIZE-1;n<a;n+=2)if(h=s[n],h>=t){let r,l;return n==o?(r=0,l=0):(r=s[n-2],l=s[n-1]),l+(s[n+1]-l)*(t-r)/(h-r)}const c=s[n-1];return c+(1-c)*(t-h)/(1-h)}};let lt=j;lt.LINEAR=0,lt.STEPPED=1,lt.BEZIER=2,lt.BEZIER_SIZE=10*2-1;const yt=class extends lt{constructor(t){super(t),this.data=[],this.frames=u.Utils.newFloatArray(t<<1)}getPropertyId(){return(0<<24)+this.boneIndex}setFrame(t,s,n){this.data.push({type:"RotateTimeline",frameIndex:t,time:s,degrees:n}),t<<=1,this.frames[t]=s,this.frames[t+yt.ROTATION]=n}apply(t,s,n,i,h,c,o){const a=this.frames,r=t.bones[this.boneIndex];if(!r.active)return;if(n<a[0]){switch(c){case u.MixBlend.setup:r.rotation=r.data.rotation;return;case u.MixBlend.first:const M=r.data.rotation-r.rotation;r.rotation+=(M-(16384-(16384.499999999996-M/360|0))*360)*h}return}if(n>=a[a.length-yt.ENTRIES]){let M=a[a.length+yt.PREV_ROTATION];switch(c){case u.MixBlend.setup:r.rotation=r.data.rotation+M*h;break;case u.MixBlend.first:case u.MixBlend.replace:M+=r.data.rotation-r.rotation,M-=(16384-(16384.499999999996-M/360|0))*360;case u.MixBlend.add:r.rotation+=M*h}return}const l=G.binarySearch(a,n,yt.ENTRIES),d=a[l+yt.PREV_ROTATION],f=a[l],m=this.getCurvePercent((l>>1)-1,1-(n-f)/(a[l+yt.PREV_TIME]-f));let g=a[l+yt.ROTATION]-d;switch(g=d+(g-(16384-(16384.499999999996-g/360|0))*360)*m,c){case u.MixBlend.setup:r.rotation=r.data.rotation+(g-(16384-(16384.499999999996-g/360|0))*360)*h;break;case u.MixBlend.first:case u.MixBlend.replace:g+=r.data.rotation-r.rotation;case u.MixBlend.add:r.rotation+=(g-(16384-(16384.499999999996-g/360|0))*360)*h}}};let tt=yt;tt.ENTRIES=2,tt.PREV_TIME=-2,tt.PREV_ROTATION=-1,tt.ROTATION=1;const nt=class extends lt{constructor(e){super(e),this.data=[],this.frames=u.Utils.newFloatArray(e*nt.ENTRIES)}getPropertyId(){return(1<<24)+this.boneIndex}setFrame(e,t,s,n){this.data.push({type:"TranslateTimeline",frameIndex:e,time:t,x:s,y:n}),e*=nt.ENTRIES,this.frames[e]=t,this.frames[e+nt.X]=s,this.frames[e+nt.Y]=n}apply(e,t,s,n,i,h,c){const o=this.frames,a=e.bones[this.boneIndex];if(!a.active)return;if(s<o[0]){switch(h){case u.MixBlend.setup:a.x=a.data.x,a.y=a.data.y;return;case u.MixBlend.first:a.x+=(a.data.x-a.x)*i,a.y+=(a.data.y-a.y)*i}return}let r=0,l=0;if(s>=o[o.length-nt.ENTRIES])r=o[o.length+nt.PREV_X],l=o[o.length+nt.PREV_Y];else{const d=G.binarySearch(o,s,nt.ENTRIES);r=o[d+nt.PREV_X],l=o[d+nt.PREV_Y];const f=o[d],m=this.getCurvePercent(d/nt.ENTRIES-1,1-(s-f)/(o[d+nt.PREV_TIME]-f));r+=(o[d+nt.X]-r)*m,l+=(o[d+nt.Y]-l)*m}switch(h){case u.MixBlend.setup:a.x=a.data.x+r*i,a.y=a.data.y+l*i;break;case u.MixBlend.first:case u.MixBlend.replace:a.x+=(a.data.x+r-a.x)*i,a.y+=(a.data.y+l-a.y)*i;break;case u.MixBlend.add:a.x+=r*i,a.y+=l*i}}};let mt=nt;mt.ENTRIES=3,mt.PREV_TIME=-3,mt.PREV_X=-2,mt.PREV_Y=-1,mt.X=1,mt.Y=2;class ht extends mt{constructor(t){super(t)}getPropertyId(){return(2<<24)+this.boneIndex}apply(t,s,n,i,h,c,o){const a=this.frames,r=t.bones[this.boneIndex];if(!r.active)return;if(n<a[0]){switch(c){case u.MixBlend.setup:r.scaleX=r.data.scaleX,r.scaleY=r.data.scaleY;return;case u.MixBlend.first:r.scaleX+=(r.data.scaleX-r.scaleX)*h,r.scaleY+=(r.data.scaleY-r.scaleY)*h}return}let l=0,d=0;if(n>=a[a.length-ht.ENTRIES])l=a[a.length+ht.PREV_X]*r.data.scaleX,d=a[a.length+ht.PREV_Y]*r.data.scaleY;else{const f=G.binarySearch(a,n,ht.ENTRIES);l=a[f+ht.PREV_X],d=a[f+ht.PREV_Y];const m=a[f],g=this.getCurvePercent(f/ht.ENTRIES-1,1-(n-m)/(a[f+ht.PREV_TIME]-m));l=(l+(a[f+ht.X]-l)*g)*r.data.scaleX,d=(d+(a[f+ht.Y]-d)*g)*r.data.scaleY}if(h==1)c==u.MixBlend.add?(r.scaleX+=l-r.data.scaleX,r.scaleY+=d-r.data.scaleY):(r.scaleX=l,r.scaleY=d);else{let f=0,m=0;if(o==u.MixDirection.mixOut)switch(c){case u.MixBlend.setup:f=r.data.scaleX,m=r.data.scaleY,r.scaleX=f+(Math.abs(l)*u.MathUtils.signum(f)-f)*h,r.scaleY=m+(Math.abs(d)*u.MathUtils.signum(m)-m)*h;break;case u.MixBlend.first:case u.MixBlend.replace:f=r.scaleX,m=r.scaleY,r.scaleX=f+(Math.abs(l)*u.MathUtils.signum(f)-f)*h,r.scaleY=m+(Math.abs(d)*u.MathUtils.signum(m)-m)*h;break;case u.MixBlend.add:f=r.scaleX,m=r.scaleY,r.scaleX=f+(Math.abs(l)*u.MathUtils.signum(f)-r.data.scaleX)*h,r.scaleY=m+(Math.abs(d)*u.MathUtils.signum(m)-r.data.scaleY)*h}else switch(c){case u.MixBlend.setup:f=Math.abs(r.data.scaleX)*u.MathUtils.signum(l),m=Math.abs(r.data.scaleY)*u.MathUtils.signum(d),r.scaleX=f+(l-f)*h,r.scaleY=m+(d-m)*h;break;case u.MixBlend.first:case u.MixBlend.replace:f=Math.abs(r.scaleX)*u.MathUtils.signum(l),m=Math.abs(r.scaleY)*u.MathUtils.signum(d),r.scaleX=f+(l-f)*h,r.scaleY=m+(d-m)*h;break;case u.MixBlend.add:f=u.MathUtils.signum(l),m=u.MathUtils.signum(d),r.scaleX=Math.abs(r.scaleX)*f+(l-Math.abs(r.data.scaleX)*f)*h,r.scaleY=Math.abs(r.scaleY)*m+(d-Math.abs(r.data.scaleY)*m)*h}}}}class ct extends mt{constructor(t){super(t)}getPropertyId(){return(3<<24)+this.boneIndex}apply(t,s,n,i,h,c,o){const a=this.frames,r=t.bones[this.boneIndex];if(!r.active)return;if(n<a[0]){switch(c){case u.MixBlend.setup:r.shearX=r.data.shearX,r.shearY=r.data.shearY;return;case u.MixBlend.first:r.shearX+=(r.data.shearX-r.shearX)*h,r.shearY+=(r.data.shearY-r.shearY)*h}return}let l=0,d=0;if(n>=a[a.length-ct.ENTRIES])l=a[a.length+ct.PREV_X],d=a[a.length+ct.PREV_Y];else{const f=G.binarySearch(a,n,ct.ENTRIES);l=a[f+ct.PREV_X],d=a[f+ct.PREV_Y];const m=a[f],g=this.getCurvePercent(f/ct.ENTRIES-1,1-(n-m)/(a[f+ct.PREV_TIME]-m));l=l+(a[f+ct.X]-l)*g,d=d+(a[f+ct.Y]-d)*g}switch(c){case u.MixBlend.setup:r.shearX=r.data.shearX+l*h,r.shearY=r.data.shearY+d*h;break;case u.MixBlend.first:case u.MixBlend.replace:r.shearX+=(r.data.shearX+l-r.shearX)*h,r.shearY+=(r.data.shearY+d-r.shearY)*h;break;case u.MixBlend.add:r.shearX+=l*h,r.shearY+=d*h}}}const _=class extends lt{constructor(e){super(e),this.data=[],this.frames=u.Utils.newFloatArray(e*_.ENTRIES)}getPropertyId(){return(5<<24)+this.slotIndex}setFrame(e,t,s,n,i,h){this.data.push({type:"ColorTimeline",frameIndex:e,time:t,r:s,g:n,b:i,a:h}),e*=_.ENTRIES,this.frames[e]=t,this.frames[e+_.R]=s,this.frames[e+_.G]=n,this.frames[e+_.B]=i,this.frames[e+_.A]=h}apply(e,t,s,n,i,h,c){const o=e.slots[this.slotIndex];if(!o.bone.active)return;const a=this.frames;if(s<a[0]){switch(h){case u.MixBlend.setup:o.color.setFromColor(o.data.color);return;case u.MixBlend.first:const m=o.color,g=o.data.color;m.add((g.r-m.r)*i,(g.g-m.g)*i,(g.b-m.b)*i,(g.a-m.a)*i)}return}let r=0,l=0,d=0,f=0;if(s>=a[a.length-_.ENTRIES]){const m=a.length;r=a[m+_.PREV_R],l=a[m+_.PREV_G],d=a[m+_.PREV_B],f=a[m+_.PREV_A]}else{const m=G.binarySearch(a,s,_.ENTRIES);r=a[m+_.PREV_R],l=a[m+_.PREV_G],d=a[m+_.PREV_B],f=a[m+_.PREV_A];const g=a[m],M=this.getCurvePercent(m/_.ENTRIES-1,1-(s-g)/(a[m+_.PREV_TIME]-g));r+=(a[m+_.R]-r)*M,l+=(a[m+_.G]-l)*M,d+=(a[m+_.B]-d)*M,f+=(a[m+_.A]-f)*M}if(i==1)o.color.set(r,l,d,f);else{const m=o.color;h==u.MixBlend.setup&&m.setFromColor(o.data.color),m.add((r-m.r)*i,(l-m.g)*i,(d-m.b)*i,(f-m.a)*i)}}};let st=_;st.ENTRIES=5,st.PREV_TIME=-5,st.PREV_R=-4,st.PREV_G=-3,st.PREV_B=-2,st.PREV_A=-1,st.R=1,st.G=2,st.B=3,st.A=4;const Y=class extends lt{constructor(e){super(e),this.data=[],this.frames=u.Utils.newFloatArray(e*Y.ENTRIES)}getPropertyId(){return(14<<24)+this.slotIndex}setFrame(e,t,s,n,i,h,c,o,a){this.data.push({type:"TwoColorTimeline",frameIndex:e,time:t,r:s,g:n,b:i,a:h,r2:c,g2:o,b2:a}),e*=Y.ENTRIES,this.frames[e]=t,this.frames[e+Y.R]=s,this.frames[e+Y.G]=n,this.frames[e+Y.B]=i,this.frames[e+Y.A]=h,this.frames[e+Y.R2]=c,this.frames[e+Y.G2]=o,this.frames[e+Y.B2]=a}apply(e,t,s,n,i,h,c){const o=e.slots[this.slotIndex];if(!o.bone.active)return;const a=this.frames;if(s<a[0]){switch(h){case u.MixBlend.setup:o.color.setFromColor(o.data.color),o.darkColor.setFromColor(o.data.darkColor);return;case u.MixBlend.first:const p=o.color,x=o.darkColor,E=o.data.color,w=o.data.darkColor;p.add((E.r-p.r)*i,(E.g-p.g)*i,(E.b-p.b)*i,(E.a-p.a)*i),x.add((w.r-x.r)*i,(w.g-x.g)*i,(w.b-x.b)*i,0)}return}let r=0,l=0,d=0,f=0,m=0,g=0,M=0;if(s>=a[a.length-Y.ENTRIES]){const p=a.length;r=a[p+Y.PREV_R],l=a[p+Y.PREV_G],d=a[p+Y.PREV_B],f=a[p+Y.PREV_A],m=a[p+Y.PREV_R2],g=a[p+Y.PREV_G2],M=a[p+Y.PREV_B2]}else{const p=G.binarySearch(a,s,Y.ENTRIES);r=a[p+Y.PREV_R],l=a[p+Y.PREV_G],d=a[p+Y.PREV_B],f=a[p+Y.PREV_A],m=a[p+Y.PREV_R2],g=a[p+Y.PREV_G2],M=a[p+Y.PREV_B2];const x=a[p],E=this.getCurvePercent(p/Y.ENTRIES-1,1-(s-x)/(a[p+Y.PREV_TIME]-x));r+=(a[p+Y.R]-r)*E,l+=(a[p+Y.G]-l)*E,d+=(a[p+Y.B]-d)*E,f+=(a[p+Y.A]-f)*E,m+=(a[p+Y.R2]-m)*E,g+=(a[p+Y.G2]-g)*E,M+=(a[p+Y.B2]-M)*E}if(i==1)o.color.set(r,l,d,f),o.darkColor.set(m,g,M,1);else{const p=o.color,x=o.darkColor;h==u.MixBlend.setup&&(p.setFromColor(o.data.color),x.setFromColor(o.data.darkColor)),p.add((r-p.r)*i,(l-p.g)*i,(d-p.b)*i,(f-p.a)*i),x.add((m-x.r)*i,(g-x.g)*i,(M-x.b)*i,0)}}};let Q=Y;Q.ENTRIES=8,Q.PREV_TIME=-8,Q.PREV_R=-7,Q.PREV_G=-6,Q.PREV_B=-5,Q.PREV_A=-4,Q.PREV_R2=-3,Q.PREV_G2=-2,Q.PREV_B2=-1,Q.R=1,Q.G=2,Q.B=3,Q.A=4,Q.R2=5,Q.G2=6,Q.B2=7;class Vt{constructor(t){this.data=[],this.frames=u.Utils.newFloatArray(t),this.attachmentNames=new Array(t)}getPropertyId(){return(4<<24)+this.slotIndex}getFrameCount(){return this.frames.length}setFrame(t,s,n){this.data.push({type:"AttachmentTimeline",frameIndex:t,time:s,attachmentName:n}),this.frames[t]=s,this.attachmentNames[t]=n}apply(t,s,n,i,h,c,o){const a=t.slots[this.slotIndex];if(!a.bone.active)return;if(o==u.MixDirection.mixOut){c==u.MixBlend.setup&&this.setAttachment(t,a,a.data.attachmentName);return}const r=this.frames;if(n<r[0]){(c==u.MixBlend.setup||c==u.MixBlend.first)&&this.setAttachment(t,a,a.data.attachmentName);return}let l=0;n>=r[r.length-1]?l=r.length-1:l=G.binarySearch(r,n,1)-1;const d=this.attachmentNames[l];t.slots[this.slotIndex].setAttachment(d==null?null:t.getAttachment(this.slotIndex,d))}setAttachment(t,s,n){s.setAttachment(n==null?null:t.getAttachment(this.slotIndex,n))}}let Me=null;class Zt extends lt{constructor(t){super(t),this.data=[],this.frames=u.Utils.newFloatArray(t),this.frameVertices=new Array(t),Me==null&&(Me=u.Utils.newFloatArray(64))}getPropertyId(){return(6<<27)+Number(this.attachment.id)+this.slotIndex}setFrame(t,s,n,i){this.data.push({type:"DeformTimeline",frameIndex:t,time:s,vertices:n,skin:i}),this.frames[t]=s,this.frameVertices[t]=n}apply(t,s,n,i,h,c,o){const a=t.slots[this.slotIndex];if(!a.bone.active)return;const r=a.getAttachment();if(!(r instanceof At)||r.deformAttachment!=this.attachment)return;const l=a.deform||[];l.length==0&&(c=u.MixBlend.setup);const d=this.frameVertices,f=d[0].length,m=this.frames;if(n<m[0]){const T=r;switch(c){case u.MixBlend.setup:l.length=0;return;case u.MixBlend.first:if(h==1){l.length=0;break}const I=u.Utils.setArraySize(l,f);if(T.bones==null){const S=T.vertices;for(let A=0;A<f;A++)I[A]+=(S[A]-I[A])*h}else{h=1-h;for(let S=0;S<f;S++)I[S]*=h}}return}const g=u.Utils.setArraySize(l,f);if(n>=m[m.length-1]){const T=d[m.length-1];if(h==1)if(c==u.MixBlend.add){const I=r;if(I.bones==null){const S=I.vertices;for(let A=0;A<f;A++)g[A]+=T[A]-S[A]}else for(let S=0;S<f;S++)g[S]+=T[S]}else u.Utils.arrayCopy(T,0,g,0,f);else switch(c){case u.MixBlend.setup:{const S=r;if(S.bones==null){const A=S.vertices;for(let R=0;R<f;R++){const y=A[R];g[R]=y+(T[R]-y)*h}}else for(let A=0;A<f;A++)g[A]=T[A]*h;break}case u.MixBlend.first:case u.MixBlend.replace:for(let S=0;S<f;S++)g[S]+=(T[S]-g[S])*h;break;case u.MixBlend.add:const I=r;if(I.bones==null){const S=I.vertices;for(let A=0;A<f;A++)g[A]+=(T[A]-S[A])*h}else for(let S=0;S<f;S++)g[S]+=T[S]*h}return}const M=G.binarySearch(m,n),p=d[M-1],x=d[M],E=m[M],w=this.getCurvePercent(M-1,1-(n-E)/(m[M-1]-E));if(h==1)if(c==u.MixBlend.add){const T=r;if(T.bones==null){const I=T.vertices;for(let S=0;S<f;S++){const A=p[S];g[S]+=A+(x[S]-A)*w-I[S]}}else for(let I=0;I<f;I++){const S=p[I];g[I]+=S+(x[I]-S)*w}}else for(let T=0;T<f;T++){const I=p[T];g[T]=I+(x[T]-I)*w}else switch(c){case u.MixBlend.setup:{const I=r;if(I.bones==null){const S=I.vertices;for(let A=0;A<f;A++){const R=p[A],y=S[A];g[A]=y+(R+(x[A]-R)*w-y)*h}}else for(let S=0;S<f;S++){const A=p[S];g[S]=(A+(x[S]-A)*w)*h}break}case u.MixBlend.first:case u.MixBlend.replace:for(let I=0;I<f;I++){const S=p[I];g[I]+=(S+(x[I]-S)*w-g[I])*h}break;case u.MixBlend.add:const T=r;if(T.bones==null){const I=T.vertices;for(let S=0;S<f;S++){const A=p[S];g[S]+=(A+(x[S]-A)*w-I[S])*h}}else for(let I=0;I<f;I++){const S=p[I];g[I]+=(S+(x[I]-S)*w)*h}}}}class Lt{constructor(t){this.data=[],this.frames=u.Utils.newFloatArray(t),this.events=new Array(t)}getPropertyId(){return 7<<24}getFrameCount(){return this.frames.length}setFrame(t,s){this.data.push({type:"EventTimeline",frameIndex:t,event:s}),this.frames[t]=s.time,this.events[t]=s}apply(t,s,n,i,h,c,o){if(i==null)return;const a=this.frames,r=this.frames.length;if(s>n)this.apply(t,s,Number.MAX_VALUE,i,h,c,o),s=-1;else if(s>=a[r-1])return;if(n<a[0])return;let l=0;if(s<a[0])l=0;else{l=G.binarySearch(a,s);const d=a[l];for(;l>0&&a[l-1]==d;)l--}for(;l<r&&n>=a[l];l++)i.push(this.events[l])}}class Bt{constructor(t){this.data=[],this.frames=u.Utils.newFloatArray(t),this.drawOrders=new Array(t)}getPropertyId(){return 8<<24}getFrameCount(){return this.frames.length}setFrame(t,s,n){this.data.push({type:"DrawOrderTimeline",frameIndex:t,time:s,drawOrder:n}),this.frames[t]=s,this.drawOrders[t]=n}apply(t,s,n,i,h,c,o){const a=t.drawOrder,r=t.slots;if(o==u.MixDirection.mixOut&&c==u.MixBlend.setup){u.Utils.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}const l=this.frames;if(n<l[0]){(c==u.MixBlend.setup||c==u.MixBlend.first)&&u.Utils.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}let d=0;n>=l[l.length-1]?d=l.length-1:d=G.binarySearch(l,n)-1;const f=this.drawOrders[d];if(f==null)u.Utils.arrayCopy(r,0,a,0,r.length);else for(let m=0,g=f.length;m<g;m++)a[m]=r[f[m]]}}const q=class extends lt{constructor(e){super(e),this.data=[],this.frames=u.Utils.newFloatArray(e*q.ENTRIES)}getPropertyId(){return(9<<24)+this.ikConstraintIndex}setFrame(e,t,s,n){this.data.push({type:"IkConstraintTimeline",frameIndex:e,time:t,mix:s,bendDirection:n}),e*=q.ENTRIES,this.frames[e]=t,this.frames[e+q.MIX]=s,this.frames[e+q.BEND_DIRECTION]=n}apply(e,t,s,n,i,h,c){const o=this.frames,a=e.ikConstraints[this.ikConstraintIndex];if(!a.active)return;if(s<o[0]){switch(h){case u.MixBlend.setup:a.mix=a.data.mix,a.softness=a.data.softness,a.bendDirection=a.data.bendDirection,a.compress=a.data.compress,a.stretch=a.data.stretch;return;case u.MixBlend.first:a.mix+=(a.data.mix-a.mix)*i,a.softness+=(a.data.softness-a.softness)*i,a.bendDirection=a.data.bendDirection,a.compress=a.data.compress,a.stretch=a.data.stretch}return}if(s>=o[o.length-q.ENTRIES]){h===u.MixBlend.setup?(a.mix=a.data.mix+(o[o.length+q.PREV_MIX]-a.data.mix)*i,a.softness=a.data.softness+(o[o.length+q.PREV_SOFTNESS]-a.data.softness)*i,c===u.MixDirection.mixOut?(a.bendDirection=a.data.bendDirection,a.compress=a.data.compress,a.stretch=a.data.stretch):(a.bendDirection=o[o.length+q.PREV_BEND_DIRECTION],a.compress=o[o.length+q.PREV_COMPRESS]!==0,a.stretch=o[o.length+q.PREV_STRETCH]!==0)):(a.mix+=(o[o.length+q.PREV_MIX]-a.mix)*i,a.softness+=(o[o.length+q.PREV_SOFTNESS]-a.softness)*i,c===u.MixDirection.mixIn&&(a.bendDirection=o[o.length+q.PREV_BEND_DIRECTION],a.compress=o[o.length+q.PREV_COMPRESS]!==0,a.stretch=o[o.length+q.PREV_STRETCH]!==0));return}const r=G.binarySearch(o,s,q.ENTRIES),l=o[r+q.PREV_MIX],d=o[r],f=this.getCurvePercent(r/q.ENTRIES-1,1-(s-d)/(o[r+q.PREV_TIME]-d));a.mix+=(l+(o[r+q.MIX]-l)*f-a.mix)*i,a.bendDirection=Math.floor(o[r+q.PREV_BEND_DIRECTION])}};let et=q;et.ENTRIES=6,et.PREV_TIME=-6,et.PREV_MIX=-5,et.PREV_SOFTNESS=-4,et.PREV_BEND_DIRECTION=-3,et.PREV_COMPRESS=-2,et.PREV_STRETCH=-1,et.MIX=1,et.SOFTNESS=2,et.BEND_DIRECTION=3,et.COMPRESS=4,et.STRETCH=5;const b=class extends lt{constructor(t){super(t),this.data=[],this.frames=u.Utils.newFloatArray(t*b.ENTRIES)}getPropertyId(){return(10<<24)+this.transformConstraintIndex}setFrame(t,s,n,i,h,c){this.data.push({type:"TransformConstraintTimeline",frameIndex:t,time:s,rotateMix:n,translateMix:i,scaleMix:h,shearMix:c}),t*=b.ENTRIES,this.frames[t]=s,this.frames[t+b.ROTATE]=n,this.frames[t+b.TRANSLATE]=i,this.frames[t+b.SCALE]=h,this.frames[t+b.SHEAR]=c}apply(t,s,n,i,h,c,o){const a=this.frames,r=t.transformConstraints[this.transformConstraintIndex];if(!r.active)return;if(n<a[0]){const g=r.data;switch(c){case u.MixBlend.setup:r.rotateMix=g.rotateMix,r.translateMix=g.translateMix,r.scaleMix=g.scaleMix,r.shearMix=g.shearMix;return;case u.MixBlend.first:r.rotateMix+=(g.rotateMix-r.rotateMix)*h,r.translateMix+=(g.translateMix-r.translateMix)*h,r.scaleMix+=(g.scaleMix-r.scaleMix)*h,r.shearMix+=(g.shearMix-r.shearMix)*h}return}let l=0,d=0,f=0,m=0;if(n>=a[a.length-b.ENTRIES]){const g=a.length;l=a[g+b.PREV_ROTATE],d=a[g+b.PREV_TRANSLATE],f=a[g+b.PREV_SCALE],m=a[g+b.PREV_SHEAR]}else{const g=G.binarySearch(a,n,b.ENTRIES);l=a[g+b.PREV_ROTATE],d=a[g+b.PREV_TRANSLATE],f=a[g+b.PREV_SCALE],m=a[g+b.PREV_SHEAR];const M=a[g],p=this.getCurvePercent(g/b.ENTRIES-1,1-(n-M)/(a[g+b.PREV_TIME]-M));l+=(a[g+b.ROTATE]-l)*p,d+=(a[g+b.TRANSLATE]-d)*p,f+=(a[g+b.SCALE]-f)*p,m+=(a[g+b.SHEAR]-m)*p}if(c==u.MixBlend.setup){const g=r.data;r.rotateMix=g.rotateMix+(l-g.rotateMix)*h,r.translateMix=g.translateMix+(d-g.translateMix)*h,r.scaleMix=g.scaleMix+(f-g.scaleMix)*h,r.shearMix=g.shearMix+(m-g.shearMix)*h}else r.rotateMix+=(l-r.rotateMix)*h,r.translateMix+=(d-r.translateMix)*h,r.scaleMix+=(f-r.scaleMix)*h,r.shearMix+=(m-r.shearMix)*h}};let it=b;it.ENTRIES=5,it.PREV_TIME=-5,it.PREV_ROTATE=-4,it.PREV_TRANSLATE=-3,it.PREV_SCALE=-2,it.PREV_SHEAR=-1,it.ROTATE=1,it.TRANSLATE=2,it.SCALE=3,it.SHEAR=4;const pt=class extends lt{constructor(e){super(e),this.data=[],this.frames=u.Utils.newFloatArray(e*pt.ENTRIES)}getPropertyId(){return(11<<24)+this.pathConstraintIndex}setFrame(e,t,s){this.data.push({type:"PathConstraintPositionTimeline",frameIndex:e,time:t,value:s}),e*=pt.ENTRIES,this.frames[e]=t,this.frames[e+pt.VALUE]=s}apply(e,t,s,n,i,h,c){const o=this.frames,a=e.pathConstraints[this.pathConstraintIndex];if(!a.active)return;if(s<o[0]){switch(h){case u.MixBlend.setup:a.position=a.data.position;return;case u.MixBlend.first:a.position+=(a.data.position-a.position)*i}return}let r=0;if(s>=o[o.length-pt.ENTRIES])r=o[o.length+pt.PREV_VALUE];else{const l=G.binarySearch(o,s,pt.ENTRIES);r=o[l+pt.PREV_VALUE];const d=o[l],f=this.getCurvePercent(l/pt.ENTRIES-1,1-(s-d)/(o[l+pt.PREV_TIME]-d));r+=(o[l+pt.VALUE]-r)*f}h==u.MixBlend.setup?a.position=a.data.position+(r-a.data.position)*i:a.position+=(r-a.position)*i}};let Et=pt;Et.ENTRIES=2,Et.PREV_TIME=-2,Et.PREV_VALUE=-1,Et.VALUE=1;class Mt extends Et{constructor(t){super(t)}getPropertyId(){return(12<<24)+this.pathConstraintIndex}apply(t,s,n,i,h,c,o){const a=this.frames,r=t.pathConstraints[this.pathConstraintIndex];if(!r.active)return;if(n<a[0]){switch(c){case u.MixBlend.setup:r.spacing=r.data.spacing;return;case u.MixBlend.first:r.spacing+=(r.data.spacing-r.spacing)*h}return}let l=0;if(n>=a[a.length-Mt.ENTRIES])l=a[a.length+Mt.PREV_VALUE];else{const d=G.binarySearch(a,n,Mt.ENTRIES);l=a[d+Mt.PREV_VALUE];const f=a[d],m=this.getCurvePercent(d/Mt.ENTRIES-1,1-(n-f)/(a[d+Mt.PREV_TIME]-f));l+=(a[d+Mt.VALUE]-l)*m}c==u.MixBlend.setup?r.spacing=r.data.spacing+(l-r.data.spacing)*h:r.spacing+=(l-r.spacing)*h}}const at=class extends lt{constructor(e){super(e),this.data=[],this.frames=u.Utils.newFloatArray(e*at.ENTRIES)}getPropertyId(){return(13<<24)+this.pathConstraintIndex}setFrame(e,t,s,n){this.data.push({type:"PathConstraintMixTimeline",frameIndex:e,time:t,rotateMix:s,translateMix:n}),e*=at.ENTRIES,this.frames[e]=t,this.frames[e+at.ROTATE]=s,this.frames[e+at.TRANSLATE]=n}apply(e,t,s,n,i,h,c){const o=this.frames,a=e.pathConstraints[this.pathConstraintIndex];if(!a.active)return;if(s<o[0]){switch(h){case u.MixBlend.setup:a.rotateMix=a.data.rotateMix,a.translateMix=a.data.translateMix;return;case u.MixBlend.first:a.rotateMix+=(a.data.rotateMix-a.rotateMix)*i,a.translateMix+=(a.data.translateMix-a.translateMix)*i}return}let r=0,l=0;if(s>=o[o.length-at.ENTRIES])r=o[o.length+at.PREV_ROTATE],l=o[o.length+at.PREV_TRANSLATE];else{const d=G.binarySearch(o,s,at.ENTRIES);r=o[d+at.PREV_ROTATE],l=o[d+at.PREV_TRANSLATE];const f=o[d],m=this.getCurvePercent(d/at.ENTRIES-1,1-(s-f)/(o[d+at.PREV_TIME]-f));r+=(o[d+at.ROTATE]-r)*m,l+=(o[d+at.TRANSLATE]-l)*m}h==u.MixBlend.setup?(a.rotateMix=a.data.rotateMix+(r-a.data.rotateMix)*i,a.translateMix=a.data.translateMix+(l-a.data.translateMix)*i):(a.rotateMix+=(r-a.rotateMix)*i,a.translateMix+=(l-a.translateMix)*i)}};let xt=at;xt.ENTRIES=3,xt.PREV_TIME=-3,xt.PREV_ROTATE=-2,xt.PREV_TRANSLATE=-1,xt.ROTATE=1,xt.TRANSLATE=2;const W=class{constructor(e){this.tracks=new Array,this.timeScale=1,this.unkeyedState=0,this.events=new Array,this.listeners=new Array,this.queue=new Qt(this),this.propertyIDs=new u.IntSet,this.animationsChanged=!1,this.trackEntryPool=new u.Pool(()=>new _t),this.data=e}update(e){e*=this.timeScale;const t=this.tracks;for(let s=0,n=t.length;s<n;s++){const i=t[s];if(i==null)continue;i.animationLast=i.nextAnimationLast,i.trackLast=i.nextTrackLast;let h=e*i.timeScale;if(i.delay>0){if(i.delay-=h,i.delay>0)continue;h=-i.delay,i.delay=0}let c=i.next;if(c!=null){const o=i.trackLast-c.delay;if(o>=0){for(c.delay=0,c.trackTime+=i.timeScale==0?0:(o/i.timeScale+e)*c.timeScale,i.trackTime+=h,this.setCurrent(s,c,!0);c.mixingFrom!=null;)c.mixTime+=e,c=c.mixingFrom;continue}}else if(i.trackLast>=i.trackEnd&&i.mixingFrom==null){t[s]=null,this.queue.end(i),this.disposeNext(i);continue}if(i.mixingFrom!=null&&this.updateMixingFrom(i,e)){let o=i.mixingFrom;for(i.mixingFrom=null,o!=null&&(o.mixingTo=null);o!=null;)this.queue.end(o),o=o.mixingFrom}i.trackTime+=h}this.queue.drain()}updateMixingFrom(e,t){const s=e.mixingFrom;if(s==null)return!0;const n=this.updateMixingFrom(s,t);return s.animationLast=s.nextAnimationLast,s.trackLast=s.nextTrackLast,e.mixTime>0&&e.mixTime>=e.mixDuration?((s.totalAlpha==0||e.mixDuration==0)&&(e.mixingFrom=s.mixingFrom,s.mixingFrom!=null&&(s.mixingFrom.mixingTo=e),e.interruptAlpha=s.interruptAlpha,this.queue.end(s)),n):(s.trackTime+=t*s.timeScale,e.mixTime+=t,!1)}apply(e){if(e==null)throw new Error("skeleton cannot be null.");this.animationsChanged&&this._animationsChanged();const t=this.events,s=this.tracks;let n=!1;for(let c=0,o=s.length;c<o;c++){const a=s[c];if(a==null||a.delay>0)continue;n=!0;const r=c==0?u.MixBlend.first:a.mixBlend;let l=a.alpha;a.mixingFrom!=null?l*=this.applyMixingFrom(a,e,r):a.trackTime>=a.trackEnd&&a.next==null&&(l=0);const d=a.animationLast,f=a.getAnimationTime(),m=a.animation.timelines.length,g=a.animation.timelines;if(c==0&&l==1||r==u.MixBlend.add)for(let M=0;M<m;M++){u.Utils.webkit602BugfixHelper(l,r);const p=g[M];p instanceof Vt?this.applyAttachmentTimeline(p,e,f,r,!0):p.apply(e,d,f,t,l,r,u.MixDirection.mixIn)}else{const M=a.timelineMode,p=a.timelinesRotation.length==0;p&&u.Utils.setArraySize(a.timelinesRotation,m<<1,null);const x=a.timelinesRotation;for(let E=0;E<m;E++){const w=g[E],T=M[E]==W.SUBSEQUENT?r:u.MixBlend.setup;w instanceof tt?this.applyRotateTimeline(w,e,f,l,T,x,E<<1,p):w instanceof Vt?this.applyAttachmentTimeline(w,e,f,r,!0):(u.Utils.webkit602BugfixHelper(l,r),w.apply(e,d,f,t,l,T,u.MixDirection.mixIn))}}this.queueEvents(a,f),t.length=0,a.nextAnimationLast=f,a.nextTrackLast=a.trackTime}const i=this.unkeyedState+W.SETUP,h=e.slots;for(let c=0,o=e.slots.length;c<o;c++){const a=h[c];if(a.attachmentState==i){const r=a.data.attachmentName;a.setAttachment(r==null?null:e.getAttachment(a.data.index,r))}}return this.unkeyedState+=2,this.queue.drain(),n}applyMixingFrom(e,t,s){const n=e.mixingFrom;n.mixingFrom!=null&&this.applyMixingFrom(n,t,s);let i=0;e.mixDuration==0?(i=1,s==u.MixBlend.first&&(s=u.MixBlend.setup)):(i=e.mixTime/e.mixDuration,i>1&&(i=1),s!=u.MixBlend.first&&(s=n.mixBlend));const h=i<n.eventThreshold?this.events:null,c=i<n.attachmentThreshold,o=i<n.drawOrderThreshold,a=n.animationLast,r=n.getAnimationTime(),l=n.animation.timelines.length,d=n.animation.timelines,f=n.alpha*e.interruptAlpha,m=f*(1-i);if(s==u.MixBlend.add)for(let g=0;g<l;g++)d[g].apply(t,a,r,h,m,s,u.MixDirection.mixOut);else{const g=n.timelineMode,M=n.timelineHoldMix,p=n.timelinesRotation.length==0;p&&u.Utils.setArraySize(n.timelinesRotation,l<<1,null);const x=n.timelinesRotation;n.totalAlpha=0;for(let E=0;E<l;E++){const w=d[E];let T=u.MixDirection.mixOut,I,S=0;switch(g[E]){case W.SUBSEQUENT:if(!o&&w instanceof Bt)continue;I=s,S=m;break;case W.FIRST:I=u.MixBlend.setup,S=m;break;case W.HOLD_SUBSEQUENT:I=s,S=f;break;case W.HOLD_FIRST:I=u.MixBlend.setup,S=f;break;default:I=u.MixBlend.setup;const A=M[E];S=f*Math.max(0,1-A.mixTime/A.mixDuration);break}n.totalAlpha+=S,w instanceof tt?this.applyRotateTimeline(w,t,r,S,I,x,E<<1,p):w instanceof Vt?this.applyAttachmentTimeline(w,t,r,I,c):(u.Utils.webkit602BugfixHelper(S,s),o&&w instanceof Bt&&I==u.MixBlend.setup&&(T=u.MixDirection.mixIn),w.apply(t,a,r,h,S,I,T))}}return e.mixDuration>0&&this.queueEvents(n,r),this.events.length=0,n.nextAnimationLast=r,n.nextTrackLast=n.trackTime,i}applyAttachmentTimeline(e,t,s,n,i){const h=t.slots[e.slotIndex];if(!h.bone.active)return;const c=e.frames;if(s<c[0])(n==u.MixBlend.setup||n==u.MixBlend.first)&&this.setAttachment(t,h,h.data.attachmentName,i);else{let o;s>=c[c.length-1]?o=c.length-1:o=G.binarySearch(c,s)-1,this.setAttachment(t,h,e.attachmentNames[o],i)}h.attachmentState<=this.unkeyedState&&(h.attachmentState=this.unkeyedState+W.SETUP)}setAttachment(e,t,s,n){t.setAttachment(s==null?null:e.getAttachment(t.data.index,s)),n&&(t.attachmentState=this.unkeyedState+W.CURRENT)}applyRotateTimeline(e,t,s,n,i,h,c,o){if(o&&(h[c]=0),n==1){e.apply(t,0,s,null,1,i,u.MixDirection.mixIn);return}const a=e,r=a.frames,l=t.bones[a.boneIndex];if(!l.active)return;let d=0,f=0;if(s<r[0])switch(i){case u.MixBlend.setup:l.rotation=l.data.rotation;default:return;case u.MixBlend.first:d=l.rotation,f=l.data.rotation}else if(d=i==u.MixBlend.setup?l.data.rotation:l.rotation,s>=r[r.length-tt.ENTRIES])f=l.data.rotation+r[r.length+tt.PREV_ROTATION];else{const M=G.binarySearch(r,s,tt.ENTRIES),p=r[M+tt.PREV_ROTATION],x=r[M],E=a.getCurvePercent((M>>1)-1,1-(s-x)/(r[M+tt.PREV_TIME]-x));f=r[M+tt.ROTATION]-p,f-=(16384-(16384.499999999996-f/360|0))*360,f=p+f*E+l.data.rotation,f-=(16384-(16384.499999999996-f/360|0))*360}let m=0,g=f-d;if(g-=(16384-(16384.499999999996-g/360|0))*360,g==0)m=h[c];else{let M=0,p=0;o?(M=0,p=g):(M=h[c],p=h[c+1]);const x=g>0;let E=M>=0;u.MathUtils.signum(p)!=u.MathUtils.signum(g)&&Math.abs(p)<=90&&(Math.abs(M)>180&&(M+=360*u.MathUtils.signum(M)),E=x),m=g+M-M%360,E!=x&&(m+=360*u.MathUtils.signum(M)),h[c]=m}h[c+1]=g,d+=m*n,l.rotation=d-(16384-(16384.499999999996-d/360|0))*360}queueEvents(e,t){const s=e.animationStart,n=e.animationEnd,i=n-s,h=e.trackLast%i,c=this.events;let o=0;const a=c.length;for(;o<a;o++){const l=c[o];if(l.time<h)break;l.time>n||this.queue.event(e,l)}let r=!1;for(e.loop?r=i==0||h>e.trackTime%i:r=t>=n&&e.animationLast<n,r&&this.queue.complete(e);o<a;o++)c[o].time<s||this.queue.event(e,c[o])}clearTracks(){const e=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let t=0,s=this.tracks.length;t<s;t++)this.clearTrack(t);this.tracks.length=0,this.queue.drainDisabled=e,this.queue.drain()}clearTrack(e){if(e>=this.tracks.length)return;const t=this.tracks[e];if(t==null)return;this.queue.end(t),this.disposeNext(t);let s=t;for(;;){const n=s.mixingFrom;if(n==null)break;this.queue.end(n),s.mixingFrom=null,s.mixingTo=null,s=n}this.tracks[t.trackIndex]=null,this.queue.drain()}setCurrent(e,t,s){const n=this.expandToIndex(e);this.tracks[e]=t,n!=null&&(s&&this.queue.interrupt(n),t.mixingFrom=n,n.mixingTo=t,t.mixTime=0,n.mixingFrom!=null&&n.mixDuration>0&&(t.interruptAlpha*=Math.min(1,n.mixTime/n.mixDuration)),n.timelinesRotation.length=0),this.queue.start(t)}setAnimation(e,t,s){const n=this.data.skeletonData.findAnimation(t);if(n==null)throw new Error(`Animation not found: ${t}`);return this.setAnimationWith(e,n,s)}setAnimationWith(e,t,s){if(t==null)throw new Error("animation cannot be null.");let n=!0,i=this.expandToIndex(e);i!=null&&(i.nextTrackLast==-1?(this.tracks[e]=i.mixingFrom,this.queue.interrupt(i),this.queue.end(i),this.disposeNext(i),i=i.mixingFrom,n=!1):this.disposeNext(i));const h=this.trackEntry(e,t,s,i);return this.setCurrent(e,h,n),this.queue.drain(),h}addAnimation(e,t,s,n){const i=this.data.skeletonData.findAnimation(t);if(i==null)throw new Error(`Animation not found: ${t}`);return this.addAnimationWith(e,i,s,n)}addAnimationWith(e,t,s,n){if(t==null)throw new Error("animation cannot be null.");let i=this.expandToIndex(e);if(i!=null)for(;i.next!=null;)i=i.next;const h=this.trackEntry(e,t,s,i);if(i==null)this.setCurrent(e,h,!0),this.queue.drain();else if(i.next=h,n<=0){const c=i.animationEnd-i.animationStart;c!=0?(i.loop?n+=c*(1+(i.trackTime/c|0)):n+=Math.max(c,i.trackTime),n-=this.data.getMix(i.animation,t)):n=i.trackTime}return h.delay=n,h}setEmptyAnimation(e,t){const s=this.setAnimationWith(e,W.emptyAnimation,!1);return s.mixDuration=t,s.trackEnd=t,s}addEmptyAnimation(e,t,s){s<=0&&(s-=t);const n=this.addAnimationWith(e,W.emptyAnimation,!1,s);return n.mixDuration=t,n.trackEnd=t,n}setEmptyAnimations(e){const t=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let s=0,n=this.tracks.length;s<n;s++){const i=this.tracks[s];i!=null&&this.setEmptyAnimation(i.trackIndex,e)}this.queue.drainDisabled=t,this.queue.drain()}expandToIndex(e){return e<this.tracks.length?this.tracks[e]:(u.Utils.ensureArrayCapacity(this.tracks,e+1,null),this.tracks.length=e+1,null)}trackEntry(e,t,s,n){const i=this.trackEntryPool.obtain();return i.trackIndex=e,i.animation=t,i.loop=s,i.holdPrevious=!1,i.eventThreshold=0,i.attachmentThreshold=0,i.drawOrderThreshold=0,i.animationStart=0,i.animationEnd=t.duration,i.animationLast=-1,i.nextAnimationLast=-1,i.delay=0,i.trackTime=0,i.trackLast=-1,i.nextTrackLast=-1,i.trackEnd=Number.MAX_VALUE,i.timeScale=1,i.alpha=1,i.interruptAlpha=1,i.mixTime=0,i.mixDuration=n==null?0:this.data.getMix(n.animation,t),i.mixBlend=u.MixBlend.replace,i}disposeNext(e){let t=e.next;for(;t!=null;)this.queue.dispose(t),t=t.next;e.next=null}_animationsChanged(){this.animationsChanged=!1,this.propertyIDs.clear();for(let e=0,t=this.tracks.length;e<t;e++){let s=this.tracks[e];if(s!=null){for(;s.mixingFrom!=null;)s=s.mixingFrom;do(s.mixingFrom==null||s.mixBlend!=u.MixBlend.add)&&this.computeHold(s),s=s.mixingTo;while(s!=null)}}}computeHold(e){const t=e.mixingTo,s=e.animation.timelines,n=e.animation.timelines.length,i=u.Utils.setArraySize(e.timelineMode,n);e.timelineHoldMix.length=0;const h=u.Utils.setArraySize(e.timelineHoldMix,n),c=this.propertyIDs;if(t!=null&&t.holdPrevious){for(let o=0;o<n;o++)i[o]=c.add(s[o].getPropertyId())?W.HOLD_FIRST:W.HOLD_SUBSEQUENT;return}t:for(let o=0;o<n;o++){const a=s[o],r=a.getPropertyId();if(!c.add(r))i[o]=W.SUBSEQUENT;else if(t==null||a instanceof Vt||a instanceof Bt||a instanceof Lt||!t.animation.hasTimeline(r))i[o]=W.FIRST;else{for(let l=t.mixingTo;l!=null;l=l.mixingTo)if(!l.animation.hasTimeline(r)){if(e.mixDuration>0){i[o]=W.HOLD_MIX,h[o]=l;continue t}break}i[o]=W.HOLD_FIRST}}}getCurrent(e){return e>=this.tracks.length?null:this.tracks[e]}addListener(e){if(e==null)throw new Error("listener cannot be null.");this.listeners.push(e)}removeListener(e){const t=this.listeners.indexOf(e);t>=0&&this.listeners.splice(t,1)}clearListeners(){this.listeners.length=0}clearListenerNotifications(){this.queue.clear()}setAnimationByName(e,t,s){W.deprecatedWarning1||(W.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.")),this.setAnimation(e,t,s)}addAnimationByName(e,t,s,n){W.deprecatedWarning2||(W.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.")),this.addAnimation(e,t,s,n)}hasAnimation(e){return this.data.skeletonData.findAnimation(e)!==null}hasAnimationByName(e){return W.deprecatedWarning3||(W.deprecatedWarning3=!0,console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.")),this.hasAnimation(e)}};let ft=W;ft.emptyAnimation=new G("<empty>",[],0),ft.SUBSEQUENT=0,ft.FIRST=1,ft.HOLD_SUBSEQUENT=2,ft.HOLD_FIRST=3,ft.HOLD_MIX=4,ft.SETUP=1,ft.CURRENT=2,ft.deprecatedWarning1=!1,ft.deprecatedWarning2=!1,ft.deprecatedWarning3=!1;const Tt=class{constructor(){this.mixBlend=u.MixBlend.replace,this.timelineMode=new Array,this.timelineHoldMix=new Array,this.timelinesRotation=new Array}reset(){this.next=null,this.mixingFrom=null,this.mixingTo=null,this.animation=null,this.listener=null,this.timelineMode.length=0,this.timelineHoldMix.length=0,this.timelinesRotation.length=0}getAnimationTime(){if(this.loop){const e=this.animationEnd-this.animationStart;return e==0?this.animationStart:this.trackTime%e+this.animationStart}return Math.min(this.trackTime+this.animationStart,this.animationEnd)}setAnimationLast(e){this.animationLast=e,this.nextAnimationLast=e}isComplete(){return this.trackTime>=this.animationEnd-this.animationStart}resetRotationDirections(){this.timelinesRotation.length=0}get time(){return Tt.deprecatedWarning1||(Tt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime}set time(e){Tt.deprecatedWarning1||(Tt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime=e}get endTime(){return Tt.deprecatedWarning2||(Tt.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime}set endTime(e){Tt.deprecatedWarning2||(Tt.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime=e}loopsCount(){return Math.floor(this.trackTime/this.trackEnd)}};let _t=Tt;_t.deprecatedWarning1=!1,_t.deprecatedWarning2=!1;const zt=class{constructor(e){this.objects=[],this.drainDisabled=!1,this.animState=e}start(e){this.objects.push(dt.start),this.objects.push(e),this.animState.animationsChanged=!0}interrupt(e){this.objects.push(dt.interrupt),this.objects.push(e)}end(e){this.objects.push(dt.end),this.objects.push(e),this.animState.animationsChanged=!0}dispose(e){this.objects.push(dt.dispose),this.objects.push(e)}complete(e){this.objects.push(dt.complete),this.objects.push(e)}event(e,t){this.objects.push(dt.event),this.objects.push(e),this.objects.push(t)}deprecateStuff(){return zt.deprecatedWarning1||(zt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'")),!0}drain(){if(this.drainDisabled)return;this.drainDisabled=!0;const e=this.objects,t=this.animState.listeners;for(let s=0;s<e.length;s+=2){const n=e[s],i=e[s+1];switch(n){case dt.start:i.listener!=null&&i.listener.start&&i.listener.start(i);for(let o=0;o<t.length;o++)t[o].start&&t[o].start(i);i.onStart&&this.deprecateStuff()&&i.onStart(i.trackIndex),this.animState.onStart&&this.deprecateStuff()&&this.deprecateStuff&&this.animState.onStart(i.trackIndex);break;case dt.interrupt:i.listener!=null&&i.listener.interrupt&&i.listener.interrupt(i);for(let o=0;o<t.length;o++)t[o].interrupt&&t[o].interrupt(i);break;case dt.end:i.listener!=null&&i.listener.end&&i.listener.end(i);for(let o=0;o<t.length;o++)t[o].end&&t[o].end(i);i.onEnd&&this.deprecateStuff()&&i.onEnd(i.trackIndex),this.animState.onEnd&&this.deprecateStuff()&&this.animState.onEnd(i.trackIndex);case dt.dispose:i.listener!=null&&i.listener.dispose&&i.listener.dispose(i);for(let o=0;o<t.length;o++)t[o].dispose&&t[o].dispose(i);this.animState.trackEntryPool.free(i);break;case dt.complete:i.listener!=null&&i.listener.complete&&i.listener.complete(i);for(let o=0;o<t.length;o++)t[o].complete&&t[o].complete(i);const h=u.MathUtils.toInt(i.loopsCount());i.onComplete&&this.deprecateStuff()&&i.onComplete(i.trackIndex,h),this.animState.onComplete&&this.deprecateStuff()&&this.animState.onComplete(i.trackIndex,h);break;case dt.event:const c=e[s+++2];i.listener!=null&&i.listener.event&&i.listener.event(i,c);for(let o=0;o<t.length;o++)t[o].event&&t[o].event(i,c);i.onEvent&&this.deprecateStuff()&&i.onEvent(i.trackIndex,c),this.animState.onEvent&&this.deprecateStuff()&&this.animState.onEvent(i.trackIndex,c);break}}this.clear(),this.drainDisabled=!1}clear(){this.objects.length=0}};let Qt=zt;Qt.deprecatedWarning1=!1;var dt=(e=>(e[e.start=0]="start",e[e.interrupt=1]="interrupt",e[e.end=2]="end",e[e.dispose=3]="dispose",e[e.complete=4]="complete",e[e.event=5]="event",e))(dt||{});class ke{start(t){}interrupt(t){}end(t){}dispose(t){}complete(t){}event(t,s){}}const Kt=class{constructor(e){if(this.animationToMixTime={},this.defaultMix=0,e==null)throw new Error("skeletonData cannot be null.");this.skeletonData=e}setMix(e,t,s){const n=this.skeletonData.findAnimation(e);if(n==null)throw new Error(`Animation not found: ${e}`);const i=this.skeletonData.findAnimation(t);if(i==null)throw new Error(`Animation not found: ${t}`);this.setMixWith(n,i,s)}setMixByName(e,t,s){Kt.deprecatedWarning1||(Kt.deprecatedWarning1=!0,console.warn("Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.")),this.setMix(e,t,s)}setMixWith(e,t,s){if(e==null)throw new Error("from cannot be null.");if(t==null)throw new Error("to cannot be null.");const n=`${e.name}.${t.name}`;this.animationToMixTime[n]=s}getMix(e,t){const s=`${e.name}.${t.name}`,n=this.animationToMixTime[s];return n===void 0?this.defaultMix:n}};let Jt=Kt;Jt.deprecatedWarning1=!1;class Ve{constructor(t){this.atlas=t}newRegionAttachment(t,s,n){const i=this.atlas.findRegion(n);if(i==null)throw new Error(`Region not found in atlas: ${n} (region attachment: ${s})`);const h=new B(s);return h.region=i,h}newMeshAttachment(t,s,n){const i=this.atlas.findRegion(n);if(i==null)throw new Error(`Region not found in atlas: ${n} (mesh attachment: ${s})`);const h=new Ct(s);return h.region=i,h}newBoundingBoxAttachment(t,s){return new Xt(s)}newPathAttachment(t,s){return new kt(s)}newPointAttachment(t,s){return new Ot(s)}newClippingAttachment(t,s){return new Yt(s)}}class te{constructor(t,s,n){if(this.matrix=new wt.Matrix,this.children=new Array,this.x=0,this.y=0,this.rotation=0,this.scaleX=0,this.scaleY=0,this.shearX=0,this.shearY=0,this.ax=0,this.ay=0,this.arotation=0,this.ascaleX=0,this.ascaleY=0,this.ashearX=0,this.ashearY=0,this.appliedValid=!1,this.sorted=!1,this.active=!1,t==null)throw new Error("data cannot be null.");if(s==null)throw new Error("skeleton cannot be null.");this.data=t,this.skeleton=s,this.parent=n,this.setToSetupPose()}get worldX(){return this.matrix.tx}get worldY(){return this.matrix.ty}isActive(){return this.active}update(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransform(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransformWith(t,s,n,i,h,c,o){this.ax=t,this.ay=s,this.arotation=n,this.ascaleX=i,this.ascaleY=h,this.ashearX=c,this.ashearY=o,this.appliedValid=!0;const a=this.parent,r=this.matrix,l=this.skeleton.scaleX,d=u.settings.yDown?-this.skeleton.scaleY:this.skeleton.scaleY;if(a==null){const p=this.skeleton,x=n+90+o;r.a=u.MathUtils.cosDeg(n+c)*i*l,r.c=u.MathUtils.cosDeg(x)*h*l,r.b=u.MathUtils.sinDeg(n+c)*i*d,r.d=u.MathUtils.sinDeg(x)*h*d,r.tx=t*l+p.x,r.ty=s*d+p.y;return}let f=a.matrix.a,m=a.matrix.c,g=a.matrix.b,M=a.matrix.d;switch(r.tx=f*t+m*s+a.matrix.tx,r.ty=g*t+M*s+a.matrix.ty,this.data.transformMode){case u.TransformMode.Normal:{const p=n+90+o,x=u.MathUtils.cosDeg(n+c)*i,E=u.MathUtils.cosDeg(p)*h,w=u.MathUtils.sinDeg(n+c)*i,T=u.MathUtils.sinDeg(p)*h;r.a=f*x+m*w,r.c=f*E+m*T,r.b=g*x+M*w,r.d=g*E+M*T;return}case u.TransformMode.OnlyTranslation:{const p=n+90+o;r.a=u.MathUtils.cosDeg(n+c)*i,r.c=u.MathUtils.cosDeg(p)*h,r.b=u.MathUtils.sinDeg(n+c)*i,r.d=u.MathUtils.sinDeg(p)*h;break}case u.TransformMode.NoRotationOrReflection:{let p=f*f+g*g,x=0;p>1e-4?(p=Math.abs(f*M-m*g)/p,f/=this.skeleton.scaleX,g/=this.skeleton.scaleY,m=g*p,M=f*p,x=Math.atan2(g,f)*u.MathUtils.radDeg):(f=0,g=0,x=90-Math.atan2(M,m)*u.MathUtils.radDeg);const E=n+c-x,w=n+o-x+90,T=u.MathUtils.cosDeg(E)*i,I=u.MathUtils.cosDeg(w)*h,S=u.MathUtils.sinDeg(E)*i,A=u.MathUtils.sinDeg(w)*h;r.a=f*T-m*S,r.c=f*I-m*A,r.b=g*T+M*S,r.d=g*I+M*A;break}case u.TransformMode.NoScale:case u.TransformMode.NoScaleOrReflection:{const p=u.MathUtils.cosDeg(n),x=u.MathUtils.sinDeg(n);let E=(f*p+m*x)/l,w=(g*p+M*x)/d,T=Math.sqrt(E*E+w*w);T>1e-5&&(T=1/T),E*=T,w*=T,T=Math.sqrt(E*E+w*w),this.data.transformMode==u.TransformMode.NoScale&&f*M-m*g<0!=(u.settings.yDown?this.skeleton.scaleX<0!=this.skeleton.scaleY>0:this.skeleton.scaleX<0!=this.skeleton.scaleY<0)&&(T=-T);const I=Math.PI/2+Math.atan2(w,E),S=Math.cos(I)*T,A=Math.sin(I)*T,R=u.MathUtils.cosDeg(c)*i,y=u.MathUtils.cosDeg(90+o)*h,k=u.MathUtils.sinDeg(c)*i,X=u.MathUtils.sinDeg(90+o)*h;r.a=E*R+S*k,r.c=E*y+S*X,r.b=w*R+A*k,r.d=w*y+A*X;break}}r.a*=l,r.c*=l,r.b*=d,r.d*=d}setToSetupPose(){const t=this.data;this.x=t.x,this.y=t.y,this.rotation=t.rotation,this.scaleX=t.scaleX,this.scaleY=t.scaleY,this.shearX=t.shearX,this.shearY=t.shearY}getWorldRotationX(){return Math.atan2(this.matrix.b,this.matrix.a)*u.MathUtils.radDeg}getWorldRotationY(){return Math.atan2(this.matrix.d,this.matrix.c)*u.MathUtils.radDeg}getWorldScaleX(){const t=this.matrix;return Math.sqrt(t.a*t.a+t.c*t.c)}getWorldScaleY(){const t=this.matrix;return Math.sqrt(t.b*t.b+t.d*t.d)}updateAppliedTransform(){this.appliedValid=!0;const t=this.parent,s=this.matrix;if(t==null){this.ax=s.tx,this.ay=s.ty,this.arotation=Math.atan2(s.b,s.a)*u.MathUtils.radDeg,this.ascaleX=Math.sqrt(s.a*s.a+s.b*s.b),this.ascaleY=Math.sqrt(s.c*s.c+s.d*s.d),this.ashearX=0,this.ashearY=Math.atan2(s.a*s.c+s.b*s.d,s.a*s.d-s.b*s.c)*u.MathUtils.radDeg;return}const n=t.matrix,i=1/(n.a*n.d-n.b*n.c),h=s.tx-n.tx,c=s.ty-n.ty;this.ax=h*n.d*i-c*n.c*i,this.ay=c*n.a*i-h*n.b*i;const o=i*n.d,a=i*n.a,r=i*n.c,l=i*n.b,d=o*s.a-r*s.b,f=o*s.c-r*s.d,m=a*s.b-l*s.a,g=a*s.d-l*s.c;if(this.ashearX=0,this.ascaleX=Math.sqrt(d*d+m*m),this.ascaleX>1e-4){const M=d*g-f*m;this.ascaleY=M/this.ascaleX,this.ashearY=Math.atan2(d*f+m*g,M)*u.MathUtils.radDeg,this.arotation=Math.atan2(m,d)*u.MathUtils.radDeg}else this.ascaleX=0,this.ascaleY=Math.sqrt(f*f+g*g),this.ashearY=0,this.arotation=90-Math.atan2(g,f)*u.MathUtils.radDeg}worldToLocal(t){const s=this.matrix,n=s.a,i=s.c,h=s.b,c=s.d,o=1/(n*c-i*h),a=t.x-s.tx,r=t.y-s.ty;return t.x=a*c*o-r*i*o,t.y=r*n*o-a*h*o,t}localToWorld(t){const s=this.matrix,n=t.x,i=t.y;return t.x=n*s.a+i*s.c+s.tx,t.y=n*s.b+i*s.d+s.ty,t}worldToLocalRotation(t){const s=u.MathUtils.sinDeg(t),n=u.MathUtils.cosDeg(t),i=this.matrix;return Math.atan2(i.a*s-i.b*n,i.d*n-i.c*s)*u.MathUtils.radDeg}localToWorldRotation(t){const s=u.MathUtils.sinDeg(t),n=u.MathUtils.cosDeg(t),i=this.matrix;return Math.atan2(n*i.b+s*i.d,n*i.a+s*i.c)*u.MathUtils.radDeg}rotateWorld(t){const s=this.matrix,n=s.a,i=s.c,h=s.b,c=s.d,o=u.MathUtils.cosDeg(t),a=u.MathUtils.sinDeg(t);s.a=o*n-a*h,s.c=o*i-a*c,s.b=a*n+o*h,s.d=a*i+o*c,this.appliedValid=!1}}class ee{constructor(t,s,n){if(this.x=0,this.y=0,this.rotation=0,this.scaleX=1,this.scaleY=1,this.shearX=0,this.shearY=0,this.transformMode=u.TransformMode.Normal,this.skinRequired=!1,this.inheritRotation=!0,this.inheritScale=!0,this.color=new u.Color,t<0)throw new Error("index must be >= 0.");if(s==null)throw new Error("name cannot be null.");this.index=t,this.name=s,this.parent=n}}class bt{constructor(t,s,n){this.name=t,this.order=s,this.skinRequired=n}}class ne{constructor(t,s){if(s==null)throw new Error("data cannot be null.");this.time=t,this.data=s}}class se{constructor(t){this.name=t}}class xe{constructor(t,s){if(this.bendDirection=0,this.compress=!1,this.stretch=!1,this.mix=1,this.softness=0,this.active=!1,t==null)throw new Error("data cannot be null.");if(s==null)throw new Error("skeleton cannot be null.");this.data=t,this.mix=t.mix,this.softness=t.softness,this.bendDirection=t.bendDirection,this.compress=t.compress,this.stretch=t.stretch,this.bones=new Array;for(let n=0;n<t.bones.length;n++)this.bones.push(s.findBone(t.bones[n].name));this.target=s.findBone(t.target.name)}isActive(){return this.active}apply(){this.update()}update(){const t=this.target,s=this.bones;switch(s.length){case 1:this.apply1(s[0],t.worldX,t.worldY,this.compress,this.stretch,this.data.uniform,this.mix);break;case 2:this.apply2(s[0],s[1],t.worldX,t.worldY,this.bendDirection,this.stretch,this.softness,this.mix);break}}apply1(t,s,n,i,h,c,o){t.appliedValid||t.updateAppliedTransform();const a=t.parent.matrix,r=a.a;let l=a.c;const d=a.b;let f=a.d,m=-t.ashearX-t.arotation,g=0,M=0;switch(t.data.transformMode){case u.TransformMode.OnlyTranslation:g=s-t.worldX,M=n-t.worldY;break;case u.TransformMode.NoRotationOrReflection:const E=Math.abs(r*f-l*d)/(r*r+d*d),w=r/t.skeleton.scaleX,T=d/t.skeleton.scaleY;l=-T*E*t.skeleton.scaleX,f=w*E*t.skeleton.scaleY,m+=Math.atan2(T,w)*u.MathUtils.radDeg;default:const I=s-a.tx,S=n-a.ty,A=r*f-l*d;g=(I*f-S*l)/A-t.ax,M=(S*r-I*d)/A-t.ay}m+=Math.atan2(M,g)*u.MathUtils.radDeg,t.ascaleX<0&&(m+=180),m>180?m-=360:m<-180&&(m+=360);let p=t.ascaleX,x=t.ascaleY;if(i||h){switch(t.data.transformMode){case u.TransformMode.NoScale:case u.TransformMode.NoScaleOrReflection:g=s-t.worldX,M=n-t.worldY}const E=t.data.length*p,w=Math.sqrt(g*g+M*M);if(i&&w<E||h&&w>E&&E>1e-4){const T=(w/E-1)*o+1;p*=T,c&&(x*=T)}}t.updateWorldTransformWith(t.ax,t.ay,t.arotation+m*o,p,x,t.ashearX,t.ashearY)}apply2(t,s,n,i,h,c,o,a){if(a==0){s.updateWorldTransform();return}t.appliedValid||t.updateAppliedTransform(),s.appliedValid||s.updateAppliedTransform();const r=t.ax,l=t.ay;let d=t.ascaleX,f=d,m=t.ascaleY,g=s.ascaleX;const M=t.matrix;let p=0,x=0,E=0;d<0?(d=-d,p=180,E=-1):(p=0,E=1),m<0&&(m=-m,E=-E),g<0?(g=-g,x=180):x=0;const w=s.ax;let T=0,I=0,S=0,A=M.a,R=M.c,y=M.b,k=M.d;const X=Math.abs(d-m)<=1e-4;X?(T=s.ay,I=A*w+R*T+M.tx,S=y*w+k*T+M.ty):(T=0,I=A*w+M.tx,S=y*w+M.ty);const N=t.parent.matrix;A=N.a,R=N.c,y=N.b,k=N.d;const $=1/(A*k-R*y);let P=I-N.tx,F=S-N.ty;const rt=(P*k-F*R)*$-r,ot=(F*A-P*y)*$-l,V=Math.sqrt(rt*rt+ot*ot);let U=s.data.length*g,D,L;if(V<1e-4){this.apply1(t,n,i,!1,c,!1,a),s.updateWorldTransformWith(w,T,0,s.ascaleX,s.ascaleY,s.ashearX,s.ashearY);return}P=n-N.tx,F=i-N.ty;let H=(P*k-F*R)*$-r,O=(F*A-P*y)*$-l,v=H*H+O*O;if(o!=0){o*=d*(g+1)/2;const ut=Math.sqrt(v),St=ut-V-U*d+o;if(St>0){let It=Math.min(1,St/(o*2))-1;It=(St-o*(1-It*It))/ut,H-=It*H,O-=It*O,v=H*H+O*O}}t:if(X){U*=d;let ut=(v-V*V-U*U)/(2*V*U);ut<-1?ut=-1:ut>1&&(ut=1,c&&(f*=(Math.sqrt(v)/(V+U)-1)*a+1)),L=Math.acos(ut)*h,A=V+U*ut,R=U*Math.sin(L),D=Math.atan2(O*A-H*R,H*A+O*R)}else{A=d*U,R=m*U;const ut=A*A,St=R*R,It=Math.atan2(O,H);y=St*V*V+ut*v-ut*St;const qt=-2*St*V,we=St-ut;if(k=qt*qt-4*we*y,k>=0){let vt=Math.sqrt(k);qt<0&&(vt=-vt),vt=-(qt+vt)/2;const ye=vt/we,Re=y/vt,Ut=Math.abs(ye)<Math.abs(Re)?ye:Re;if(Ut*Ut<=v){F=Math.sqrt(v-Ut*Ut)*h,D=It-Math.atan2(F,Ut),L=Math.atan2(F/m,(Ut-V)/d);break t}}let Te=u.MathUtils.PI,$t=V-A,de=$t*$t,Se=0,Ie=0,Ht=V+A,ue=Ht*Ht,Ae=0;y=-A*V/(ut-St),y>=-1&&y<=1&&(y=Math.acos(y),P=A*Math.cos(y)+V,F=R*Math.sin(y),k=P*P+F*F,k<de&&(Te=y,de=k,$t=P,Se=F),k>ue&&(Ie=y,ue=k,Ht=P,Ae=F)),v<=(de+ue)/2?(D=It-Math.atan2(Se*h,$t),L=Te*h):(D=It-Math.atan2(Ae*h,Ht),L=Ie*h)}const gt=Math.atan2(T,w)*E;let Rt=t.arotation;D=(D-gt)*u.MathUtils.radDeg+p-Rt,D>180?D-=360:D<-180&&(D+=360),t.updateWorldTransformWith(r,l,Rt+D*a,f,t.ascaleY,0,0),Rt=s.arotation,L=((L+gt)*u.MathUtils.radDeg-s.ashearX)*E+x-Rt,L>180?L-=360:L<-180&&(L+=360),s.updateWorldTransformWith(w,T,Rt+L*a,s.ascaleX,s.ascaleY,s.ashearX,s.ashearY)}}class ie extends bt{constructor(t){super(t,0,!1),this.bones=new Array,this.bendDirection=1,this.compress=!1,this.stretch=!1,this.uniform=!1,this.mix=1,this.softness=0}}class ae extends bt{constructor(t){super(t,0,!1),this.bones=new Array}}var J=(e=>(e[e.Length=0]="Length",e[e.Fixed=1]="Fixed",e[e.Percent=2]="Percent",e))(J||{});const Pt=class{constructor(e,t){if(this.position=0,this.spacing=0,this.rotateMix=0,this.translateMix=0,this.spaces=new Array,this.positions=new Array,this.world=new Array,this.curves=new Array,this.lengths=new Array,this.segments=new Array,this.active=!1,e==null)throw new Error("data cannot be null.");if(t==null)throw new Error("skeleton cannot be null.");this.data=e,this.bones=new Array;for(let s=0,n=e.bones.length;s<n;s++)this.bones.push(t.findBone(e.bones[s].name));this.target=t.findSlot(e.target.name),this.position=e.position,this.spacing=e.spacing,this.rotateMix=e.rotateMix,this.translateMix=e.translateMix}isActive(){return this.active}apply(){this.update()}update(){const e=this.target.getAttachment();if(!(e instanceof kt))return;const t=this.rotateMix,s=this.translateMix,n=s>0,i=t>0;if(!n&&!i)return;const h=this.data,c=h.spacingMode,o=c==J.Length,a=h.rotateMode,r=a==u.RotateMode.Tangent,l=a==u.RotateMode.ChainScale,d=this.bones.length,f=r?d:d+1,m=this.bones,g=u.Utils.setArraySize(this.spaces,f);let M=null;const p=this.spacing;if(l||o){l&&(M=u.Utils.setArraySize(this.lengths,d));for(let S=0,A=f-1;S<A;){const R=m[S],y=R.data.length;if(y<Pt.epsilon)l&&(M[S]=0),g[++S]=0;else{const k=y*R.matrix.a,X=y*R.matrix.b,N=Math.sqrt(k*k+X*X);l&&(M[S]=N),g[++S]=(o?y+p:p)*N/y}}}else for(let S=1;S<f;S++)g[S]=p;const x=this.computeWorldPositions(e,f,r,h.positionMode==u.PositionMode.Percent,c==J.Percent);let E=x[0],w=x[1],T=h.offsetRotation,I=!1;if(T==0)I=a==u.RotateMode.Chain;else{I=!1;const S=this.target.bone.matrix;T*=S.a*S.d-S.b*S.c>0?u.MathUtils.degRad:-u.MathUtils.degRad}for(let S=0,A=3;S<d;S++,A+=3){const R=m[S],y=R.matrix;y.tx+=(E-y.tx)*s,y.ty+=(w-y.ty)*s;const k=x[A],X=x[A+1],N=k-E,$=X-w;if(l){const P=M[S];if(P!=0){const F=(Math.sqrt(N*N+$*$)/P-1)*t+1;y.a*=F,y.b*=F}}if(E=k,w=X,i){const P=y.a,F=y.c,rt=y.b,ot=y.d;let V=0,U=0,D=0;if(r&&(r?V=x[A-1]:g[S+1]==0?V=x[A+2]:V=Math.atan2($,N)),V-=Math.atan2(rt,P),I){U=Math.cos(V),D=Math.sin(V);const L=R.data.length;E+=(L*(U*P-D*rt)-N)*t,w+=(L*(D*P+U*rt)-$)*t}else V+=T;V>u.MathUtils.PI?V-=u.MathUtils.PI2:V<-u.MathUtils.PI&&(V+=u.MathUtils.PI2),V*=t,U=Math.cos(V),D=Math.sin(V),y.a=U*P-D*rt,y.c=U*F-D*ot,y.b=D*P+U*rt,y.d=D*F+U*ot}R.appliedValid=!1}}computeWorldPositions(e,t,s,n,i){const h=this.target;let c=this.position;const o=this.spaces,a=u.Utils.setArraySize(this.positions,t*3+2);let r=null;const l=e.closed;let d=e.worldVerticesLength,f=d/6,m=Pt.NONE;if(!e.constantSpeed){const V=e.lengths;f-=l?1:2;const U=V[f];if(n&&(c*=U),i)for(let D=0;D<t;D++)o[D]*=U;r=u.Utils.setArraySize(this.world,8);for(let D=0,L=0,H=0;D<t;D++,L+=3){const O=o[D];c+=O;let v=c;if(l)v%=U,v<0&&(v+=U),H=0;else if(v<0){m!=Pt.BEFORE&&(m=Pt.BEFORE,e.computeWorldVertices(h,2,4,r,0,2)),this.addBeforePosition(v,r,0,a,L);continue}else if(v>U){m!=Pt.AFTER&&(m=Pt.AFTER,e.computeWorldVertices(h,d-6,4,r,0,2)),this.addAfterPosition(v-U,r,0,a,L);continue}for(;;H++){const gt=V[H];if(!(v>gt)){if(H==0)v/=gt;else{const Rt=V[H-1];v=(v-Rt)/(gt-Rt)}break}}H!=m&&(m=H,l&&H==f?(e.computeWorldVertices(h,d-4,4,r,0,2),e.computeWorldVertices(h,0,4,r,4,2)):e.computeWorldVertices(h,H*6+2,8,r,0,2)),this.addCurvePosition(v,r[0],r[1],r[2],r[3],r[4],r[5],r[6],r[7],a,L,s||D>0&&O==0)}return a}l?(d+=2,r=u.Utils.setArraySize(this.world,d),e.computeWorldVertices(h,2,d-4,r,0,2),e.computeWorldVertices(h,0,2,r,d-4,2),r[d-2]=r[0],r[d-1]=r[1]):(f--,d-=4,r=u.Utils.setArraySize(this.world,d),e.computeWorldVertices(h,2,d,r,0,2));const g=u.Utils.setArraySize(this.curves,f);let M=0,p=r[0],x=r[1],E=0,w=0,T=0,I=0,S=0,A=0,R=0,y=0,k=0,X=0,N=0,$=0,P=0,F=0;for(let V=0,U=2;V<f;V++,U+=6)E=r[U],w=r[U+1],T=r[U+2],I=r[U+3],S=r[U+4],A=r[U+5],R=(p-E*2+T)*.1875,y=(x-w*2+I)*.1875,k=((E-T)*3-p+S)*.09375,X=((w-I)*3-x+A)*.09375,N=R*2+k,$=y*2+X,P=(E-p)*.75+R+k*.16666667,F=(w-x)*.75+y+X*.16666667,M+=Math.sqrt(P*P+F*F),P+=N,F+=$,N+=k,$+=X,M+=Math.sqrt(P*P+F*F),P+=N,F+=$,M+=Math.sqrt(P*P+F*F),P+=N+k,F+=$+X,M+=Math.sqrt(P*P+F*F),g[V]=M,p=S,x=A;if(n&&(c*=M),i)for(let V=0;V<t;V++)o[V]*=M;const rt=this.segments;let ot=0;for(let V=0,U=0,D=0,L=0;V<t;V++,U+=3){const H=o[V];c+=H;let O=c;if(l)O%=M,O<0&&(O+=M),D=0;else if(O<0){this.addBeforePosition(O,r,0,a,U);continue}else if(O>M){this.addAfterPosition(O-M,r,d-4,a,U);continue}for(;;D++){const v=g[D];if(!(O>v)){if(D==0)O/=v;else{const gt=g[D-1];O=(O-gt)/(v-gt)}break}}if(D!=m){m=D;let v=D*6;for(p=r[v],x=r[v+1],E=r[v+2],w=r[v+3],T=r[v+4],I=r[v+5],S=r[v+6],A=r[v+7],R=(p-E*2+T)*.03,y=(x-w*2+I)*.03,k=((E-T)*3-p+S)*.006,X=((w-I)*3-x+A)*.006,N=R*2+k,$=y*2+X,P=(E-p)*.3+R+k*.16666667,F=(w-x)*.3+y+X*.16666667,ot=Math.sqrt(P*P+F*F),rt[0]=ot,v=1;v<8;v++)P+=N,F+=$,N+=k,$+=X,ot+=Math.sqrt(P*P+F*F),rt[v]=ot;P+=N,F+=$,ot+=Math.sqrt(P*P+F*F),rt[8]=ot,P+=N+k,F+=$+X,ot+=Math.sqrt(P*P+F*F),rt[9]=ot,L=0}for(O*=ot;;L++){const v=rt[L];if(!(O>v)){if(L==0)O/=v;else{const gt=rt[L-1];O=L+(O-gt)/(v-gt)}break}}this.addCurvePosition(O*.1,p,x,E,w,T,I,S,A,a,U,s||V>0&&H==0)}return a}addBeforePosition(e,t,s,n,i){const h=t[s],c=t[s+1],o=t[s+2]-h,a=t[s+3]-c,r=Math.atan2(a,o);n[i]=h+e*Math.cos(r),n[i+1]=c+e*Math.sin(r),n[i+2]=r}addAfterPosition(e,t,s,n,i){const h=t[s+2],c=t[s+3],o=h-t[s],a=c-t[s+1],r=Math.atan2(a,o);n[i]=h+e*Math.cos(r),n[i+1]=c+e*Math.sin(r),n[i+2]=r}addCurvePosition(e,t,s,n,i,h,c,o,a,r,l,d){(e==0||isNaN(e))&&(e=1e-4);const f=e*e,m=f*e,g=1-e,M=g*g,p=M*g,x=g*e,E=x*3,w=g*E,T=E*e,I=t*p+n*w+h*T+o*m,S=s*p+i*w+c*T+a*m;r[l]=I,r[l+1]=S,d&&(r[l+2]=Math.atan2(S-(s*M+i*x*2+c*f),I-(t*M+n*x*2+h*f)))}};let Nt=Pt;Nt.NONE=-1,Nt.BEFORE=-2,Nt.AFTER=-3,Nt.epsilon=1e-5;class Ee{constructor(t,s){if(this.rotateMix=0,this.translateMix=0,this.scaleMix=0,this.shearMix=0,this.temp=new u.Vector2,this.active=!1,t==null)throw new Error("data cannot be null.");if(s==null)throw new Error("skeleton cannot be null.");this.data=t,this.rotateMix=t.rotateMix,this.translateMix=t.translateMix,this.scaleMix=t.scaleMix,this.shearMix=t.shearMix,this.bones=new Array;for(let n=0;n<t.bones.length;n++)this.bones.push(s.findBone(t.bones[n].name));this.target=s.findBone(t.target.name)}isActive(){return this.active}apply(){this.update()}update(){this.data.local?this.data.relative?this.applyRelativeLocal():this.applyAbsoluteLocal():this.data.relative?this.applyRelativeWorld():this.applyAbsoluteWorld()}applyAbsoluteWorld(){const t=this.rotateMix,s=this.translateMix,n=this.scaleMix,i=this.shearMix,h=this.target,c=h.matrix,o=c.a,a=c.c,r=c.b,l=c.d,d=o*l-a*r>0?u.MathUtils.degRad:-u.MathUtils.degRad,f=this.data.offsetRotation*d,m=this.data.offsetShearY*d,g=this.bones;for(let M=0,p=g.length;M<p;M++){const x=g[M];let E=!1;const w=x.matrix;if(t!=0){const T=w.a,I=w.c,S=w.b,A=w.d;let R=Math.atan2(r,o)-Math.atan2(S,T)+f;R>u.MathUtils.PI?R-=u.MathUtils.PI2:R<-u.MathUtils.PI&&(R+=u.MathUtils.PI2),R*=t;const y=Math.cos(R),k=Math.sin(R);w.a=y*T-k*S,w.c=y*I-k*A,w.b=k*T+y*S,w.d=k*I+y*A,E=!0}if(s!=0){const T=this.temp;h.localToWorld(T.set(this.data.offsetX,this.data.offsetY)),w.tx+=(T.x-w.tx)*s,w.ty+=(T.y-w.ty)*s,E=!0}if(n>0){let T=Math.sqrt(w.a*w.a+w.b*w.b),I=Math.sqrt(o*o+r*r);T>1e-5&&(T=(T+(I-T+this.data.offsetScaleX)*n)/T),w.a*=T,w.b*=T,T=Math.sqrt(w.c*w.c+w.d*w.d),I=Math.sqrt(a*a+l*l),T>1e-5&&(T=(T+(I-T+this.data.offsetScaleY)*n)/T),w.c*=T,w.d*=T,E=!0}if(i>0){const T=w.c,I=w.d,S=Math.atan2(I,T);let A=Math.atan2(l,a)-Math.atan2(r,o)-(S-Math.atan2(w.b,w.a));A>u.MathUtils.PI?A-=u.MathUtils.PI2:A<-u.MathUtils.PI&&(A+=u.MathUtils.PI2),A=S+(A+m)*i;const R=Math.sqrt(T*T+I*I);w.c=Math.cos(A)*R,w.d=Math.sin(A)*R,E=!0}E&&(x.appliedValid=!1)}}applyRelativeWorld(){const t=this.rotateMix,s=this.translateMix,n=this.scaleMix,i=this.shearMix,h=this.target,c=h.matrix,o=c.a,a=c.c,r=c.b,l=c.d,d=o*l-a*r>0?u.MathUtils.degRad:-u.MathUtils.degRad,f=this.data.offsetRotation*d,m=this.data.offsetShearY*d,g=this.bones;for(let M=0,p=g.length;M<p;M++){const x=g[M];let E=!1;const w=x.matrix;if(t!=0){const T=w.a,I=w.c,S=w.b,A=w.d;let R=Math.atan2(r,o)+f;R>u.MathUtils.PI?R-=u.MathUtils.PI2:R<-u.MathUtils.PI&&(R+=u.MathUtils.PI2),R*=t;const y=Math.cos(R),k=Math.sin(R);w.a=y*T-k*S,w.c=y*I-k*A,w.b=k*T+y*S,w.d=k*I+y*A,E=!0}if(s!=0){const T=this.temp;h.localToWorld(T.set(this.data.offsetX,this.data.offsetY)),w.tx+=T.x*s,w.ty+=T.y*s,E=!0}if(n>0){let T=(Math.sqrt(o*o+r*r)-1+this.data.offsetScaleX)*n+1;w.a*=T,w.b*=T,T=(Math.sqrt(a*a+l*l)-1+this.data.offsetScaleY)*n+1,w.c*=T,w.d*=T,E=!0}if(i>0){let T=Math.atan2(l,a)-Math.atan2(r,o);T>u.MathUtils.PI?T-=u.MathUtils.PI2:T<-u.MathUtils.PI&&(T+=u.MathUtils.PI2);const I=w.c,S=w.d;T=Math.atan2(S,I)+(T-u.MathUtils.PI/2+m)*i;const A=Math.sqrt(I*I+S*S);w.c=Math.cos(T)*A,w.d=Math.sin(T)*A,E=!0}E&&(x.appliedValid=!1)}}applyAbsoluteLocal(){const t=this.rotateMix,s=this.translateMix,n=this.scaleMix,i=this.shearMix,h=this.target;h.appliedValid||h.updateAppliedTransform();const c=this.bones;for(let o=0,a=c.length;o<a;o++){const r=c[o];r.appliedValid||r.updateAppliedTransform();let l=r.arotation;if(t!=0){let p=h.arotation-l+this.data.offsetRotation;p-=(16384-(16384.499999999996-p/360|0))*360,l+=p*t}let d=r.ax,f=r.ay;s!=0&&(d+=(h.ax-d+this.data.offsetX)*s,f+=(h.ay-f+this.data.offsetY)*s);let m=r.ascaleX,g=r.ascaleY;n>0&&(m>1e-5&&(m=(m+(h.ascaleX-m+this.data.offsetScaleX)*n)/m),g>1e-5&&(g=(g+(h.ascaleY-g+this.data.offsetScaleY)*n)/g));const M=r.ashearY;if(i>0){let p=h.ashearY-M+this.data.offsetShearY;p-=(16384-(16384.499999999996-p/360|0))*360,r.shearY+=p*i}r.updateWorldTransformWith(d,f,l,m,g,r.ashearX,M)}}applyRelativeLocal(){const t=this.rotateMix,s=this.translateMix,n=this.scaleMix,i=this.shearMix,h=this.target;h.appliedValid||h.updateAppliedTransform();const c=this.bones;for(let o=0,a=c.length;o<a;o++){const r=c[o];r.appliedValid||r.updateAppliedTransform();let l=r.arotation;t!=0&&(l+=(h.arotation+this.data.offsetRotation)*t);let d=r.ax,f=r.ay;s!=0&&(d+=(h.ax+this.data.offsetX)*s,f+=(h.ay+this.data.offsetY)*s);let m=r.ascaleX,g=r.ascaleY;n>0&&(m>1e-5&&(m*=(h.ascaleX-1+this.data.offsetScaleX)*n+1),g>1e-5&&(g*=(h.ascaleY-1+this.data.offsetScaleY)*n+1));let M=r.ashearY;i>0&&(M+=(h.ashearY+this.data.offsetShearY)*i),r.updateWorldTransformWith(d,f,l,m,g,r.ashearX,M)}}}const Dt=class{constructor(e){if(this._updateCache=new Array,this.updateCacheReset=new Array,this.time=0,this.scaleX=1,this.scaleY=1,this.x=0,this.y=0,e==null)throw new Error("data cannot be null.");this.data=e,this.bones=new Array;for(let t=0;t<e.bones.length;t++){const s=e.bones[t];let n;if(s.parent==null)n=new te(s,this,null);else{const i=this.bones[s.parent.index];n=new te(s,this,i),i.children.push(n)}this.bones.push(n)}this.slots=new Array,this.drawOrder=new Array;for(let t=0;t<e.slots.length;t++){const s=e.slots[t],n=this.bones[s.boneData.index],i=new jt(s,n);this.slots.push(i),this.drawOrder.push(i)}this.ikConstraints=new Array;for(let t=0;t<e.ikConstraints.length;t++){const s=e.ikConstraints[t];this.ikConstraints.push(new xe(s,this))}this.transformConstraints=new Array;for(let t=0;t<e.transformConstraints.length;t++){const s=e.transformConstraints[t];this.transformConstraints.push(new Ee(s,this))}this.pathConstraints=new Array;for(let t=0;t<e.pathConstraints.length;t++){const s=e.pathConstraints[t];this.pathConstraints.push(new Nt(s,this))}this.color=new u.Color(1,1,1,1),this.updateCache()}updateCache(){const e=this._updateCache;e.length=0,this.updateCacheReset.length=0;const t=this.bones;for(let r=0,l=t.length;r<l;r++){const d=t[r];d.sorted=d.data.skinRequired,d.active=!d.sorted}if(this.skin!=null){const r=this.skin.bones;for(let l=0,d=this.skin.bones.length;l<d;l++){let f=this.bones[r[l].index];do f.sorted=!1,f.active=!0,f=f.parent;while(f!=null)}}const s=this.ikConstraints,n=this.transformConstraints,i=this.pathConstraints,h=s.length,c=n.length,o=i.length,a=h+c+o;t:for(let r=0;r<a;r++){for(let l=0;l<h;l++){const d=s[l];if(d.data.order==r){this.sortIkConstraint(d);continue t}}for(let l=0;l<c;l++){const d=n[l];if(d.data.order==r){this.sortTransformConstraint(d);continue t}}for(let l=0;l<o;l++){const d=i[l];if(d.data.order==r){this.sortPathConstraint(d);continue t}}}for(let r=0,l=t.length;r<l;r++)this.sortBone(t[r])}sortIkConstraint(e){if(e.active=e.target.isActive()&&(!e.data.skinRequired||this.skin!=null&&u.Utils.contains(this.skin.constraints,e.data,!0)),!e.active)return;const t=e.target;this.sortBone(t);const s=e.bones,n=s[0];if(this.sortBone(n),s.length>1){const i=s[s.length-1];this._updateCache.indexOf(i)>-1||this.updateCacheReset.push(i)}this._updateCache.push(e),this.sortReset(n.children),s[s.length-1].sorted=!0}sortPathConstraint(e){if(e.active=e.target.bone.isActive()&&(!e.data.skinRequired||this.skin!=null&&u.Utils.contains(this.skin.constraints,e.data,!0)),!e.active)return;const t=e.target,s=t.data.index,n=t.bone;this.skin!=null&&this.sortPathConstraintAttachment(this.skin,s,n),this.data.defaultSkin!=null&&this.data.defaultSkin!=this.skin&&this.sortPathConstraintAttachment(this.data.defaultSkin,s,n);for(let o=0,a=this.data.skins.length;o<a;o++)this.sortPathConstraintAttachment(this.data.skins[o],s,n);const i=t.getAttachment();i instanceof kt&&this.sortPathConstraintAttachmentWith(i,n);const h=e.bones,c=h.length;for(let o=0;o<c;o++)this.sortBone(h[o]);this._updateCache.push(e);for(let o=0;o<c;o++)this.sortReset(h[o].children);for(let o=0;o<c;o++)h[o].sorted=!0}sortTransformConstraint(e){if(e.active=e.target.isActive()&&(!e.data.skinRequired||this.skin!=null&&u.Utils.contains(this.skin.constraints,e.data,!0)),!e.active)return;this.sortBone(e.target);const t=e.bones,s=t.length;if(e.data.local)for(let n=0;n<s;n++){const i=t[n];this.sortBone(i.parent),this._updateCache.indexOf(i)>-1||this.updateCacheReset.push(i)}else for(let n=0;n<s;n++)this.sortBone(t[n]);this._updateCache.push(e);for(let n=0;n<s;n++)this.sortReset(t[n].children);for(let n=0;n<s;n++)t[n].sorted=!0}sortPathConstraintAttachment(e,t,s){const n=e.attachments[t];if(n)for(const i in n)this.sortPathConstraintAttachmentWith(n[i],s)}sortPathConstraintAttachmentWith(e,t){if(!(e instanceof kt))return;const s=e.bones;if(s==null)this.sortBone(t);else{const n=this.bones;let i=0;for(;i<s.length;){const h=s[i++];for(let c=i+h;i<c;i++){const o=s[i];this.sortBone(n[o])}}}}sortBone(e){if(e.sorted)return;const t=e.parent;t!=null&&this.sortBone(t),e.sorted=!0,this._updateCache.push(e)}sortReset(e){for(let t=0,s=e.length;t<s;t++){const n=e[t];n.active&&(n.sorted&&this.sortReset(n.children),n.sorted=!1)}}updateWorldTransform(){const e=this.updateCacheReset;for(let s=0,n=e.length;s<n;s++){const i=e[s];i.ax=i.x,i.ay=i.y,i.arotation=i.rotation,i.ascaleX=i.scaleX,i.ascaleY=i.scaleY,i.ashearX=i.shearX,i.ashearY=i.shearY,i.appliedValid=!0}const t=this._updateCache;for(let s=0,n=t.length;s<n;s++)t[s].update()}setToSetupPose(){this.setBonesToSetupPose(),this.setSlotsToSetupPose()}setBonesToSetupPose(){const e=this.bones;for(let i=0,h=e.length;i<h;i++)e[i].setToSetupPose();const t=this.ikConstraints;for(let i=0,h=t.length;i<h;i++){const c=t[i];c.mix=c.data.mix,c.softness=c.data.softness,c.bendDirection=c.data.bendDirection,c.compress=c.data.compress,c.stretch=c.data.stretch}const s=this.transformConstraints;for(let i=0,h=s.length;i<h;i++){const c=s[i],o=c.data;c.rotateMix=o.rotateMix,c.translateMix=o.translateMix,c.scaleMix=o.scaleMix,c.shearMix=o.shearMix}const n=this.pathConstraints;for(let i=0,h=n.length;i<h;i++){const c=n[i],o=c.data;c.position=o.position,c.spacing=o.spacing,c.rotateMix=o.rotateMix,c.translateMix=o.translateMix}}setSlotsToSetupPose(){const e=this.slots;u.Utils.arrayCopy(e,0,this.drawOrder,0,e.length);for(let t=0,s=e.length;t<s;t++)e[t].setToSetupPose()}getRootBone(){return this.bones.length==0?null:this.bones[0]}findBone(e){if(e==null)throw new Error("boneName cannot be null.");const t=this.bones;for(let s=0,n=t.length;s<n;s++){const i=t[s];if(i.data.name==e)return i}return null}findBoneIndex(e){if(e==null)throw new Error("boneName cannot be null.");const t=this.bones;for(let s=0,n=t.length;s<n;s++)if(t[s].data.name==e)return s;return-1}findSlot(e){if(e==null)throw new Error("slotName cannot be null.");const t=this.slots;for(let s=0,n=t.length;s<n;s++){const i=t[s];if(i.data.name==e)return i}return null}findSlotIndex(e){if(e==null)throw new Error("slotName cannot be null.");const t=this.slots;for(let s=0,n=t.length;s<n;s++)if(t[s].data.name==e)return s;return-1}setSkinByName(e){const t=this.data.findSkin(e);if(t==null)throw new Error(`Skin not found: ${e}`);this.setSkin(t)}setSkin(e){if(e!=this.skin){if(e!=null)if(this.skin!=null)e.attachAll(this,this.skin);else{const t=this.slots;for(let s=0,n=t.length;s<n;s++){const i=t[s],h=i.data.attachmentName;if(h!=null){const c=e.getAttachment(s,h);c!=null&&i.setAttachment(c)}}}this.skin=e,this.updateCache()}}getAttachmentByName(e,t){return this.getAttachment(this.data.findSlotIndex(e),t)}getAttachment(e,t){if(t==null)throw new Error("attachmentName cannot be null.");if(this.skin!=null){const s=this.skin.getAttachment(e,t);if(s!=null)return s}return this.data.defaultSkin!=null?this.data.defaultSkin.getAttachment(e,t):null}setAttachment(e,t){if(e==null)throw new Error("slotName cannot be null.");const s=this.slots;for(let n=0,i=s.length;n<i;n++){const h=s[n];if(h.data.name==e){let c=null;if(t!=null&&(c=this.getAttachment(n,t),c==null))throw new Error(`Attachment not found: ${t}, for slot: ${e}`);h.setAttachment(c);return}}throw new Error(`Slot not found: ${e}`)}findIkConstraint(e){if(e==null)throw new Error("constraintName cannot be null.");const t=this.ikConstraints;for(let s=0,n=t.length;s<n;s++){const i=t[s];if(i.data.name==e)return i}return null}findTransformConstraint(e){if(e==null)throw new Error("constraintName cannot be null.");const t=this.transformConstraints;for(let s=0,n=t.length;s<n;s++){const i=t[s];if(i.data.name==e)return i}return null}findPathConstraint(e){if(e==null)throw new Error("constraintName cannot be null.");const t=this.pathConstraints;for(let s=0,n=t.length;s<n;s++){const i=t[s];if(i.data.name==e)return i}return null}getBounds(e,t,s=new Array(2)){if(e==null)throw new Error("offset cannot be null.");if(t==null)throw new Error("size cannot be null.");const n=this.drawOrder;let i=Number.POSITIVE_INFINITY,h=Number.POSITIVE_INFINITY,c=Number.NEGATIVE_INFINITY,o=Number.NEGATIVE_INFINITY;for(let a=0,r=n.length;a<r;a++){const l=n[a];if(!l.bone.active)continue;let d=0,f=null;const m=l.getAttachment();if(m instanceof B)d=8,f=u.Utils.setArraySize(s,d,0),m.computeWorldVertices(l.bone,f,0,2);else if(m instanceof Ct){const g=m;d=g.worldVerticesLength,f=u.Utils.setArraySize(s,d,0),g.computeWorldVertices(l,0,d,f,0,2)}if(f!=null)for(let g=0,M=f.length;g<M;g+=2){const p=f[g],x=f[g+1];i=Math.min(i,p),h=Math.min(h,x),c=Math.max(c,p),o=Math.max(o,x)}}e.set(i,h),t.set(c-i,o-h)}update(e){this.time+=e}get flipX(){return this.scaleX==-1}set flipX(e){Dt.deprecatedWarning1||(Dt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleX=e?1:-1}get flipY(){return this.scaleY==-1}set flipY(e){Dt.deprecatedWarning1||(Dt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleY=e?1:-1}};let re=Dt;re.deprecatedWarning1=!1;class oe{constructor(){this.bones=new Array,this.slots=new Array,this.skins=new Array,this.events=new Array,this.animations=new Array,this.ikConstraints=new Array,this.transformConstraints=new Array,this.pathConstraints=new Array,this.fps=0}findBone(t){if(t==null)throw new Error("boneName cannot be null.");const s=this.bones;for(let n=0,i=s.length;n<i;n++){const h=s[n];if(h.name==t)return h}return null}findBoneIndex(t){if(t==null)throw new Error("boneName cannot be null.");const s=this.bones;for(let n=0,i=s.length;n<i;n++)if(s[n].name==t)return n;return-1}findSlot(t){if(t==null)throw new Error("slotName cannot be null.");const s=this.slots;for(let n=0,i=s.length;n<i;n++){const h=s[n];if(h.name==t)return h}return null}findSlotIndex(t){if(t==null)throw new Error("slotName cannot be null.");const s=this.slots;for(let n=0,i=s.length;n<i;n++)if(s[n].name==t)return n;return-1}findSkin(t){if(t==null)throw new Error("skinName cannot be null.");const s=this.skins;for(let n=0,i=s.length;n<i;n++){const h=s[n];if(h.name==t)return h}return null}findEvent(t){if(t==null)throw new Error("eventDataName cannot be null.");const s=this.events;for(let n=0,i=s.length;n<i;n++){const h=s[n];if(h.name==t)return h}return null}findAnimation(t){if(t==null)throw new Error("animationName cannot be null.");const s=this.animations;for(let n=0,i=s.length;n<i;n++){const h=s[n];if(h.name==t)return h}return null}findIkConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const s=this.ikConstraints;for(let n=0,i=s.length;n<i;n++){const h=s[n];if(h.name==t)return h}return null}findTransformConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const s=this.transformConstraints;for(let n=0,i=s.length;n<i;n++){const h=s[n];if(h.name==t)return h}return null}findPathConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const s=this.pathConstraints;for(let n=0,i=s.length;n<i;n++){const h=s[n];if(h.name==t)return h}return null}findPathConstraintIndex(t){if(t==null)throw new Error("pathConstraintName cannot be null.");const s=this.pathConstraints;for(let n=0,i=s.length;n<i;n++)if(s[n].name==t)return n;return-1}}class le{constructor(t,s,n){if(this.color=new u.Color(1,1,1,1),t<0)throw new Error("index must be >= 0.");if(s==null)throw new Error("name cannot be null.");if(n==null)throw new Error("boneData cannot be null.");this.index=t,this.name=s,this.boneData=n}}class he extends bt{constructor(t){super(t,0,!1),this.bones=new Array,this.rotateMix=0,this.translateMix=0,this.scaleMix=0,this.shearMix=0,this.offsetRotation=0,this.offsetX=0,this.offsetY=0,this.offsetScaleX=0,this.offsetScaleY=0,this.offsetShearY=0,this.relative=!1,this.local=!1}}class ce{constructor(t,s,n){this.slotIndex=t,this.name=s,this.attachment=n}}class Wt{constructor(t){if(this.attachments=new Array,this.bones=Array(),this.constraints=new Array,t==null)throw new Error("name cannot be null.");this.name=t}setAttachment(t,s,n){if(n==null)throw new Error("attachment cannot be null.");const i=this.attachments;t>=i.length&&(i.length=t+1),i[t]||(i[t]={}),i[t][s]=n}addSkin(t){for(let n=0;n<t.bones.length;n++){const i=t.bones[n];let h=!1;for(let c=0;c<this.bones.length;c++)if(this.bones[c]==i){h=!0;break}h||this.bones.push(i)}for(let n=0;n<t.constraints.length;n++){const i=t.constraints[n];let h=!1;for(let c=0;c<this.constraints.length;c++)if(this.constraints[c]==i){h=!0;break}h||this.constraints.push(i)}const s=t.getAttachments();for(let n=0;n<s.length;n++){const i=s[n];this.setAttachment(i.slotIndex,i.name,i.attachment)}}copySkin(t){for(let n=0;n<t.bones.length;n++){const i=t.bones[n];let h=!1;for(let c=0;c<this.bones.length;c++)if(this.bones[c]==i){h=!0;break}h||this.bones.push(i)}for(let n=0;n<t.constraints.length;n++){const i=t.constraints[n];let h=!1;for(let c=0;c<this.constraints.length;c++)if(this.constraints[c]==i){h=!0;break}h||this.constraints.push(i)}const s=t.getAttachments();for(let n=0;n<s.length;n++){const i=s[n];i.attachment!=null&&(i.attachment instanceof Ct?(i.attachment=i.attachment.newLinkedMesh(),this.setAttachment(i.slotIndex,i.name,i.attachment)):(i.attachment=i.attachment.copy(),this.setAttachment(i.slotIndex,i.name,i.attachment)))}}getAttachment(t,s){const n=this.attachments[t];return n?n[s]:null}removeAttachment(t,s){const n=this.attachments[t];n&&(n[s]=null)}getAttachments(){const t=new Array;for(let s=0;s<this.attachments.length;s++){const n=this.attachments[s];if(n)for(const i in n){const h=n[i];h&&t.push(new ce(s,i,h))}}return t}getAttachmentsForSlot(t,s){const n=this.attachments[t];if(n)for(const i in n){const h=n[i];h&&s.push(new ce(t,i,h))}}clear(){this.attachments.length=0,this.bones.length=0,this.constraints.length=0}attachAll(t,s){let n=0;for(let i=0;i<t.slots.length;i++){const h=t.slots[i],c=h.getAttachment();if(c&&n<s.attachments.length){const o=s.attachments[n];for(const a in o){const r=o[a];if(c==r){const l=this.getAttachment(n,a);l!=null&&h.setAttachment(l);break}}}n++}}}const Z=class{constructor(e){this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=e}readSkeletonData(e){const t=this.scale,s=new oe;s.name="";const n=new u.BinaryInput(e);s.hash=n.readString(),s.version=n.readString(),s.version==="3.8.75"&&console.error("Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine."),s.width=n.readFloat(),s.height=n.readFloat();const i=n.readBoolean();i&&(s.imagesPath=n.readString());let h=0;h=n.readInt(!0);for(let o=0;o<h;o++){const a=n.readString(),r=o==0?null:s.bones[n.readInt(!0)],l=new ee(o,a,r);l.rotation=n.readFloat(),l.x=n.readFloat()*t,l.y=n.readFloat()*t,l.scaleX=n.readFloat(),l.scaleY=n.readFloat(),l.shearX=n.readFloat(),l.shearY=n.readFloat(),l.length=n.readFloat()*t,l.inheritRotation=n.readBoolean(),l.inheritScale=n.readBoolean(),i&&u.Color.rgba8888ToColor(l.color,n.readInt32()),s.bones.push(l)}h=n.readInt(!0);for(let o=0;o<h;o++){const a=n.readString(),r=s.bones[n.readInt(!0)],l=new le(o,a,r);u.Color.rgba8888ToColor(l.color,n.readInt32()),l.attachmentName=n.readString(),l.blendMode=Z.BlendModeValues[n.readInt(!0)],s.slots.push(l)}h=n.readInt(!0);for(let o=0,a;o<h;o++){const r=n.readString(),l=new ie(r);a=n.readInt(!0);for(let d=0;d<a;d++)l.bones.push(s.bones[n.readInt(!0)]);l.target=s.bones[n.readInt(!0)],l.mix=n.readFloat(),l.bendDirection=n.readByte(),s.ikConstraints.push(l)}h=n.readInt(!0);for(let o=0,a;o<h;o++){const r=n.readString(),l=new he(r);a=n.readInt(!0);for(let d=0;d<a;d++)l.bones.push(s.bones[n.readInt(!0)]);l.target=s.bones[n.readInt(!0)],l.offsetRotation=n.readFloat(),l.offsetX=n.readFloat()*t,l.offsetY=n.readFloat()*t,l.offsetScaleX=n.readFloat(),l.offsetScaleY=n.readFloat(),l.offsetShearY=n.readFloat(),l.rotateMix=n.readFloat(),l.translateMix=n.readFloat(),l.scaleMix=n.readFloat(),l.shearMix=n.readFloat(),s.transformConstraints.push(l)}h=n.readInt(!0);for(let o=0,a;o<h;o++){const r=n.readString(),l=new ae(r);a=n.readInt(!0);for(let d=0;d<a;d++)l.bones.push(s.bones[n.readInt(!0)]);l.target=s.slots[n.readInt(!0)],l.positionMode=Z.PositionModeValues[n.readInt(!0)],l.spacingMode=Z.SpacingModeValues[n.readInt(!0)],l.rotateMode=Z.RotateModeValues[n.readInt(!0)],l.offsetRotation=n.readFloat(),l.position=n.readFloat(),l.positionMode==u.PositionMode.Fixed&&(l.position*=t),l.spacing=n.readFloat(),(l.spacingMode==J.Length||l.spacingMode==J.Fixed)&&(l.spacing*=t),l.rotateMix=n.readFloat(),l.translateMix=n.readFloat(),s.pathConstraints.push(l)}const c=this.readSkin(n,s,!0,i);c!=null&&(s.defaultSkin=c,s.skins.push(c));{let o=s.skins.length;for(u.Utils.setArraySize(s.skins,h=o+n.readInt(!0));o<h;o++)s.skins[o]=this.readSkin(n,s,!1,i)}h=this.linkedMeshes.length;for(let o=0;o<h;o++){const a=this.linkedMeshes[o],r=a.skin==null?s.defaultSkin:s.findSkin(a.skin);if(r==null)throw new Error(`Skin not found: ${a.skin}`);const l=r.getAttachment(a.slotIndex,a.parent);if(l==null)throw new Error(`Parent mesh not found: ${a.parent}`);a.mesh.deformAttachment=a.inheritDeform?l:a.mesh,a.mesh.setParentMesh(l)}this.linkedMeshes.length=0,h=n.readInt(!0);for(let o=0;o<h;o++){const a=new se(n.readStringRef());a.intValue=n.readInt(!1),a.floatValue=n.readFloat(),a.stringValue=n.readString(),a.audioPath=n.readString(),a.audioPath!=null&&(a.volume=n.readFloat(),a.balance=n.readFloat()),s.events.push(a)}h=n.readInt(!0);for(let o=0;o<h;o++)s.animations.push(this.readAnimation(n,n.readString(),s));return s}readSkin(e,t,s,n){let i=null,h=0;if(s){if(h=e.readInt(!0),h==0)return null;i=new Wt("default")}else{i=new Wt(e.readString()),i.bones.length=e.readInt(!0);for(let c=0,o=i.bones.length;c<o;c++)i.bones[c]=t.bones[e.readInt(!0)];for(let c=0,o=e.readInt(!0);c<o;c++)i.constraints.push(t.ikConstraints[e.readInt(!0)]);for(let c=0,o=e.readInt(!0);c<o;c++)i.constraints.push(t.transformConstraints[e.readInt(!0)]);for(let c=0,o=e.readInt(!0);c<o;c++)i.constraints.push(t.pathConstraints[e.readInt(!0)]);h=e.readInt(!0)}for(let c=0;c<h;c++){const o=e.readInt(!0);for(let a=0,r=e.readInt(!0);a<r;a++){const l=e.readString(),d=this.readAttachment(e,t,i,o,l,n);d!=null&&i.setAttachment(o,l,d)}}return i}readAttachment(e,t,s,n,i,h){const c=this.scale;let o=e.readStringRef();o==null&&(o=i);const a=e.readByte();switch(Z.AttachmentTypeValues[a]){case u.AttachmentType.Region:{let r=e.readString();const l=e.readFloat(),d=e.readFloat(),f=e.readFloat(),m=e.readFloat(),g=e.readFloat(),M=e.readFloat(),p=e.readFloat(),x=e.readInt32();r==null&&(r=o);const E=this.attachmentLoader.newRegionAttachment(s,o,r);return E==null?null:(E.path=r,E.x=d*c,E.y=f*c,E.scaleX=m,E.scaleY=g,E.rotation=l,E.width=M*c,E.height=p*c,u.Color.rgba8888ToColor(E.color,x),E)}case u.AttachmentType.BoundingBox:{const r=e.readInt(!0),l=this.readVertices(e,r),d=h?e.readInt32():0,f=this.attachmentLoader.newBoundingBoxAttachment(s,o);return f==null?null:(f.worldVerticesLength=r<<1,f.vertices=l.vertices,f.bones=l.bones,f.cVertices=l.cVertices,h&&u.Color.rgba8888ToColor(f.color,d),f)}case u.AttachmentType.Mesh:{let r=e.readStringRef();const l=e.readInt32(),d=e.readInt(!0),f=this.readFloatArray(e,d<<1,1),m=this.readShortArray(e),g=this.readVertices(e,d),M=e.readInt(!0);let p=null,x=0,E=0;h&&(p=this.readShortArray(e),x=e.readFloat(),E=e.readFloat()),r==null&&(r=o);const w=this.attachmentLoader.newMeshAttachment(s,o,r);return w==null?null:(w.path=r,u.Color.rgba8888ToColor(w.color,l),w.bones=g.bones,w.vertices=g.vertices,w.worldVerticesLength=d<<1,w.triangles=m,w.regionUVs=new Float32Array(f),w.cVertices=g.cVertices,w.hullLength=M<<1,h&&(w.edges=p,w.width=x*c,w.height=E*c),w)}case u.AttachmentType.LinkedMesh:{let r=e.readStringRef();const l=e.readInt32(),d=e.readStringRef(),f=e.readStringRef(),m=e.readBoolean();let g=0,M=0;h&&(g=e.readFloat(),M=e.readFloat()),r==null&&(r=o);const p=this.attachmentLoader.newMeshAttachment(s,o,r);return p==null?null:(p.path=r,u.Color.rgba8888ToColor(p.color,l),h&&(p.width=g*c,p.height=M*c),this.linkedMeshes.push(new Pe(p,d,n,f,m)),p)}case u.AttachmentType.Path:{const r=e.readBoolean(),l=e.readBoolean(),d=e.readInt(!0),f=this.readVertices(e,d),m=u.Utils.newArray(d/3,0);for(let p=0,x=m.length;p<x;p++)m[p]=e.readFloat()*c;const g=h?e.readInt32():0,M=this.attachmentLoader.newPathAttachment(s,o);return M==null?null:(M.closed=r,M.constantSpeed=l,M.worldVerticesLength=d<<1,M.vertices=f.vertices,M.bones=f.bones,M.lengths=m,M.cVertices=f.cVertices,h&&u.Color.rgba8888ToColor(M.color,g),M)}case u.AttachmentType.Point:{const r=e.readFloat(),l=e.readFloat(),d=e.readFloat(),f=h?e.readInt32():0,m=this.attachmentLoader.newPointAttachment(s,o);return m==null?null:(m.x=l*c,m.y=d*c,m.rotation=r,h&&u.Color.rgba8888ToColor(m.color,f),m)}case u.AttachmentType.Clipping:{const r=e.readInt(!0),l=e.readInt(!0),d=this.readVertices(e,l),f=h?e.readInt32():0,m=this.attachmentLoader.newClippingAttachment(s,o);return m==null?null:(m.endSlot=t.slots[r],m.worldVerticesLength=l<<1,m.vertices=d.vertices,m.bones=d.bones,m.cVertices=d.cVertices,h&&u.Color.rgba8888ToColor(m.color,f),m)}}return null}readVertices(e,t){const s=t<<1,n=new Fe,i=this.scale;if(!e.readBoolean())return n.vertices=this.readFloatArray(e,s,i),n;const h=new Array,c=new Array,o=new Array;for(let a=0;a<t;a++){const r=e.readInt(!0);o.push(r),h.push(r);for(let l=0;l<r;l++){const d=e.readInt(!0);o.push(d),h.push(d);const f=e.readFloat()*i,m=e.readFloat()*i,g=e.readFloat();c.push(f),c.push(m),c.push(g),h.push(f),h.push(m),h.push(g)}}return n.vertices=u.Utils.toFloatArray(c),n.bones=o,n.cVertices=h,n}readFloatArray(e,t,s){const n=new Array(t);if(s==1)for(let i=0;i<t;i++)n[i]=e.readFloat();else for(let i=0;i<t;i++)n[i]=e.readFloat()*s;return n}readShortArray(e){const t=e.readInt(!0),s=new Array(t);for(let n=0;n<t;n++)s[n]=e.readShort();return s}readAnimation(e,t,s){const n=new Array,i=this.scale;let h=0;const c=new u.Color;for(let r=0,l=e.readInt(!0);r<l;r++){const d=e.readInt(!0);for(let f=0,m=e.readInt(!0);f<m;f++){const g=e.readByte(),M=e.readInt(!0);switch(g){case Z.SLOT_ATTACHMENT:{const p=new Vt(M);p.slotIndex=d;for(let x=0;x<M;x++){const E=e.readFloat(),w=e.readString();p.setFrame(x,E,w)}n.push(p),h=Math.max(h,p.frames[M-1]);break}case Z.SLOT_COLOR:{const p=new st(M);p.slotIndex=d;for(let x=0;x<M;x++){const E=e.readFloat();u.Color.rgba8888ToColor(c,e.readInt32()),p.setFrame(x,E,c.r,c.g,c.b,c.a),x<M-1&&this.readCurve(e,x,p)}n.push(p),h=Math.max(h,p.frames[(M-1)*st.ENTRIES]);break}}}}for(let r=0,l=e.readInt(!0);r<l;r++){const d=e.readInt(!0);for(let f=0,m=e.readInt(!0);f<m;f++){const g=e.readByte(),M=e.readInt(!0);switch(g){case Z.BONE_ROTATE:{const p=new tt(M);p.boneIndex=d;for(let x=0;x<M;x++)p.setFrame(x,e.readFloat(),e.readFloat()),x<M-1&&this.readCurve(e,x,p);n.push(p),h=Math.max(h,p.frames[(M-1)*tt.ENTRIES]);break}case Z.BONE_TRANSLATE:case Z.BONE_SCALE:case Z.BONE_SHEAR:{let p,x=1;g==Z.BONE_SCALE?p=new ht(M):g==Z.BONE_SHEAR?p=new ct(M):(p=new mt(M),x=i),p.boneIndex=d;for(let E=0;E<M;E++){const w=e.readFloat(),T=e.readFloat(),I=e.readFloat();p.setFrame(E,w,T*x,I*x),E<M-1&&this.readCurve(e,E,p)}n.push(p),h=Math.max(h,p.frames[(M-1)*mt.ENTRIES]);break}}}}for(let r=0,l=e.readInt(!0);r<l;r++){const d=e.readInt(!0),f=e.readInt(!0),m=new et(f);m.ikConstraintIndex=d;for(let g=0;g<f;g++){const M=e.readFloat(),p=e.readFloat(),x=e.readByte();m.setFrame(g,M,p,x),g<f-1&&this.readCurve(e,g,m)}n.push(m),h=Math.max(h,m.frames[(f-1)*et.ENTRIES])}for(let r=0,l=e.readInt(!0);r<l;r++){const d=e.readInt(!0),f=e.readInt(!0),m=new it(f);m.transformConstraintIndex=d;for(let g=0;g<f;g++)m.setFrame(g,e.readFloat(),e.readFloat(),e.readFloat(),e.readFloat(),e.readFloat()),g<f-1&&this.readCurve(e,g,m);n.push(m),h=Math.max(h,m.frames[(f-1)*it.ENTRIES])}for(let r=0,l=e.readInt(!0);r<l;r++){const d=e.readInt(!0),f=s.pathConstraints[d];for(let m=0,g=e.readInt(!0);m<g;m++){const M=e.readByte(),p=e.readInt(!0);switch(M){case Z.PATH_POSITION:case Z.PATH_SPACING:{let x,E=1;M==Z.PATH_SPACING?(x=new Mt(p),(f.spacingMode==J.Length||f.spacingMode==J.Fixed)&&(E=i)):(x=new Et(p),f.positionMode==u.PositionMode.Fixed&&(E=i)),x.pathConstraintIndex=d;for(let w=0;w<p;w++){const T=e.readFloat(),I=e.readFloat()*E;x.setFrame(w,T,I),w<p-1&&this.readCurve(e,w,x)}n.push(x),h=Math.max(h,x.frames[(p-1)*Et.ENTRIES]);break}case Z.PATH_MIX:{const x=new xt(p);x.pathConstraintIndex=d;for(let E=0;E<p;E++){const w=e.readFloat(),T=e.readFloat(),I=e.readFloat();x.setFrame(E,w,T,I),E<p-1&&this.readCurve(e,E,x)}n.push(x),h=Math.max(h,x.frames[(p-1)*xt.ENTRIES]);break}}}}for(let r=0,l=e.readInt(!0);r<l;r++){const d=s.skins[e.readInt(!0)];for(let f=0,m=e.readInt(!0);f<m;f++){const g=e.readInt(!0);for(let M=0,p=e.readInt(!0);M<p;M++){const x=d==null?void 0:d.getAttachment(g,e.readString()),E=x.bones!=null,w=x.vertices,T=E?w.length/3*2:w.length,I=e.readInt(!0),S=new Zt(I);S.slotIndex=g,S.attachment=x;for(let A=0;A<I;A++){const R=e.readFloat();let y,k=e.readInt(!0);if(k==0)y=E?u.Utils.newFloatArray(T):w;else{y=u.Utils.newFloatArray(T);const X=e.readInt(!0);if(k+=X,i==1)for(let N=X;N<k;N++)y[N]=e.readFloat();else for(let N=X;N<k;N++)y[N]=e.readFloat()*i;if(!E)for(let N=0,$=y.length;N<$;N++)y[N]+=w[N]}S.setFrame(A,R,y,d.name),A<I-1&&this.readCurve(e,A,S)}n.push(S),h=Math.max(h,S.frames[I-1])}}}const o=e.readInt(!0);if(o>0){const r=new Bt(o),l=s.slots.length;for(let d=0;d<o;d++){const f=e.readFloat(),m=e.readInt(!0),g=u.Utils.newArray(l,0);for(let E=l-1;E>=0;E--)g[E]=-1;const M=u.Utils.newArray(l-m,0);let p=0,x=0;for(let E=0;E<m;E++){const w=e.readInt(!0);for(;p!=w;)M[x++]=p++;g[p+e.readInt(!0)]=p++}for(;p<l;)M[x++]=p++;for(let E=l-1;E>=0;E--)g[E]==-1&&(g[E]=M[--x]);r.setFrame(d,f,g)}n.push(r),h=Math.max(h,r.frames[o-1])}const a=e.readInt(!0);if(a>0){const r=new Lt(a);for(let l=0;l<a;l++){const d=e.readFloat(),f=s.events[e.readInt(!0)],m=new ne(d,f);m.intValue=e.readInt(!1),m.floatValue=e.readFloat(),m.stringValue=e.readBoolean()?e.readString():f.stringValue,m.data.audioPath!=null&&(m.volume=e.readFloat(),m.balance=e.readFloat()),r.setFrame(l,m)}n.push(r),h=Math.max(h,r.frames[a-1])}return new G(t,n,h)}readCurve(e,t,s){switch(e.readByte()){case Z.CURVE_STEPPED:s.setStepped(t);break;case Z.CURVE_BEZIER:this.setCurve(s,t,e.readFloat(),e.readFloat(),e.readFloat(),e.readFloat());break}}setCurve(e,t,s,n,i,h){e.setCurve(t,s,n,i,h)}};let z=Z;z.AttachmentTypeValues=[0,1,2,3,4,5,6],z.TransformModeValues=[u.TransformMode.Normal,u.TransformMode.OnlyTranslation,u.TransformMode.NoRotationOrReflection,u.TransformMode.NoScale,u.TransformMode.NoScaleOrReflection],z.PositionModeValues=[u.PositionMode.Fixed,u.PositionMode.Percent],z.SpacingModeValues=[J.Length,J.Fixed,J.Percent],z.RotateModeValues=[u.RotateMode.Tangent,u.RotateMode.Chain,u.RotateMode.ChainScale],z.BlendModeValues=[wt.BLEND_MODES.NORMAL,wt.BLEND_MODES.ADD,wt.BLEND_MODES.MULTIPLY,wt.BLEND_MODES.SCREEN],z.BONE_ROTATE=0,z.BONE_TRANSLATE=1,z.BONE_SCALE=2,z.BONE_SHEAR=3,z.SLOT_ATTACHMENT=0,z.SLOT_COLOR=1,z.SLOT_TWO_COLOR=2,z.PATH_POSITION=0,z.PATH_SPACING=1,z.PATH_MIX=2,z.CURVE_LINEAR=0,z.CURVE_STEPPED=1,z.CURVE_BEZIER=2;class Pe{constructor(t,s,n,i,h){this.mesh=t,this.skin=s,this.slotIndex=n,this.parent=i,this.inheritDeform=h}}class Fe{constructor(t=null,s=null,n=null){this.bones=t,this.vertices=s,this.cVertices=n}}class Be extends u.SkeletonBoundsBase{}class Ft{constructor(t){this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=t}readSkeletonData(t){const s=this.scale,n=new oe,i=typeof t=="string"?JSON.parse(t):t,h=i.skeleton;if(h!=null){if(n.hash=h.hash,n.version=h.spine,n.version.substr(0,3)!=="3.4"){const c=`Spine 3.4 loader cant load version ${h.spine}. Please configure your pixi-spine bundle`;console.error(c)}n.version==="3.4.75"&&console.error("Unsupported skeleton data, 3.4.75 is deprecated, please export with a newer version of Spine."),n.x=h.x,n.y=h.y,n.width=h.width,n.height=h.height,n.fps=h.fps,n.imagesPath=h.images}if(i.bones)for(let c=0;c<i.bones.length;c++){const o=i.bones[c];let a=null;const r=this.getValue(o,"parent",null);if(r!=null&&(a=n.findBone(r),a==null))throw new Error(`Parent bone not found: ${r}`);const l=new ee(n.bones.length,o.name,a);l.length=this.getValue(o,"length",0)*s,l.x=this.getValue(o,"x",0)*s,l.y=this.getValue(o,"y",0)*s,l.rotation=this.getValue(o,"rotation",0),l.scaleX=this.getValue(o,"scaleX",1),l.scaleY=this.getValue(o,"scaleY",1),l.shearX=this.getValue(o,"shearX",0),l.shearY=this.getValue(o,"shearY",0),l.transformMode=Ft.transformModeFromString(this.getValue(o,"transform","normal")),l.skinRequired=this.getValue(o,"skin",!1),n.bones.push(l)}if(i.slots)for(let c=0;c<i.slots.length;c++){const o=i.slots[c],a=o.name,r=o.bone,l=n.findBone(r);if(l==null)throw new Error(`Slot bone not found: ${r}`);const d=new le(n.slots.length,a,l),f=this.getValue(o,"color",null);f!=null&&d.color.setFromString(f);const m=this.getValue(o,"dark",null);m!=null&&(d.darkColor=new u.Color(1,1,1,1),d.darkColor.setFromString(m)),d.attachmentName=this.getValue(o,"attachment",null),d.blendMode=Ft.blendModeFromString(this.getValue(o,"blend","normal")),n.slots.push(d)}if(i.ik)for(let c=0;c<i.ik.length;c++){const o=i.ik[c],a=new ie(o.name);a.order=this.getValue(o,"order",0),a.skinRequired=this.getValue(o,"skin",!1);for(let l=0;l<o.bones.length;l++){const d=o.bones[l],f=n.findBone(d);if(f==null)throw new Error(`IK bone not found: ${d}`);a.bones.push(f)}const r=o.target;if(a.target=n.findBone(r),a.target==null)throw new Error(`IK target bone not found: ${r}`);a.mix=this.getValue(o,"mix",1),a.softness=this.getValue(o,"softness",0)*s,a.bendDirection=this.getValue(o,"bendPositive",!0)?1:-1,a.compress=this.getValue(o,"compress",!1),a.stretch=this.getValue(o,"stretch",!1),a.uniform=this.getValue(o,"uniform",!1),n.ikConstraints.push(a)}if(i.transform)for(let c=0;c<i.transform.length;c++){const o=i.transform[c],a=new he(o.name);a.order=this.getValue(o,"order",0),a.skinRequired=this.getValue(o,"skin",!1);for(let l=0;l<o.bones.length;l++){const d=o.bones[l],f=n.findBone(d);if(f==null)throw new Error(`Transform constraint bone not found: ${d}`);a.bones.push(f)}const r=o.target;if(a.target=n.findBone(r),a.target==null)throw new Error(`Transform constraint target bone not found: ${r}`);a.local=this.getValue(o,"local",!1),a.relative=this.getValue(o,"relative",!1),a.offsetRotation=this.getValue(o,"rotation",0),a.offsetX=this.getValue(o,"x",0)*s,a.offsetY=this.getValue(o,"y",0)*s,a.offsetScaleX=this.getValue(o,"scaleX",0),a.offsetScaleY=this.getValue(o,"scaleY",0),a.offsetShearY=this.getValue(o,"shearY",0),a.rotateMix=this.getValue(o,"rotateMix",1),a.translateMix=this.getValue(o,"translateMix",1),a.scaleMix=this.getValue(o,"scaleMix",1),a.shearMix=this.getValue(o,"shearMix",1),n.transformConstraints.push(a)}if(i.path)for(let c=0;c<i.path.length;c++){const o=i.path[c],a=new ae(o.name);a.order=this.getValue(o,"order",0),a.skinRequired=this.getValue(o,"skin",!1);for(let l=0;l<o.bones.length;l++){const d=o.bones[l],f=n.findBone(d);if(f==null)throw new Error(`Transform constraint bone not found: ${d}`);a.bones.push(f)}const r=o.target;if(a.target=n.findSlot(r),a.target==null)throw new Error(`Path target slot not found: ${r}`);a.positionMode=Ft.positionModeFromString(this.getValue(o,"positionMode","percent")),a.spacingMode=Ft.spacingModeFromString(this.getValue(o,"spacingMode","length")),a.rotateMode=Ft.rotateModeFromString(this.getValue(o,"rotateMode","tangent")),a.offsetRotation=this.getValue(o,"rotation",0),a.position=this.getValue(o,"position",0),a.positionMode==u.PositionMode.Fixed&&(a.position*=s),a.spacing=this.getValue(o,"spacing",0),(a.spacingMode==J.Length||a.spacingMode==J.Fixed)&&(a.spacing*=s),a.rotateMix=this.getValue(o,"rotateMix",1),a.translateMix=this.getValue(o,"translateMix",1),n.pathConstraints.push(a)}if(i.skins)for(let c=0;c<i.skins.length;c++){const o=i.skins[c],a=new Wt(o.name);if(o.bones)for(let r=0;r<o.bones.length;r++){const l=n.findBone(o.bones[r]);if(l==null)throw new Error(`Skin bone not found: ${o.bones[c]}`);a.bones.push(l)}if(o.ik)for(let r=0;r<o.ik.length;r++){const l=n.findIkConstraint(o.ik[r]);if(l==null)throw new Error(`Skin IK constraint not found: ${o.ik[c]}`);a.constraints.push(l)}if(o.transform)for(let r=0;r<o.transform.length;r++){const l=n.findTransformConstraint(o.transform[r]);if(l==null)throw new Error(`Skin transform constraint not found: ${o.transform[c]}`);a.constraints.push(l)}if(o.path)for(let r=0;r<o.path.length;r++){const l=n.findPathConstraint(o.path[r]);if(l==null)throw new Error(`Skin path constraint not found: ${o.path[c]}`);a.constraints.push(l)}for(const r in o.attachments){const l=n.findSlot(r);if(l==null)throw new Error(`Slot not found: ${r}`);const d=o.attachments[r];for(const f in d){const m=this.readAttachment(d[f],a,l.index,f,n);m!=null&&a.setAttachment(l.index,f,m)}}n.skins.push(a),a.name=="default"&&(n.defaultSkin=a)}for(let c=0,o=this.linkedMeshes.length;c<o;c++){const a=this.linkedMeshes[c],r=a.skin==null?n.defaultSkin:n.findSkin(a.skin);if(r==null)throw new Error(`Skin not found: ${a.skin}`);const l=r.getAttachment(a.slotIndex,a.parent);if(l==null)throw new Error(`Parent mesh not found: ${a.parent}`);a.mesh.deformAttachment=a.inheritDeform?l:a.mesh,a.mesh.setParentMesh(l)}if(this.linkedMeshes.length=0,i.events)for(const c in i.events){const o=i.events[c],a=new se(c);a.intValue=this.getValue(o,"int",0),a.floatValue=this.getValue(o,"float",0),a.stringValue=this.getValue(o,"string",""),a.audioPath=this.getValue(o,"audio",null),a.audioPath!=null&&(a.volume=this.getValue(o,"volume",1),a.balance=this.getValue(o,"balance",0)),n.events.push(a)}if(i.animations)for(const c in i.animations){const o=i.animations[c];this.readAnimation(o,c,n)}return n}readAttachment(t,s,n,i,h){const c=this.scale;switch(i=this.getValue(t,"name",i),this.getValue(t,"type","region")){case"region":{const o=this.getValue(t,"path",i),a=this.attachmentLoader.newRegionAttachment(s,i,o);if(a==null)return null;a.path=o,a.x=this.getValue(t,"x",0)*c,a.y=this.getValue(t,"y",0)*c,a.scaleX=this.getValue(t,"scaleX",1),a.scaleY=this.getValue(t,"scaleY",1),a.rotation=this.getValue(t,"rotation",0),a.width=t.width*c,a.height=t.height*c;const r=this.getValue(t,"color",null);return r!=null&&a.color.setFromString(r),a}case"boundingbox":{const o=this.attachmentLoader.newBoundingBoxAttachment(s,i);if(o==null)return null;this.readVertices(t,o,t.vertexCount<<1);const a=this.getValue(t,"color",null);return a!=null&&o.color.setFromString(a),o}case"mesh":case"linkedmesh":{const o=this.getValue(t,"path",i),a=this.attachmentLoader.newMeshAttachment(s,i,o);if(a==null)return null;a.path=o;const r=this.getValue(t,"color",null);r!=null&&a.color.setFromString(r),a.width=this.getValue(t,"width",0)*c,a.height=this.getValue(t,"height",0)*c;const l=this.getValue(t,"parent",null);if(l!=null)return this.linkedMeshes.push(new Ne(a,this.getValue(t,"skin",null),n,l,this.getValue(t,"deform",!0))),a;const d=t.uvs;return this.readVertices(t,a,d.length),a.triangles=t.triangles,a.regionUVs=new Float32Array(d),a.edges=this.getValue(t,"edges",null),a.hullLength=this.getValue(t,"hull",0)*2,a}case"path":{const o=this.attachmentLoader.newPathAttachment(s,i);if(o==null)return null;o.closed=this.getValue(t,"closed",!1),o.constantSpeed=this.getValue(t,"constantSpeed",!0);const a=t.vertexCount;this.readVertices(t,o,a<<1);const r=u.Utils.newArray(a/3,0);for(let d=0;d<t.lengths.length;d++)r[d]=t.lengths[d]*c;o.lengths=r;const l=this.getValue(t,"color",null);return l!=null&&o.color.setFromString(l),o}case"point":{const o=this.attachmentLoader.newPointAttachment(s,i);if(o==null)return null;o.x=this.getValue(t,"x",0)*c,o.y=this.getValue(t,"y",0)*c,o.rotation=this.getValue(t,"rotation",0);const a=this.getValue(t,"color",null);return a!=null&&o.color.setFromString(a),o}case"clipping":{const o=this.attachmentLoader.newClippingAttachment(s,i);if(o==null)return null;const a=this.getValue(t,"end",null);if(a!=null){const d=h.findSlot(a);if(d==null)throw new Error(`Clipping end slot not found: ${a}`);o.endSlot=d}const r=t.vertexCount;this.readVertices(t,o,r<<1);const l=this.getValue(t,"color",null);return l!=null&&o.color.setFromString(l),o}}return null}readVertices(t,s,n){const i=this.scale;s.worldVerticesLength=n;const h=t.vertices;if(n==h.length){const a=u.Utils.toFloatArray(h);if(i!=1)for(let r=0,l=h.length;r<l;r++)a[r]*=i;s.vertices=a;return}const c=new Array,o=new Array;for(let a=0,r=h.length;a<r;){const l=h[a++];o.push(l);for(let d=a+l*4;a<d;a+=4)o.push(h[a]),c.push(h[a+1]*i),c.push(h[a+2]*i),c.push(h[a+3])}s.bones=o,s.vertices=u.Utils.toFloatArray(c)}readAnimation(t,s,n){const i=this.scale,h=new Array;let c=0;if(t.slots)for(const a in t.slots){const r=t.slots[a],l=n.findSlotIndex(a);if(l==-1)throw new Error(`Slot not found: ${a}`);for(const d in r){const f=r[d];if(d=="attachment"){const m=new Vt(f.length);m.slotIndex=l;let g=0;for(let M=0;M<f.length;M++){const p=f[M];m.setFrame(g++,this.getValue(p,"time",0),p.name)}h.push(m),c=Math.max(c,m.frames[m.getFrameCount()-1])}else if(d=="color"){const m=new st(f.length);m.slotIndex=l;let g=0;for(let M=0;M<f.length;M++){const p=f[M],x=new u.Color;x.setFromString(p.color||"ffffffff"),m.setFrame(g,this.getValue(p,"time",0),x.r,x.g,x.b,x.a),this.readCurve(p,m,g),g++}h.push(m),c=Math.max(c,m.frames[(m.getFrameCount()-1)*st.ENTRIES])}else if(d=="twoColor"){const m=new Q(f.length);m.slotIndex=l;let g=0;for(let M=0;M<f.length;M++){const p=f[M],x=new u.Color,E=new u.Color;x.setFromString(p.light),E.setFromString(p.dark),m.setFrame(g,this.getValue(p,"time",0),x.r,x.g,x.b,x.a,E.r,E.g,E.b),this.readCurve(p,m,g),g++}h.push(m),c=Math.max(c,m.frames[(m.getFrameCount()-1)*Q.ENTRIES])}else throw new Error(`Invalid timeline type for a slot: ${d} (${a})`)}}if(t.bones)for(const a in t.bones){const r=t.bones[a],l=n.findBoneIndex(a);if(l==-1)throw new Error(`Bone not found: ${a}`);for(const d in r){const f=r[d];if(d==="rotate"){const m=new tt(f.length);m.boneIndex=l;let g=0;for(let M=0;M<f.length;M++){const p=f[M];m.setFrame(g,this.getValue(p,"time",0),this.getValue(p,"angle",0)),this.readCurve(p,m,g),g++}h.push(m),c=Math.max(c,m.frames[(m.getFrameCount()-1)*tt.ENTRIES])}else if(d==="translate"||d==="scale"||d==="shear"){let m=null,g=1,M=0;d==="scale"?(m=new ht(f.length),M=1):d==="shear"?m=new ct(f.length):(m=new mt(f.length),g=i),m.boneIndex=l;let p=0;for(let x=0;x<f.length;x++){const E=f[x],w=this.getValue(E,"x",M),T=this.getValue(E,"y",M);m.setFrame(p,this.getValue(E,"time",0),w*g,T*g),this.readCurve(E,m,p),p++}h.push(m),c=Math.max(c,m.frames[(m.getFrameCount()-1)*mt.ENTRIES])}else throw new Error(`Invalid timeline type for a bone: ${d} (${a})`)}}if(t.ik)for(const a in t.ik){const r=t.ik[a],l=n.findIkConstraint(a),d=new et(r.length);d.ikConstraintIndex=n.ikConstraints.indexOf(l);let f=0;for(let m=0;m<r.length;m++){const g=r[m];d.setFrame(f,this.getValue(g,"time",0),this.getValue(g,"mix",1),this.getValue(g,"softness",0)*i),this.readCurve(g,d,f),f++}h.push(d),c=Math.max(c,d.frames[(d.getFrameCount()-1)*et.ENTRIES])}if(t.transform)for(const a in t.transform){const r=t.transform[a],l=n.findTransformConstraint(a),d=new it(r.length);d.transformConstraintIndex=n.transformConstraints.indexOf(l);let f=0;for(let m=0;m<r.length;m++){const g=r[m];d.setFrame(f,this.getValue(g,"time",0),this.getValue(g,"rotateMix",1),this.getValue(g,"translateMix",1),this.getValue(g,"scaleMix",1),this.getValue(g,"shearMix",1)),this.readCurve(g,d,f),f++}h.push(d),c=Math.max(c,d.frames[(d.getFrameCount()-1)*it.ENTRIES])}if(t.path)for(const a in t.path){const r=t.path[a],l=n.findPathConstraintIndex(a);if(l==-1)throw new Error(`Path constraint not found: ${a}`);const d=n.pathConstraints[l];for(const f in r){const m=r[f];if(f==="position"||f==="spacing"){let g=null,M=1;f==="spacing"?(g=new Mt(m.length),(d.spacingMode==J.Length||d.spacingMode==J.Fixed)&&(M=i)):(g=new Et(m.length),d.positionMode==u.PositionMode.Fixed&&(M=i)),g.pathConstraintIndex=l;let p=0;for(let x=0;x<m.length;x++){const E=m[x];g.setFrame(p,this.getValue(E,"time",0),this.getValue(E,f,0)*M),this.readCurve(E,g,p),p++}h.push(g),c=Math.max(c,g.frames[(g.getFrameCount()-1)*Et.ENTRIES])}else if(f==="mix"){const g=new xt(m.length);g.pathConstraintIndex=l;let M=0;for(let p=0;p<m.length;p++){const x=m[p];g.setFrame(M,this.getValue(x,"time",0),this.getValue(x,"rotateMix",1),this.getValue(x,"translateMix",1)),this.readCurve(x,g,M),M++}h.push(g),c=Math.max(c,g.frames[(g.getFrameCount()-1)*xt.ENTRIES])}}}if(t.deform)for(const a in t.deform){const r=t.deform[a],l=n.findSkin(a);if(l==null){if(u.settings.FAIL_ON_NON_EXISTING_SKIN)throw new Error(`Skin not found: ${a}`);continue}for(const d in r){const f=r[d],m=n.findSlotIndex(d);if(m==-1)throw new Error(`Slot not found: ${f.name}`);for(const g in f){const M=f[g],p=l.getAttachment(m,g);if(p==null)throw new Error(`Deform attachment not found: ${M.name}`);const x=p.bones!=null,E=p.vertices,w=x?E.length/3*2:E.length,T=new Zt(M.length);T.slotIndex=m,T.attachment=p;let I=0;for(let S=0;S<M.length;S++){const A=M[S];let R;const y=this.getValue(A,"vertices",null);if(y==null)R=x?u.Utils.newFloatArray(w):E;else{R=u.Utils.newFloatArray(w);const k=this.getValue(A,"offset",0);if(u.Utils.arrayCopy(y,0,R,k,y.length),i!=1)for(let X=k,N=X+y.length;X<N;X++)R[X]*=i;if(!x)for(let X=0;X<w;X++)R[X]+=E[X]}T.setFrame(I,this.getValue(A,"time",0),R,l.name),this.readCurve(A,T,I),I++}h.push(T),c=Math.max(c,T.frames[T.getFrameCount()-1])}}}let o=t.drawOrder;if(o==null&&(o=t.draworder),o!=null){const a=new Bt(o.length),r=n.slots.length;let l=0;for(let d=0;d<o.length;d++){const f=o[d];let m=null;const g=this.getValue(f,"offsets",null);if(g!=null){m=u.Utils.newArray(r,-1);const M=u.Utils.newArray(r-g.length,0);let p=0,x=0;for(let E=0;E<g.length;E++){const w=g[E],T=n.findSlotIndex(w.slot);if(T==-1)throw new Error(`Slot not found: ${w.slot}`);for(;p!=T;)M[x++]=p++;m[p+w.offset]=p++}for(;p<r;)M[x++]=p++;for(let E=r-1;E>=0;E--)m[E]==-1&&(m[E]=M[--x])}a.setFrame(l++,this.getValue(f,"time",0),m)}h.push(a),c=Math.max(c,a.frames[a.getFrameCount()-1])}if(t.events){const a=new Lt(t.events.length);let r=0;for(let l=0;l<t.events.length;l++){const d=t.events[l],f=n.findEvent(d.name);if(f==null)throw new Error(`Event not found: ${d.name}`);const m=new ne(u.Utils.toSinglePrecision(this.getValue(d,"time",0)),f);m.intValue=this.getValue(d,"int",f.intValue),m.floatValue=this.getValue(d,"float",f.floatValue),m.stringValue=this.getValue(d,"string",f.stringValue),m.data.audioPath!=null&&(m.volume=this.getValue(d,"volume",1),m.balance=this.getValue(d,"balance",0)),a.setFrame(r++,m)}h.push(a),c=Math.max(c,a.frames[a.getFrameCount()-1])}if(isNaN(c))throw new Error("Error while parsing animation, duration is NaN");n.animations.push(new G(s,h,c))}readCurve(t,s,n){if(t.hasOwnProperty("curve"))if(t.curve==="stepped")s.setStepped(n);else{const i=t.curve;s.setCurve(n,i,this.getValue(t,"c2",0),this.getValue(t,"c3",1),this.getValue(t,"c4",1))}}getValue(t,s,n){return t[s]!==void 0?t[s]:n}static blendModeFromString(t){if(t=t.toLowerCase(),t=="normal")return wt.BLEND_MODES.NORMAL;if(t=="additive")return wt.BLEND_MODES.ADD;if(t=="multiply")return wt.BLEND_MODES.MULTIPLY;if(t=="screen")return wt.BLEND_MODES.SCREEN;throw new Error(`Unknown blend mode: ${t}`)}static positionModeFromString(t){if(t=t.toLowerCase(),t=="fixed")return u.PositionMode.Fixed;if(t=="percent")return u.PositionMode.Percent;throw new Error(`Unknown position mode: ${t}`)}static spacingModeFromString(t){if(t=t.toLowerCase(),t=="length")return J.Length;if(t=="fixed")return J.Fixed;if(t=="percent")return J.Percent;throw new Error(`Unknown position mode: ${t}`)}static rotateModeFromString(t){if(t=t.toLowerCase(),t=="tangent")return u.RotateMode.Tangent;if(t=="chain")return u.RotateMode.Chain;if(t=="chainscale")return u.RotateMode.ChainScale;throw new Error(`Unknown rotate mode: ${t}`)}static transformModeFromString(t){if(t=t.toLowerCase(),t=="normal")return u.TransformMode.Normal;if(t=="onlytranslation")return u.TransformMode.OnlyTranslation;if(t=="norotationorreflection")return u.TransformMode.NoRotationOrReflection;if(t=="noscale")return u.TransformMode.NoScale;if(t=="noscaleorreflection")return u.TransformMode.NoScaleOrReflection;throw new Error(`Unknown transform mode: ${t}`)}}class Ne{constructor(t,s,n,i,h){this.mesh=t,this.skin=s,this.slotIndex=n,this.parent=i,this.inheritDeform=h}}class ve extends u.SpineBase{createSkeleton(t){this.skeleton=new re(t),this.skeleton.updateWorldTransform(),this.stateData=new Jt(t),this.state=new ft(this.stateData)}}return C.Animation=G,C.AnimationState=ft,C.AnimationStateAdapter=ke,C.AnimationStateData=Jt,C.AtlasAttachmentLoader=Ve,C.Attachment=Gt,C.AttachmentTimeline=Vt,C.Bone=te,C.BoneData=ee,C.BoundingBoxAttachment=Xt,C.ClippingAttachment=Yt,C.ColorTimeline=st,C.ConstraintData=bt,C.CurveTimeline=lt,C.DeformTimeline=Zt,C.DrawOrderTimeline=Bt,C.Event=ne,C.EventData=se,C.EventQueue=Qt,C.EventTimeline=Lt,C.EventType=dt,C.IkConstraint=xe,C.IkConstraintData=ie,C.IkConstraintTimeline=et,C.JitterEffect=Ce,C.MeshAttachment=Ct,C.PathAttachment=kt,C.PathConstraint=Nt,C.PathConstraintData=ae,C.PathConstraintMixTimeline=xt,C.PathConstraintPositionTimeline=Et,C.PathConstraintSpacingTimeline=Mt,C.PointAttachment=Ot,C.RegionAttachment=B,C.RotateTimeline=tt,C.ScaleTimeline=ht,C.ShearTimeline=ct,C.Skeleton=re,C.SkeletonBinary=z,C.SkeletonBounds=Be,C.SkeletonData=oe,C.SkeletonJson=Ft,C.Skin=Wt,C.SkinEntry=ce,C.Slot=jt,C.SlotData=le,C.SpacingMode=J,C.Spine=ve,C.SwirlEffect=ge,C.TimelineType=pe,C.TrackEntry=_t,C.TransformConstraint=Ee,C.TransformConstraintData=he,C.TransformConstraintTimeline=it,C.TranslateTimeline=mt,C.TwoColorTimeline=Q,C.VertexAttachment=At,C}({},PIXI.spine,PIXI);
//# sourceMappingURL=runtime-3.4.js.map
