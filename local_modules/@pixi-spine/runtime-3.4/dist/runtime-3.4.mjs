/*!
 * @pixi-spine/runtime-3.4 - v4.0.3
 * Compiled Fri, 16 Jun 2023 01:12:21 UTC
 *
 * @pixi-spine/runtime-3.4 is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 * 
 * Copyright 2023, Ivan Igorevich Popelyshev <ivan.popelyshev@gmail.com>, All Rights Reserved
 */import{Utils as k,AttachmentType as pt,Color as _,MathUtils as y,PowOut as Xe,MixBlend as A,MixDirection as bt,IntSet as Ye,Pool as De,settings as ne,TransformMode as Z,RotateMode as Rt,PositionMode as kt,Vector2 as Oe,BinaryInput as Le,SkeletonBoundsBase as Be,SpineBase as _e}from"@pixi-spine/base";import{Matrix as We,BLEND_MODES as Pt}from"@pixi/core";class se{constructor(t){if(t==null)throw new Error("name cannot be null.");this.name=t}}const ke=class extends se{constructor(t){super(t),this.id=(ke.nextID++&65535)<<11,this.worldVerticesLength=0,this.deformAttachment=this}computeWorldVerticesOld(t,s){this.computeWorldVertices(t,0,this.worldVerticesLength,s,0,2)}computeWorldVertices(t,s,n,a,h,c){n=h+(n>>1)*c;const o=t.bone.skeleton,r=t.deform;let i=this.vertices;const l=this.bones;if(l==null){r.length>0&&(i=r);const f=t.bone.matrix,p=f.tx,g=f.ty,x=f.a,E=f.c,w=f.b,b=f.d;for(let I=s,M=h;M<n;I+=2,M+=c){const S=i[I],R=i[I+1];a[M]=S*x+R*E+p,a[M+1]=S*w+R*b+g}return}let d=0,m=0;for(let f=0;f<s;f+=2){const p=l[d];d+=p+1,m+=p}const u=o.bones;if(r.length==0)for(let f=h,p=m*3;f<n;f+=c){let g=0,x=0,E=l[d++];for(E+=d;d<E;d++,p+=3){const w=u[l[d]].matrix,b=i[p],I=i[p+1],M=i[p+2];g+=(b*w.a+I*w.c+w.tx)*M,x+=(b*w.b+I*w.d+w.ty)*M}a[f]=g,a[f+1]=x}else{const f=r;for(let p=h,g=m*3,x=m<<1;p<n;p+=c){let E=0,w=0,b=l[d++];for(b+=d;d<b;d++,g+=3,x+=2){const I=u[l[d]].matrix,M=i[g]+f[x],S=i[g+1]+f[x+1],R=i[g+2];E+=(M*I.a+S*I.c+I.tx)*R,w+=(M*I.b+S*I.d+I.ty)*R}a[p]=E,a[p+1]=w}}}copyTo(t){this.bones!=null?(t.bones=new Array(this.bones.length),k.arrayCopy(this.bones,0,t.bones,0,this.bones.length)):t.bones=null,this.vertices!=null?(t.vertices=k.newFloatArray(this.vertices.length),k.arrayCopy(this.vertices,0,t.vertices,0,this.vertices.length)):t.vertices=null,t.worldVerticesLength=this.worldVerticesLength,t.deformAttachment=this.deformAttachment}};let Ft=ke;Ft.nextID=0;class Qt extends Ft{constructor(t){super(t),this.type=pt.BoundingBox,this.color=new _(1,1,1,1)}copy(){const t=new Qt(this.name);return this.copyTo(t),t.color.setFromColor(this.color),t}}class Kt extends Ft{constructor(t){super(t),this.type=pt.Clipping,this.color=new _(.2275,.2275,.8078,1)}copy(){const t=new Kt(this.name);return this.copyTo(t),t.endSlot=this.endSlot,t.color.setFromColor(this.color),t}}class Ot extends Ft{constructor(t){super(t),this.type=pt.Mesh,this.color=new _(1,1,1,1),this.tempColor=new _(0,0,0,0)}getParentMesh(){return this.parentMesh}setParentMesh(t){this.parentMesh=t,t!=null&&(this.bones=t.bones,this.vertices=t.vertices,this.worldVerticesLength=t.worldVerticesLength,this.regionUVs=t.regionUVs,this.triangles=t.triangles,this.hullLength=t.hullLength,this.worldVerticesLength=t.worldVerticesLength)}copy(){if(this.parentMesh!=null)return this.newLinkedMesh();const t=new Ot(this.name);return t.region=this.region,t.path=this.path,t.color.setFromColor(this.color),this.copyTo(t),t.regionUVs=new Float32Array(this.regionUVs.length),k.arrayCopy(this.regionUVs,0,t.regionUVs,0,this.regionUVs.length),t.triangles=new Array(this.triangles.length),k.arrayCopy(this.triangles,0,t.triangles,0,this.triangles.length),t.hullLength=this.hullLength,this.edges!=null&&(t.edges=new Array(this.edges.length),k.arrayCopy(this.edges,0,t.edges,0,this.edges.length)),t.width=this.width,t.height=this.height,t}newLinkedMesh(){const t=new Ot(this.name);return t.region=this.region,t.path=this.path,t.color.setFromColor(this.color),t.deformAttachment=this.deformAttachment,t.setParentMesh(this.parentMesh!=null?this.parentMesh:this),t}}class Yt extends Ft{constructor(t){super(t),this.type=pt.Path,this.closed=!1,this.constantSpeed=!1,this.color=new _(1,1,1,1)}copy(){const t=new Yt(this.name);return this.copyTo(t),t.lengths=new Array(this.lengths.length),k.arrayCopy(this.lengths,0,t.lengths,0,this.lengths.length),t.closed=closed,t.constantSpeed=this.constantSpeed,t.color.setFromColor(this.color),t}}class Jt extends Ft{constructor(t){super(t),this.type=pt.Point,this.color=new _(.38,.94,0,1)}computeWorldPosition(t,s){const n=t.matrix;return s.x=this.x*n.a+this.y*n.c+t.worldX,s.y=this.x*n.b+this.y*n.d+t.worldY,s}computeWorldRotation(t){const s=t.matrix,n=y.cosDeg(this.rotation),a=y.sinDeg(this.rotation),h=n*s.a+a*s.c,c=n*s.b+a*s.d;return Math.atan2(c,h)*y.radDeg}copy(){const t=new Jt(this.name);return t.x=this.x,t.y=this.y,t.rotation=this.rotation,t.color.setFromColor(this.color),t}}class ae{constructor(t,s){if(this.deform=new Array,t==null)throw new Error("data cannot be null.");if(s==null)throw new Error("bone cannot be null.");this.data=t,this.bone=s,this.color=new _,this.darkColor=t.darkColor==null?null:new _,this.setToSetupPose(),this.blendMode=this.data.blendMode}getAttachment(){return this.attachment}setAttachment(t){this.attachment!=t&&(this.attachment=t,this.attachmentTime=this.bone.skeleton.time,this.deform.length=0)}setAttachmentTime(t){this.attachmentTime=this.bone.skeleton.time-t}getAttachmentTime(){return this.bone.skeleton.time-this.attachmentTime}setToSetupPose(){this.color.setFromColor(this.data.color),this.darkColor!=null&&this.darkColor.setFromColor(this.data.darkColor),this.data.attachmentName==null?this.attachment=null:(this.attachment=null,this.setAttachment(this.bone.skeleton.getAttachment(this.data.index,this.data.attachmentName)))}}const et=class extends se{constructor(e){super(e),this.type=pt.Region,this.x=0,this.y=0,this.scaleX=1,this.scaleY=1,this.rotation=0,this.width=0,this.height=0,this.color=new _(1,1,1,1),this.offset=k.newFloatArray(8),this.uvs=k.newFloatArray(8),this.tempColor=new _(1,1,1,1)}updateOffset(){const e=this.width/this.region.originalWidth*this.scaleX,t=this.height/this.region.originalHeight*this.scaleY,s=-this.width/2*this.scaleX+this.region.offsetX*e,n=-this.height/2*this.scaleY+this.region.offsetY*t,a=s+this.region.width*e,h=n+this.region.height*t,c=this.rotation*Math.PI/180,o=Math.cos(c),r=Math.sin(c),i=s*o+this.x,l=s*r,d=n*o+this.y,m=n*r,u=a*o+this.x,f=a*r,p=h*o+this.y,g=h*r,x=this.offset;x[et.OX1]=i-m,x[et.OY1]=d+l,x[et.OX2]=i-g,x[et.OY2]=p+l,x[et.OX3]=u-g,x[et.OY3]=p+f,x[et.OX4]=u-m,x[et.OY4]=d+f}setRegion(e){this.region=e;const t=this.uvs;e.rotate?(t[2]=e.u,t[3]=e.v2,t[4]=e.u,t[5]=e.v,t[6]=e.u2,t[7]=e.v,t[0]=e.u2,t[1]=e.v2):(t[0]=e.u,t[1]=e.v2,t[2]=e.u,t[3]=e.v,t[4]=e.u2,t[5]=e.v,t[6]=e.u2,t[7]=e.v2)}computeWorldVertices(e,t,s,n){const a=this.offset,h=e instanceof ae?e.bone.matrix:e.matrix,c=h.tx,o=h.ty,r=h.a,i=h.c,l=h.b,d=h.d;let m=0,u=0;m=a[et.OX1],u=a[et.OY1],t[s]=m*r+u*i+c,t[s+1]=m*l+u*d+o,s+=n,m=a[et.OX2],u=a[et.OY2],t[s]=m*r+u*i+c,t[s+1]=m*l+u*d+o,s+=n,m=a[et.OX3],u=a[et.OY3],t[s]=m*r+u*i+c,t[s+1]=m*l+u*d+o,s+=n,m=a[et.OX4],u=a[et.OY4],t[s]=m*r+u*i+c,t[s+1]=m*l+u*d+o}copy(){const e=new et(this.name);return e.region=this.region,e.rendererObject=this.rendererObject,e.path=this.path,e.x=this.x,e.y=this.y,e.scaleX=this.scaleX,e.scaleY=this.scaleY,e.rotation=this.rotation,e.width=this.width,e.height=this.height,k.arrayCopy(this.uvs,0,e.uvs,0,8),k.arrayCopy(this.offset,0,e.offset,0,8),e.color.setFromColor(this.color),e}};let N=et;N.OX1=0,N.OY1=1,N.OX2=2,N.OY2=3,N.OX3=4,N.OY3=5,N.OX4=6,N.OY4=7,N.X1=0,N.Y1=1,N.C1R=2,N.C1G=3,N.C1B=4,N.C1A=5,N.U1=6,N.V1=7,N.X2=8,N.Y2=9,N.C2R=10,N.C2G=11,N.C2B=12,N.C2A=13,N.U2=14,N.V2=15,N.X3=16,N.Y3=17,N.C3R=18,N.C3G=19,N.C3B=20,N.C3A=21,N.U3=22,N.V3=23,N.X4=24,N.Y4=25,N.C4R=26,N.C4G=27,N.C4B=28,N.C4A=29,N.U4=30,N.V4=31;class qe{constructor(t,s){this.jitterX=0,this.jitterY=0,this.jitterX=t,this.jitterY=s}begin(t){}transform(t,s,n,a){t.x+=y.randomTriangular(-this.jitterX,this.jitterY),t.y+=y.randomTriangular(-this.jitterX,this.jitterY)}end(){}}const Ve=class{constructor(e){this.centerX=0,this.centerY=0,this.radius=0,this.angle=0,this.worldX=0,this.worldY=0,this.radius=e}begin(e){this.worldX=e.x+this.centerX,this.worldY=e.y+this.centerY}transform(e,t,s,n){const a=this.angle*y.degreesToRadians,h=e.x-this.worldX,c=e.y-this.worldY,o=Math.sqrt(h*h+c*c);if(o<this.radius){const r=Ve.interpolation.apply(0,a,(this.radius-o)/this.radius),i=Math.cos(r),l=Math.sin(r);e.x=i*h-l*c+this.worldX,e.y=l*h+i*c+this.worldY}}end(){}};let Ce=Ve;Ce.interpolation=new Xe(2);class z{constructor(t,s,n){if(t==null)throw new Error("name cannot be null.");if(s==null)throw new Error("timelines cannot be null.");this.name=t,this.timelines=s,this.timelineIds=[];for(let a=0;a<s.length;a++)this.timelineIds[s[a].getPropertyId()]=!0;this.duration=n}hasTimeline(t){return this.timelineIds[t]==!0}apply(t,s,n,a,h,c,o,r){if(t==null)throw new Error("skeleton cannot be null.");a&&this.duration!=0&&(n%=this.duration,s>0&&(s%=this.duration));const i=this.timelines;for(let l=0,d=i.length;l<d;l++)i[l].apply(t,s,n,h,c,o,r)}static binarySearch(t,s,n=1){let a=0,h=t.length/n-2;if(h==0)return n;let c=h>>>1;for(;;){if(t[(c+1)*n]<=s?a=c+1:h=c,a==h)return(a+1)*n;c=a+h>>>1}}static linearSearch(t,s,n){for(let a=0,h=t.length-n;a<=h;a+=n)if(t[a]>s)return a;return-1}}var Pe=(e=>(e[e.rotate=0]="rotate",e[e.translate=1]="translate",e[e.scale=2]="scale",e[e.shear=3]="shear",e[e.attachment=4]="attachment",e[e.color=5]="color",e[e.deform=6]="deform",e[e.event=7]="event",e[e.drawOrder=8]="drawOrder",e[e.ikConstraint=9]="ikConstraint",e[e.transformConstraint=10]="transformConstraint",e[e.pathConstraintPosition=11]="pathConstraintPosition",e[e.pathConstraintSpacing=12]="pathConstraintSpacing",e[e.pathConstraintMix=13]="pathConstraintMix",e[e.twoColor=14]="twoColor",e))(Pe||{});const Q=class{constructor(e){if(this.curveData=[],e<=0)throw new Error(`frameCount must be > 0: ${e}`);this.curves=k.newFloatArray((e-1)*Q.BEZIER_SIZE)}getFrameCount(){return this.curves.length/Q.BEZIER_SIZE+1}setLinear(e){this.curves[e*Q.BEZIER_SIZE]=Q.LINEAR}setStepped(e){this.curves[e*Q.BEZIER_SIZE]=Q.STEPPED}getCurveType(e){const t=e*Q.BEZIER_SIZE;if(t==this.curves.length)return Q.LINEAR;const s=this.curves[t];return s==Q.LINEAR?Q.LINEAR:s==Q.STEPPED?Q.STEPPED:Q.BEZIER}setCurve(e,t,s,n,a){this.curveData.push({frameIndex:e,cx1:t,cy1:s,cx2:n,cy2:a});const h=(-t*2+n)*.03,c=(-s*2+a)*.03,o=((t-n)*3+1)*.006,r=((s-a)*3+1)*.006;let i=h*2+o,l=c*2+r,d=t*.3+h+o*.16666667,m=s*.3+c+r*.16666667,u=e*Q.BEZIER_SIZE;const f=this.curves;f[u++]=Q.BEZIER;let p=d,g=m;for(let x=u+Q.BEZIER_SIZE-1;u<x;u+=2)f[u]=p,f[u+1]=g,d+=i,m+=l,i+=o,l+=r,p+=d,g+=m}getCurvePercent(e,t){t=y.clamp(t,0,1);const s=this.curves;let n=e*Q.BEZIER_SIZE;const a=s[n];if(a==Q.LINEAR)return t;if(a==Q.STEPPED)return 0;n++;let h=0;for(let o=n,r=n+Q.BEZIER_SIZE-1;n<r;n+=2)if(h=s[n],h>=t){let i,l;return n==o?(i=0,l=0):(i=s[n-2],l=s[n-1]),l+(s[n+1]-l)*(t-i)/(h-i)}const c=s[n-1];return c+(1-c)*(t-h)/(1-h)}};let ut=Q;ut.LINEAR=0,ut.STEPPED=1,ut.BEZIER=2,ut.BEZIER_SIZE=10*2-1;const Nt=class extends ut{constructor(t){super(t),this.data=[],this.frames=k.newFloatArray(t<<1)}getPropertyId(){return(0<<24)+this.boneIndex}setFrame(t,s,n){this.data.push({type:"RotateTimeline",frameIndex:t,time:s,degrees:n}),t<<=1,this.frames[t]=s,this.frames[t+Nt.ROTATION]=n}apply(t,s,n,a,h,c,o){const r=this.frames,i=t.bones[this.boneIndex];if(!i.active)return;if(n<r[0]){switch(c){case A.setup:i.rotation=i.data.rotation;return;case A.first:const p=i.data.rotation-i.rotation;i.rotation+=(p-(16384-(16384.499999999996-p/360|0))*360)*h}return}if(n>=r[r.length-Nt.ENTRIES]){let p=r[r.length+Nt.PREV_ROTATION];switch(c){case A.setup:i.rotation=i.data.rotation+p*h;break;case A.first:case A.replace:p+=i.data.rotation-i.rotation,p-=(16384-(16384.499999999996-p/360|0))*360;case A.add:i.rotation+=p*h}return}const l=z.binarySearch(r,n,Nt.ENTRIES),d=r[l+Nt.PREV_ROTATION],m=r[l],u=this.getCurvePercent((l>>1)-1,1-(n-m)/(r[l+Nt.PREV_TIME]-m));let f=r[l+Nt.ROTATION]-d;switch(f=d+(f-(16384-(16384.499999999996-f/360|0))*360)*u,c){case A.setup:i.rotation=i.data.rotation+(f-(16384-(16384.499999999996-f/360|0))*360)*h;break;case A.first:case A.replace:f+=i.data.rotation-i.rotation;case A.add:i.rotation+=(f-(16384-(16384.499999999996-f/360|0))*360)*h}}};let st=Nt;st.ENTRIES=2,st.PREV_TIME=-2,st.PREV_ROTATION=-1,st.ROTATION=1;const ot=class extends ut{constructor(e){super(e),this.data=[],this.frames=k.newFloatArray(e*ot.ENTRIES)}getPropertyId(){return(1<<24)+this.boneIndex}setFrame(e,t,s,n){this.data.push({type:"TranslateTimeline",frameIndex:e,time:t,x:s,y:n}),e*=ot.ENTRIES,this.frames[e]=t,this.frames[e+ot.X]=s,this.frames[e+ot.Y]=n}apply(e,t,s,n,a,h,c){const o=this.frames,r=e.bones[this.boneIndex];if(!r.active)return;if(s<o[0]){switch(h){case A.setup:r.x=r.data.x,r.y=r.data.y;return;case A.first:r.x+=(r.data.x-r.x)*a,r.y+=(r.data.y-r.y)*a}return}let i=0,l=0;if(s>=o[o.length-ot.ENTRIES])i=o[o.length+ot.PREV_X],l=o[o.length+ot.PREV_Y];else{const d=z.binarySearch(o,s,ot.ENTRIES);i=o[d+ot.PREV_X],l=o[d+ot.PREV_Y];const m=o[d],u=this.getCurvePercent(d/ot.ENTRIES-1,1-(s-m)/(o[d+ot.PREV_TIME]-m));i+=(o[d+ot.X]-i)*u,l+=(o[d+ot.Y]-l)*u}switch(h){case A.setup:r.x=r.data.x+i*a,r.y=r.data.y+l*a;break;case A.first:case A.replace:r.x+=(r.data.x+i-r.x)*a,r.y+=(r.data.y+l-r.y)*a;break;case A.add:r.x+=i*a,r.y+=l*a}}};let xt=ot;xt.ENTRIES=3,xt.PREV_TIME=-3,xt.PREV_X=-2,xt.PREV_Y=-1,xt.X=1,xt.Y=2;class ft extends xt{constructor(t){super(t)}getPropertyId(){return(2<<24)+this.boneIndex}apply(t,s,n,a,h,c,o){const r=this.frames,i=t.bones[this.boneIndex];if(!i.active)return;if(n<r[0]){switch(c){case A.setup:i.scaleX=i.data.scaleX,i.scaleY=i.data.scaleY;return;case A.first:i.scaleX+=(i.data.scaleX-i.scaleX)*h,i.scaleY+=(i.data.scaleY-i.scaleY)*h}return}let l=0,d=0;if(n>=r[r.length-ft.ENTRIES])l=r[r.length+ft.PREV_X]*i.data.scaleX,d=r[r.length+ft.PREV_Y]*i.data.scaleY;else{const m=z.binarySearch(r,n,ft.ENTRIES);l=r[m+ft.PREV_X],d=r[m+ft.PREV_Y];const u=r[m],f=this.getCurvePercent(m/ft.ENTRIES-1,1-(n-u)/(r[m+ft.PREV_TIME]-u));l=(l+(r[m+ft.X]-l)*f)*i.data.scaleX,d=(d+(r[m+ft.Y]-d)*f)*i.data.scaleY}if(h==1)c==A.add?(i.scaleX+=l-i.data.scaleX,i.scaleY+=d-i.data.scaleY):(i.scaleX=l,i.scaleY=d);else{let m=0,u=0;if(o==bt.mixOut)switch(c){case A.setup:m=i.data.scaleX,u=i.data.scaleY,i.scaleX=m+(Math.abs(l)*y.signum(m)-m)*h,i.scaleY=u+(Math.abs(d)*y.signum(u)-u)*h;break;case A.first:case A.replace:m=i.scaleX,u=i.scaleY,i.scaleX=m+(Math.abs(l)*y.signum(m)-m)*h,i.scaleY=u+(Math.abs(d)*y.signum(u)-u)*h;break;case A.add:m=i.scaleX,u=i.scaleY,i.scaleX=m+(Math.abs(l)*y.signum(m)-i.data.scaleX)*h,i.scaleY=u+(Math.abs(d)*y.signum(u)-i.data.scaleY)*h}else switch(c){case A.setup:m=Math.abs(i.data.scaleX)*y.signum(l),u=Math.abs(i.data.scaleY)*y.signum(d),i.scaleX=m+(l-m)*h,i.scaleY=u+(d-u)*h;break;case A.first:case A.replace:m=Math.abs(i.scaleX)*y.signum(l),u=Math.abs(i.scaleY)*y.signum(d),i.scaleX=m+(l-m)*h,i.scaleY=u+(d-u)*h;break;case A.add:m=y.signum(l),u=y.signum(d),i.scaleX=Math.abs(i.scaleX)*m+(l-Math.abs(i.data.scaleX)*m)*h,i.scaleY=Math.abs(i.scaleY)*u+(d-Math.abs(i.data.scaleY)*u)*h}}}}class gt extends xt{constructor(t){super(t)}getPropertyId(){return(3<<24)+this.boneIndex}apply(t,s,n,a,h,c,o){const r=this.frames,i=t.bones[this.boneIndex];if(!i.active)return;if(n<r[0]){switch(c){case A.setup:i.shearX=i.data.shearX,i.shearY=i.data.shearY;return;case A.first:i.shearX+=(i.data.shearX-i.shearX)*h,i.shearY+=(i.data.shearY-i.shearY)*h}return}let l=0,d=0;if(n>=r[r.length-gt.ENTRIES])l=r[r.length+gt.PREV_X],d=r[r.length+gt.PREV_Y];else{const m=z.binarySearch(r,n,gt.ENTRIES);l=r[m+gt.PREV_X],d=r[m+gt.PREV_Y];const u=r[m],f=this.getCurvePercent(m/gt.ENTRIES-1,1-(n-u)/(r[m+gt.PREV_TIME]-u));l=l+(r[m+gt.X]-l)*f,d=d+(r[m+gt.Y]-d)*f}switch(c){case A.setup:i.shearX=i.data.shearX+l*h,i.shearY=i.data.shearY+d*h;break;case A.first:case A.replace:i.shearX+=(i.data.shearX+l-i.shearX)*h,i.shearY+=(i.data.shearY+d-i.shearY)*h;break;case A.add:i.shearX+=l*h,i.shearY+=d*h}}}const q=class extends ut{constructor(e){super(e),this.data=[],this.frames=k.newFloatArray(e*q.ENTRIES)}getPropertyId(){return(5<<24)+this.slotIndex}setFrame(e,t,s,n,a,h){this.data.push({type:"ColorTimeline",frameIndex:e,time:t,r:s,g:n,b:a,a:h}),e*=q.ENTRIES,this.frames[e]=t,this.frames[e+q.R]=s,this.frames[e+q.G]=n,this.frames[e+q.B]=a,this.frames[e+q.A]=h}apply(e,t,s,n,a,h,c){const o=e.slots[this.slotIndex];if(!o.bone.active)return;const r=this.frames;if(s<r[0]){switch(h){case A.setup:o.color.setFromColor(o.data.color);return;case A.first:const u=o.color,f=o.data.color;u.add((f.r-u.r)*a,(f.g-u.g)*a,(f.b-u.b)*a,(f.a-u.a)*a)}return}let i=0,l=0,d=0,m=0;if(s>=r[r.length-q.ENTRIES]){const u=r.length;i=r[u+q.PREV_R],l=r[u+q.PREV_G],d=r[u+q.PREV_B],m=r[u+q.PREV_A]}else{const u=z.binarySearch(r,s,q.ENTRIES);i=r[u+q.PREV_R],l=r[u+q.PREV_G],d=r[u+q.PREV_B],m=r[u+q.PREV_A];const f=r[u],p=this.getCurvePercent(u/q.ENTRIES-1,1-(s-f)/(r[u+q.PREV_TIME]-f));i+=(r[u+q.R]-i)*p,l+=(r[u+q.G]-l)*p,d+=(r[u+q.B]-d)*p,m+=(r[u+q.A]-m)*p}if(a==1)o.color.set(i,l,d,m);else{const u=o.color;h==A.setup&&u.setFromColor(o.data.color),u.add((i-u.r)*a,(l-u.g)*a,(d-u.b)*a,(m-u.a)*a)}}};let lt=q;lt.ENTRIES=5,lt.PREV_TIME=-5,lt.PREV_R=-4,lt.PREV_G=-3,lt.PREV_B=-2,lt.PREV_A=-1,lt.R=1,lt.G=2,lt.B=3,lt.A=4;const L=class extends ut{constructor(e){super(e),this.data=[],this.frames=k.newFloatArray(e*L.ENTRIES)}getPropertyId(){return(14<<24)+this.slotIndex}setFrame(e,t,s,n,a,h,c,o,r){this.data.push({type:"TwoColorTimeline",frameIndex:e,time:t,r:s,g:n,b:a,a:h,r2:c,g2:o,b2:r}),e*=L.ENTRIES,this.frames[e]=t,this.frames[e+L.R]=s,this.frames[e+L.G]=n,this.frames[e+L.B]=a,this.frames[e+L.A]=h,this.frames[e+L.R2]=c,this.frames[e+L.G2]=o,this.frames[e+L.B2]=r}apply(e,t,s,n,a,h,c){const o=e.slots[this.slotIndex];if(!o.bone.active)return;const r=this.frames;if(s<r[0]){switch(h){case A.setup:o.color.setFromColor(o.data.color),o.darkColor.setFromColor(o.data.darkColor);return;case A.first:const g=o.color,x=o.darkColor,E=o.data.color,w=o.data.darkColor;g.add((E.r-g.r)*a,(E.g-g.g)*a,(E.b-g.b)*a,(E.a-g.a)*a),x.add((w.r-x.r)*a,(w.g-x.g)*a,(w.b-x.b)*a,0)}return}let i=0,l=0,d=0,m=0,u=0,f=0,p=0;if(s>=r[r.length-L.ENTRIES]){const g=r.length;i=r[g+L.PREV_R],l=r[g+L.PREV_G],d=r[g+L.PREV_B],m=r[g+L.PREV_A],u=r[g+L.PREV_R2],f=r[g+L.PREV_G2],p=r[g+L.PREV_B2]}else{const g=z.binarySearch(r,s,L.ENTRIES);i=r[g+L.PREV_R],l=r[g+L.PREV_G],d=r[g+L.PREV_B],m=r[g+L.PREV_A],u=r[g+L.PREV_R2],f=r[g+L.PREV_G2],p=r[g+L.PREV_B2];const x=r[g],E=this.getCurvePercent(g/L.ENTRIES-1,1-(s-x)/(r[g+L.PREV_TIME]-x));i+=(r[g+L.R]-i)*E,l+=(r[g+L.G]-l)*E,d+=(r[g+L.B]-d)*E,m+=(r[g+L.A]-m)*E,u+=(r[g+L.R2]-u)*E,f+=(r[g+L.G2]-f)*E,p+=(r[g+L.B2]-p)*E}if(a==1)o.color.set(i,l,d,m),o.darkColor.set(u,f,p,1);else{const g=o.color,x=o.darkColor;h==A.setup&&(g.setFromColor(o.data.color),x.setFromColor(o.data.darkColor)),g.add((i-g.r)*a,(l-g.g)*a,(d-g.b)*a,(m-g.a)*a),x.add((u-x.r)*a,(f-x.g)*a,(p-x.b)*a,0)}}};let tt=L;tt.ENTRIES=8,tt.PREV_TIME=-8,tt.PREV_R=-7,tt.PREV_G=-6,tt.PREV_B=-5,tt.PREV_A=-4,tt.PREV_R2=-3,tt.PREV_G2=-2,tt.PREV_B2=-1,tt.R=1,tt.G=2,tt.B=3,tt.A=4,tt.R2=5,tt.G2=6,tt.B2=7;class vt{constructor(t){this.data=[],this.frames=k.newFloatArray(t),this.attachmentNames=new Array(t)}getPropertyId(){return(4<<24)+this.slotIndex}getFrameCount(){return this.frames.length}setFrame(t,s,n){this.data.push({type:"AttachmentTimeline",frameIndex:t,time:s,attachmentName:n}),this.frames[t]=s,this.attachmentNames[t]=n}apply(t,s,n,a,h,c,o){const r=t.slots[this.slotIndex];if(!r.bone.active)return;if(o==bt.mixOut){c==A.setup&&this.setAttachment(t,r,r.data.attachmentName);return}const i=this.frames;if(n<i[0]){(c==A.setup||c==A.first)&&this.setAttachment(t,r,r.data.attachmentName);return}let l=0;n>=i[i.length-1]?l=i.length-1:l=z.binarySearch(i,n,1)-1;const d=this.attachmentNames[l];t.slots[this.slotIndex].setAttachment(d==null?null:t.getAttachment(this.slotIndex,d))}setAttachment(t,s,n){s.setAttachment(n==null?null:t.getAttachment(this.slotIndex,n))}}let Fe=null;class re extends ut{constructor(t){super(t),this.data=[],this.frames=k.newFloatArray(t),this.frameVertices=new Array(t),Fe==null&&(Fe=k.newFloatArray(64))}getPropertyId(){return(6<<27)+Number(this.attachment.id)+this.slotIndex}setFrame(t,s,n,a){this.data.push({type:"DeformTimeline",frameIndex:t,time:s,vertices:n,skin:a}),this.frames[t]=s,this.frameVertices[t]=n}apply(t,s,n,a,h,c,o){const r=t.slots[this.slotIndex];if(!r.bone.active)return;const i=r.getAttachment();if(!(i instanceof Ft)||i.deformAttachment!=this.attachment)return;const l=r.deform||[];l.length==0&&(c=A.setup);const d=this.frameVertices,m=d[0].length,u=this.frames;if(n<u[0]){const b=i;switch(c){case A.setup:l.length=0;return;case A.first:if(h==1){l.length=0;break}const I=k.setArraySize(l,m);if(b.bones==null){const M=b.vertices;for(let S=0;S<m;S++)I[S]+=(M[S]-I[S])*h}else{h=1-h;for(let M=0;M<m;M++)I[M]*=h}}return}const f=k.setArraySize(l,m);if(n>=u[u.length-1]){const b=d[u.length-1];if(h==1)if(c==A.add){const I=i;if(I.bones==null){const M=I.vertices;for(let S=0;S<m;S++)f[S]+=b[S]-M[S]}else for(let M=0;M<m;M++)f[M]+=b[M]}else k.arrayCopy(b,0,f,0,m);else switch(c){case A.setup:{const M=i;if(M.bones==null){const S=M.vertices;for(let R=0;R<m;R++){const T=S[R];f[R]=T+(b[R]-T)*h}}else for(let S=0;S<m;S++)f[S]=b[S]*h;break}case A.first:case A.replace:for(let M=0;M<m;M++)f[M]+=(b[M]-f[M])*h;break;case A.add:const I=i;if(I.bones==null){const M=I.vertices;for(let S=0;S<m;S++)f[S]+=(b[S]-M[S])*h}else for(let M=0;M<m;M++)f[M]+=b[M]*h}return}const p=z.binarySearch(u,n),g=d[p-1],x=d[p],E=u[p],w=this.getCurvePercent(p-1,1-(n-E)/(u[p-1]-E));if(h==1)if(c==A.add){const b=i;if(b.bones==null){const I=b.vertices;for(let M=0;M<m;M++){const S=g[M];f[M]+=S+(x[M]-S)*w-I[M]}}else for(let I=0;I<m;I++){const M=g[I];f[I]+=M+(x[I]-M)*w}}else for(let b=0;b<m;b++){const I=g[b];f[b]=I+(x[b]-I)*w}else switch(c){case A.setup:{const I=i;if(I.bones==null){const M=I.vertices;for(let S=0;S<m;S++){const R=g[S],T=M[S];f[S]=T+(R+(x[S]-R)*w-T)*h}}else for(let M=0;M<m;M++){const S=g[M];f[M]=(S+(x[M]-S)*w)*h}break}case A.first:case A.replace:for(let I=0;I<m;I++){const M=g[I];f[I]+=(M+(x[I]-M)*w-f[I])*h}break;case A.add:const b=i;if(b.bones==null){const I=b.vertices;for(let M=0;M<m;M++){const S=g[M];f[M]+=(S+(x[M]-S)*w-I[M])*h}}else for(let I=0;I<m;I++){const M=g[I];f[I]+=(M+(x[I]-M)*w)*h}}}}class Gt{constructor(t){this.data=[],this.frames=k.newFloatArray(t),this.events=new Array(t)}getPropertyId(){return 7<<24}getFrameCount(){return this.frames.length}setFrame(t,s){this.data.push({type:"EventTimeline",frameIndex:t,event:s}),this.frames[t]=s.time,this.events[t]=s}apply(t,s,n,a,h,c,o){if(a==null)return;const r=this.frames,i=this.frames.length;if(s>n)this.apply(t,s,Number.MAX_VALUE,a,h,c,o),s=-1;else if(s>=r[i-1])return;if(n<r[0])return;let l=0;if(s<r[0])l=0;else{l=z.binarySearch(r,s);const d=r[l];for(;l>0&&r[l-1]==d;)l--}for(;l<i&&n>=r[l];l++)a.push(this.events[l])}}class _t{constructor(t){this.data=[],this.frames=k.newFloatArray(t),this.drawOrders=new Array(t)}getPropertyId(){return 8<<24}getFrameCount(){return this.frames.length}setFrame(t,s,n){this.data.push({type:"DrawOrderTimeline",frameIndex:t,time:s,drawOrder:n}),this.frames[t]=s,this.drawOrders[t]=n}apply(t,s,n,a,h,c,o){const r=t.drawOrder,i=t.slots;if(o==bt.mixOut&&c==A.setup){k.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}const l=this.frames;if(n<l[0]){(c==A.setup||c==A.first)&&k.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}let d=0;n>=l[l.length-1]?d=l.length-1:d=z.binarySearch(l,n)-1;const m=this.drawOrders[d];if(m==null)k.arrayCopy(i,0,r,0,i.length);else for(let u=0,f=m.length;u<f;u++)r[u]=i[m[u]]}}const j=class extends ut{constructor(e){super(e),this.data=[],this.frames=k.newFloatArray(e*j.ENTRIES)}getPropertyId(){return(9<<24)+this.ikConstraintIndex}setFrame(e,t,s,n){this.data.push({type:"IkConstraintTimeline",frameIndex:e,time:t,mix:s,bendDirection:n}),e*=j.ENTRIES,this.frames[e]=t,this.frames[e+j.MIX]=s,this.frames[e+j.BEND_DIRECTION]=n}apply(e,t,s,n,a,h,c){const o=this.frames,r=e.ikConstraints[this.ikConstraintIndex];if(!r.active)return;if(s<o[0]){switch(h){case A.setup:r.mix=r.data.mix,r.softness=r.data.softness,r.bendDirection=r.data.bendDirection,r.compress=r.data.compress,r.stretch=r.data.stretch;return;case A.first:r.mix+=(r.data.mix-r.mix)*a,r.softness+=(r.data.softness-r.softness)*a,r.bendDirection=r.data.bendDirection,r.compress=r.data.compress,r.stretch=r.data.stretch}return}if(s>=o[o.length-j.ENTRIES]){h===A.setup?(r.mix=r.data.mix+(o[o.length+j.PREV_MIX]-r.data.mix)*a,r.softness=r.data.softness+(o[o.length+j.PREV_SOFTNESS]-r.data.softness)*a,c===bt.mixOut?(r.bendDirection=r.data.bendDirection,r.compress=r.data.compress,r.stretch=r.data.stretch):(r.bendDirection=o[o.length+j.PREV_BEND_DIRECTION],r.compress=o[o.length+j.PREV_COMPRESS]!==0,r.stretch=o[o.length+j.PREV_STRETCH]!==0)):(r.mix+=(o[o.length+j.PREV_MIX]-r.mix)*a,r.softness+=(o[o.length+j.PREV_SOFTNESS]-r.softness)*a,c===bt.mixIn&&(r.bendDirection=o[o.length+j.PREV_BEND_DIRECTION],r.compress=o[o.length+j.PREV_COMPRESS]!==0,r.stretch=o[o.length+j.PREV_STRETCH]!==0));return}const i=z.binarySearch(o,s,j.ENTRIES),l=o[i+j.PREV_MIX],d=o[i],m=this.getCurvePercent(i/j.ENTRIES-1,1-(s-d)/(o[i+j.PREV_TIME]-d));r.mix+=(l+(o[i+j.MIX]-l)*m-r.mix)*a,r.bendDirection=Math.floor(o[i+j.PREV_BEND_DIRECTION])}};let at=j;at.ENTRIES=6,at.PREV_TIME=-6,at.PREV_MIX=-5,at.PREV_SOFTNESS=-4,at.PREV_BEND_DIRECTION=-3,at.PREV_COMPRESS=-2,at.PREV_STRETCH=-1,at.MIX=1,at.SOFTNESS=2,at.BEND_DIRECTION=3,at.COMPRESS=4,at.STRETCH=5;const U=class extends ut{constructor(t){super(t),this.data=[],this.frames=k.newFloatArray(t*U.ENTRIES)}getPropertyId(){return(10<<24)+this.transformConstraintIndex}setFrame(t,s,n,a,h,c){this.data.push({type:"TransformConstraintTimeline",frameIndex:t,time:s,rotateMix:n,translateMix:a,scaleMix:h,shearMix:c}),t*=U.ENTRIES,this.frames[t]=s,this.frames[t+U.ROTATE]=n,this.frames[t+U.TRANSLATE]=a,this.frames[t+U.SCALE]=h,this.frames[t+U.SHEAR]=c}apply(t,s,n,a,h,c,o){const r=this.frames,i=t.transformConstraints[this.transformConstraintIndex];if(!i.active)return;if(n<r[0]){const f=i.data;switch(c){case A.setup:i.rotateMix=f.rotateMix,i.translateMix=f.translateMix,i.scaleMix=f.scaleMix,i.shearMix=f.shearMix;return;case A.first:i.rotateMix+=(f.rotateMix-i.rotateMix)*h,i.translateMix+=(f.translateMix-i.translateMix)*h,i.scaleMix+=(f.scaleMix-i.scaleMix)*h,i.shearMix+=(f.shearMix-i.shearMix)*h}return}let l=0,d=0,m=0,u=0;if(n>=r[r.length-U.ENTRIES]){const f=r.length;l=r[f+U.PREV_ROTATE],d=r[f+U.PREV_TRANSLATE],m=r[f+U.PREV_SCALE],u=r[f+U.PREV_SHEAR]}else{const f=z.binarySearch(r,n,U.ENTRIES);l=r[f+U.PREV_ROTATE],d=r[f+U.PREV_TRANSLATE],m=r[f+U.PREV_SCALE],u=r[f+U.PREV_SHEAR];const p=r[f],g=this.getCurvePercent(f/U.ENTRIES-1,1-(n-p)/(r[f+U.PREV_TIME]-p));l+=(r[f+U.ROTATE]-l)*g,d+=(r[f+U.TRANSLATE]-d)*g,m+=(r[f+U.SCALE]-m)*g,u+=(r[f+U.SHEAR]-u)*g}if(c==A.setup){const f=i.data;i.rotateMix=f.rotateMix+(l-f.rotateMix)*h,i.translateMix=f.translateMix+(d-f.translateMix)*h,i.scaleMix=f.scaleMix+(m-f.scaleMix)*h,i.shearMix=f.shearMix+(u-f.shearMix)*h}else i.rotateMix+=(l-i.rotateMix)*h,i.translateMix+=(d-i.translateMix)*h,i.scaleMix+=(m-i.scaleMix)*h,i.shearMix+=(u-i.shearMix)*h}};let ht=U;ht.ENTRIES=5,ht.PREV_TIME=-5,ht.PREV_ROTATE=-4,ht.PREV_TRANSLATE=-3,ht.PREV_SCALE=-2,ht.PREV_SHEAR=-1,ht.ROTATE=1,ht.TRANSLATE=2,ht.SCALE=3,ht.SHEAR=4;const Mt=class extends ut{constructor(e){super(e),this.data=[],this.frames=k.newFloatArray(e*Mt.ENTRIES)}getPropertyId(){return(11<<24)+this.pathConstraintIndex}setFrame(e,t,s){this.data.push({type:"PathConstraintPositionTimeline",frameIndex:e,time:t,value:s}),e*=Mt.ENTRIES,this.frames[e]=t,this.frames[e+Mt.VALUE]=s}apply(e,t,s,n,a,h,c){const o=this.frames,r=e.pathConstraints[this.pathConstraintIndex];if(!r.active)return;if(s<o[0]){switch(h){case A.setup:r.position=r.data.position;return;case A.first:r.position+=(r.data.position-r.position)*a}return}let i=0;if(s>=o[o.length-Mt.ENTRIES])i=o[o.length+Mt.PREV_VALUE];else{const l=z.binarySearch(o,s,Mt.ENTRIES);i=o[l+Mt.PREV_VALUE];const d=o[l],m=this.getCurvePercent(l/Mt.ENTRIES-1,1-(s-d)/(o[l+Mt.PREV_TIME]-d));i+=(o[l+Mt.VALUE]-i)*m}h==A.setup?r.position=r.data.position+(i-r.data.position)*a:r.position+=(i-r.position)*a}};let yt=Mt;yt.ENTRIES=2,yt.PREV_TIME=-2,yt.PREV_VALUE=-1,yt.VALUE=1;class St extends yt{constructor(t){super(t)}getPropertyId(){return(12<<24)+this.pathConstraintIndex}apply(t,s,n,a,h,c,o){const r=this.frames,i=t.pathConstraints[this.pathConstraintIndex];if(!i.active)return;if(n<r[0]){switch(c){case A.setup:i.spacing=i.data.spacing;return;case A.first:i.spacing+=(i.data.spacing-i.spacing)*h}return}let l=0;if(n>=r[r.length-St.ENTRIES])l=r[r.length+St.PREV_VALUE];else{const d=z.binarySearch(r,n,St.ENTRIES);l=r[d+St.PREV_VALUE];const m=r[d],u=this.getCurvePercent(d/St.ENTRIES-1,1-(n-m)/(r[d+St.PREV_TIME]-m));l+=(r[d+St.VALUE]-l)*u}c==A.setup?i.spacing=i.data.spacing+(l-i.data.spacing)*h:i.spacing+=(l-i.spacing)*h}}const ct=class extends ut{constructor(e){super(e),this.data=[],this.frames=k.newFloatArray(e*ct.ENTRIES)}getPropertyId(){return(13<<24)+this.pathConstraintIndex}setFrame(e,t,s,n){this.data.push({type:"PathConstraintMixTimeline",frameIndex:e,time:t,rotateMix:s,translateMix:n}),e*=ct.ENTRIES,this.frames[e]=t,this.frames[e+ct.ROTATE]=s,this.frames[e+ct.TRANSLATE]=n}apply(e,t,s,n,a,h,c){const o=this.frames,r=e.pathConstraints[this.pathConstraintIndex];if(!r.active)return;if(s<o[0]){switch(h){case A.setup:r.rotateMix=r.data.rotateMix,r.translateMix=r.data.translateMix;return;case A.first:r.rotateMix+=(r.data.rotateMix-r.rotateMix)*a,r.translateMix+=(r.data.translateMix-r.translateMix)*a}return}let i=0,l=0;if(s>=o[o.length-ct.ENTRIES])i=o[o.length+ct.PREV_ROTATE],l=o[o.length+ct.PREV_TRANSLATE];else{const d=z.binarySearch(o,s,ct.ENTRIES);i=o[d+ct.PREV_ROTATE],l=o[d+ct.PREV_TRANSLATE];const m=o[d],u=this.getCurvePercent(d/ct.ENTRIES-1,1-(s-m)/(o[d+ct.PREV_TIME]-m));i+=(o[d+ct.ROTATE]-i)*u,l+=(o[d+ct.TRANSLATE]-l)*u}h==A.setup?(r.rotateMix=r.data.rotateMix+(i-r.data.rotateMix)*a,r.translateMix=r.data.translateMix+(l-r.data.translateMix)*a):(r.rotateMix+=(i-r.rotateMix)*a,r.translateMix+=(l-r.translateMix)*a)}};let It=ct;It.ENTRIES=3,It.PREV_TIME=-3,It.PREV_ROTATE=-2,It.PREV_TRANSLATE=-1,It.ROTATE=1,It.TRANSLATE=2;const $=class{constructor(e){this.tracks=new Array,this.timeScale=1,this.unkeyedState=0,this.events=new Array,this.listeners=new Array,this.queue=new oe(this),this.propertyIDs=new Ye,this.animationsChanged=!1,this.trackEntryPool=new De(()=>new jt),this.data=e}update(e){e*=this.timeScale;const t=this.tracks;for(let s=0,n=t.length;s<n;s++){const a=t[s];if(a==null)continue;a.animationLast=a.nextAnimationLast,a.trackLast=a.nextTrackLast;let h=e*a.timeScale;if(a.delay>0){if(a.delay-=h,a.delay>0)continue;h=-a.delay,a.delay=0}let c=a.next;if(c!=null){const o=a.trackLast-c.delay;if(o>=0){for(c.delay=0,c.trackTime+=a.timeScale==0?0:(o/a.timeScale+e)*c.timeScale,a.trackTime+=h,this.setCurrent(s,c,!0);c.mixingFrom!=null;)c.mixTime+=e,c=c.mixingFrom;continue}}else if(a.trackLast>=a.trackEnd&&a.mixingFrom==null){t[s]=null,this.queue.end(a),this.disposeNext(a);continue}if(a.mixingFrom!=null&&this.updateMixingFrom(a,e)){let o=a.mixingFrom;for(a.mixingFrom=null,o!=null&&(o.mixingTo=null);o!=null;)this.queue.end(o),o=o.mixingFrom}a.trackTime+=h}this.queue.drain()}updateMixingFrom(e,t){const s=e.mixingFrom;if(s==null)return!0;const n=this.updateMixingFrom(s,t);return s.animationLast=s.nextAnimationLast,s.trackLast=s.nextTrackLast,e.mixTime>0&&e.mixTime>=e.mixDuration?((s.totalAlpha==0||e.mixDuration==0)&&(e.mixingFrom=s.mixingFrom,s.mixingFrom!=null&&(s.mixingFrom.mixingTo=e),e.interruptAlpha=s.interruptAlpha,this.queue.end(s)),n):(s.trackTime+=t*s.timeScale,e.mixTime+=t,!1)}apply(e){if(e==null)throw new Error("skeleton cannot be null.");this.animationsChanged&&this._animationsChanged();const t=this.events,s=this.tracks;let n=!1;for(let c=0,o=s.length;c<o;c++){const r=s[c];if(r==null||r.delay>0)continue;n=!0;const i=c==0?A.first:r.mixBlend;let l=r.alpha;r.mixingFrom!=null?l*=this.applyMixingFrom(r,e,i):r.trackTime>=r.trackEnd&&r.next==null&&(l=0);const d=r.animationLast,m=r.getAnimationTime(),u=r.animation.timelines.length,f=r.animation.timelines;if(c==0&&l==1||i==A.add)for(let p=0;p<u;p++){k.webkit602BugfixHelper(l,i);const g=f[p];g instanceof vt?this.applyAttachmentTimeline(g,e,m,i,!0):g.apply(e,d,m,t,l,i,bt.mixIn)}else{const p=r.timelineMode,g=r.timelinesRotation.length==0;g&&k.setArraySize(r.timelinesRotation,u<<1,null);const x=r.timelinesRotation;for(let E=0;E<u;E++){const w=f[E],b=p[E]==$.SUBSEQUENT?i:A.setup;w instanceof st?this.applyRotateTimeline(w,e,m,l,b,x,E<<1,g):w instanceof vt?this.applyAttachmentTimeline(w,e,m,i,!0):(k.webkit602BugfixHelper(l,i),w.apply(e,d,m,t,l,b,bt.mixIn))}}this.queueEvents(r,m),t.length=0,r.nextAnimationLast=m,r.nextTrackLast=r.trackTime}const a=this.unkeyedState+$.SETUP,h=e.slots;for(let c=0,o=e.slots.length;c<o;c++){const r=h[c];if(r.attachmentState==a){const i=r.data.attachmentName;r.setAttachment(i==null?null:e.getAttachment(r.data.index,i))}}return this.unkeyedState+=2,this.queue.drain(),n}applyMixingFrom(e,t,s){const n=e.mixingFrom;n.mixingFrom!=null&&this.applyMixingFrom(n,t,s);let a=0;e.mixDuration==0?(a=1,s==A.first&&(s=A.setup)):(a=e.mixTime/e.mixDuration,a>1&&(a=1),s!=A.first&&(s=n.mixBlend));const h=a<n.eventThreshold?this.events:null,c=a<n.attachmentThreshold,o=a<n.drawOrderThreshold,r=n.animationLast,i=n.getAnimationTime(),l=n.animation.timelines.length,d=n.animation.timelines,m=n.alpha*e.interruptAlpha,u=m*(1-a);if(s==A.add)for(let f=0;f<l;f++)d[f].apply(t,r,i,h,u,s,bt.mixOut);else{const f=n.timelineMode,p=n.timelineHoldMix,g=n.timelinesRotation.length==0;g&&k.setArraySize(n.timelinesRotation,l<<1,null);const x=n.timelinesRotation;n.totalAlpha=0;for(let E=0;E<l;E++){const w=d[E];let b=bt.mixOut,I,M=0;switch(f[E]){case $.SUBSEQUENT:if(!o&&w instanceof _t)continue;I=s,M=u;break;case $.FIRST:I=A.setup,M=u;break;case $.HOLD_SUBSEQUENT:I=s,M=m;break;case $.HOLD_FIRST:I=A.setup,M=m;break;default:I=A.setup;const S=p[E];M=m*Math.max(0,1-S.mixTime/S.mixDuration);break}n.totalAlpha+=M,w instanceof st?this.applyRotateTimeline(w,t,i,M,I,x,E<<1,g):w instanceof vt?this.applyAttachmentTimeline(w,t,i,I,c):(k.webkit602BugfixHelper(M,s),o&&w instanceof _t&&I==A.setup&&(b=bt.mixIn),w.apply(t,r,i,h,M,I,b))}}return e.mixDuration>0&&this.queueEvents(n,i),this.events.length=0,n.nextAnimationLast=i,n.nextTrackLast=n.trackTime,a}applyAttachmentTimeline(e,t,s,n,a){const h=t.slots[e.slotIndex];if(!h.bone.active)return;const c=e.frames;if(s<c[0])(n==A.setup||n==A.first)&&this.setAttachment(t,h,h.data.attachmentName,a);else{let o;s>=c[c.length-1]?o=c.length-1:o=z.binarySearch(c,s)-1,this.setAttachment(t,h,e.attachmentNames[o],a)}h.attachmentState<=this.unkeyedState&&(h.attachmentState=this.unkeyedState+$.SETUP)}setAttachment(e,t,s,n){t.setAttachment(s==null?null:e.getAttachment(t.data.index,s)),n&&(t.attachmentState=this.unkeyedState+$.CURRENT)}applyRotateTimeline(e,t,s,n,a,h,c,o){if(o&&(h[c]=0),n==1){e.apply(t,0,s,null,1,a,bt.mixIn);return}const r=e,i=r.frames,l=t.bones[r.boneIndex];if(!l.active)return;let d=0,m=0;if(s<i[0])switch(a){case A.setup:l.rotation=l.data.rotation;default:return;case A.first:d=l.rotation,m=l.data.rotation}else if(d=a==A.setup?l.data.rotation:l.rotation,s>=i[i.length-st.ENTRIES])m=l.data.rotation+i[i.length+st.PREV_ROTATION];else{const p=z.binarySearch(i,s,st.ENTRIES),g=i[p+st.PREV_ROTATION],x=i[p],E=r.getCurvePercent((p>>1)-1,1-(s-x)/(i[p+st.PREV_TIME]-x));m=i[p+st.ROTATION]-g,m-=(16384-(16384.499999999996-m/360|0))*360,m=g+m*E+l.data.rotation,m-=(16384-(16384.499999999996-m/360|0))*360}let u=0,f=m-d;if(f-=(16384-(16384.499999999996-f/360|0))*360,f==0)u=h[c];else{let p=0,g=0;o?(p=0,g=f):(p=h[c],g=h[c+1]);const x=f>0;let E=p>=0;y.signum(g)!=y.signum(f)&&Math.abs(g)<=90&&(Math.abs(p)>180&&(p+=360*y.signum(p)),E=x),u=f+p-p%360,E!=x&&(u+=360*y.signum(p)),h[c]=u}h[c+1]=f,d+=u*n,l.rotation=d-(16384-(16384.499999999996-d/360|0))*360}queueEvents(e,t){const s=e.animationStart,n=e.animationEnd,a=n-s,h=e.trackLast%a,c=this.events;let o=0;const r=c.length;for(;o<r;o++){const l=c[o];if(l.time<h)break;l.time>n||this.queue.event(e,l)}let i=!1;for(e.loop?i=a==0||h>e.trackTime%a:i=t>=n&&e.animationLast<n,i&&this.queue.complete(e);o<r;o++)c[o].time<s||this.queue.event(e,c[o])}clearTracks(){const e=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let t=0,s=this.tracks.length;t<s;t++)this.clearTrack(t);this.tracks.length=0,this.queue.drainDisabled=e,this.queue.drain()}clearTrack(e){if(e>=this.tracks.length)return;const t=this.tracks[e];if(t==null)return;this.queue.end(t),this.disposeNext(t);let s=t;for(;;){const n=s.mixingFrom;if(n==null)break;this.queue.end(n),s.mixingFrom=null,s.mixingTo=null,s=n}this.tracks[t.trackIndex]=null,this.queue.drain()}setCurrent(e,t,s){const n=this.expandToIndex(e);this.tracks[e]=t,n!=null&&(s&&this.queue.interrupt(n),t.mixingFrom=n,n.mixingTo=t,t.mixTime=0,n.mixingFrom!=null&&n.mixDuration>0&&(t.interruptAlpha*=Math.min(1,n.mixTime/n.mixDuration)),n.timelinesRotation.length=0),this.queue.start(t)}setAnimation(e,t,s){const n=this.data.skeletonData.findAnimation(t);if(n==null)throw new Error(`Animation not found: ${t}`);return this.setAnimationWith(e,n,s)}setAnimationWith(e,t,s){if(t==null)throw new Error("animation cannot be null.");let n=!0,a=this.expandToIndex(e);a!=null&&(a.nextTrackLast==-1?(this.tracks[e]=a.mixingFrom,this.queue.interrupt(a),this.queue.end(a),this.disposeNext(a),a=a.mixingFrom,n=!1):this.disposeNext(a));const h=this.trackEntry(e,t,s,a);return this.setCurrent(e,h,n),this.queue.drain(),h}addAnimation(e,t,s,n){const a=this.data.skeletonData.findAnimation(t);if(a==null)throw new Error(`Animation not found: ${t}`);return this.addAnimationWith(e,a,s,n)}addAnimationWith(e,t,s,n){if(t==null)throw new Error("animation cannot be null.");let a=this.expandToIndex(e);if(a!=null)for(;a.next!=null;)a=a.next;const h=this.trackEntry(e,t,s,a);if(a==null)this.setCurrent(e,h,!0),this.queue.drain();else if(a.next=h,n<=0){const c=a.animationEnd-a.animationStart;c!=0?(a.loop?n+=c*(1+(a.trackTime/c|0)):n+=Math.max(c,a.trackTime),n-=this.data.getMix(a.animation,t)):n=a.trackTime}return h.delay=n,h}setEmptyAnimation(e,t){const s=this.setAnimationWith(e,$.emptyAnimation,!1);return s.mixDuration=t,s.trackEnd=t,s}addEmptyAnimation(e,t,s){s<=0&&(s-=t);const n=this.addAnimationWith(e,$.emptyAnimation,!1,s);return n.mixDuration=t,n.trackEnd=t,n}setEmptyAnimations(e){const t=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let s=0,n=this.tracks.length;s<n;s++){const a=this.tracks[s];a!=null&&this.setEmptyAnimation(a.trackIndex,e)}this.queue.drainDisabled=t,this.queue.drain()}expandToIndex(e){return e<this.tracks.length?this.tracks[e]:(k.ensureArrayCapacity(this.tracks,e+1,null),this.tracks.length=e+1,null)}trackEntry(e,t,s,n){const a=this.trackEntryPool.obtain();return a.trackIndex=e,a.animation=t,a.loop=s,a.holdPrevious=!1,a.eventThreshold=0,a.attachmentThreshold=0,a.drawOrderThreshold=0,a.animationStart=0,a.animationEnd=t.duration,a.animationLast=-1,a.nextAnimationLast=-1,a.delay=0,a.trackTime=0,a.trackLast=-1,a.nextTrackLast=-1,a.trackEnd=Number.MAX_VALUE,a.timeScale=1,a.alpha=1,a.interruptAlpha=1,a.mixTime=0,a.mixDuration=n==null?0:this.data.getMix(n.animation,t),a.mixBlend=A.replace,a}disposeNext(e){let t=e.next;for(;t!=null;)this.queue.dispose(t),t=t.next;e.next=null}_animationsChanged(){this.animationsChanged=!1,this.propertyIDs.clear();for(let e=0,t=this.tracks.length;e<t;e++){let s=this.tracks[e];if(s!=null){for(;s.mixingFrom!=null;)s=s.mixingFrom;do(s.mixingFrom==null||s.mixBlend!=A.add)&&this.computeHold(s),s=s.mixingTo;while(s!=null)}}}computeHold(e){const t=e.mixingTo,s=e.animation.timelines,n=e.animation.timelines.length,a=k.setArraySize(e.timelineMode,n);e.timelineHoldMix.length=0;const h=k.setArraySize(e.timelineHoldMix,n),c=this.propertyIDs;if(t!=null&&t.holdPrevious){for(let o=0;o<n;o++)a[o]=c.add(s[o].getPropertyId())?$.HOLD_FIRST:$.HOLD_SUBSEQUENT;return}t:for(let o=0;o<n;o++){const r=s[o],i=r.getPropertyId();if(!c.add(i))a[o]=$.SUBSEQUENT;else if(t==null||r instanceof vt||r instanceof _t||r instanceof Gt||!t.animation.hasTimeline(i))a[o]=$.FIRST;else{for(let l=t.mixingTo;l!=null;l=l.mixingTo)if(!l.animation.hasTimeline(i)){if(e.mixDuration>0){a[o]=$.HOLD_MIX,h[o]=l;continue t}break}a[o]=$.HOLD_FIRST}}}getCurrent(e){return e>=this.tracks.length?null:this.tracks[e]}addListener(e){if(e==null)throw new Error("listener cannot be null.");this.listeners.push(e)}removeListener(e){const t=this.listeners.indexOf(e);t>=0&&this.listeners.splice(t,1)}clearListeners(){this.listeners.length=0}clearListenerNotifications(){this.queue.clear()}setAnimationByName(e,t,s){$.deprecatedWarning1||($.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.")),this.setAnimation(e,t,s)}addAnimationByName(e,t,s,n){$.deprecatedWarning2||($.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.")),this.addAnimation(e,t,s,n)}hasAnimation(e){return this.data.skeletonData.findAnimation(e)!==null}hasAnimationByName(e){return $.deprecatedWarning3||($.deprecatedWarning3=!0,console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.")),this.hasAnimation(e)}};let Et=$;Et.emptyAnimation=new z("<empty>",[],0),Et.SUBSEQUENT=0,Et.FIRST=1,Et.HOLD_SUBSEQUENT=2,Et.HOLD_FIRST=3,Et.HOLD_MIX=4,Et.SETUP=1,Et.CURRENT=2,Et.deprecatedWarning1=!1,Et.deprecatedWarning2=!1,Et.deprecatedWarning3=!1;const Vt=class{constructor(){this.mixBlend=A.replace,this.timelineMode=new Array,this.timelineHoldMix=new Array,this.timelinesRotation=new Array}reset(){this.next=null,this.mixingFrom=null,this.mixingTo=null,this.animation=null,this.listener=null,this.timelineMode.length=0,this.timelineHoldMix.length=0,this.timelinesRotation.length=0}getAnimationTime(){if(this.loop){const e=this.animationEnd-this.animationStart;return e==0?this.animationStart:this.trackTime%e+this.animationStart}return Math.min(this.trackTime+this.animationStart,this.animationEnd)}setAnimationLast(e){this.animationLast=e,this.nextAnimationLast=e}isComplete(){return this.trackTime>=this.animationEnd-this.animationStart}resetRotationDirections(){this.timelinesRotation.length=0}get time(){return Vt.deprecatedWarning1||(Vt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime}set time(e){Vt.deprecatedWarning1||(Vt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime=e}get endTime(){return Vt.deprecatedWarning2||(Vt.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime}set endTime(e){Vt.deprecatedWarning2||(Vt.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime=e}loopsCount(){return Math.floor(this.trackTime/this.trackEnd)}};let jt=Vt;jt.deprecatedWarning1=!1,jt.deprecatedWarning2=!1;const ie=class{constructor(e){this.objects=[],this.drainDisabled=!1,this.animState=e}start(e){this.objects.push(mt.start),this.objects.push(e),this.animState.animationsChanged=!0}interrupt(e){this.objects.push(mt.interrupt),this.objects.push(e)}end(e){this.objects.push(mt.end),this.objects.push(e),this.animState.animationsChanged=!0}dispose(e){this.objects.push(mt.dispose),this.objects.push(e)}complete(e){this.objects.push(mt.complete),this.objects.push(e)}event(e,t){this.objects.push(mt.event),this.objects.push(e),this.objects.push(t)}deprecateStuff(){return ie.deprecatedWarning1||(ie.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'")),!0}drain(){if(this.drainDisabled)return;this.drainDisabled=!0;const e=this.objects,t=this.animState.listeners;for(let s=0;s<e.length;s+=2){const n=e[s],a=e[s+1];switch(n){case mt.start:a.listener!=null&&a.listener.start&&a.listener.start(a);for(let o=0;o<t.length;o++)t[o].start&&t[o].start(a);a.onStart&&this.deprecateStuff()&&a.onStart(a.trackIndex),this.animState.onStart&&this.deprecateStuff()&&this.deprecateStuff&&this.animState.onStart(a.trackIndex);break;case mt.interrupt:a.listener!=null&&a.listener.interrupt&&a.listener.interrupt(a);for(let o=0;o<t.length;o++)t[o].interrupt&&t[o].interrupt(a);break;case mt.end:a.listener!=null&&a.listener.end&&a.listener.end(a);for(let o=0;o<t.length;o++)t[o].end&&t[o].end(a);a.onEnd&&this.deprecateStuff()&&a.onEnd(a.trackIndex),this.animState.onEnd&&this.deprecateStuff()&&this.animState.onEnd(a.trackIndex);case mt.dispose:a.listener!=null&&a.listener.dispose&&a.listener.dispose(a);for(let o=0;o<t.length;o++)t[o].dispose&&t[o].dispose(a);this.animState.trackEntryPool.free(a);break;case mt.complete:a.listener!=null&&a.listener.complete&&a.listener.complete(a);for(let o=0;o<t.length;o++)t[o].complete&&t[o].complete(a);const h=y.toInt(a.loopsCount());a.onComplete&&this.deprecateStuff()&&a.onComplete(a.trackIndex,h),this.animState.onComplete&&this.deprecateStuff()&&this.animState.onComplete(a.trackIndex,h);break;case mt.event:const c=e[s+++2];a.listener!=null&&a.listener.event&&a.listener.event(a,c);for(let o=0;o<t.length;o++)t[o].event&&t[o].event(a,c);a.onEvent&&this.deprecateStuff()&&a.onEvent(a.trackIndex,c),this.animState.onEvent&&this.deprecateStuff()&&this.animState.onEvent(a.trackIndex,c);break}}this.clear(),this.drainDisabled=!1}clear(){this.objects.length=0}};let oe=ie;oe.deprecatedWarning1=!1;var mt=(e=>(e[e.start=0]="start",e[e.interrupt=1]="interrupt",e[e.end=2]="end",e[e.dispose=3]="dispose",e[e.complete=4]="complete",e[e.event=5]="event",e))(mt||{});class Ue{start(t){}interrupt(t){}end(t){}dispose(t){}complete(t){}event(t,s){}}const le=class{constructor(e){if(this.animationToMixTime={},this.defaultMix=0,e==null)throw new Error("skeletonData cannot be null.");this.skeletonData=e}setMix(e,t,s){const n=this.skeletonData.findAnimation(e);if(n==null)throw new Error(`Animation not found: ${e}`);const a=this.skeletonData.findAnimation(t);if(a==null)throw new Error(`Animation not found: ${t}`);this.setMixWith(n,a,s)}setMixByName(e,t,s){le.deprecatedWarning1||(le.deprecatedWarning1=!0,console.warn("Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.")),this.setMix(e,t,s)}setMixWith(e,t,s){if(e==null)throw new Error("from cannot be null.");if(t==null)throw new Error("to cannot be null.");const n=`${e.name}.${t.name}`;this.animationToMixTime[n]=s}getMix(e,t){const s=`${e.name}.${t.name}`,n=this.animationToMixTime[s];return n===void 0?this.defaultMix:n}};let he=le;he.deprecatedWarning1=!1;class $e{constructor(t){this.atlas=t}newRegionAttachment(t,s,n){const a=this.atlas.findRegion(n);if(a==null)throw new Error(`Region not found in atlas: ${n} (region attachment: ${s})`);const h=new N(s);return h.region=a,h}newMeshAttachment(t,s,n){const a=this.atlas.findRegion(n);if(a==null)throw new Error(`Region not found in atlas: ${n} (mesh attachment: ${s})`);const h=new Ot(s);return h.region=a,h}newBoundingBoxAttachment(t,s){return new Qt(s)}newPathAttachment(t,s){return new Yt(s)}newPointAttachment(t,s){return new Jt(s)}newClippingAttachment(t,s){return new Kt(s)}}class ce{constructor(t,s,n){if(this.matrix=new We,this.children=new Array,this.x=0,this.y=0,this.rotation=0,this.scaleX=0,this.scaleY=0,this.shearX=0,this.shearY=0,this.ax=0,this.ay=0,this.arotation=0,this.ascaleX=0,this.ascaleY=0,this.ashearX=0,this.ashearY=0,this.appliedValid=!1,this.sorted=!1,this.active=!1,t==null)throw new Error("data cannot be null.");if(s==null)throw new Error("skeleton cannot be null.");this.data=t,this.skeleton=s,this.parent=n,this.setToSetupPose()}get worldX(){return this.matrix.tx}get worldY(){return this.matrix.ty}isActive(){return this.active}update(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransform(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransformWith(t,s,n,a,h,c,o){this.ax=t,this.ay=s,this.arotation=n,this.ascaleX=a,this.ascaleY=h,this.ashearX=c,this.ashearY=o,this.appliedValid=!0;const r=this.parent,i=this.matrix,l=this.skeleton.scaleX,d=ne.yDown?-this.skeleton.scaleY:this.skeleton.scaleY;if(r==null){const g=this.skeleton,x=n+90+o;i.a=y.cosDeg(n+c)*a*l,i.c=y.cosDeg(x)*h*l,i.b=y.sinDeg(n+c)*a*d,i.d=y.sinDeg(x)*h*d,i.tx=t*l+g.x,i.ty=s*d+g.y;return}let m=r.matrix.a,u=r.matrix.c,f=r.matrix.b,p=r.matrix.d;switch(i.tx=m*t+u*s+r.matrix.tx,i.ty=f*t+p*s+r.matrix.ty,this.data.transformMode){case Z.Normal:{const g=n+90+o,x=y.cosDeg(n+c)*a,E=y.cosDeg(g)*h,w=y.sinDeg(n+c)*a,b=y.sinDeg(g)*h;i.a=m*x+u*w,i.c=m*E+u*b,i.b=f*x+p*w,i.d=f*E+p*b;return}case Z.OnlyTranslation:{const g=n+90+o;i.a=y.cosDeg(n+c)*a,i.c=y.cosDeg(g)*h,i.b=y.sinDeg(n+c)*a,i.d=y.sinDeg(g)*h;break}case Z.NoRotationOrReflection:{let g=m*m+f*f,x=0;g>1e-4?(g=Math.abs(m*p-u*f)/g,m/=this.skeleton.scaleX,f/=this.skeleton.scaleY,u=f*g,p=m*g,x=Math.atan2(f,m)*y.radDeg):(m=0,f=0,x=90-Math.atan2(p,u)*y.radDeg);const E=n+c-x,w=n+o-x+90,b=y.cosDeg(E)*a,I=y.cosDeg(w)*h,M=y.sinDeg(E)*a,S=y.sinDeg(w)*h;i.a=m*b-u*M,i.c=m*I-u*S,i.b=f*b+p*M,i.d=f*I+p*S;break}case Z.NoScale:case Z.NoScaleOrReflection:{const g=y.cosDeg(n),x=y.sinDeg(n);let E=(m*g+u*x)/l,w=(f*g+p*x)/d,b=Math.sqrt(E*E+w*w);b>1e-5&&(b=1/b),E*=b,w*=b,b=Math.sqrt(E*E+w*w),this.data.transformMode==Z.NoScale&&m*p-u*f<0!=(ne.yDown?this.skeleton.scaleX<0!=this.skeleton.scaleY>0:this.skeleton.scaleX<0!=this.skeleton.scaleY<0)&&(b=-b);const I=Math.PI/2+Math.atan2(w,E),M=Math.cos(I)*b,S=Math.sin(I)*b,R=y.cosDeg(c)*a,T=y.cosDeg(90+o)*h,V=y.sinDeg(c)*a,O=y.sinDeg(90+o)*h;i.a=E*R+M*V,i.c=E*T+M*O,i.b=w*R+S*V,i.d=w*T+S*O;break}}i.a*=l,i.c*=l,i.b*=d,i.d*=d}setToSetupPose(){const t=this.data;this.x=t.x,this.y=t.y,this.rotation=t.rotation,this.scaleX=t.scaleX,this.scaleY=t.scaleY,this.shearX=t.shearX,this.shearY=t.shearY}getWorldRotationX(){return Math.atan2(this.matrix.b,this.matrix.a)*y.radDeg}getWorldRotationY(){return Math.atan2(this.matrix.d,this.matrix.c)*y.radDeg}getWorldScaleX(){const t=this.matrix;return Math.sqrt(t.a*t.a+t.c*t.c)}getWorldScaleY(){const t=this.matrix;return Math.sqrt(t.b*t.b+t.d*t.d)}updateAppliedTransform(){this.appliedValid=!0;const t=this.parent,s=this.matrix;if(t==null){this.ax=s.tx,this.ay=s.ty,this.arotation=Math.atan2(s.b,s.a)*y.radDeg,this.ascaleX=Math.sqrt(s.a*s.a+s.b*s.b),this.ascaleY=Math.sqrt(s.c*s.c+s.d*s.d),this.ashearX=0,this.ashearY=Math.atan2(s.a*s.c+s.b*s.d,s.a*s.d-s.b*s.c)*y.radDeg;return}const n=t.matrix,a=1/(n.a*n.d-n.b*n.c),h=s.tx-n.tx,c=s.ty-n.ty;this.ax=h*n.d*a-c*n.c*a,this.ay=c*n.a*a-h*n.b*a;const o=a*n.d,r=a*n.a,i=a*n.c,l=a*n.b,d=o*s.a-i*s.b,m=o*s.c-i*s.d,u=r*s.b-l*s.a,f=r*s.d-l*s.c;if(this.ashearX=0,this.ascaleX=Math.sqrt(d*d+u*u),this.ascaleX>1e-4){const p=d*f-m*u;this.ascaleY=p/this.ascaleX,this.ashearY=Math.atan2(d*m+u*f,p)*y.radDeg,this.arotation=Math.atan2(u,d)*y.radDeg}else this.ascaleX=0,this.ascaleY=Math.sqrt(m*m+f*f),this.ashearY=0,this.arotation=90-Math.atan2(f,m)*y.radDeg}worldToLocal(t){const s=this.matrix,n=s.a,a=s.c,h=s.b,c=s.d,o=1/(n*c-a*h),r=t.x-s.tx,i=t.y-s.ty;return t.x=r*c*o-i*a*o,t.y=i*n*o-r*h*o,t}localToWorld(t){const s=this.matrix,n=t.x,a=t.y;return t.x=n*s.a+a*s.c+s.tx,t.y=n*s.b+a*s.d+s.ty,t}worldToLocalRotation(t){const s=y.sinDeg(t),n=y.cosDeg(t),a=this.matrix;return Math.atan2(a.a*s-a.b*n,a.d*n-a.c*s)*y.radDeg}localToWorldRotation(t){const s=y.sinDeg(t),n=y.cosDeg(t),a=this.matrix;return Math.atan2(n*a.b+s*a.d,n*a.a+s*a.c)*y.radDeg}rotateWorld(t){const s=this.matrix,n=s.a,a=s.c,h=s.b,c=s.d,o=y.cosDeg(t),r=y.sinDeg(t);s.a=o*n-r*h,s.c=o*a-r*c,s.b=r*n+o*h,s.d=r*a+o*c,this.appliedValid=!1}}class de{constructor(t,s,n){if(this.x=0,this.y=0,this.rotation=0,this.scaleX=1,this.scaleY=1,this.shearX=0,this.shearY=0,this.transformMode=Z.Normal,this.skinRequired=!1,this.inheritRotation=!0,this.inheritScale=!0,this.color=new _,t<0)throw new Error("index must be >= 0.");if(s==null)throw new Error("name cannot be null.");this.index=t,this.name=s,this.parent=n}}class Zt{constructor(t,s,n){this.name=t,this.order=s,this.skinRequired=n}}class ue{constructor(t,s){if(s==null)throw new Error("data cannot be null.");this.time=t,this.data=s}}class me{constructor(t){this.name=t}}class Ne{constructor(t,s){if(this.bendDirection=0,this.compress=!1,this.stretch=!1,this.mix=1,this.softness=0,this.active=!1,t==null)throw new Error("data cannot be null.");if(s==null)throw new Error("skeleton cannot be null.");this.data=t,this.mix=t.mix,this.softness=t.softness,this.bendDirection=t.bendDirection,this.compress=t.compress,this.stretch=t.stretch,this.bones=new Array;for(let n=0;n<t.bones.length;n++)this.bones.push(s.findBone(t.bones[n].name));this.target=s.findBone(t.target.name)}isActive(){return this.active}apply(){this.update()}update(){const t=this.target,s=this.bones;switch(s.length){case 1:this.apply1(s[0],t.worldX,t.worldY,this.compress,this.stretch,this.data.uniform,this.mix);break;case 2:this.apply2(s[0],s[1],t.worldX,t.worldY,this.bendDirection,this.stretch,this.softness,this.mix);break}}apply1(t,s,n,a,h,c,o){t.appliedValid||t.updateAppliedTransform();const r=t.parent.matrix,i=r.a;let l=r.c;const d=r.b;let m=r.d,u=-t.ashearX-t.arotation,f=0,p=0;switch(t.data.transformMode){case Z.OnlyTranslation:f=s-t.worldX,p=n-t.worldY;break;case Z.NoRotationOrReflection:const E=Math.abs(i*m-l*d)/(i*i+d*d),w=i/t.skeleton.scaleX,b=d/t.skeleton.scaleY;l=-b*E*t.skeleton.scaleX,m=w*E*t.skeleton.scaleY,u+=Math.atan2(b,w)*y.radDeg;default:const I=s-r.tx,M=n-r.ty,S=i*m-l*d;f=(I*m-M*l)/S-t.ax,p=(M*i-I*d)/S-t.ay}u+=Math.atan2(p,f)*y.radDeg,t.ascaleX<0&&(u+=180),u>180?u-=360:u<-180&&(u+=360);let g=t.ascaleX,x=t.ascaleY;if(a||h){switch(t.data.transformMode){case Z.NoScale:case Z.NoScaleOrReflection:f=s-t.worldX,p=n-t.worldY}const E=t.data.length*g,w=Math.sqrt(f*f+p*p);if(a&&w<E||h&&w>E&&E>1e-4){const b=(w/E-1)*o+1;g*=b,c&&(x*=b)}}t.updateWorldTransformWith(t.ax,t.ay,t.arotation+u*o,g,x,t.ashearX,t.ashearY)}apply2(t,s,n,a,h,c,o,r){if(r==0){s.updateWorldTransform();return}t.appliedValid||t.updateAppliedTransform(),s.appliedValid||s.updateAppliedTransform();const i=t.ax,l=t.ay;let d=t.ascaleX,m=d,u=t.ascaleY,f=s.ascaleX;const p=t.matrix;let g=0,x=0,E=0;d<0?(d=-d,g=180,E=-1):(g=0,E=1),u<0&&(u=-u,E=-E),f<0?(f=-f,x=180):x=0;const w=s.ax;let b=0,I=0,M=0,S=p.a,R=p.c,T=p.b,V=p.d;const O=Math.abs(d-u)<=1e-4;O?(b=s.ay,I=S*w+R*b+p.tx,M=T*w+V*b+p.ty):(b=0,I=S*w+p.tx,M=T*w+p.ty);const v=t.parent.matrix;S=v.a,R=v.c,T=v.b,V=v.d;const H=1/(S*V-R*T);let P=I-v.tx,F=M-v.ty;const rt=(P*V-F*R)*H-i,it=(F*S-P*T)*H-l,C=Math.sqrt(rt*rt+it*it);let Y=s.data.length*f,D,W;if(C<1e-4){this.apply1(t,n,a,!1,c,!1,r),s.updateWorldTransformWith(w,b,0,s.ascaleX,s.ascaleY,s.ashearX,s.ashearY);return}P=n-v.tx,F=a-v.ty;let G=(P*V-F*R)*H-i,B=(F*S-P*T)*H-l,X=G*G+B*B;if(o!=0){o*=d*(f+1)/2;const dt=Math.sqrt(X),At=dt-C-Y*d+o;if(At>0){let Tt=Math.min(1,At/(o*2))-1;Tt=(At-o*(1-Tt*Tt))/dt,G-=Tt*G,B-=Tt*B,X=G*G+B*B}}t:if(O){Y*=d;let dt=(X-C*C-Y*Y)/(2*C*Y);dt<-1?dt=-1:dt>1&&(dt=1,c&&(m*=(Math.sqrt(X)/(C+Y)-1)*r+1)),W=Math.acos(dt)*h,S=C+Y*dt,R=Y*Math.sin(W),D=Math.atan2(B*S-G*R,G*S+B*R)}else{S=d*Y,R=u*Y;const dt=S*S,At=R*R,Tt=Math.atan2(B,G);T=At*C*C+dt*X-dt*At;const Ut=-2*At*C,Me=At-dt;if(V=Ut*Ut-4*Me*T,V>=0){let Lt=Math.sqrt(V);Ut<0&&(Lt=-Lt),Lt=-(Ut+Lt)/2;const Te=Lt/Me,Re=T/Lt,Bt=Math.abs(Te)<Math.abs(Re)?Te:Re;if(Bt*Bt<=X){F=Math.sqrt(X-Bt*Bt)*h,D=Tt-Math.atan2(F,Bt),W=Math.atan2(F/u,(Bt-C)/d);break t}}let Ie=y.PI,$t=C-S,te=$t*$t,Se=0,ye=0,Ht=C+S,ee=Ht*Ht,Ae=0;T=-S*C/(dt-At),T>=-1&&T<=1&&(T=Math.acos(T),P=S*Math.cos(T)+C,F=R*Math.sin(T),V=P*P+F*F,V<te&&(Ie=T,te=V,$t=P,Se=F),V>ee&&(ye=T,ee=V,Ht=P,Ae=F)),X<=(te+ee)/2?(D=Tt-Math.atan2(Se*h,$t),W=Ie*h):(D=Tt-Math.atan2(Ae*h,Ht),W=ye*h)}const wt=Math.atan2(b,w)*E;let Ct=t.arotation;D=(D-wt)*y.radDeg+g-Ct,D>180?D-=360:D<-180&&(D+=360),t.updateWorldTransformWith(i,l,Ct+D*r,m,t.ascaleY,0,0),Ct=s.arotation,W=((W+wt)*y.radDeg-s.ashearX)*E+x-Ct,W>180?W-=360:W<-180&&(W+=360),s.updateWorldTransformWith(w,b,Ct+W*r,s.ascaleX,s.ascaleY,s.ashearX,s.ashearY)}}class fe extends Zt{constructor(t){super(t,0,!1),this.bones=new Array,this.bendDirection=1,this.compress=!1,this.stretch=!1,this.uniform=!1,this.mix=1,this.softness=0}}class ge extends Zt{constructor(t){super(t,0,!1),this.bones=new Array}}var nt=(e=>(e[e.Length=0]="Length",e[e.Fixed=1]="Fixed",e[e.Percent=2]="Percent",e))(nt||{});const Xt=class{constructor(e,t){if(this.position=0,this.spacing=0,this.rotateMix=0,this.translateMix=0,this.spaces=new Array,this.positions=new Array,this.world=new Array,this.curves=new Array,this.lengths=new Array,this.segments=new Array,this.active=!1,e==null)throw new Error("data cannot be null.");if(t==null)throw new Error("skeleton cannot be null.");this.data=e,this.bones=new Array;for(let s=0,n=e.bones.length;s<n;s++)this.bones.push(t.findBone(e.bones[s].name));this.target=t.findSlot(e.target.name),this.position=e.position,this.spacing=e.spacing,this.rotateMix=e.rotateMix,this.translateMix=e.translateMix}isActive(){return this.active}apply(){this.update()}update(){const e=this.target.getAttachment();if(!(e instanceof Yt))return;const t=this.rotateMix,s=this.translateMix,n=s>0,a=t>0;if(!n&&!a)return;const h=this.data,c=h.spacingMode,o=c==nt.Length,r=h.rotateMode,i=r==Rt.Tangent,l=r==Rt.ChainScale,d=this.bones.length,m=i?d:d+1,u=this.bones,f=k.setArraySize(this.spaces,m);let p=null;const g=this.spacing;if(l||o){l&&(p=k.setArraySize(this.lengths,d));for(let M=0,S=m-1;M<S;){const R=u[M],T=R.data.length;if(T<Xt.epsilon)l&&(p[M]=0),f[++M]=0;else{const V=T*R.matrix.a,O=T*R.matrix.b,v=Math.sqrt(V*V+O*O);l&&(p[M]=v),f[++M]=(o?T+g:g)*v/T}}}else for(let M=1;M<m;M++)f[M]=g;const x=this.computeWorldPositions(e,m,i,h.positionMode==kt.Percent,c==nt.Percent);let E=x[0],w=x[1],b=h.offsetRotation,I=!1;if(b==0)I=r==Rt.Chain;else{I=!1;const M=this.target.bone.matrix;b*=M.a*M.d-M.b*M.c>0?y.degRad:-y.degRad}for(let M=0,S=3;M<d;M++,S+=3){const R=u[M],T=R.matrix;T.tx+=(E-T.tx)*s,T.ty+=(w-T.ty)*s;const V=x[S],O=x[S+1],v=V-E,H=O-w;if(l){const P=p[M];if(P!=0){const F=(Math.sqrt(v*v+H*H)/P-1)*t+1;T.a*=F,T.b*=F}}if(E=V,w=O,a){const P=T.a,F=T.c,rt=T.b,it=T.d;let C=0,Y=0,D=0;if(i&&(i?C=x[S-1]:f[M+1]==0?C=x[S+2]:C=Math.atan2(H,v)),C-=Math.atan2(rt,P),I){Y=Math.cos(C),D=Math.sin(C);const W=R.data.length;E+=(W*(Y*P-D*rt)-v)*t,w+=(W*(D*P+Y*rt)-H)*t}else C+=b;C>y.PI?C-=y.PI2:C<-y.PI&&(C+=y.PI2),C*=t,Y=Math.cos(C),D=Math.sin(C),T.a=Y*P-D*rt,T.c=Y*F-D*it,T.b=D*P+Y*rt,T.d=D*F+Y*it}R.appliedValid=!1}}computeWorldPositions(e,t,s,n,a){const h=this.target;let c=this.position;const o=this.spaces,r=k.setArraySize(this.positions,t*3+2);let i=null;const l=e.closed;let d=e.worldVerticesLength,m=d/6,u=Xt.NONE;if(!e.constantSpeed){const C=e.lengths;m-=l?1:2;const Y=C[m];if(n&&(c*=Y),a)for(let D=0;D<t;D++)o[D]*=Y;i=k.setArraySize(this.world,8);for(let D=0,W=0,G=0;D<t;D++,W+=3){const B=o[D];c+=B;let X=c;if(l)X%=Y,X<0&&(X+=Y),G=0;else if(X<0){u!=Xt.BEFORE&&(u=Xt.BEFORE,e.computeWorldVertices(h,2,4,i,0,2)),this.addBeforePosition(X,i,0,r,W);continue}else if(X>Y){u!=Xt.AFTER&&(u=Xt.AFTER,e.computeWorldVertices(h,d-6,4,i,0,2)),this.addAfterPosition(X-Y,i,0,r,W);continue}for(;;G++){const wt=C[G];if(!(X>wt)){if(G==0)X/=wt;else{const Ct=C[G-1];X=(X-Ct)/(wt-Ct)}break}}G!=u&&(u=G,l&&G==m?(e.computeWorldVertices(h,d-4,4,i,0,2),e.computeWorldVertices(h,0,4,i,4,2)):e.computeWorldVertices(h,G*6+2,8,i,0,2)),this.addCurvePosition(X,i[0],i[1],i[2],i[3],i[4],i[5],i[6],i[7],r,W,s||D>0&&B==0)}return r}l?(d+=2,i=k.setArraySize(this.world,d),e.computeWorldVertices(h,2,d-4,i,0,2),e.computeWorldVertices(h,0,2,i,d-4,2),i[d-2]=i[0],i[d-1]=i[1]):(m--,d-=4,i=k.setArraySize(this.world,d),e.computeWorldVertices(h,2,d,i,0,2));const f=k.setArraySize(this.curves,m);let p=0,g=i[0],x=i[1],E=0,w=0,b=0,I=0,M=0,S=0,R=0,T=0,V=0,O=0,v=0,H=0,P=0,F=0;for(let C=0,Y=2;C<m;C++,Y+=6)E=i[Y],w=i[Y+1],b=i[Y+2],I=i[Y+3],M=i[Y+4],S=i[Y+5],R=(g-E*2+b)*.1875,T=(x-w*2+I)*.1875,V=((E-b)*3-g+M)*.09375,O=((w-I)*3-x+S)*.09375,v=R*2+V,H=T*2+O,P=(E-g)*.75+R+V*.16666667,F=(w-x)*.75+T+O*.16666667,p+=Math.sqrt(P*P+F*F),P+=v,F+=H,v+=V,H+=O,p+=Math.sqrt(P*P+F*F),P+=v,F+=H,p+=Math.sqrt(P*P+F*F),P+=v+V,F+=H+O,p+=Math.sqrt(P*P+F*F),f[C]=p,g=M,x=S;if(n&&(c*=p),a)for(let C=0;C<t;C++)o[C]*=p;const rt=this.segments;let it=0;for(let C=0,Y=0,D=0,W=0;C<t;C++,Y+=3){const G=o[C];c+=G;let B=c;if(l)B%=p,B<0&&(B+=p),D=0;else if(B<0){this.addBeforePosition(B,i,0,r,Y);continue}else if(B>p){this.addAfterPosition(B-p,i,d-4,r,Y);continue}for(;;D++){const X=f[D];if(!(B>X)){if(D==0)B/=X;else{const wt=f[D-1];B=(B-wt)/(X-wt)}break}}if(D!=u){u=D;let X=D*6;for(g=i[X],x=i[X+1],E=i[X+2],w=i[X+3],b=i[X+4],I=i[X+5],M=i[X+6],S=i[X+7],R=(g-E*2+b)*.03,T=(x-w*2+I)*.03,V=((E-b)*3-g+M)*.006,O=((w-I)*3-x+S)*.006,v=R*2+V,H=T*2+O,P=(E-g)*.3+R+V*.16666667,F=(w-x)*.3+T+O*.16666667,it=Math.sqrt(P*P+F*F),rt[0]=it,X=1;X<8;X++)P+=v,F+=H,v+=V,H+=O,it+=Math.sqrt(P*P+F*F),rt[X]=it;P+=v,F+=H,it+=Math.sqrt(P*P+F*F),rt[8]=it,P+=v+V,F+=H+O,it+=Math.sqrt(P*P+F*F),rt[9]=it,W=0}for(B*=it;;W++){const X=rt[W];if(!(B>X)){if(W==0)B/=X;else{const wt=rt[W-1];B=W+(B-wt)/(X-wt)}break}}this.addCurvePosition(B*.1,g,x,E,w,b,I,M,S,r,Y,s||C>0&&G==0)}return r}addBeforePosition(e,t,s,n,a){const h=t[s],c=t[s+1],o=t[s+2]-h,r=t[s+3]-c,i=Math.atan2(r,o);n[a]=h+e*Math.cos(i),n[a+1]=c+e*Math.sin(i),n[a+2]=i}addAfterPosition(e,t,s,n,a){const h=t[s+2],c=t[s+3],o=h-t[s],r=c-t[s+1],i=Math.atan2(r,o);n[a]=h+e*Math.cos(i),n[a+1]=c+e*Math.sin(i),n[a+2]=i}addCurvePosition(e,t,s,n,a,h,c,o,r,i,l,d){(e==0||isNaN(e))&&(e=1e-4);const m=e*e,u=m*e,f=1-e,p=f*f,g=p*f,x=f*e,E=x*3,w=f*E,b=E*e,I=t*g+n*w+h*b+o*u,M=s*g+a*w+c*b+r*u;i[l]=I,i[l+1]=M,d&&(i[l+2]=Math.atan2(M-(s*p+a*x*2+c*m),I-(t*p+n*x*2+h*m)))}};let Wt=Xt;Wt.NONE=-1,Wt.BEFORE=-2,Wt.AFTER=-3,Wt.epsilon=1e-5;class ve{constructor(t,s){if(this.rotateMix=0,this.translateMix=0,this.scaleMix=0,this.shearMix=0,this.temp=new Oe,this.active=!1,t==null)throw new Error("data cannot be null.");if(s==null)throw new Error("skeleton cannot be null.");this.data=t,this.rotateMix=t.rotateMix,this.translateMix=t.translateMix,this.scaleMix=t.scaleMix,this.shearMix=t.shearMix,this.bones=new Array;for(let n=0;n<t.bones.length;n++)this.bones.push(s.findBone(t.bones[n].name));this.target=s.findBone(t.target.name)}isActive(){return this.active}apply(){this.update()}update(){this.data.local?this.data.relative?this.applyRelativeLocal():this.applyAbsoluteLocal():this.data.relative?this.applyRelativeWorld():this.applyAbsoluteWorld()}applyAbsoluteWorld(){const t=this.rotateMix,s=this.translateMix,n=this.scaleMix,a=this.shearMix,h=this.target,c=h.matrix,o=c.a,r=c.c,i=c.b,l=c.d,d=o*l-r*i>0?y.degRad:-y.degRad,m=this.data.offsetRotation*d,u=this.data.offsetShearY*d,f=this.bones;for(let p=0,g=f.length;p<g;p++){const x=f[p];let E=!1;const w=x.matrix;if(t!=0){const b=w.a,I=w.c,M=w.b,S=w.d;let R=Math.atan2(i,o)-Math.atan2(M,b)+m;R>y.PI?R-=y.PI2:R<-y.PI&&(R+=y.PI2),R*=t;const T=Math.cos(R),V=Math.sin(R);w.a=T*b-V*M,w.c=T*I-V*S,w.b=V*b+T*M,w.d=V*I+T*S,E=!0}if(s!=0){const b=this.temp;h.localToWorld(b.set(this.data.offsetX,this.data.offsetY)),w.tx+=(b.x-w.tx)*s,w.ty+=(b.y-w.ty)*s,E=!0}if(n>0){let b=Math.sqrt(w.a*w.a+w.b*w.b),I=Math.sqrt(o*o+i*i);b>1e-5&&(b=(b+(I-b+this.data.offsetScaleX)*n)/b),w.a*=b,w.b*=b,b=Math.sqrt(w.c*w.c+w.d*w.d),I=Math.sqrt(r*r+l*l),b>1e-5&&(b=(b+(I-b+this.data.offsetScaleY)*n)/b),w.c*=b,w.d*=b,E=!0}if(a>0){const b=w.c,I=w.d,M=Math.atan2(I,b);let S=Math.atan2(l,r)-Math.atan2(i,o)-(M-Math.atan2(w.b,w.a));S>y.PI?S-=y.PI2:S<-y.PI&&(S+=y.PI2),S=M+(S+u)*a;const R=Math.sqrt(b*b+I*I);w.c=Math.cos(S)*R,w.d=Math.sin(S)*R,E=!0}E&&(x.appliedValid=!1)}}applyRelativeWorld(){const t=this.rotateMix,s=this.translateMix,n=this.scaleMix,a=this.shearMix,h=this.target,c=h.matrix,o=c.a,r=c.c,i=c.b,l=c.d,d=o*l-r*i>0?y.degRad:-y.degRad,m=this.data.offsetRotation*d,u=this.data.offsetShearY*d,f=this.bones;for(let p=0,g=f.length;p<g;p++){const x=f[p];let E=!1;const w=x.matrix;if(t!=0){const b=w.a,I=w.c,M=w.b,S=w.d;let R=Math.atan2(i,o)+m;R>y.PI?R-=y.PI2:R<-y.PI&&(R+=y.PI2),R*=t;const T=Math.cos(R),V=Math.sin(R);w.a=T*b-V*M,w.c=T*I-V*S,w.b=V*b+T*M,w.d=V*I+T*S,E=!0}if(s!=0){const b=this.temp;h.localToWorld(b.set(this.data.offsetX,this.data.offsetY)),w.tx+=b.x*s,w.ty+=b.y*s,E=!0}if(n>0){let b=(Math.sqrt(o*o+i*i)-1+this.data.offsetScaleX)*n+1;w.a*=b,w.b*=b,b=(Math.sqrt(r*r+l*l)-1+this.data.offsetScaleY)*n+1,w.c*=b,w.d*=b,E=!0}if(a>0){let b=Math.atan2(l,r)-Math.atan2(i,o);b>y.PI?b-=y.PI2:b<-y.PI&&(b+=y.PI2);const I=w.c,M=w.d;b=Math.atan2(M,I)+(b-y.PI/2+u)*a;const S=Math.sqrt(I*I+M*M);w.c=Math.cos(b)*S,w.d=Math.sin(b)*S,E=!0}E&&(x.appliedValid=!1)}}applyAbsoluteLocal(){const t=this.rotateMix,s=this.translateMix,n=this.scaleMix,a=this.shearMix,h=this.target;h.appliedValid||h.updateAppliedTransform();const c=this.bones;for(let o=0,r=c.length;o<r;o++){const i=c[o];i.appliedValid||i.updateAppliedTransform();let l=i.arotation;if(t!=0){let g=h.arotation-l+this.data.offsetRotation;g-=(16384-(16384.499999999996-g/360|0))*360,l+=g*t}let d=i.ax,m=i.ay;s!=0&&(d+=(h.ax-d+this.data.offsetX)*s,m+=(h.ay-m+this.data.offsetY)*s);let u=i.ascaleX,f=i.ascaleY;n>0&&(u>1e-5&&(u=(u+(h.ascaleX-u+this.data.offsetScaleX)*n)/u),f>1e-5&&(f=(f+(h.ascaleY-f+this.data.offsetScaleY)*n)/f));const p=i.ashearY;if(a>0){let g=h.ashearY-p+this.data.offsetShearY;g-=(16384-(16384.499999999996-g/360|0))*360,i.shearY+=g*a}i.updateWorldTransformWith(d,m,l,u,f,i.ashearX,p)}}applyRelativeLocal(){const t=this.rotateMix,s=this.translateMix,n=this.scaleMix,a=this.shearMix,h=this.target;h.appliedValid||h.updateAppliedTransform();const c=this.bones;for(let o=0,r=c.length;o<r;o++){const i=c[o];i.appliedValid||i.updateAppliedTransform();let l=i.arotation;t!=0&&(l+=(h.arotation+this.data.offsetRotation)*t);let d=i.ax,m=i.ay;s!=0&&(d+=(h.ax+this.data.offsetX)*s,m+=(h.ay+this.data.offsetY)*s);let u=i.ascaleX,f=i.ascaleY;n>0&&(u>1e-5&&(u*=(h.ascaleX-1+this.data.offsetScaleX)*n+1),f>1e-5&&(f*=(h.ascaleY-1+this.data.offsetScaleY)*n+1));let p=i.ashearY;a>0&&(p+=(h.ashearY+this.data.offsetShearY)*a),i.updateWorldTransformWith(d,m,l,u,f,i.ashearX,p)}}}const qt=class{constructor(e){if(this._updateCache=new Array,this.updateCacheReset=new Array,this.time=0,this.scaleX=1,this.scaleY=1,this.x=0,this.y=0,e==null)throw new Error("data cannot be null.");this.data=e,this.bones=new Array;for(let t=0;t<e.bones.length;t++){const s=e.bones[t];let n;if(s.parent==null)n=new ce(s,this,null);else{const a=this.bones[s.parent.index];n=new ce(s,this,a),a.children.push(n)}this.bones.push(n)}this.slots=new Array,this.drawOrder=new Array;for(let t=0;t<e.slots.length;t++){const s=e.slots[t],n=this.bones[s.boneData.index],a=new ae(s,n);this.slots.push(a),this.drawOrder.push(a)}this.ikConstraints=new Array;for(let t=0;t<e.ikConstraints.length;t++){const s=e.ikConstraints[t];this.ikConstraints.push(new Ne(s,this))}this.transformConstraints=new Array;for(let t=0;t<e.transformConstraints.length;t++){const s=e.transformConstraints[t];this.transformConstraints.push(new ve(s,this))}this.pathConstraints=new Array;for(let t=0;t<e.pathConstraints.length;t++){const s=e.pathConstraints[t];this.pathConstraints.push(new Wt(s,this))}this.color=new _(1,1,1,1),this.updateCache()}updateCache(){const e=this._updateCache;e.length=0,this.updateCacheReset.length=0;const t=this.bones;for(let i=0,l=t.length;i<l;i++){const d=t[i];d.sorted=d.data.skinRequired,d.active=!d.sorted}if(this.skin!=null){const i=this.skin.bones;for(let l=0,d=this.skin.bones.length;l<d;l++){let m=this.bones[i[l].index];do m.sorted=!1,m.active=!0,m=m.parent;while(m!=null)}}const s=this.ikConstraints,n=this.transformConstraints,a=this.pathConstraints,h=s.length,c=n.length,o=a.length,r=h+c+o;t:for(let i=0;i<r;i++){for(let l=0;l<h;l++){const d=s[l];if(d.data.order==i){this.sortIkConstraint(d);continue t}}for(let l=0;l<c;l++){const d=n[l];if(d.data.order==i){this.sortTransformConstraint(d);continue t}}for(let l=0;l<o;l++){const d=a[l];if(d.data.order==i){this.sortPathConstraint(d);continue t}}}for(let i=0,l=t.length;i<l;i++)this.sortBone(t[i])}sortIkConstraint(e){if(e.active=e.target.isActive()&&(!e.data.skinRequired||this.skin!=null&&k.contains(this.skin.constraints,e.data,!0)),!e.active)return;const t=e.target;this.sortBone(t);const s=e.bones,n=s[0];if(this.sortBone(n),s.length>1){const a=s[s.length-1];this._updateCache.indexOf(a)>-1||this.updateCacheReset.push(a)}this._updateCache.push(e),this.sortReset(n.children),s[s.length-1].sorted=!0}sortPathConstraint(e){if(e.active=e.target.bone.isActive()&&(!e.data.skinRequired||this.skin!=null&&k.contains(this.skin.constraints,e.data,!0)),!e.active)return;const t=e.target,s=t.data.index,n=t.bone;this.skin!=null&&this.sortPathConstraintAttachment(this.skin,s,n),this.data.defaultSkin!=null&&this.data.defaultSkin!=this.skin&&this.sortPathConstraintAttachment(this.data.defaultSkin,s,n);for(let o=0,r=this.data.skins.length;o<r;o++)this.sortPathConstraintAttachment(this.data.skins[o],s,n);const a=t.getAttachment();a instanceof Yt&&this.sortPathConstraintAttachmentWith(a,n);const h=e.bones,c=h.length;for(let o=0;o<c;o++)this.sortBone(h[o]);this._updateCache.push(e);for(let o=0;o<c;o++)this.sortReset(h[o].children);for(let o=0;o<c;o++)h[o].sorted=!0}sortTransformConstraint(e){if(e.active=e.target.isActive()&&(!e.data.skinRequired||this.skin!=null&&k.contains(this.skin.constraints,e.data,!0)),!e.active)return;this.sortBone(e.target);const t=e.bones,s=t.length;if(e.data.local)for(let n=0;n<s;n++){const a=t[n];this.sortBone(a.parent),this._updateCache.indexOf(a)>-1||this.updateCacheReset.push(a)}else for(let n=0;n<s;n++)this.sortBone(t[n]);this._updateCache.push(e);for(let n=0;n<s;n++)this.sortReset(t[n].children);for(let n=0;n<s;n++)t[n].sorted=!0}sortPathConstraintAttachment(e,t,s){const n=e.attachments[t];if(n)for(const a in n)this.sortPathConstraintAttachmentWith(n[a],s)}sortPathConstraintAttachmentWith(e,t){if(!(e instanceof Yt))return;const s=e.bones;if(s==null)this.sortBone(t);else{const n=this.bones;let a=0;for(;a<s.length;){const h=s[a++];for(let c=a+h;a<c;a++){const o=s[a];this.sortBone(n[o])}}}}sortBone(e){if(e.sorted)return;const t=e.parent;t!=null&&this.sortBone(t),e.sorted=!0,this._updateCache.push(e)}sortReset(e){for(let t=0,s=e.length;t<s;t++){const n=e[t];n.active&&(n.sorted&&this.sortReset(n.children),n.sorted=!1)}}updateWorldTransform(){const e=this.updateCacheReset;for(let s=0,n=e.length;s<n;s++){const a=e[s];a.ax=a.x,a.ay=a.y,a.arotation=a.rotation,a.ascaleX=a.scaleX,a.ascaleY=a.scaleY,a.ashearX=a.shearX,a.ashearY=a.shearY,a.appliedValid=!0}const t=this._updateCache;for(let s=0,n=t.length;s<n;s++)t[s].update()}setToSetupPose(){this.setBonesToSetupPose(),this.setSlotsToSetupPose()}setBonesToSetupPose(){const e=this.bones;for(let a=0,h=e.length;a<h;a++)e[a].setToSetupPose();const t=this.ikConstraints;for(let a=0,h=t.length;a<h;a++){const c=t[a];c.mix=c.data.mix,c.softness=c.data.softness,c.bendDirection=c.data.bendDirection,c.compress=c.data.compress,c.stretch=c.data.stretch}const s=this.transformConstraints;for(let a=0,h=s.length;a<h;a++){const c=s[a],o=c.data;c.rotateMix=o.rotateMix,c.translateMix=o.translateMix,c.scaleMix=o.scaleMix,c.shearMix=o.shearMix}const n=this.pathConstraints;for(let a=0,h=n.length;a<h;a++){const c=n[a],o=c.data;c.position=o.position,c.spacing=o.spacing,c.rotateMix=o.rotateMix,c.translateMix=o.translateMix}}setSlotsToSetupPose(){const e=this.slots;k.arrayCopy(e,0,this.drawOrder,0,e.length);for(let t=0,s=e.length;t<s;t++)e[t].setToSetupPose()}getRootBone(){return this.bones.length==0?null:this.bones[0]}findBone(e){if(e==null)throw new Error("boneName cannot be null.");const t=this.bones;for(let s=0,n=t.length;s<n;s++){const a=t[s];if(a.data.name==e)return a}return null}findBoneIndex(e){if(e==null)throw new Error("boneName cannot be null.");const t=this.bones;for(let s=0,n=t.length;s<n;s++)if(t[s].data.name==e)return s;return-1}findSlot(e){if(e==null)throw new Error("slotName cannot be null.");const t=this.slots;for(let s=0,n=t.length;s<n;s++){const a=t[s];if(a.data.name==e)return a}return null}findSlotIndex(e){if(e==null)throw new Error("slotName cannot be null.");const t=this.slots;for(let s=0,n=t.length;s<n;s++)if(t[s].data.name==e)return s;return-1}setSkinByName(e){const t=this.data.findSkin(e);if(t==null)throw new Error(`Skin not found: ${e}`);this.setSkin(t)}setSkin(e){if(e!=this.skin){if(e!=null)if(this.skin!=null)e.attachAll(this,this.skin);else{const t=this.slots;for(let s=0,n=t.length;s<n;s++){const a=t[s],h=a.data.attachmentName;if(h!=null){const c=e.getAttachment(s,h);c!=null&&a.setAttachment(c)}}}this.skin=e,this.updateCache()}}getAttachmentByName(e,t){return this.getAttachment(this.data.findSlotIndex(e),t)}getAttachment(e,t){if(t==null)throw new Error("attachmentName cannot be null.");if(this.skin!=null){const s=this.skin.getAttachment(e,t);if(s!=null)return s}return this.data.defaultSkin!=null?this.data.defaultSkin.getAttachment(e,t):null}setAttachment(e,t){if(e==null)throw new Error("slotName cannot be null.");const s=this.slots;for(let n=0,a=s.length;n<a;n++){const h=s[n];if(h.data.name==e){let c=null;if(t!=null&&(c=this.getAttachment(n,t),c==null))throw new Error(`Attachment not found: ${t}, for slot: ${e}`);h.setAttachment(c);return}}throw new Error(`Slot not found: ${e}`)}findIkConstraint(e){if(e==null)throw new Error("constraintName cannot be null.");const t=this.ikConstraints;for(let s=0,n=t.length;s<n;s++){const a=t[s];if(a.data.name==e)return a}return null}findTransformConstraint(e){if(e==null)throw new Error("constraintName cannot be null.");const t=this.transformConstraints;for(let s=0,n=t.length;s<n;s++){const a=t[s];if(a.data.name==e)return a}return null}findPathConstraint(e){if(e==null)throw new Error("constraintName cannot be null.");const t=this.pathConstraints;for(let s=0,n=t.length;s<n;s++){const a=t[s];if(a.data.name==e)return a}return null}getBounds(e,t,s=new Array(2)){if(e==null)throw new Error("offset cannot be null.");if(t==null)throw new Error("size cannot be null.");const n=this.drawOrder;let a=Number.POSITIVE_INFINITY,h=Number.POSITIVE_INFINITY,c=Number.NEGATIVE_INFINITY,o=Number.NEGATIVE_INFINITY;for(let r=0,i=n.length;r<i;r++){const l=n[r];if(!l.bone.active)continue;let d=0,m=null;const u=l.getAttachment();if(u instanceof N)d=8,m=k.setArraySize(s,d,0),u.computeWorldVertices(l.bone,m,0,2);else if(u instanceof Ot){const f=u;d=f.worldVerticesLength,m=k.setArraySize(s,d,0),f.computeWorldVertices(l,0,d,m,0,2)}if(m!=null)for(let f=0,p=m.length;f<p;f+=2){const g=m[f],x=m[f+1];a=Math.min(a,g),h=Math.min(h,x),c=Math.max(c,g),o=Math.max(o,x)}}e.set(a,h),t.set(c-a,o-h)}update(e){this.time+=e}get flipX(){return this.scaleX==-1}set flipX(e){qt.deprecatedWarning1||(qt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleX=e?1:-1}get flipY(){return this.scaleY==-1}set flipY(e){qt.deprecatedWarning1||(qt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleY=e?1:-1}};let pe=qt;pe.deprecatedWarning1=!1;class xe{constructor(){this.bones=new Array,this.slots=new Array,this.skins=new Array,this.events=new Array,this.animations=new Array,this.ikConstraints=new Array,this.transformConstraints=new Array,this.pathConstraints=new Array,this.fps=0}findBone(t){if(t==null)throw new Error("boneName cannot be null.");const s=this.bones;for(let n=0,a=s.length;n<a;n++){const h=s[n];if(h.name==t)return h}return null}findBoneIndex(t){if(t==null)throw new Error("boneName cannot be null.");const s=this.bones;for(let n=0,a=s.length;n<a;n++)if(s[n].name==t)return n;return-1}findSlot(t){if(t==null)throw new Error("slotName cannot be null.");const s=this.slots;for(let n=0,a=s.length;n<a;n++){const h=s[n];if(h.name==t)return h}return null}findSlotIndex(t){if(t==null)throw new Error("slotName cannot be null.");const s=this.slots;for(let n=0,a=s.length;n<a;n++)if(s[n].name==t)return n;return-1}findSkin(t){if(t==null)throw new Error("skinName cannot be null.");const s=this.skins;for(let n=0,a=s.length;n<a;n++){const h=s[n];if(h.name==t)return h}return null}findEvent(t){if(t==null)throw new Error("eventDataName cannot be null.");const s=this.events;for(let n=0,a=s.length;n<a;n++){const h=s[n];if(h.name==t)return h}return null}findAnimation(t){if(t==null)throw new Error("animationName cannot be null.");const s=this.animations;for(let n=0,a=s.length;n<a;n++){const h=s[n];if(h.name==t)return h}return null}findIkConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const s=this.ikConstraints;for(let n=0,a=s.length;n<a;n++){const h=s[n];if(h.name==t)return h}return null}findTransformConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const s=this.transformConstraints;for(let n=0,a=s.length;n<a;n++){const h=s[n];if(h.name==t)return h}return null}findPathConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const s=this.pathConstraints;for(let n=0,a=s.length;n<a;n++){const h=s[n];if(h.name==t)return h}return null}findPathConstraintIndex(t){if(t==null)throw new Error("pathConstraintName cannot be null.");const s=this.pathConstraints;for(let n=0,a=s.length;n<a;n++)if(s[n].name==t)return n;return-1}}class Ee{constructor(t,s,n){if(this.color=new _(1,1,1,1),t<0)throw new Error("index must be >= 0.");if(s==null)throw new Error("name cannot be null.");if(n==null)throw new Error("boneData cannot be null.");this.index=t,this.name=s,this.boneData=n}}class we extends Zt{constructor(t){super(t,0,!1),this.bones=new Array,this.rotateMix=0,this.translateMix=0,this.scaleMix=0,this.shearMix=0,this.offsetRotation=0,this.offsetX=0,this.offsetY=0,this.offsetScaleX=0,this.offsetScaleY=0,this.offsetShearY=0,this.relative=!1,this.local=!1}}class be{constructor(t,s,n){this.slotIndex=t,this.name=s,this.attachment=n}}class zt{constructor(t){if(this.attachments=new Array,this.bones=Array(),this.constraints=new Array,t==null)throw new Error("name cannot be null.");this.name=t}setAttachment(t,s,n){if(n==null)throw new Error("attachment cannot be null.");const a=this.attachments;t>=a.length&&(a.length=t+1),a[t]||(a[t]={}),a[t][s]=n}addSkin(t){for(let n=0;n<t.bones.length;n++){const a=t.bones[n];let h=!1;for(let c=0;c<this.bones.length;c++)if(this.bones[c]==a){h=!0;break}h||this.bones.push(a)}for(let n=0;n<t.constraints.length;n++){const a=t.constraints[n];let h=!1;for(let c=0;c<this.constraints.length;c++)if(this.constraints[c]==a){h=!0;break}h||this.constraints.push(a)}const s=t.getAttachments();for(let n=0;n<s.length;n++){const a=s[n];this.setAttachment(a.slotIndex,a.name,a.attachment)}}copySkin(t){for(let n=0;n<t.bones.length;n++){const a=t.bones[n];let h=!1;for(let c=0;c<this.bones.length;c++)if(this.bones[c]==a){h=!0;break}h||this.bones.push(a)}for(let n=0;n<t.constraints.length;n++){const a=t.constraints[n];let h=!1;for(let c=0;c<this.constraints.length;c++)if(this.constraints[c]==a){h=!0;break}h||this.constraints.push(a)}const s=t.getAttachments();for(let n=0;n<s.length;n++){const a=s[n];a.attachment!=null&&(a.attachment instanceof Ot?(a.attachment=a.attachment.newLinkedMesh(),this.setAttachment(a.slotIndex,a.name,a.attachment)):(a.attachment=a.attachment.copy(),this.setAttachment(a.slotIndex,a.name,a.attachment)))}}getAttachment(t,s){const n=this.attachments[t];return n?n[s]:null}removeAttachment(t,s){const n=this.attachments[t];n&&(n[s]=null)}getAttachments(){const t=new Array;for(let s=0;s<this.attachments.length;s++){const n=this.attachments[s];if(n)for(const a in n){const h=n[a];h&&t.push(new be(s,a,h))}}return t}getAttachmentsForSlot(t,s){const n=this.attachments[t];if(n)for(const a in n){const h=n[a];h&&s.push(new be(t,a,h))}}clear(){this.attachments.length=0,this.bones.length=0,this.constraints.length=0}attachAll(t,s){let n=0;for(let a=0;a<t.slots.length;a++){const h=t.slots[a],c=h.getAttachment();if(c&&n<s.attachments.length){const o=s.attachments[n];for(const r in o){const i=o[r];if(c==i){const l=this.getAttachment(n,r);l!=null&&h.setAttachment(l);break}}}n++}}}const K=class{constructor(e){this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=e}readSkeletonData(e){const t=this.scale,s=new xe;s.name="";const n=new Le(e);s.hash=n.readString(),s.version=n.readString(),s.version==="3.8.75"&&console.error("Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine."),s.width=n.readFloat(),s.height=n.readFloat();const a=n.readBoolean();a&&(s.imagesPath=n.readString());let h=0;h=n.readInt(!0);for(let o=0;o<h;o++){const r=n.readString(),i=o==0?null:s.bones[n.readInt(!0)],l=new de(o,r,i);l.rotation=n.readFloat(),l.x=n.readFloat()*t,l.y=n.readFloat()*t,l.scaleX=n.readFloat(),l.scaleY=n.readFloat(),l.shearX=n.readFloat(),l.shearY=n.readFloat(),l.length=n.readFloat()*t,l.inheritRotation=n.readBoolean(),l.inheritScale=n.readBoolean(),a&&_.rgba8888ToColor(l.color,n.readInt32()),s.bones.push(l)}h=n.readInt(!0);for(let o=0;o<h;o++){const r=n.readString(),i=s.bones[n.readInt(!0)],l=new Ee(o,r,i);_.rgba8888ToColor(l.color,n.readInt32()),l.attachmentName=n.readString(),l.blendMode=K.BlendModeValues[n.readInt(!0)],s.slots.push(l)}h=n.readInt(!0);for(let o=0,r;o<h;o++){const i=n.readString(),l=new fe(i);r=n.readInt(!0);for(let d=0;d<r;d++)l.bones.push(s.bones[n.readInt(!0)]);l.target=s.bones[n.readInt(!0)],l.mix=n.readFloat(),l.bendDirection=n.readByte(),s.ikConstraints.push(l)}h=n.readInt(!0);for(let o=0,r;o<h;o++){const i=n.readString(),l=new we(i);r=n.readInt(!0);for(let d=0;d<r;d++)l.bones.push(s.bones[n.readInt(!0)]);l.target=s.bones[n.readInt(!0)],l.offsetRotation=n.readFloat(),l.offsetX=n.readFloat()*t,l.offsetY=n.readFloat()*t,l.offsetScaleX=n.readFloat(),l.offsetScaleY=n.readFloat(),l.offsetShearY=n.readFloat(),l.rotateMix=n.readFloat(),l.translateMix=n.readFloat(),l.scaleMix=n.readFloat(),l.shearMix=n.readFloat(),s.transformConstraints.push(l)}h=n.readInt(!0);for(let o=0,r;o<h;o++){const i=n.readString(),l=new ge(i);r=n.readInt(!0);for(let d=0;d<r;d++)l.bones.push(s.bones[n.readInt(!0)]);l.target=s.slots[n.readInt(!0)],l.positionMode=K.PositionModeValues[n.readInt(!0)],l.spacingMode=K.SpacingModeValues[n.readInt(!0)],l.rotateMode=K.RotateModeValues[n.readInt(!0)],l.offsetRotation=n.readFloat(),l.position=n.readFloat(),l.positionMode==kt.Fixed&&(l.position*=t),l.spacing=n.readFloat(),(l.spacingMode==nt.Length||l.spacingMode==nt.Fixed)&&(l.spacing*=t),l.rotateMix=n.readFloat(),l.translateMix=n.readFloat(),s.pathConstraints.push(l)}const c=this.readSkin(n,s,!0,a);c!=null&&(s.defaultSkin=c,s.skins.push(c));{let o=s.skins.length;for(k.setArraySize(s.skins,h=o+n.readInt(!0));o<h;o++)s.skins[o]=this.readSkin(n,s,!1,a)}h=this.linkedMeshes.length;for(let o=0;o<h;o++){const r=this.linkedMeshes[o],i=r.skin==null?s.defaultSkin:s.findSkin(r.skin);if(i==null)throw new Error(`Skin not found: ${r.skin}`);const l=i.getAttachment(r.slotIndex,r.parent);if(l==null)throw new Error(`Parent mesh not found: ${r.parent}`);r.mesh.deformAttachment=r.inheritDeform?l:r.mesh,r.mesh.setParentMesh(l)}this.linkedMeshes.length=0,h=n.readInt(!0);for(let o=0;o<h;o++){const r=new me(n.readStringRef());r.intValue=n.readInt(!1),r.floatValue=n.readFloat(),r.stringValue=n.readString(),r.audioPath=n.readString(),r.audioPath!=null&&(r.volume=n.readFloat(),r.balance=n.readFloat()),s.events.push(r)}h=n.readInt(!0);for(let o=0;o<h;o++)s.animations.push(this.readAnimation(n,n.readString(),s));return s}readSkin(e,t,s,n){let a=null,h=0;if(s){if(h=e.readInt(!0),h==0)return null;a=new zt("default")}else{a=new zt(e.readString()),a.bones.length=e.readInt(!0);for(let c=0,o=a.bones.length;c<o;c++)a.bones[c]=t.bones[e.readInt(!0)];for(let c=0,o=e.readInt(!0);c<o;c++)a.constraints.push(t.ikConstraints[e.readInt(!0)]);for(let c=0,o=e.readInt(!0);c<o;c++)a.constraints.push(t.transformConstraints[e.readInt(!0)]);for(let c=0,o=e.readInt(!0);c<o;c++)a.constraints.push(t.pathConstraints[e.readInt(!0)]);h=e.readInt(!0)}for(let c=0;c<h;c++){const o=e.readInt(!0);for(let r=0,i=e.readInt(!0);r<i;r++){const l=e.readString(),d=this.readAttachment(e,t,a,o,l,n);d!=null&&a.setAttachment(o,l,d)}}return a}readAttachment(e,t,s,n,a,h){const c=this.scale;let o=e.readStringRef();o==null&&(o=a);const r=e.readByte();switch(K.AttachmentTypeValues[r]){case pt.Region:{let i=e.readString();const l=e.readFloat(),d=e.readFloat(),m=e.readFloat(),u=e.readFloat(),f=e.readFloat(),p=e.readFloat(),g=e.readFloat(),x=e.readInt32();i==null&&(i=o);const E=this.attachmentLoader.newRegionAttachment(s,o,i);return E==null?null:(E.path=i,E.x=d*c,E.y=m*c,E.scaleX=u,E.scaleY=f,E.rotation=l,E.width=p*c,E.height=g*c,_.rgba8888ToColor(E.color,x),E)}case pt.BoundingBox:{const i=e.readInt(!0),l=this.readVertices(e,i),d=h?e.readInt32():0,m=this.attachmentLoader.newBoundingBoxAttachment(s,o);return m==null?null:(m.worldVerticesLength=i<<1,m.vertices=l.vertices,m.bones=l.bones,m.cVertices=l.cVertices,h&&_.rgba8888ToColor(m.color,d),m)}case pt.Mesh:{let i=e.readStringRef();const l=e.readInt32(),d=e.readInt(!0),m=this.readFloatArray(e,d<<1,1),u=this.readShortArray(e),f=this.readVertices(e,d),p=e.readInt(!0);let g=null,x=0,E=0;h&&(g=this.readShortArray(e),x=e.readFloat(),E=e.readFloat()),i==null&&(i=o);const w=this.attachmentLoader.newMeshAttachment(s,o,i);return w==null?null:(w.path=i,_.rgba8888ToColor(w.color,l),w.bones=f.bones,w.vertices=f.vertices,w.worldVerticesLength=d<<1,w.triangles=u,w.regionUVs=new Float32Array(m),w.cVertices=f.cVertices,w.hullLength=p<<1,h&&(w.edges=g,w.width=x*c,w.height=E*c),w)}case pt.LinkedMesh:{let i=e.readStringRef();const l=e.readInt32(),d=e.readStringRef(),m=e.readStringRef(),u=e.readBoolean();let f=0,p=0;h&&(f=e.readFloat(),p=e.readFloat()),i==null&&(i=o);const g=this.attachmentLoader.newMeshAttachment(s,o,i);return g==null?null:(g.path=i,_.rgba8888ToColor(g.color,l),h&&(g.width=f*c,g.height=p*c),this.linkedMeshes.push(new He(g,d,n,m,u)),g)}case pt.Path:{const i=e.readBoolean(),l=e.readBoolean(),d=e.readInt(!0),m=this.readVertices(e,d),u=k.newArray(d/3,0);for(let g=0,x=u.length;g<x;g++)u[g]=e.readFloat()*c;const f=h?e.readInt32():0,p=this.attachmentLoader.newPathAttachment(s,o);return p==null?null:(p.closed=i,p.constantSpeed=l,p.worldVerticesLength=d<<1,p.vertices=m.vertices,p.bones=m.bones,p.lengths=u,p.cVertices=m.cVertices,h&&_.rgba8888ToColor(p.color,f),p)}case pt.Point:{const i=e.readFloat(),l=e.readFloat(),d=e.readFloat(),m=h?e.readInt32():0,u=this.attachmentLoader.newPointAttachment(s,o);return u==null?null:(u.x=l*c,u.y=d*c,u.rotation=i,h&&_.rgba8888ToColor(u.color,m),u)}case pt.Clipping:{const i=e.readInt(!0),l=e.readInt(!0),d=this.readVertices(e,l),m=h?e.readInt32():0,u=this.attachmentLoader.newClippingAttachment(s,o);return u==null?null:(u.endSlot=t.slots[i],u.worldVerticesLength=l<<1,u.vertices=d.vertices,u.bones=d.bones,u.cVertices=d.cVertices,h&&_.rgba8888ToColor(u.color,m),u)}}return null}readVertices(e,t){const s=t<<1,n=new Ge,a=this.scale;if(!e.readBoolean())return n.vertices=this.readFloatArray(e,s,a),n;const h=new Array,c=new Array,o=new Array;for(let r=0;r<t;r++){const i=e.readInt(!0);o.push(i),h.push(i);for(let l=0;l<i;l++){const d=e.readInt(!0);o.push(d),h.push(d);const m=e.readFloat()*a,u=e.readFloat()*a,f=e.readFloat();c.push(m),c.push(u),c.push(f),h.push(m),h.push(u),h.push(f)}}return n.vertices=k.toFloatArray(c),n.bones=o,n.cVertices=h,n}readFloatArray(e,t,s){const n=new Array(t);if(s==1)for(let a=0;a<t;a++)n[a]=e.readFloat();else for(let a=0;a<t;a++)n[a]=e.readFloat()*s;return n}readShortArray(e){const t=e.readInt(!0),s=new Array(t);for(let n=0;n<t;n++)s[n]=e.readShort();return s}readAnimation(e,t,s){const n=new Array,a=this.scale;let h=0;const c=new _;for(let i=0,l=e.readInt(!0);i<l;i++){const d=e.readInt(!0);for(let m=0,u=e.readInt(!0);m<u;m++){const f=e.readByte(),p=e.readInt(!0);switch(f){case K.SLOT_ATTACHMENT:{const g=new vt(p);g.slotIndex=d;for(let x=0;x<p;x++){const E=e.readFloat(),w=e.readString();g.setFrame(x,E,w)}n.push(g),h=Math.max(h,g.frames[p-1]);break}case K.SLOT_COLOR:{const g=new lt(p);g.slotIndex=d;for(let x=0;x<p;x++){const E=e.readFloat();_.rgba8888ToColor(c,e.readInt32()),g.setFrame(x,E,c.r,c.g,c.b,c.a),x<p-1&&this.readCurve(e,x,g)}n.push(g),h=Math.max(h,g.frames[(p-1)*lt.ENTRIES]);break}}}}for(let i=0,l=e.readInt(!0);i<l;i++){const d=e.readInt(!0);for(let m=0,u=e.readInt(!0);m<u;m++){const f=e.readByte(),p=e.readInt(!0);switch(f){case K.BONE_ROTATE:{const g=new st(p);g.boneIndex=d;for(let x=0;x<p;x++)g.setFrame(x,e.readFloat(),e.readFloat()),x<p-1&&this.readCurve(e,x,g);n.push(g),h=Math.max(h,g.frames[(p-1)*st.ENTRIES]);break}case K.BONE_TRANSLATE:case K.BONE_SCALE:case K.BONE_SHEAR:{let g,x=1;f==K.BONE_SCALE?g=new ft(p):f==K.BONE_SHEAR?g=new gt(p):(g=new xt(p),x=a),g.boneIndex=d;for(let E=0;E<p;E++){const w=e.readFloat(),b=e.readFloat(),I=e.readFloat();g.setFrame(E,w,b*x,I*x),E<p-1&&this.readCurve(e,E,g)}n.push(g),h=Math.max(h,g.frames[(p-1)*xt.ENTRIES]);break}}}}for(let i=0,l=e.readInt(!0);i<l;i++){const d=e.readInt(!0),m=e.readInt(!0),u=new at(m);u.ikConstraintIndex=d;for(let f=0;f<m;f++){const p=e.readFloat(),g=e.readFloat(),x=e.readByte();u.setFrame(f,p,g,x),f<m-1&&this.readCurve(e,f,u)}n.push(u),h=Math.max(h,u.frames[(m-1)*at.ENTRIES])}for(let i=0,l=e.readInt(!0);i<l;i++){const d=e.readInt(!0),m=e.readInt(!0),u=new ht(m);u.transformConstraintIndex=d;for(let f=0;f<m;f++)u.setFrame(f,e.readFloat(),e.readFloat(),e.readFloat(),e.readFloat(),e.readFloat()),f<m-1&&this.readCurve(e,f,u);n.push(u),h=Math.max(h,u.frames[(m-1)*ht.ENTRIES])}for(let i=0,l=e.readInt(!0);i<l;i++){const d=e.readInt(!0),m=s.pathConstraints[d];for(let u=0,f=e.readInt(!0);u<f;u++){const p=e.readByte(),g=e.readInt(!0);switch(p){case K.PATH_POSITION:case K.PATH_SPACING:{let x,E=1;p==K.PATH_SPACING?(x=new St(g),(m.spacingMode==nt.Length||m.spacingMode==nt.Fixed)&&(E=a)):(x=new yt(g),m.positionMode==kt.Fixed&&(E=a)),x.pathConstraintIndex=d;for(let w=0;w<g;w++){const b=e.readFloat(),I=e.readFloat()*E;x.setFrame(w,b,I),w<g-1&&this.readCurve(e,w,x)}n.push(x),h=Math.max(h,x.frames[(g-1)*yt.ENTRIES]);break}case K.PATH_MIX:{const x=new It(g);x.pathConstraintIndex=d;for(let E=0;E<g;E++){const w=e.readFloat(),b=e.readFloat(),I=e.readFloat();x.setFrame(E,w,b,I),E<g-1&&this.readCurve(e,E,x)}n.push(x),h=Math.max(h,x.frames[(g-1)*It.ENTRIES]);break}}}}for(let i=0,l=e.readInt(!0);i<l;i++){const d=s.skins[e.readInt(!0)];for(let m=0,u=e.readInt(!0);m<u;m++){const f=e.readInt(!0);for(let p=0,g=e.readInt(!0);p<g;p++){const x=d==null?void 0:d.getAttachment(f,e.readString()),E=x.bones!=null,w=x.vertices,b=E?w.length/3*2:w.length,I=e.readInt(!0),M=new re(I);M.slotIndex=f,M.attachment=x;for(let S=0;S<I;S++){const R=e.readFloat();let T,V=e.readInt(!0);if(V==0)T=E?k.newFloatArray(b):w;else{T=k.newFloatArray(b);const O=e.readInt(!0);if(V+=O,a==1)for(let v=O;v<V;v++)T[v]=e.readFloat();else for(let v=O;v<V;v++)T[v]=e.readFloat()*a;if(!E)for(let v=0,H=T.length;v<H;v++)T[v]+=w[v]}M.setFrame(S,R,T,d.name),S<I-1&&this.readCurve(e,S,M)}n.push(M),h=Math.max(h,M.frames[I-1])}}}const o=e.readInt(!0);if(o>0){const i=new _t(o),l=s.slots.length;for(let d=0;d<o;d++){const m=e.readFloat(),u=e.readInt(!0),f=k.newArray(l,0);for(let E=l-1;E>=0;E--)f[E]=-1;const p=k.newArray(l-u,0);let g=0,x=0;for(let E=0;E<u;E++){const w=e.readInt(!0);for(;g!=w;)p[x++]=g++;f[g+e.readInt(!0)]=g++}for(;g<l;)p[x++]=g++;for(let E=l-1;E>=0;E--)f[E]==-1&&(f[E]=p[--x]);i.setFrame(d,m,f)}n.push(i),h=Math.max(h,i.frames[o-1])}const r=e.readInt(!0);if(r>0){const i=new Gt(r);for(let l=0;l<r;l++){const d=e.readFloat(),m=s.events[e.readInt(!0)],u=new ue(d,m);u.intValue=e.readInt(!1),u.floatValue=e.readFloat(),u.stringValue=e.readBoolean()?e.readString():m.stringValue,u.data.audioPath!=null&&(u.volume=e.readFloat(),u.balance=e.readFloat()),i.setFrame(l,u)}n.push(i),h=Math.max(h,i.frames[r-1])}return new z(t,n,h)}readCurve(e,t,s){switch(e.readByte()){case K.CURVE_STEPPED:s.setStepped(t);break;case K.CURVE_BEZIER:this.setCurve(s,t,e.readFloat(),e.readFloat(),e.readFloat(),e.readFloat());break}}setCurve(e,t,s,n,a,h){e.setCurve(t,s,n,a,h)}};let J=K;J.AttachmentTypeValues=[0,1,2,3,4,5,6],J.TransformModeValues=[Z.Normal,Z.OnlyTranslation,Z.NoRotationOrReflection,Z.NoScale,Z.NoScaleOrReflection],J.PositionModeValues=[kt.Fixed,kt.Percent],J.SpacingModeValues=[nt.Length,nt.Fixed,nt.Percent],J.RotateModeValues=[Rt.Tangent,Rt.Chain,Rt.ChainScale],J.BlendModeValues=[Pt.NORMAL,Pt.ADD,Pt.MULTIPLY,Pt.SCREEN],J.BONE_ROTATE=0,J.BONE_TRANSLATE=1,J.BONE_SCALE=2,J.BONE_SHEAR=3,J.SLOT_ATTACHMENT=0,J.SLOT_COLOR=1,J.SLOT_TWO_COLOR=2,J.PATH_POSITION=0,J.PATH_SPACING=1,J.PATH_MIX=2,J.CURVE_LINEAR=0,J.CURVE_STEPPED=1,J.CURVE_BEZIER=2;class He{constructor(t,s,n,a,h){this.mesh=t,this.skin=s,this.slotIndex=n,this.parent=a,this.inheritDeform=h}}class Ge{constructor(t=null,s=null,n=null){this.bones=t,this.vertices=s,this.cVertices=n}}class je extends Be{}class Dt{constructor(t){this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=t}readSkeletonData(t){const s=this.scale,n=new xe,a=typeof t=="string"?JSON.parse(t):t,h=a.skeleton;if(h!=null){if(n.hash=h.hash,n.version=h.spine,n.version.substr(0,3)!=="3.4"){const c=`Spine 3.4 loader cant load version ${h.spine}. Please configure your pixi-spine bundle`;console.error(c)}n.version==="3.4.75"&&console.error("Unsupported skeleton data, 3.4.75 is deprecated, please export with a newer version of Spine."),n.x=h.x,n.y=h.y,n.width=h.width,n.height=h.height,n.fps=h.fps,n.imagesPath=h.images}if(a.bones)for(let c=0;c<a.bones.length;c++){const o=a.bones[c];let r=null;const i=this.getValue(o,"parent",null);if(i!=null&&(r=n.findBone(i),r==null))throw new Error(`Parent bone not found: ${i}`);const l=new de(n.bones.length,o.name,r);l.length=this.getValue(o,"length",0)*s,l.x=this.getValue(o,"x",0)*s,l.y=this.getValue(o,"y",0)*s,l.rotation=this.getValue(o,"rotation",0),l.scaleX=this.getValue(o,"scaleX",1),l.scaleY=this.getValue(o,"scaleY",1),l.shearX=this.getValue(o,"shearX",0),l.shearY=this.getValue(o,"shearY",0),l.transformMode=Dt.transformModeFromString(this.getValue(o,"transform","normal")),l.skinRequired=this.getValue(o,"skin",!1),n.bones.push(l)}if(a.slots)for(let c=0;c<a.slots.length;c++){const o=a.slots[c],r=o.name,i=o.bone,l=n.findBone(i);if(l==null)throw new Error(`Slot bone not found: ${i}`);const d=new Ee(n.slots.length,r,l),m=this.getValue(o,"color",null);m!=null&&d.color.setFromString(m);const u=this.getValue(o,"dark",null);u!=null&&(d.darkColor=new _(1,1,1,1),d.darkColor.setFromString(u)),d.attachmentName=this.getValue(o,"attachment",null),d.blendMode=Dt.blendModeFromString(this.getValue(o,"blend","normal")),n.slots.push(d)}if(a.ik)for(let c=0;c<a.ik.length;c++){const o=a.ik[c],r=new fe(o.name);r.order=this.getValue(o,"order",0),r.skinRequired=this.getValue(o,"skin",!1);for(let l=0;l<o.bones.length;l++){const d=o.bones[l],m=n.findBone(d);if(m==null)throw new Error(`IK bone not found: ${d}`);r.bones.push(m)}const i=o.target;if(r.target=n.findBone(i),r.target==null)throw new Error(`IK target bone not found: ${i}`);r.mix=this.getValue(o,"mix",1),r.softness=this.getValue(o,"softness",0)*s,r.bendDirection=this.getValue(o,"bendPositive",!0)?1:-1,r.compress=this.getValue(o,"compress",!1),r.stretch=this.getValue(o,"stretch",!1),r.uniform=this.getValue(o,"uniform",!1),n.ikConstraints.push(r)}if(a.transform)for(let c=0;c<a.transform.length;c++){const o=a.transform[c],r=new we(o.name);r.order=this.getValue(o,"order",0),r.skinRequired=this.getValue(o,"skin",!1);for(let l=0;l<o.bones.length;l++){const d=o.bones[l],m=n.findBone(d);if(m==null)throw new Error(`Transform constraint bone not found: ${d}`);r.bones.push(m)}const i=o.target;if(r.target=n.findBone(i),r.target==null)throw new Error(`Transform constraint target bone not found: ${i}`);r.local=this.getValue(o,"local",!1),r.relative=this.getValue(o,"relative",!1),r.offsetRotation=this.getValue(o,"rotation",0),r.offsetX=this.getValue(o,"x",0)*s,r.offsetY=this.getValue(o,"y",0)*s,r.offsetScaleX=this.getValue(o,"scaleX",0),r.offsetScaleY=this.getValue(o,"scaleY",0),r.offsetShearY=this.getValue(o,"shearY",0),r.rotateMix=this.getValue(o,"rotateMix",1),r.translateMix=this.getValue(o,"translateMix",1),r.scaleMix=this.getValue(o,"scaleMix",1),r.shearMix=this.getValue(o,"shearMix",1),n.transformConstraints.push(r)}if(a.path)for(let c=0;c<a.path.length;c++){const o=a.path[c],r=new ge(o.name);r.order=this.getValue(o,"order",0),r.skinRequired=this.getValue(o,"skin",!1);for(let l=0;l<o.bones.length;l++){const d=o.bones[l],m=n.findBone(d);if(m==null)throw new Error(`Transform constraint bone not found: ${d}`);r.bones.push(m)}const i=o.target;if(r.target=n.findSlot(i),r.target==null)throw new Error(`Path target slot not found: ${i}`);r.positionMode=Dt.positionModeFromString(this.getValue(o,"positionMode","percent")),r.spacingMode=Dt.spacingModeFromString(this.getValue(o,"spacingMode","length")),r.rotateMode=Dt.rotateModeFromString(this.getValue(o,"rotateMode","tangent")),r.offsetRotation=this.getValue(o,"rotation",0),r.position=this.getValue(o,"position",0),r.positionMode==kt.Fixed&&(r.position*=s),r.spacing=this.getValue(o,"spacing",0),(r.spacingMode==nt.Length||r.spacingMode==nt.Fixed)&&(r.spacing*=s),r.rotateMix=this.getValue(o,"rotateMix",1),r.translateMix=this.getValue(o,"translateMix",1),n.pathConstraints.push(r)}if(a.skins)for(let c=0;c<a.skins.length;c++){const o=a.skins[c],r=new zt(o.name);if(o.bones)for(let i=0;i<o.bones.length;i++){const l=n.findBone(o.bones[i]);if(l==null)throw new Error(`Skin bone not found: ${o.bones[c]}`);r.bones.push(l)}if(o.ik)for(let i=0;i<o.ik.length;i++){const l=n.findIkConstraint(o.ik[i]);if(l==null)throw new Error(`Skin IK constraint not found: ${o.ik[c]}`);r.constraints.push(l)}if(o.transform)for(let i=0;i<o.transform.length;i++){const l=n.findTransformConstraint(o.transform[i]);if(l==null)throw new Error(`Skin transform constraint not found: ${o.transform[c]}`);r.constraints.push(l)}if(o.path)for(let i=0;i<o.path.length;i++){const l=n.findPathConstraint(o.path[i]);if(l==null)throw new Error(`Skin path constraint not found: ${o.path[c]}`);r.constraints.push(l)}for(const i in o.attachments){const l=n.findSlot(i);if(l==null)throw new Error(`Slot not found: ${i}`);const d=o.attachments[i];for(const m in d){const u=this.readAttachment(d[m],r,l.index,m,n);u!=null&&r.setAttachment(l.index,m,u)}}n.skins.push(r),r.name=="default"&&(n.defaultSkin=r)}for(let c=0,o=this.linkedMeshes.length;c<o;c++){const r=this.linkedMeshes[c],i=r.skin==null?n.defaultSkin:n.findSkin(r.skin);if(i==null)throw new Error(`Skin not found: ${r.skin}`);const l=i.getAttachment(r.slotIndex,r.parent);if(l==null)throw new Error(`Parent mesh not found: ${r.parent}`);r.mesh.deformAttachment=r.inheritDeform?l:r.mesh,r.mesh.setParentMesh(l)}if(this.linkedMeshes.length=0,a.events)for(const c in a.events){const o=a.events[c],r=new me(c);r.intValue=this.getValue(o,"int",0),r.floatValue=this.getValue(o,"float",0),r.stringValue=this.getValue(o,"string",""),r.audioPath=this.getValue(o,"audio",null),r.audioPath!=null&&(r.volume=this.getValue(o,"volume",1),r.balance=this.getValue(o,"balance",0)),n.events.push(r)}if(a.animations)for(const c in a.animations){const o=a.animations[c];this.readAnimation(o,c,n)}return n}readAttachment(t,s,n,a,h){const c=this.scale;switch(a=this.getValue(t,"name",a),this.getValue(t,"type","region")){case"region":{const o=this.getValue(t,"path",a),r=this.attachmentLoader.newRegionAttachment(s,a,o);if(r==null)return null;r.path=o,r.x=this.getValue(t,"x",0)*c,r.y=this.getValue(t,"y",0)*c,r.scaleX=this.getValue(t,"scaleX",1),r.scaleY=this.getValue(t,"scaleY",1),r.rotation=this.getValue(t,"rotation",0),r.width=t.width*c,r.height=t.height*c;const i=this.getValue(t,"color",null);return i!=null&&r.color.setFromString(i),r}case"boundingbox":{const o=this.attachmentLoader.newBoundingBoxAttachment(s,a);if(o==null)return null;this.readVertices(t,o,t.vertexCount<<1);const r=this.getValue(t,"color",null);return r!=null&&o.color.setFromString(r),o}case"mesh":case"linkedmesh":{const o=this.getValue(t,"path",a),r=this.attachmentLoader.newMeshAttachment(s,a,o);if(r==null)return null;r.path=o;const i=this.getValue(t,"color",null);i!=null&&r.color.setFromString(i),r.width=this.getValue(t,"width",0)*c,r.height=this.getValue(t,"height",0)*c;const l=this.getValue(t,"parent",null);if(l!=null)return this.linkedMeshes.push(new Ze(r,this.getValue(t,"skin",null),n,l,this.getValue(t,"deform",!0))),r;const d=t.uvs;return this.readVertices(t,r,d.length),r.triangles=t.triangles,r.regionUVs=new Float32Array(d),r.edges=this.getValue(t,"edges",null),r.hullLength=this.getValue(t,"hull",0)*2,r}case"path":{const o=this.attachmentLoader.newPathAttachment(s,a);if(o==null)return null;o.closed=this.getValue(t,"closed",!1),o.constantSpeed=this.getValue(t,"constantSpeed",!0);const r=t.vertexCount;this.readVertices(t,o,r<<1);const i=k.newArray(r/3,0);for(let d=0;d<t.lengths.length;d++)i[d]=t.lengths[d]*c;o.lengths=i;const l=this.getValue(t,"color",null);return l!=null&&o.color.setFromString(l),o}case"point":{const o=this.attachmentLoader.newPointAttachment(s,a);if(o==null)return null;o.x=this.getValue(t,"x",0)*c,o.y=this.getValue(t,"y",0)*c,o.rotation=this.getValue(t,"rotation",0);const r=this.getValue(t,"color",null);return r!=null&&o.color.setFromString(r),o}case"clipping":{const o=this.attachmentLoader.newClippingAttachment(s,a);if(o==null)return null;const r=this.getValue(t,"end",null);if(r!=null){const d=h.findSlot(r);if(d==null)throw new Error(`Clipping end slot not found: ${r}`);o.endSlot=d}const i=t.vertexCount;this.readVertices(t,o,i<<1);const l=this.getValue(t,"color",null);return l!=null&&o.color.setFromString(l),o}}return null}readVertices(t,s,n){const a=this.scale;s.worldVerticesLength=n;const h=t.vertices;if(n==h.length){const r=k.toFloatArray(h);if(a!=1)for(let i=0,l=h.length;i<l;i++)r[i]*=a;s.vertices=r;return}const c=new Array,o=new Array;for(let r=0,i=h.length;r<i;){const l=h[r++];o.push(l);for(let d=r+l*4;r<d;r+=4)o.push(h[r]),c.push(h[r+1]*a),c.push(h[r+2]*a),c.push(h[r+3])}s.bones=o,s.vertices=k.toFloatArray(c)}readAnimation(t,s,n){const a=this.scale,h=new Array;let c=0;if(t.slots)for(const r in t.slots){const i=t.slots[r],l=n.findSlotIndex(r);if(l==-1)throw new Error(`Slot not found: ${r}`);for(const d in i){const m=i[d];if(d=="attachment"){const u=new vt(m.length);u.slotIndex=l;let f=0;for(let p=0;p<m.length;p++){const g=m[p];u.setFrame(f++,this.getValue(g,"time",0),g.name)}h.push(u),c=Math.max(c,u.frames[u.getFrameCount()-1])}else if(d=="color"){const u=new lt(m.length);u.slotIndex=l;let f=0;for(let p=0;p<m.length;p++){const g=m[p],x=new _;x.setFromString(g.color||"ffffffff"),u.setFrame(f,this.getValue(g,"time",0),x.r,x.g,x.b,x.a),this.readCurve(g,u,f),f++}h.push(u),c=Math.max(c,u.frames[(u.getFrameCount()-1)*lt.ENTRIES])}else if(d=="twoColor"){const u=new tt(m.length);u.slotIndex=l;let f=0;for(let p=0;p<m.length;p++){const g=m[p],x=new _,E=new _;x.setFromString(g.light),E.setFromString(g.dark),u.setFrame(f,this.getValue(g,"time",0),x.r,x.g,x.b,x.a,E.r,E.g,E.b),this.readCurve(g,u,f),f++}h.push(u),c=Math.max(c,u.frames[(u.getFrameCount()-1)*tt.ENTRIES])}else throw new Error(`Invalid timeline type for a slot: ${d} (${r})`)}}if(t.bones)for(const r in t.bones){const i=t.bones[r],l=n.findBoneIndex(r);if(l==-1)throw new Error(`Bone not found: ${r}`);for(const d in i){const m=i[d];if(d==="rotate"){const u=new st(m.length);u.boneIndex=l;let f=0;for(let p=0;p<m.length;p++){const g=m[p];u.setFrame(f,this.getValue(g,"time",0),this.getValue(g,"angle",0)),this.readCurve(g,u,f),f++}h.push(u),c=Math.max(c,u.frames[(u.getFrameCount()-1)*st.ENTRIES])}else if(d==="translate"||d==="scale"||d==="shear"){let u=null,f=1,p=0;d==="scale"?(u=new ft(m.length),p=1):d==="shear"?u=new gt(m.length):(u=new xt(m.length),f=a),u.boneIndex=l;let g=0;for(let x=0;x<m.length;x++){const E=m[x],w=this.getValue(E,"x",p),b=this.getValue(E,"y",p);u.setFrame(g,this.getValue(E,"time",0),w*f,b*f),this.readCurve(E,u,g),g++}h.push(u),c=Math.max(c,u.frames[(u.getFrameCount()-1)*xt.ENTRIES])}else throw new Error(`Invalid timeline type for a bone: ${d} (${r})`)}}if(t.ik)for(const r in t.ik){const i=t.ik[r],l=n.findIkConstraint(r),d=new at(i.length);d.ikConstraintIndex=n.ikConstraints.indexOf(l);let m=0;for(let u=0;u<i.length;u++){const f=i[u];d.setFrame(m,this.getValue(f,"time",0),this.getValue(f,"mix",1),this.getValue(f,"softness",0)*a),this.readCurve(f,d,m),m++}h.push(d),c=Math.max(c,d.frames[(d.getFrameCount()-1)*at.ENTRIES])}if(t.transform)for(const r in t.transform){const i=t.transform[r],l=n.findTransformConstraint(r),d=new ht(i.length);d.transformConstraintIndex=n.transformConstraints.indexOf(l);let m=0;for(let u=0;u<i.length;u++){const f=i[u];d.setFrame(m,this.getValue(f,"time",0),this.getValue(f,"rotateMix",1),this.getValue(f,"translateMix",1),this.getValue(f,"scaleMix",1),this.getValue(f,"shearMix",1)),this.readCurve(f,d,m),m++}h.push(d),c=Math.max(c,d.frames[(d.getFrameCount()-1)*ht.ENTRIES])}if(t.path)for(const r in t.path){const i=t.path[r],l=n.findPathConstraintIndex(r);if(l==-1)throw new Error(`Path constraint not found: ${r}`);const d=n.pathConstraints[l];for(const m in i){const u=i[m];if(m==="position"||m==="spacing"){let f=null,p=1;m==="spacing"?(f=new St(u.length),(d.spacingMode==nt.Length||d.spacingMode==nt.Fixed)&&(p=a)):(f=new yt(u.length),d.positionMode==kt.Fixed&&(p=a)),f.pathConstraintIndex=l;let g=0;for(let x=0;x<u.length;x++){const E=u[x];f.setFrame(g,this.getValue(E,"time",0),this.getValue(E,m,0)*p),this.readCurve(E,f,g),g++}h.push(f),c=Math.max(c,f.frames[(f.getFrameCount()-1)*yt.ENTRIES])}else if(m==="mix"){const f=new It(u.length);f.pathConstraintIndex=l;let p=0;for(let g=0;g<u.length;g++){const x=u[g];f.setFrame(p,this.getValue(x,"time",0),this.getValue(x,"rotateMix",1),this.getValue(x,"translateMix",1)),this.readCurve(x,f,p),p++}h.push(f),c=Math.max(c,f.frames[(f.getFrameCount()-1)*It.ENTRIES])}}}if(t.deform)for(const r in t.deform){const i=t.deform[r],l=n.findSkin(r);if(l==null){if(ne.FAIL_ON_NON_EXISTING_SKIN)throw new Error(`Skin not found: ${r}`);continue}for(const d in i){const m=i[d],u=n.findSlotIndex(d);if(u==-1)throw new Error(`Slot not found: ${m.name}`);for(const f in m){const p=m[f],g=l.getAttachment(u,f);if(g==null)throw new Error(`Deform attachment not found: ${p.name}`);const x=g.bones!=null,E=g.vertices,w=x?E.length/3*2:E.length,b=new re(p.length);b.slotIndex=u,b.attachment=g;let I=0;for(let M=0;M<p.length;M++){const S=p[M];let R;const T=this.getValue(S,"vertices",null);if(T==null)R=x?k.newFloatArray(w):E;else{R=k.newFloatArray(w);const V=this.getValue(S,"offset",0);if(k.arrayCopy(T,0,R,V,T.length),a!=1)for(let O=V,v=O+T.length;O<v;O++)R[O]*=a;if(!x)for(let O=0;O<w;O++)R[O]+=E[O]}b.setFrame(I,this.getValue(S,"time",0),R,l.name),this.readCurve(S,b,I),I++}h.push(b),c=Math.max(c,b.frames[b.getFrameCount()-1])}}}let o=t.drawOrder;if(o==null&&(o=t.draworder),o!=null){const r=new _t(o.length),i=n.slots.length;let l=0;for(let d=0;d<o.length;d++){const m=o[d];let u=null;const f=this.getValue(m,"offsets",null);if(f!=null){u=k.newArray(i,-1);const p=k.newArray(i-f.length,0);let g=0,x=0;for(let E=0;E<f.length;E++){const w=f[E],b=n.findSlotIndex(w.slot);if(b==-1)throw new Error(`Slot not found: ${w.slot}`);for(;g!=b;)p[x++]=g++;u[g+w.offset]=g++}for(;g<i;)p[x++]=g++;for(let E=i-1;E>=0;E--)u[E]==-1&&(u[E]=p[--x])}r.setFrame(l++,this.getValue(m,"time",0),u)}h.push(r),c=Math.max(c,r.frames[r.getFrameCount()-1])}if(t.events){const r=new Gt(t.events.length);let i=0;for(let l=0;l<t.events.length;l++){const d=t.events[l],m=n.findEvent(d.name);if(m==null)throw new Error(`Event not found: ${d.name}`);const u=new ue(k.toSinglePrecision(this.getValue(d,"time",0)),m);u.intValue=this.getValue(d,"int",m.intValue),u.floatValue=this.getValue(d,"float",m.floatValue),u.stringValue=this.getValue(d,"string",m.stringValue),u.data.audioPath!=null&&(u.volume=this.getValue(d,"volume",1),u.balance=this.getValue(d,"balance",0)),r.setFrame(i++,u)}h.push(r),c=Math.max(c,r.frames[r.getFrameCount()-1])}if(isNaN(c))throw new Error("Error while parsing animation, duration is NaN");n.animations.push(new z(s,h,c))}readCurve(t,s,n){if(t.hasOwnProperty("curve"))if(t.curve==="stepped")s.setStepped(n);else{const a=t.curve;s.setCurve(n,a,this.getValue(t,"c2",0),this.getValue(t,"c3",1),this.getValue(t,"c4",1))}}getValue(t,s,n){return t[s]!==void 0?t[s]:n}static blendModeFromString(t){if(t=t.toLowerCase(),t=="normal")return Pt.NORMAL;if(t=="additive")return Pt.ADD;if(t=="multiply")return Pt.MULTIPLY;if(t=="screen")return Pt.SCREEN;throw new Error(`Unknown blend mode: ${t}`)}static positionModeFromString(t){if(t=t.toLowerCase(),t=="fixed")return kt.Fixed;if(t=="percent")return kt.Percent;throw new Error(`Unknown position mode: ${t}`)}static spacingModeFromString(t){if(t=t.toLowerCase(),t=="length")return nt.Length;if(t=="fixed")return nt.Fixed;if(t=="percent")return nt.Percent;throw new Error(`Unknown position mode: ${t}`)}static rotateModeFromString(t){if(t=t.toLowerCase(),t=="tangent")return Rt.Tangent;if(t=="chain")return Rt.Chain;if(t=="chainscale")return Rt.ChainScale;throw new Error(`Unknown rotate mode: ${t}`)}static transformModeFromString(t){if(t=t.toLowerCase(),t=="normal")return Z.Normal;if(t=="onlytranslation")return Z.OnlyTranslation;if(t=="norotationorreflection")return Z.NoRotationOrReflection;if(t=="noscale")return Z.NoScale;if(t=="noscaleorreflection")return Z.NoScaleOrReflection;throw new Error(`Unknown transform mode: ${t}`)}}class Ze{constructor(t,s,n,a,h){this.mesh=t,this.skin=s,this.slotIndex=n,this.parent=a,this.inheritDeform=h}}class ze extends _e{createSkeleton(t){this.skeleton=new pe(t),this.skeleton.updateWorldTransform(),this.stateData=new he(t),this.state=new Et(this.stateData)}}export{z as Animation,Et as AnimationState,Ue as AnimationStateAdapter,he as AnimationStateData,$e as AtlasAttachmentLoader,se as Attachment,vt as AttachmentTimeline,ce as Bone,de as BoneData,Qt as BoundingBoxAttachment,Kt as ClippingAttachment,lt as ColorTimeline,Zt as ConstraintData,ut as CurveTimeline,re as DeformTimeline,_t as DrawOrderTimeline,ue as Event,me as EventData,oe as EventQueue,Gt as EventTimeline,mt as EventType,Ne as IkConstraint,fe as IkConstraintData,at as IkConstraintTimeline,qe as JitterEffect,Ot as MeshAttachment,Yt as PathAttachment,Wt as PathConstraint,ge as PathConstraintData,It as PathConstraintMixTimeline,yt as PathConstraintPositionTimeline,St as PathConstraintSpacingTimeline,Jt as PointAttachment,N as RegionAttachment,st as RotateTimeline,ft as ScaleTimeline,gt as ShearTimeline,pe as Skeleton,J as SkeletonBinary,je as SkeletonBounds,xe as SkeletonData,Dt as SkeletonJson,zt as Skin,be as SkinEntry,ae as Slot,Ee as SlotData,nt as SpacingMode,ze as Spine,Ce as SwirlEffect,Pe as TimelineType,jt as TrackEntry,ve as TransformConstraint,we as TransformConstraintData,ht as TransformConstraintTimeline,xt as TranslateTimeline,tt as TwoColorTimeline,Ft as VertexAttachment};
//# sourceMappingURL=runtime-3.4.mjs.map
