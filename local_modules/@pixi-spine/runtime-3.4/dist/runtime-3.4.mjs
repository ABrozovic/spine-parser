/*!
 * @pixi-spine/runtime-3.4 - v4.0.3
 * Compiled Thu, 15 Jun 2023 17:47:34 UTC
 *
 * @pixi-spine/runtime-3.4 is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 * 
 * Copyright 2023, Ivan Igorevich Popelyshev <ivan.popelyshev@gmail.com>, All Rights Reserved
 */import{Utils as T,AttachmentType as pt,Color as _,MathUtils as A,PowOut as Xe,MixBlend as y,MixDirection as bt,IntSet as Ye,Pool as De,settings as ne,TransformMode as Z,RotateMode as Tt,PositionMode as Vt,Vector2 as Le,BinaryInput as Oe,SkeletonBoundsBase as Be,SpineBase as _e}from"@pixi-spine/base";import{Matrix as We,BLEND_MODES as Pt}from"@pixi/core";class se{constructor(t){if(t==null)throw new Error("name cannot be null.");this.name=t}}const Ve=class extends se{constructor(e){super(e),this.id=(Ve.nextID++&65535)<<11,this.worldVerticesLength=0,this.deformAttachment=this}computeWorldVerticesOld(e,t){this.computeWorldVertices(e,0,this.worldVerticesLength,t,0,2)}computeWorldVertices(e,t,n,s,r,h){n=r+(n>>1)*h;const d=e.bone.skeleton,o=e.deform;let a=this.vertices;const i=this.bones;if(i==null){o.length>0&&(a=o);const c=e.bone.matrix,f=c.tx,p=c.ty,g=c.a,x=c.c,E=c.b,w=c.d;for(let b=t,I=r;I<n;b+=2,I+=h){const M=a[b],S=a[b+1];s[I]=M*g+S*x+f,s[I+1]=M*E+S*w+p}return}let l=0,u=0;for(let c=0;c<t;c+=2){const f=i[l];l+=f+1,u+=f}const m=d.bones;if(o.length==0)for(let c=r,f=u*3;c<n;c+=h){let p=0,g=0,x=i[l++];for(x+=l;l<x;l++,f+=3){const E=m[i[l]].matrix,w=a[f],b=a[f+1],I=a[f+2];p+=(w*E.a+b*E.c+E.tx)*I,g+=(w*E.b+b*E.d+E.ty)*I}s[c]=p,s[c+1]=g}else{const c=o;for(let f=r,p=u*3,g=u<<1;f<n;f+=h){let x=0,E=0,w=i[l++];for(w+=l;l<w;l++,p+=3,g+=2){const b=m[i[l]].matrix,I=a[p]+c[g],M=a[p+1]+c[g+1],S=a[p+2];x+=(I*b.a+M*b.c+b.tx)*S,E+=(I*b.b+M*b.d+b.ty)*S}s[f]=x,s[f+1]=E}}}copyTo(e){this.bones!=null?(e.bones=new Array(this.bones.length),T.arrayCopy(this.bones,0,e.bones,0,this.bones.length)):e.bones=null,this.vertices!=null?(e.vertices=T.newFloatArray(this.vertices.length),T.arrayCopy(this.vertices,0,e.vertices,0,this.vertices.length)):e.vertices=null,e.worldVerticesLength=this.worldVerticesLength,e.deformAttachment=this.deformAttachment}};let Ft=Ve;Ft.nextID=0;class Qt extends Ft{constructor(t){super(t),this.type=pt.BoundingBox,this.color=new _(1,1,1,1)}copy(){const t=new Qt(this.name);return this.copyTo(t),t.color.setFromColor(this.color),t}}class Kt extends Ft{constructor(t){super(t),this.type=pt.Clipping,this.color=new _(.2275,.2275,.8078,1)}copy(){const t=new Kt(this.name);return this.copyTo(t),t.endSlot=this.endSlot,t.color.setFromColor(this.color),t}}class Lt extends Ft{constructor(t){super(t),this.type=pt.Mesh,this.color=new _(1,1,1,1),this.tempColor=new _(0,0,0,0)}getParentMesh(){return this.parentMesh}setParentMesh(t){this.parentMesh=t,t!=null&&(this.bones=t.bones,this.vertices=t.vertices,this.worldVerticesLength=t.worldVerticesLength,this.regionUVs=t.regionUVs,this.triangles=t.triangles,this.hullLength=t.hullLength,this.worldVerticesLength=t.worldVerticesLength)}copy(){if(this.parentMesh!=null)return this.newLinkedMesh();const t=new Lt(this.name);return t.region=this.region,t.path=this.path,t.color.setFromColor(this.color),this.copyTo(t),t.regionUVs=new Float32Array(this.regionUVs.length),T.arrayCopy(this.regionUVs,0,t.regionUVs,0,this.regionUVs.length),t.triangles=new Array(this.triangles.length),T.arrayCopy(this.triangles,0,t.triangles,0,this.triangles.length),t.hullLength=this.hullLength,this.edges!=null&&(t.edges=new Array(this.edges.length),T.arrayCopy(this.edges,0,t.edges,0,this.edges.length)),t.width=this.width,t.height=this.height,t}newLinkedMesh(){const t=new Lt(this.name);return t.region=this.region,t.path=this.path,t.color.setFromColor(this.color),t.deformAttachment=this.deformAttachment,t.setParentMesh(this.parentMesh!=null?this.parentMesh:this),t}}class Yt extends Ft{constructor(t){super(t),this.type=pt.Path,this.closed=!1,this.constantSpeed=!1,this.color=new _(1,1,1,1)}copy(){const t=new Yt(this.name);return this.copyTo(t),t.lengths=new Array(this.lengths.length),T.arrayCopy(this.lengths,0,t.lengths,0,this.lengths.length),t.closed=closed,t.constantSpeed=this.constantSpeed,t.color.setFromColor(this.color),t}}class Jt extends Ft{constructor(t){super(t),this.type=pt.Point,this.color=new _(.38,.94,0,1)}computeWorldPosition(t,n){const s=t.matrix;return n.x=this.x*s.a+this.y*s.c+t.worldX,n.y=this.x*s.b+this.y*s.d+t.worldY,n}computeWorldRotation(t){const n=t.matrix,s=A.cosDeg(this.rotation),r=A.sinDeg(this.rotation),h=s*n.a+r*n.c,d=s*n.b+r*n.d;return Math.atan2(d,h)*A.radDeg}copy(){const t=new Jt(this.name);return t.x=this.x,t.y=this.y,t.rotation=this.rotation,t.color.setFromColor(this.color),t}}class ae{constructor(t,n){if(this.deform=new Array,t==null)throw new Error("data cannot be null.");if(n==null)throw new Error("bone cannot be null.");this.data=t,this.bone=n,this.color=new _,this.darkColor=t.darkColor==null?null:new _,this.setToSetupPose(),this.blendMode=this.data.blendMode}getAttachment(){return this.attachment}setAttachment(t){this.attachment!=t&&(this.attachment=t,this.attachmentTime=this.bone.skeleton.time,this.deform.length=0)}setAttachmentTime(t){this.attachmentTime=this.bone.skeleton.time-t}getAttachmentTime(){return this.bone.skeleton.time-this.attachmentTime}setToSetupPose(){this.color.setFromColor(this.data.color),this.darkColor!=null&&this.darkColor.setFromColor(this.data.darkColor),this.data.attachmentName==null?this.attachment=null:(this.attachment=null,this.setAttachment(this.bone.skeleton.getAttachment(this.data.index,this.data.attachmentName)))}}const et=class extends se{constructor(e){super(e),this.type=pt.Region,this.x=0,this.y=0,this.scaleX=1,this.scaleY=1,this.rotation=0,this.width=0,this.height=0,this.color=new _(1,1,1,1),this.offset=T.newFloatArray(8),this.uvs=T.newFloatArray(8),this.tempColor=new _(1,1,1,1)}updateOffset(){const e=this.width/this.region.originalWidth*this.scaleX,t=this.height/this.region.originalHeight*this.scaleY,n=-this.width/2*this.scaleX+this.region.offsetX*e,s=-this.height/2*this.scaleY+this.region.offsetY*t,r=n+this.region.width*e,h=s+this.region.height*t,d=this.rotation*Math.PI/180,o=Math.cos(d),a=Math.sin(d),i=n*o+this.x,l=n*a,u=s*o+this.y,m=s*a,c=r*o+this.x,f=r*a,p=h*o+this.y,g=h*a,x=this.offset;x[et.OX1]=i-m,x[et.OY1]=u+l,x[et.OX2]=i-g,x[et.OY2]=p+l,x[et.OX3]=c-g,x[et.OY3]=p+f,x[et.OX4]=c-m,x[et.OY4]=u+f}setRegion(e){this.region=e;const t=this.uvs;e.rotate?(t[2]=e.u,t[3]=e.v2,t[4]=e.u,t[5]=e.v,t[6]=e.u2,t[7]=e.v,t[0]=e.u2,t[1]=e.v2):(t[0]=e.u,t[1]=e.v2,t[2]=e.u,t[3]=e.v,t[4]=e.u2,t[5]=e.v,t[6]=e.u2,t[7]=e.v2)}computeWorldVertices(e,t,n,s){const r=this.offset,h=e instanceof ae?e.bone.matrix:e.matrix,d=h.tx,o=h.ty,a=h.a,i=h.c,l=h.b,u=h.d;let m=0,c=0;m=r[et.OX1],c=r[et.OY1],t[n]=m*a+c*i+d,t[n+1]=m*l+c*u+o,n+=s,m=r[et.OX2],c=r[et.OY2],t[n]=m*a+c*i+d,t[n+1]=m*l+c*u+o,n+=s,m=r[et.OX3],c=r[et.OY3],t[n]=m*a+c*i+d,t[n+1]=m*l+c*u+o,n+=s,m=r[et.OX4],c=r[et.OY4],t[n]=m*a+c*i+d,t[n+1]=m*l+c*u+o}copy(){const e=new et(this.name);return e.region=this.region,e.rendererObject=this.rendererObject,e.path=this.path,e.x=this.x,e.y=this.y,e.scaleX=this.scaleX,e.scaleY=this.scaleY,e.rotation=this.rotation,e.width=this.width,e.height=this.height,T.arrayCopy(this.uvs,0,e.uvs,0,8),T.arrayCopy(this.offset,0,e.offset,0,8),e.color.setFromColor(this.color),e}};let N=et;N.OX1=0,N.OY1=1,N.OX2=2,N.OY2=3,N.OX3=4,N.OY3=5,N.OX4=6,N.OY4=7,N.X1=0,N.Y1=1,N.C1R=2,N.C1G=3,N.C1B=4,N.C1A=5,N.U1=6,N.V1=7,N.X2=8,N.Y2=9,N.C2R=10,N.C2G=11,N.C2B=12,N.C2A=13,N.U2=14,N.V2=15,N.X3=16,N.Y3=17,N.C3R=18,N.C3G=19,N.C3B=20,N.C3A=21,N.U3=22,N.V3=23,N.X4=24,N.Y4=25,N.C4R=26,N.C4G=27,N.C4B=28,N.C4A=29,N.U4=30,N.V4=31;class qe{constructor(t,n){this.jitterX=0,this.jitterY=0,this.jitterX=t,this.jitterY=n}begin(t){}transform(t,n,s,r){t.x+=A.randomTriangular(-this.jitterX,this.jitterY),t.y+=A.randomTriangular(-this.jitterX,this.jitterY)}end(){}}const ke=class{constructor(e){this.centerX=0,this.centerY=0,this.radius=0,this.angle=0,this.worldX=0,this.worldY=0,this.radius=e}begin(e){this.worldX=e.x+this.centerX,this.worldY=e.y+this.centerY}transform(e,t,n,s){const r=this.angle*A.degreesToRadians,h=e.x-this.worldX,d=e.y-this.worldY,o=Math.sqrt(h*h+d*d);if(o<this.radius){const a=ke.interpolation.apply(0,r,(this.radius-o)/this.radius),i=Math.cos(a),l=Math.sin(a);e.x=i*h-l*d+this.worldX,e.y=l*h+i*d+this.worldY}}end(){}};let Ce=ke;Ce.interpolation=new Xe(2);class z{constructor(t,n,s){if(t==null)throw new Error("name cannot be null.");if(n==null)throw new Error("timelines cannot be null.");this.name=t,this.timelines=n,this.timelineIds=[];for(let r=0;r<n.length;r++)this.timelineIds[n[r].getPropertyId()]=!0;this.duration=s}hasTimeline(t){return this.timelineIds[t]==!0}apply(t,n,s,r,h,d,o,a){if(t==null)throw new Error("skeleton cannot be null.");r&&this.duration!=0&&(s%=this.duration,n>0&&(n%=this.duration));const i=this.timelines;for(let l=0,u=i.length;l<u;l++)i[l].apply(t,n,s,h,d,o,a)}static binarySearch(t,n,s=1){let r=0,h=t.length/s-2;if(h==0)return s;let d=h>>>1;for(;;){if(t[(d+1)*s]<=n?r=d+1:h=d,r==h)return(r+1)*s;d=r+h>>>1}}static linearSearch(t,n,s){for(let r=0,h=t.length-s;r<=h;r+=s)if(t[r]>n)return r;return-1}}var Pe=(e=>(e[e.rotate=0]="rotate",e[e.translate=1]="translate",e[e.scale=2]="scale",e[e.shear=3]="shear",e[e.attachment=4]="attachment",e[e.color=5]="color",e[e.deform=6]="deform",e[e.event=7]="event",e[e.drawOrder=8]="drawOrder",e[e.ikConstraint=9]="ikConstraint",e[e.transformConstraint=10]="transformConstraint",e[e.pathConstraintPosition=11]="pathConstraintPosition",e[e.pathConstraintSpacing=12]="pathConstraintSpacing",e[e.pathConstraintMix=13]="pathConstraintMix",e[e.twoColor=14]="twoColor",e))(Pe||{});const Q=class{constructor(e){if(this.curveData=[],e<=0)throw new Error(`frameCount must be > 0: ${e}`);this.curves=T.newFloatArray((e-1)*Q.BEZIER_SIZE)}getFrameCount(){return this.curves.length/Q.BEZIER_SIZE+1}setLinear(e){this.curves[e*Q.BEZIER_SIZE]=Q.LINEAR}setStepped(e){this.curves[e*Q.BEZIER_SIZE]=Q.STEPPED}getCurveType(e){const t=e*Q.BEZIER_SIZE;if(t==this.curves.length)return Q.LINEAR;const n=this.curves[t];return n==Q.LINEAR?Q.LINEAR:n==Q.STEPPED?Q.STEPPED:Q.BEZIER}setCurve(e,t,n,s,r){this.curveData.push({frameIndex:e,cx1:t,cy1:n,cx2:s,cy2:r});const h=(-t*2+s)*.03,d=(-n*2+r)*.03,o=((t-s)*3+1)*.006,a=((n-r)*3+1)*.006;let i=h*2+o,l=d*2+a,u=t*.3+h+o*.16666667,m=n*.3+d+a*.16666667,c=e*Q.BEZIER_SIZE;const f=this.curves;f[c++]=Q.BEZIER;let p=u,g=m;for(let x=c+Q.BEZIER_SIZE-1;c<x;c+=2)f[c]=p,f[c+1]=g,u+=i,m+=l,i+=o,l+=a,p+=u,g+=m}getCurvePercent(e,t){t=A.clamp(t,0,1);const n=this.curves;let s=e*Q.BEZIER_SIZE;const r=n[s];if(r==Q.LINEAR)return t;if(r==Q.STEPPED)return 0;s++;let h=0;for(let o=s,a=s+Q.BEZIER_SIZE-1;s<a;s+=2)if(h=n[s],h>=t){let i,l;return s==o?(i=0,l=0):(i=n[s-2],l=n[s-1]),l+(n[s+1]-l)*(t-i)/(h-i)}const d=n[s-1];return d+(1-d)*(t-h)/(1-h)}};let ut=Q;ut.LINEAR=0,ut.STEPPED=1,ut.BEZIER=2,ut.BEZIER_SIZE=10*2-1;const Nt=class extends ut{constructor(t){super(t),this.data=[],this.frames=T.newFloatArray(t<<1)}getPropertyId(){return(0<<24)+this.boneIndex}setFrame(t,n,s){this.data.push({frameIndex:t,time:n,degrees:s}),t<<=1,this.frames[t]=n,this.frames[t+Nt.ROTATION]=s}apply(t,n,s,r,h,d,o){const a=this.frames,i=t.bones[this.boneIndex];if(!i.active)return;if(s<a[0]){switch(d){case y.setup:i.rotation=i.data.rotation;return;case y.first:const p=i.data.rotation-i.rotation;i.rotation+=(p-(16384-(16384.499999999996-p/360|0))*360)*h}return}if(s>=a[a.length-Nt.ENTRIES]){let p=a[a.length+Nt.PREV_ROTATION];switch(d){case y.setup:i.rotation=i.data.rotation+p*h;break;case y.first:case y.replace:p+=i.data.rotation-i.rotation,p-=(16384-(16384.499999999996-p/360|0))*360;case y.add:i.rotation+=p*h}return}const l=z.binarySearch(a,s,Nt.ENTRIES),u=a[l+Nt.PREV_ROTATION],m=a[l],c=this.getCurvePercent((l>>1)-1,1-(s-m)/(a[l+Nt.PREV_TIME]-m));let f=a[l+Nt.ROTATION]-u;switch(f=u+(f-(16384-(16384.499999999996-f/360|0))*360)*c,d){case y.setup:i.rotation=i.data.rotation+(f-(16384-(16384.499999999996-f/360|0))*360)*h;break;case y.first:case y.replace:f+=i.data.rotation-i.rotation;case y.add:i.rotation+=(f-(16384-(16384.499999999996-f/360|0))*360)*h}}};let st=Nt;st.ENTRIES=2,st.PREV_TIME=-2,st.PREV_ROTATION=-1,st.ROTATION=1;const ot=class extends ut{constructor(e){super(e),this.data=[],this.frames=T.newFloatArray(e*ot.ENTRIES)}getPropertyId(){return(1<<24)+this.boneIndex}setFrame(e,t,n,s){this.data.push({frameIndex:e,time:t,x:n,y:s}),e*=ot.ENTRIES,this.frames[e]=t,this.frames[e+ot.X]=n,this.frames[e+ot.Y]=s}apply(e,t,n,s,r,h,d){const o=this.frames,a=e.bones[this.boneIndex];if(!a.active)return;if(n<o[0]){switch(h){case y.setup:a.x=a.data.x,a.y=a.data.y;return;case y.first:a.x+=(a.data.x-a.x)*r,a.y+=(a.data.y-a.y)*r}return}let i=0,l=0;if(n>=o[o.length-ot.ENTRIES])i=o[o.length+ot.PREV_X],l=o[o.length+ot.PREV_Y];else{const u=z.binarySearch(o,n,ot.ENTRIES);i=o[u+ot.PREV_X],l=o[u+ot.PREV_Y];const m=o[u],c=this.getCurvePercent(u/ot.ENTRIES-1,1-(n-m)/(o[u+ot.PREV_TIME]-m));i+=(o[u+ot.X]-i)*c,l+=(o[u+ot.Y]-l)*c}switch(h){case y.setup:a.x=a.data.x+i*r,a.y=a.data.y+l*r;break;case y.first:case y.replace:a.x+=(a.data.x+i-a.x)*r,a.y+=(a.data.y+l-a.y)*r;break;case y.add:a.x+=i*r,a.y+=l*r}}};let xt=ot;xt.ENTRIES=3,xt.PREV_TIME=-3,xt.PREV_X=-2,xt.PREV_Y=-1,xt.X=1,xt.Y=2;class ft extends xt{constructor(t){super(t)}getPropertyId(){return(2<<24)+this.boneIndex}apply(t,n,s,r,h,d,o){const a=this.frames,i=t.bones[this.boneIndex];if(!i.active)return;if(s<a[0]){switch(d){case y.setup:i.scaleX=i.data.scaleX,i.scaleY=i.data.scaleY;return;case y.first:i.scaleX+=(i.data.scaleX-i.scaleX)*h,i.scaleY+=(i.data.scaleY-i.scaleY)*h}return}let l=0,u=0;if(s>=a[a.length-ft.ENTRIES])l=a[a.length+ft.PREV_X]*i.data.scaleX,u=a[a.length+ft.PREV_Y]*i.data.scaleY;else{const m=z.binarySearch(a,s,ft.ENTRIES);l=a[m+ft.PREV_X],u=a[m+ft.PREV_Y];const c=a[m],f=this.getCurvePercent(m/ft.ENTRIES-1,1-(s-c)/(a[m+ft.PREV_TIME]-c));l=(l+(a[m+ft.X]-l)*f)*i.data.scaleX,u=(u+(a[m+ft.Y]-u)*f)*i.data.scaleY}if(h==1)d==y.add?(i.scaleX+=l-i.data.scaleX,i.scaleY+=u-i.data.scaleY):(i.scaleX=l,i.scaleY=u);else{let m=0,c=0;if(o==bt.mixOut)switch(d){case y.setup:m=i.data.scaleX,c=i.data.scaleY,i.scaleX=m+(Math.abs(l)*A.signum(m)-m)*h,i.scaleY=c+(Math.abs(u)*A.signum(c)-c)*h;break;case y.first:case y.replace:m=i.scaleX,c=i.scaleY,i.scaleX=m+(Math.abs(l)*A.signum(m)-m)*h,i.scaleY=c+(Math.abs(u)*A.signum(c)-c)*h;break;case y.add:m=i.scaleX,c=i.scaleY,i.scaleX=m+(Math.abs(l)*A.signum(m)-i.data.scaleX)*h,i.scaleY=c+(Math.abs(u)*A.signum(c)-i.data.scaleY)*h}else switch(d){case y.setup:m=Math.abs(i.data.scaleX)*A.signum(l),c=Math.abs(i.data.scaleY)*A.signum(u),i.scaleX=m+(l-m)*h,i.scaleY=c+(u-c)*h;break;case y.first:case y.replace:m=Math.abs(i.scaleX)*A.signum(l),c=Math.abs(i.scaleY)*A.signum(u),i.scaleX=m+(l-m)*h,i.scaleY=c+(u-c)*h;break;case y.add:m=A.signum(l),c=A.signum(u),i.scaleX=Math.abs(i.scaleX)*m+(l-Math.abs(i.data.scaleX)*m)*h,i.scaleY=Math.abs(i.scaleY)*c+(u-Math.abs(i.data.scaleY)*c)*h}}}}class gt extends xt{constructor(t){super(t)}getPropertyId(){return(3<<24)+this.boneIndex}apply(t,n,s,r,h,d,o){const a=this.frames,i=t.bones[this.boneIndex];if(!i.active)return;if(s<a[0]){switch(d){case y.setup:i.shearX=i.data.shearX,i.shearY=i.data.shearY;return;case y.first:i.shearX+=(i.data.shearX-i.shearX)*h,i.shearY+=(i.data.shearY-i.shearY)*h}return}let l=0,u=0;if(s>=a[a.length-gt.ENTRIES])l=a[a.length+gt.PREV_X],u=a[a.length+gt.PREV_Y];else{const m=z.binarySearch(a,s,gt.ENTRIES);l=a[m+gt.PREV_X],u=a[m+gt.PREV_Y];const c=a[m],f=this.getCurvePercent(m/gt.ENTRIES-1,1-(s-c)/(a[m+gt.PREV_TIME]-c));l=l+(a[m+gt.X]-l)*f,u=u+(a[m+gt.Y]-u)*f}switch(d){case y.setup:i.shearX=i.data.shearX+l*h,i.shearY=i.data.shearY+u*h;break;case y.first:case y.replace:i.shearX+=(i.data.shearX+l-i.shearX)*h,i.shearY+=(i.data.shearY+u-i.shearY)*h;break;case y.add:i.shearX+=l*h,i.shearY+=u*h}}}const q=class extends ut{constructor(e){super(e),this.data=[],this.frames=T.newFloatArray(e*q.ENTRIES)}getPropertyId(){return(5<<24)+this.slotIndex}setFrame(e,t,n,s,r,h){this.data.push({frameIndex:e,time:t,r:n,g:s,b:r,a:h}),e*=q.ENTRIES,this.frames[e]=t,this.frames[e+q.R]=n,this.frames[e+q.G]=s,this.frames[e+q.B]=r,this.frames[e+q.A]=h}apply(e,t,n,s,r,h,d){const o=e.slots[this.slotIndex];if(!o.bone.active)return;const a=this.frames;if(n<a[0]){switch(h){case y.setup:o.color.setFromColor(o.data.color);return;case y.first:const c=o.color,f=o.data.color;c.add((f.r-c.r)*r,(f.g-c.g)*r,(f.b-c.b)*r,(f.a-c.a)*r)}return}let i=0,l=0,u=0,m=0;if(n>=a[a.length-q.ENTRIES]){const c=a.length;i=a[c+q.PREV_R],l=a[c+q.PREV_G],u=a[c+q.PREV_B],m=a[c+q.PREV_A]}else{const c=z.binarySearch(a,n,q.ENTRIES);i=a[c+q.PREV_R],l=a[c+q.PREV_G],u=a[c+q.PREV_B],m=a[c+q.PREV_A];const f=a[c],p=this.getCurvePercent(c/q.ENTRIES-1,1-(n-f)/(a[c+q.PREV_TIME]-f));i+=(a[c+q.R]-i)*p,l+=(a[c+q.G]-l)*p,u+=(a[c+q.B]-u)*p,m+=(a[c+q.A]-m)*p}if(r==1)o.color.set(i,l,u,m);else{const c=o.color;h==y.setup&&c.setFromColor(o.data.color),c.add((i-c.r)*r,(l-c.g)*r,(u-c.b)*r,(m-c.a)*r)}}};let lt=q;lt.ENTRIES=5,lt.PREV_TIME=-5,lt.PREV_R=-4,lt.PREV_G=-3,lt.PREV_B=-2,lt.PREV_A=-1,lt.R=1,lt.G=2,lt.B=3,lt.A=4;const O=class extends ut{constructor(e){super(e),this.data=[],this.frames=T.newFloatArray(e*O.ENTRIES)}getPropertyId(){return(14<<24)+this.slotIndex}setFrame(e,t,n,s,r,h,d,o,a){this.data.push({frameIndex:e,time:t,r:n,g:s,b:r,a:h,r2:d,g2:o,b2:a}),e*=O.ENTRIES,this.frames[e]=t,this.frames[e+O.R]=n,this.frames[e+O.G]=s,this.frames[e+O.B]=r,this.frames[e+O.A]=h,this.frames[e+O.R2]=d,this.frames[e+O.G2]=o,this.frames[e+O.B2]=a}apply(e,t,n,s,r,h,d){const o=e.slots[this.slotIndex];if(!o.bone.active)return;const a=this.frames;if(n<a[0]){switch(h){case y.setup:o.color.setFromColor(o.data.color),o.darkColor.setFromColor(o.data.darkColor);return;case y.first:const g=o.color,x=o.darkColor,E=o.data.color,w=o.data.darkColor;g.add((E.r-g.r)*r,(E.g-g.g)*r,(E.b-g.b)*r,(E.a-g.a)*r),x.add((w.r-x.r)*r,(w.g-x.g)*r,(w.b-x.b)*r,0)}return}let i=0,l=0,u=0,m=0,c=0,f=0,p=0;if(n>=a[a.length-O.ENTRIES]){const g=a.length;i=a[g+O.PREV_R],l=a[g+O.PREV_G],u=a[g+O.PREV_B],m=a[g+O.PREV_A],c=a[g+O.PREV_R2],f=a[g+O.PREV_G2],p=a[g+O.PREV_B2]}else{const g=z.binarySearch(a,n,O.ENTRIES);i=a[g+O.PREV_R],l=a[g+O.PREV_G],u=a[g+O.PREV_B],m=a[g+O.PREV_A],c=a[g+O.PREV_R2],f=a[g+O.PREV_G2],p=a[g+O.PREV_B2];const x=a[g],E=this.getCurvePercent(g/O.ENTRIES-1,1-(n-x)/(a[g+O.PREV_TIME]-x));i+=(a[g+O.R]-i)*E,l+=(a[g+O.G]-l)*E,u+=(a[g+O.B]-u)*E,m+=(a[g+O.A]-m)*E,c+=(a[g+O.R2]-c)*E,f+=(a[g+O.G2]-f)*E,p+=(a[g+O.B2]-p)*E}if(r==1)o.color.set(i,l,u,m),o.darkColor.set(c,f,p,1);else{const g=o.color,x=o.darkColor;h==y.setup&&(g.setFromColor(o.data.color),x.setFromColor(o.data.darkColor)),g.add((i-g.r)*r,(l-g.g)*r,(u-g.b)*r,(m-g.a)*r),x.add((c-x.r)*r,(f-x.g)*r,(p-x.b)*r,0)}}};let tt=O;tt.ENTRIES=8,tt.PREV_TIME=-8,tt.PREV_R=-7,tt.PREV_G=-6,tt.PREV_B=-5,tt.PREV_A=-4,tt.PREV_R2=-3,tt.PREV_G2=-2,tt.PREV_B2=-1,tt.R=1,tt.G=2,tt.B=3,tt.A=4,tt.R2=5,tt.G2=6,tt.B2=7;class vt{constructor(t){this.data=[],this.frames=T.newFloatArray(t),this.attachmentNames=new Array(t)}getPropertyId(){return(4<<24)+this.slotIndex}getFrameCount(){return this.frames.length}setFrame(t,n,s){this.data.push({frameIndex:t,time:n,attachmentName:s}),this.frames[t]=n,this.attachmentNames[t]=s}apply(t,n,s,r,h,d,o){const a=t.slots[this.slotIndex];if(!a.bone.active)return;if(o==bt.mixOut){d==y.setup&&this.setAttachment(t,a,a.data.attachmentName);return}const i=this.frames;if(s<i[0]){(d==y.setup||d==y.first)&&this.setAttachment(t,a,a.data.attachmentName);return}let l=0;s>=i[i.length-1]?l=i.length-1:l=z.binarySearch(i,s,1)-1;const u=this.attachmentNames[l];t.slots[this.slotIndex].setAttachment(u==null?null:t.getAttachment(this.slotIndex,u))}setAttachment(t,n,s){n.setAttachment(s==null?null:t.getAttachment(this.slotIndex,s))}}let Fe=null;class re extends ut{constructor(t){super(t),this.data=[],this.frames=T.newFloatArray(t),this.frameVertices=new Array(t),Fe==null&&(Fe=T.newFloatArray(64))}getPropertyId(){return(6<<27)+Number(this.attachment.id)+this.slotIndex}setFrame(t,n,s,r){this.data.push({frameIndex:t,time:n,vertices:s,skin:r}),this.frames[t]=n,this.frameVertices[t]=s}apply(t,n,s,r,h,d,o){const a=t.slots[this.slotIndex];if(!a.bone.active)return;const i=a.getAttachment();if(!(i instanceof Ft)||i.deformAttachment!=this.attachment)return;const l=a.deform||[];l.length==0&&(d=y.setup);const u=this.frameVertices,m=u[0].length,c=this.frames;if(s<c[0]){const b=i;switch(d){case y.setup:l.length=0;return;case y.first:if(h==1){l.length=0;break}const I=T.setArraySize(l,m);if(b.bones==null){const M=b.vertices;for(let S=0;S<m;S++)I[S]+=(M[S]-I[S])*h}else{h=1-h;for(let M=0;M<m;M++)I[M]*=h}}return}const f=T.setArraySize(l,m);if(s>=c[c.length-1]){const b=u[c.length-1];if(h==1)if(d==y.add){const I=i;if(I.bones==null){const M=I.vertices;for(let S=0;S<m;S++)f[S]+=b[S]-M[S]}else for(let M=0;M<m;M++)f[M]+=b[M]}else T.arrayCopy(b,0,f,0,m);else switch(d){case y.setup:{const M=i;if(M.bones==null){const S=M.vertices;for(let V=0;V<m;V++){const R=S[V];f[V]=R+(b[V]-R)*h}}else for(let S=0;S<m;S++)f[S]=b[S]*h;break}case y.first:case y.replace:for(let M=0;M<m;M++)f[M]+=(b[M]-f[M])*h;break;case y.add:const I=i;if(I.bones==null){const M=I.vertices;for(let S=0;S<m;S++)f[S]+=(b[S]-M[S])*h}else for(let M=0;M<m;M++)f[M]+=b[M]*h}return}const p=z.binarySearch(c,s),g=u[p-1],x=u[p],E=c[p],w=this.getCurvePercent(p-1,1-(s-E)/(c[p-1]-E));if(h==1)if(d==y.add){const b=i;if(b.bones==null){const I=b.vertices;for(let M=0;M<m;M++){const S=g[M];f[M]+=S+(x[M]-S)*w-I[M]}}else for(let I=0;I<m;I++){const M=g[I];f[I]+=M+(x[I]-M)*w}}else for(let b=0;b<m;b++){const I=g[b];f[b]=I+(x[b]-I)*w}else switch(d){case y.setup:{const I=i;if(I.bones==null){const M=I.vertices;for(let S=0;S<m;S++){const V=g[S],R=M[S];f[S]=R+(V+(x[S]-V)*w-R)*h}}else for(let M=0;M<m;M++){const S=g[M];f[M]=(S+(x[M]-S)*w)*h}break}case y.first:case y.replace:for(let I=0;I<m;I++){const M=g[I];f[I]+=(M+(x[I]-M)*w-f[I])*h}break;case y.add:const b=i;if(b.bones==null){const I=b.vertices;for(let M=0;M<m;M++){const S=g[M];f[M]+=(S+(x[M]-S)*w-I[M])*h}}else for(let I=0;I<m;I++){const M=g[I];f[I]+=(M+(x[I]-M)*w)*h}}}}class Gt{constructor(t){this.data=[],this.frames=T.newFloatArray(t),this.events=new Array(t)}getPropertyId(){return 7<<24}getFrameCount(){return this.frames.length}setFrame(t,n){this.data.push({frameIndex:t,event:n}),this.frames[t]=n.time,this.events[t]=n}apply(t,n,s,r,h,d,o){if(r==null)return;const a=this.frames,i=this.frames.length;if(n>s)this.apply(t,n,Number.MAX_VALUE,r,h,d,o),n=-1;else if(n>=a[i-1])return;if(s<a[0])return;let l=0;if(n<a[0])l=0;else{l=z.binarySearch(a,n);const u=a[l];for(;l>0&&a[l-1]==u;)l--}for(;l<i&&s>=a[l];l++)r.push(this.events[l])}}class _t{constructor(t){this.data=[],this.frames=T.newFloatArray(t),this.drawOrders=new Array(t)}getPropertyId(){return 8<<24}getFrameCount(){return this.frames.length}setFrame(t,n,s){this.data.push({frameIndex:t,time:n,drawOrder:s}),this.frames[t]=n,this.drawOrders[t]=s}apply(t,n,s,r,h,d,o){const a=t.drawOrder,i=t.slots;if(o==bt.mixOut&&d==y.setup){T.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}const l=this.frames;if(s<l[0]){(d==y.setup||d==y.first)&&T.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}let u=0;s>=l[l.length-1]?u=l.length-1:u=z.binarySearch(l,s)-1;const m=this.drawOrders[u];if(m==null)T.arrayCopy(i,0,a,0,i.length);else for(let c=0,f=m.length;c<f;c++)a[c]=i[m[c]]}}const j=class extends ut{constructor(e){super(e),this.data=[],this.frames=T.newFloatArray(e*j.ENTRIES)}getPropertyId(){return(9<<24)+this.ikConstraintIndex}setFrame(e,t,n,s){this.data.push({frameIndex:e,time:t,mix:n,bendDirection:s}),e*=j.ENTRIES,this.frames[e]=t,this.frames[e+j.MIX]=n,this.frames[e+j.BEND_DIRECTION]=s}apply(e,t,n,s,r,h,d){const o=this.frames,a=e.ikConstraints[this.ikConstraintIndex];if(!a.active)return;if(n<o[0]){switch(h){case y.setup:a.mix=a.data.mix,a.softness=a.data.softness,a.bendDirection=a.data.bendDirection,a.compress=a.data.compress,a.stretch=a.data.stretch;return;case y.first:a.mix+=(a.data.mix-a.mix)*r,a.softness+=(a.data.softness-a.softness)*r,a.bendDirection=a.data.bendDirection,a.compress=a.data.compress,a.stretch=a.data.stretch}return}if(n>=o[o.length-j.ENTRIES]){h===y.setup?(a.mix=a.data.mix+(o[o.length+j.PREV_MIX]-a.data.mix)*r,a.softness=a.data.softness+(o[o.length+j.PREV_SOFTNESS]-a.data.softness)*r,d===bt.mixOut?(a.bendDirection=a.data.bendDirection,a.compress=a.data.compress,a.stretch=a.data.stretch):(a.bendDirection=o[o.length+j.PREV_BEND_DIRECTION],a.compress=o[o.length+j.PREV_COMPRESS]!==0,a.stretch=o[o.length+j.PREV_STRETCH]!==0)):(a.mix+=(o[o.length+j.PREV_MIX]-a.mix)*r,a.softness+=(o[o.length+j.PREV_SOFTNESS]-a.softness)*r,d===bt.mixIn&&(a.bendDirection=o[o.length+j.PREV_BEND_DIRECTION],a.compress=o[o.length+j.PREV_COMPRESS]!==0,a.stretch=o[o.length+j.PREV_STRETCH]!==0));return}const i=z.binarySearch(o,n,j.ENTRIES),l=o[i+j.PREV_MIX],u=o[i],m=this.getCurvePercent(i/j.ENTRIES-1,1-(n-u)/(o[i+j.PREV_TIME]-u));a.mix+=(l+(o[i+j.MIX]-l)*m-a.mix)*r,a.bendDirection=Math.floor(o[i+j.PREV_BEND_DIRECTION])}};let at=j;at.ENTRIES=6,at.PREV_TIME=-6,at.PREV_MIX=-5,at.PREV_SOFTNESS=-4,at.PREV_BEND_DIRECTION=-3,at.PREV_COMPRESS=-2,at.PREV_STRETCH=-1,at.MIX=1,at.SOFTNESS=2,at.BEND_DIRECTION=3,at.COMPRESS=4,at.STRETCH=5;const U=class extends ut{constructor(e){super(e),this.data=[],this.frames=T.newFloatArray(e*U.ENTRIES)}getPropertyId(){return(10<<24)+this.transformConstraintIndex}setFrame(e,t,n,s,r,h){this.data.push({frameIndex:e,time:t,rotateMix:n,translateMix:s,scaleMix:r,shearMix:h}),e*=U.ENTRIES,this.frames[e]=t,this.frames[e+U.ROTATE]=n,this.frames[e+U.TRANSLATE]=s,this.frames[e+U.SCALE]=r,this.frames[e+U.SHEAR]=h}apply(e,t,n,s,r,h,d){const o=this.frames,a=e.transformConstraints[this.transformConstraintIndex];if(!a.active)return;if(n<o[0]){const c=a.data;switch(h){case y.setup:a.rotateMix=c.rotateMix,a.translateMix=c.translateMix,a.scaleMix=c.scaleMix,a.shearMix=c.shearMix;return;case y.first:a.rotateMix+=(c.rotateMix-a.rotateMix)*r,a.translateMix+=(c.translateMix-a.translateMix)*r,a.scaleMix+=(c.scaleMix-a.scaleMix)*r,a.shearMix+=(c.shearMix-a.shearMix)*r}return}let i=0,l=0,u=0,m=0;if(n>=o[o.length-U.ENTRIES]){const c=o.length;i=o[c+U.PREV_ROTATE],l=o[c+U.PREV_TRANSLATE],u=o[c+U.PREV_SCALE],m=o[c+U.PREV_SHEAR]}else{const c=z.binarySearch(o,n,U.ENTRIES);i=o[c+U.PREV_ROTATE],l=o[c+U.PREV_TRANSLATE],u=o[c+U.PREV_SCALE],m=o[c+U.PREV_SHEAR];const f=o[c],p=this.getCurvePercent(c/U.ENTRIES-1,1-(n-f)/(o[c+U.PREV_TIME]-f));i+=(o[c+U.ROTATE]-i)*p,l+=(o[c+U.TRANSLATE]-l)*p,u+=(o[c+U.SCALE]-u)*p,m+=(o[c+U.SHEAR]-m)*p}if(h==y.setup){const c=a.data;a.rotateMix=c.rotateMix+(i-c.rotateMix)*r,a.translateMix=c.translateMix+(l-c.translateMix)*r,a.scaleMix=c.scaleMix+(u-c.scaleMix)*r,a.shearMix=c.shearMix+(m-c.shearMix)*r}else a.rotateMix+=(i-a.rotateMix)*r,a.translateMix+=(l-a.translateMix)*r,a.scaleMix+=(u-a.scaleMix)*r,a.shearMix+=(m-a.shearMix)*r}};let ht=U;ht.ENTRIES=5,ht.PREV_TIME=-5,ht.PREV_ROTATE=-4,ht.PREV_TRANSLATE=-3,ht.PREV_SCALE=-2,ht.PREV_SHEAR=-1,ht.ROTATE=1,ht.TRANSLATE=2,ht.SCALE=3,ht.SHEAR=4;const Mt=class extends ut{constructor(e){super(e),this.data=[],this.frames=T.newFloatArray(e*Mt.ENTRIES)}getPropertyId(){return(11<<24)+this.pathConstraintIndex}setFrame(e,t,n){this.data.push({frameIndex:e,time:t,value:n}),e*=Mt.ENTRIES,this.frames[e]=t,this.frames[e+Mt.VALUE]=n}apply(e,t,n,s,r,h,d){const o=this.frames,a=e.pathConstraints[this.pathConstraintIndex];if(!a.active)return;if(n<o[0]){switch(h){case y.setup:a.position=a.data.position;return;case y.first:a.position+=(a.data.position-a.position)*r}return}let i=0;if(n>=o[o.length-Mt.ENTRIES])i=o[o.length+Mt.PREV_VALUE];else{const l=z.binarySearch(o,n,Mt.ENTRIES);i=o[l+Mt.PREV_VALUE];const u=o[l],m=this.getCurvePercent(l/Mt.ENTRIES-1,1-(n-u)/(o[l+Mt.PREV_TIME]-u));i+=(o[l+Mt.VALUE]-i)*m}h==y.setup?a.position=a.data.position+(i-a.data.position)*r:a.position+=(i-a.position)*r}};let At=Mt;At.ENTRIES=2,At.PREV_TIME=-2,At.PREV_VALUE=-1,At.VALUE=1;class St extends At{constructor(t){super(t)}getPropertyId(){return(12<<24)+this.pathConstraintIndex}apply(t,n,s,r,h,d,o){const a=this.frames,i=t.pathConstraints[this.pathConstraintIndex];if(!i.active)return;if(s<a[0]){switch(d){case y.setup:i.spacing=i.data.spacing;return;case y.first:i.spacing+=(i.data.spacing-i.spacing)*h}return}let l=0;if(s>=a[a.length-St.ENTRIES])l=a[a.length+St.PREV_VALUE];else{const u=z.binarySearch(a,s,St.ENTRIES);l=a[u+St.PREV_VALUE];const m=a[u],c=this.getCurvePercent(u/St.ENTRIES-1,1-(s-m)/(a[u+St.PREV_TIME]-m));l+=(a[u+St.VALUE]-l)*c}d==y.setup?i.spacing=i.data.spacing+(l-i.data.spacing)*h:i.spacing+=(l-i.spacing)*h}}const ct=class extends ut{constructor(e){super(e),this.data=[],this.frames=T.newFloatArray(e*ct.ENTRIES)}getPropertyId(){return(13<<24)+this.pathConstraintIndex}setFrame(e,t,n,s){this.data.push({frameIndex:e,time:t,rotateMix:n,translateMix:s}),e*=ct.ENTRIES,this.frames[e]=t,this.frames[e+ct.ROTATE]=n,this.frames[e+ct.TRANSLATE]=s}apply(e,t,n,s,r,h,d){const o=this.frames,a=e.pathConstraints[this.pathConstraintIndex];if(!a.active)return;if(n<o[0]){switch(h){case y.setup:a.rotateMix=a.data.rotateMix,a.translateMix=a.data.translateMix;return;case y.first:a.rotateMix+=(a.data.rotateMix-a.rotateMix)*r,a.translateMix+=(a.data.translateMix-a.translateMix)*r}return}let i=0,l=0;if(n>=o[o.length-ct.ENTRIES])i=o[o.length+ct.PREV_ROTATE],l=o[o.length+ct.PREV_TRANSLATE];else{const u=z.binarySearch(o,n,ct.ENTRIES);i=o[u+ct.PREV_ROTATE],l=o[u+ct.PREV_TRANSLATE];const m=o[u],c=this.getCurvePercent(u/ct.ENTRIES-1,1-(n-m)/(o[u+ct.PREV_TIME]-m));i+=(o[u+ct.ROTATE]-i)*c,l+=(o[u+ct.TRANSLATE]-l)*c}h==y.setup?(a.rotateMix=a.data.rotateMix+(i-a.data.rotateMix)*r,a.translateMix=a.data.translateMix+(l-a.data.translateMix)*r):(a.rotateMix+=(i-a.rotateMix)*r,a.translateMix+=(l-a.translateMix)*r)}};let It=ct;It.ENTRIES=3,It.PREV_TIME=-3,It.PREV_ROTATE=-2,It.PREV_TRANSLATE=-1,It.ROTATE=1,It.TRANSLATE=2;const $=class{constructor(e){this.tracks=new Array,this.timeScale=1,this.unkeyedState=0,this.events=new Array,this.listeners=new Array,this.queue=new oe(this),this.propertyIDs=new Ye,this.animationsChanged=!1,this.trackEntryPool=new De(()=>new jt),this.data=e}update(e){e*=this.timeScale;const t=this.tracks;for(let n=0,s=t.length;n<s;n++){const r=t[n];if(r==null)continue;r.animationLast=r.nextAnimationLast,r.trackLast=r.nextTrackLast;let h=e*r.timeScale;if(r.delay>0){if(r.delay-=h,r.delay>0)continue;h=-r.delay,r.delay=0}let d=r.next;if(d!=null){const o=r.trackLast-d.delay;if(o>=0){for(d.delay=0,d.trackTime+=r.timeScale==0?0:(o/r.timeScale+e)*d.timeScale,r.trackTime+=h,this.setCurrent(n,d,!0);d.mixingFrom!=null;)d.mixTime+=e,d=d.mixingFrom;continue}}else if(r.trackLast>=r.trackEnd&&r.mixingFrom==null){t[n]=null,this.queue.end(r),this.disposeNext(r);continue}if(r.mixingFrom!=null&&this.updateMixingFrom(r,e)){let o=r.mixingFrom;for(r.mixingFrom=null,o!=null&&(o.mixingTo=null);o!=null;)this.queue.end(o),o=o.mixingFrom}r.trackTime+=h}this.queue.drain()}updateMixingFrom(e,t){const n=e.mixingFrom;if(n==null)return!0;const s=this.updateMixingFrom(n,t);return n.animationLast=n.nextAnimationLast,n.trackLast=n.nextTrackLast,e.mixTime>0&&e.mixTime>=e.mixDuration?((n.totalAlpha==0||e.mixDuration==0)&&(e.mixingFrom=n.mixingFrom,n.mixingFrom!=null&&(n.mixingFrom.mixingTo=e),e.interruptAlpha=n.interruptAlpha,this.queue.end(n)),s):(n.trackTime+=t*n.timeScale,e.mixTime+=t,!1)}apply(e){if(e==null)throw new Error("skeleton cannot be null.");this.animationsChanged&&this._animationsChanged();const t=this.events,n=this.tracks;let s=!1;for(let d=0,o=n.length;d<o;d++){const a=n[d];if(a==null||a.delay>0)continue;s=!0;const i=d==0?y.first:a.mixBlend;let l=a.alpha;a.mixingFrom!=null?l*=this.applyMixingFrom(a,e,i):a.trackTime>=a.trackEnd&&a.next==null&&(l=0);const u=a.animationLast,m=a.getAnimationTime(),c=a.animation.timelines.length,f=a.animation.timelines;if(d==0&&l==1||i==y.add)for(let p=0;p<c;p++){T.webkit602BugfixHelper(l,i);const g=f[p];g instanceof vt?this.applyAttachmentTimeline(g,e,m,i,!0):g.apply(e,u,m,t,l,i,bt.mixIn)}else{const p=a.timelineMode,g=a.timelinesRotation.length==0;g&&T.setArraySize(a.timelinesRotation,c<<1,null);const x=a.timelinesRotation;for(let E=0;E<c;E++){const w=f[E],b=p[E]==$.SUBSEQUENT?i:y.setup;w instanceof st?this.applyRotateTimeline(w,e,m,l,b,x,E<<1,g):w instanceof vt?this.applyAttachmentTimeline(w,e,m,i,!0):(T.webkit602BugfixHelper(l,i),w.apply(e,u,m,t,l,b,bt.mixIn))}}this.queueEvents(a,m),t.length=0,a.nextAnimationLast=m,a.nextTrackLast=a.trackTime}const r=this.unkeyedState+$.SETUP,h=e.slots;for(let d=0,o=e.slots.length;d<o;d++){const a=h[d];if(a.attachmentState==r){const i=a.data.attachmentName;a.setAttachment(i==null?null:e.getAttachment(a.data.index,i))}}return this.unkeyedState+=2,this.queue.drain(),s}applyMixingFrom(e,t,n){const s=e.mixingFrom;s.mixingFrom!=null&&this.applyMixingFrom(s,t,n);let r=0;e.mixDuration==0?(r=1,n==y.first&&(n=y.setup)):(r=e.mixTime/e.mixDuration,r>1&&(r=1),n!=y.first&&(n=s.mixBlend));const h=r<s.eventThreshold?this.events:null,d=r<s.attachmentThreshold,o=r<s.drawOrderThreshold,a=s.animationLast,i=s.getAnimationTime(),l=s.animation.timelines.length,u=s.animation.timelines,m=s.alpha*e.interruptAlpha,c=m*(1-r);if(n==y.add)for(let f=0;f<l;f++)u[f].apply(t,a,i,h,c,n,bt.mixOut);else{const f=s.timelineMode,p=s.timelineHoldMix,g=s.timelinesRotation.length==0;g&&T.setArraySize(s.timelinesRotation,l<<1,null);const x=s.timelinesRotation;s.totalAlpha=0;for(let E=0;E<l;E++){const w=u[E];let b=bt.mixOut,I,M=0;switch(f[E]){case $.SUBSEQUENT:if(!o&&w instanceof _t)continue;I=n,M=c;break;case $.FIRST:I=y.setup,M=c;break;case $.HOLD_SUBSEQUENT:I=n,M=m;break;case $.HOLD_FIRST:I=y.setup,M=m;break;default:I=y.setup;const S=p[E];M=m*Math.max(0,1-S.mixTime/S.mixDuration);break}s.totalAlpha+=M,w instanceof st?this.applyRotateTimeline(w,t,i,M,I,x,E<<1,g):w instanceof vt?this.applyAttachmentTimeline(w,t,i,I,d):(T.webkit602BugfixHelper(M,n),o&&w instanceof _t&&I==y.setup&&(b=bt.mixIn),w.apply(t,a,i,h,M,I,b))}}return e.mixDuration>0&&this.queueEvents(s,i),this.events.length=0,s.nextAnimationLast=i,s.nextTrackLast=s.trackTime,r}applyAttachmentTimeline(e,t,n,s,r){const h=t.slots[e.slotIndex];if(!h.bone.active)return;const d=e.frames;if(n<d[0])(s==y.setup||s==y.first)&&this.setAttachment(t,h,h.data.attachmentName,r);else{let o;n>=d[d.length-1]?o=d.length-1:o=z.binarySearch(d,n)-1,this.setAttachment(t,h,e.attachmentNames[o],r)}h.attachmentState<=this.unkeyedState&&(h.attachmentState=this.unkeyedState+$.SETUP)}setAttachment(e,t,n,s){t.setAttachment(n==null?null:e.getAttachment(t.data.index,n)),s&&(t.attachmentState=this.unkeyedState+$.CURRENT)}applyRotateTimeline(e,t,n,s,r,h,d,o){if(o&&(h[d]=0),s==1){e.apply(t,0,n,null,1,r,bt.mixIn);return}const a=e,i=a.frames,l=t.bones[a.boneIndex];if(!l.active)return;let u=0,m=0;if(n<i[0])switch(r){case y.setup:l.rotation=l.data.rotation;default:return;case y.first:u=l.rotation,m=l.data.rotation}else if(u=r==y.setup?l.data.rotation:l.rotation,n>=i[i.length-st.ENTRIES])m=l.data.rotation+i[i.length+st.PREV_ROTATION];else{const p=z.binarySearch(i,n,st.ENTRIES),g=i[p+st.PREV_ROTATION],x=i[p],E=a.getCurvePercent((p>>1)-1,1-(n-x)/(i[p+st.PREV_TIME]-x));m=i[p+st.ROTATION]-g,m-=(16384-(16384.499999999996-m/360|0))*360,m=g+m*E+l.data.rotation,m-=(16384-(16384.499999999996-m/360|0))*360}let c=0,f=m-u;if(f-=(16384-(16384.499999999996-f/360|0))*360,f==0)c=h[d];else{let p=0,g=0;o?(p=0,g=f):(p=h[d],g=h[d+1]);const x=f>0;let E=p>=0;A.signum(g)!=A.signum(f)&&Math.abs(g)<=90&&(Math.abs(p)>180&&(p+=360*A.signum(p)),E=x),c=f+p-p%360,E!=x&&(c+=360*A.signum(p)),h[d]=c}h[d+1]=f,u+=c*s,l.rotation=u-(16384-(16384.499999999996-u/360|0))*360}queueEvents(e,t){const n=e.animationStart,s=e.animationEnd,r=s-n,h=e.trackLast%r,d=this.events;let o=0;const a=d.length;for(;o<a;o++){const l=d[o];if(l.time<h)break;l.time>s||this.queue.event(e,l)}let i=!1;for(e.loop?i=r==0||h>e.trackTime%r:i=t>=s&&e.animationLast<s,i&&this.queue.complete(e);o<a;o++)d[o].time<n||this.queue.event(e,d[o])}clearTracks(){const e=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let t=0,n=this.tracks.length;t<n;t++)this.clearTrack(t);this.tracks.length=0,this.queue.drainDisabled=e,this.queue.drain()}clearTrack(e){if(e>=this.tracks.length)return;const t=this.tracks[e];if(t==null)return;this.queue.end(t),this.disposeNext(t);let n=t;for(;;){const s=n.mixingFrom;if(s==null)break;this.queue.end(s),n.mixingFrom=null,n.mixingTo=null,n=s}this.tracks[t.trackIndex]=null,this.queue.drain()}setCurrent(e,t,n){const s=this.expandToIndex(e);this.tracks[e]=t,s!=null&&(n&&this.queue.interrupt(s),t.mixingFrom=s,s.mixingTo=t,t.mixTime=0,s.mixingFrom!=null&&s.mixDuration>0&&(t.interruptAlpha*=Math.min(1,s.mixTime/s.mixDuration)),s.timelinesRotation.length=0),this.queue.start(t)}setAnimation(e,t,n){const s=this.data.skeletonData.findAnimation(t);if(s==null)throw new Error(`Animation not found: ${t}`);return this.setAnimationWith(e,s,n)}setAnimationWith(e,t,n){if(t==null)throw new Error("animation cannot be null.");let s=!0,r=this.expandToIndex(e);r!=null&&(r.nextTrackLast==-1?(this.tracks[e]=r.mixingFrom,this.queue.interrupt(r),this.queue.end(r),this.disposeNext(r),r=r.mixingFrom,s=!1):this.disposeNext(r));const h=this.trackEntry(e,t,n,r);return this.setCurrent(e,h,s),this.queue.drain(),h}addAnimation(e,t,n,s){const r=this.data.skeletonData.findAnimation(t);if(r==null)throw new Error(`Animation not found: ${t}`);return this.addAnimationWith(e,r,n,s)}addAnimationWith(e,t,n,s){if(t==null)throw new Error("animation cannot be null.");let r=this.expandToIndex(e);if(r!=null)for(;r.next!=null;)r=r.next;const h=this.trackEntry(e,t,n,r);if(r==null)this.setCurrent(e,h,!0),this.queue.drain();else if(r.next=h,s<=0){const d=r.animationEnd-r.animationStart;d!=0?(r.loop?s+=d*(1+(r.trackTime/d|0)):s+=Math.max(d,r.trackTime),s-=this.data.getMix(r.animation,t)):s=r.trackTime}return h.delay=s,h}setEmptyAnimation(e,t){const n=this.setAnimationWith(e,$.emptyAnimation,!1);return n.mixDuration=t,n.trackEnd=t,n}addEmptyAnimation(e,t,n){n<=0&&(n-=t);const s=this.addAnimationWith(e,$.emptyAnimation,!1,n);return s.mixDuration=t,s.trackEnd=t,s}setEmptyAnimations(e){const t=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let n=0,s=this.tracks.length;n<s;n++){const r=this.tracks[n];r!=null&&this.setEmptyAnimation(r.trackIndex,e)}this.queue.drainDisabled=t,this.queue.drain()}expandToIndex(e){return e<this.tracks.length?this.tracks[e]:(T.ensureArrayCapacity(this.tracks,e+1,null),this.tracks.length=e+1,null)}trackEntry(e,t,n,s){const r=this.trackEntryPool.obtain();return r.trackIndex=e,r.animation=t,r.loop=n,r.holdPrevious=!1,r.eventThreshold=0,r.attachmentThreshold=0,r.drawOrderThreshold=0,r.animationStart=0,r.animationEnd=t.duration,r.animationLast=-1,r.nextAnimationLast=-1,r.delay=0,r.trackTime=0,r.trackLast=-1,r.nextTrackLast=-1,r.trackEnd=Number.MAX_VALUE,r.timeScale=1,r.alpha=1,r.interruptAlpha=1,r.mixTime=0,r.mixDuration=s==null?0:this.data.getMix(s.animation,t),r.mixBlend=y.replace,r}disposeNext(e){let t=e.next;for(;t!=null;)this.queue.dispose(t),t=t.next;e.next=null}_animationsChanged(){this.animationsChanged=!1,this.propertyIDs.clear();for(let e=0,t=this.tracks.length;e<t;e++){let n=this.tracks[e];if(n!=null){for(;n.mixingFrom!=null;)n=n.mixingFrom;do(n.mixingFrom==null||n.mixBlend!=y.add)&&this.computeHold(n),n=n.mixingTo;while(n!=null)}}}computeHold(e){const t=e.mixingTo,n=e.animation.timelines,s=e.animation.timelines.length,r=T.setArraySize(e.timelineMode,s);e.timelineHoldMix.length=0;const h=T.setArraySize(e.timelineHoldMix,s),d=this.propertyIDs;if(t!=null&&t.holdPrevious){for(let o=0;o<s;o++)r[o]=d.add(n[o].getPropertyId())?$.HOLD_FIRST:$.HOLD_SUBSEQUENT;return}t:for(let o=0;o<s;o++){const a=n[o],i=a.getPropertyId();if(!d.add(i))r[o]=$.SUBSEQUENT;else if(t==null||a instanceof vt||a instanceof _t||a instanceof Gt||!t.animation.hasTimeline(i))r[o]=$.FIRST;else{for(let l=t.mixingTo;l!=null;l=l.mixingTo)if(!l.animation.hasTimeline(i)){if(e.mixDuration>0){r[o]=$.HOLD_MIX,h[o]=l;continue t}break}r[o]=$.HOLD_FIRST}}}getCurrent(e){return e>=this.tracks.length?null:this.tracks[e]}addListener(e){if(e==null)throw new Error("listener cannot be null.");this.listeners.push(e)}removeListener(e){const t=this.listeners.indexOf(e);t>=0&&this.listeners.splice(t,1)}clearListeners(){this.listeners.length=0}clearListenerNotifications(){this.queue.clear()}setAnimationByName(e,t,n){$.deprecatedWarning1||($.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.")),this.setAnimation(e,t,n)}addAnimationByName(e,t,n,s){$.deprecatedWarning2||($.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.")),this.addAnimation(e,t,n,s)}hasAnimation(e){return this.data.skeletonData.findAnimation(e)!==null}hasAnimationByName(e){return $.deprecatedWarning3||($.deprecatedWarning3=!0,console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.")),this.hasAnimation(e)}};let Et=$;Et.emptyAnimation=new z("<empty>",[],0),Et.SUBSEQUENT=0,Et.FIRST=1,Et.HOLD_SUBSEQUENT=2,Et.HOLD_FIRST=3,Et.HOLD_MIX=4,Et.SETUP=1,Et.CURRENT=2,Et.deprecatedWarning1=!1,Et.deprecatedWarning2=!1,Et.deprecatedWarning3=!1;const kt=class{constructor(){this.mixBlend=y.replace,this.timelineMode=new Array,this.timelineHoldMix=new Array,this.timelinesRotation=new Array}reset(){this.next=null,this.mixingFrom=null,this.mixingTo=null,this.animation=null,this.listener=null,this.timelineMode.length=0,this.timelineHoldMix.length=0,this.timelinesRotation.length=0}getAnimationTime(){if(this.loop){const e=this.animationEnd-this.animationStart;return e==0?this.animationStart:this.trackTime%e+this.animationStart}return Math.min(this.trackTime+this.animationStart,this.animationEnd)}setAnimationLast(e){this.animationLast=e,this.nextAnimationLast=e}isComplete(){return this.trackTime>=this.animationEnd-this.animationStart}resetRotationDirections(){this.timelinesRotation.length=0}get time(){return kt.deprecatedWarning1||(kt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime}set time(e){kt.deprecatedWarning1||(kt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime=e}get endTime(){return kt.deprecatedWarning2||(kt.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime}set endTime(e){kt.deprecatedWarning2||(kt.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime=e}loopsCount(){return Math.floor(this.trackTime/this.trackEnd)}};let jt=kt;jt.deprecatedWarning1=!1,jt.deprecatedWarning2=!1;const ie=class{constructor(e){this.objects=[],this.drainDisabled=!1,this.animState=e}start(e){this.objects.push(mt.start),this.objects.push(e),this.animState.animationsChanged=!0}interrupt(e){this.objects.push(mt.interrupt),this.objects.push(e)}end(e){this.objects.push(mt.end),this.objects.push(e),this.animState.animationsChanged=!0}dispose(e){this.objects.push(mt.dispose),this.objects.push(e)}complete(e){this.objects.push(mt.complete),this.objects.push(e)}event(e,t){this.objects.push(mt.event),this.objects.push(e),this.objects.push(t)}deprecateStuff(){return ie.deprecatedWarning1||(ie.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'")),!0}drain(){if(this.drainDisabled)return;this.drainDisabled=!0;const e=this.objects,t=this.animState.listeners;for(let n=0;n<e.length;n+=2){const s=e[n],r=e[n+1];switch(s){case mt.start:r.listener!=null&&r.listener.start&&r.listener.start(r);for(let o=0;o<t.length;o++)t[o].start&&t[o].start(r);r.onStart&&this.deprecateStuff()&&r.onStart(r.trackIndex),this.animState.onStart&&this.deprecateStuff()&&this.deprecateStuff&&this.animState.onStart(r.trackIndex);break;case mt.interrupt:r.listener!=null&&r.listener.interrupt&&r.listener.interrupt(r);for(let o=0;o<t.length;o++)t[o].interrupt&&t[o].interrupt(r);break;case mt.end:r.listener!=null&&r.listener.end&&r.listener.end(r);for(let o=0;o<t.length;o++)t[o].end&&t[o].end(r);r.onEnd&&this.deprecateStuff()&&r.onEnd(r.trackIndex),this.animState.onEnd&&this.deprecateStuff()&&this.animState.onEnd(r.trackIndex);case mt.dispose:r.listener!=null&&r.listener.dispose&&r.listener.dispose(r);for(let o=0;o<t.length;o++)t[o].dispose&&t[o].dispose(r);this.animState.trackEntryPool.free(r);break;case mt.complete:r.listener!=null&&r.listener.complete&&r.listener.complete(r);for(let o=0;o<t.length;o++)t[o].complete&&t[o].complete(r);const h=A.toInt(r.loopsCount());r.onComplete&&this.deprecateStuff()&&r.onComplete(r.trackIndex,h),this.animState.onComplete&&this.deprecateStuff()&&this.animState.onComplete(r.trackIndex,h);break;case mt.event:const d=e[n+++2];r.listener!=null&&r.listener.event&&r.listener.event(r,d);for(let o=0;o<t.length;o++)t[o].event&&t[o].event(r,d);r.onEvent&&this.deprecateStuff()&&r.onEvent(r.trackIndex,d),this.animState.onEvent&&this.deprecateStuff()&&this.animState.onEvent(r.trackIndex,d);break}}this.clear(),this.drainDisabled=!1}clear(){this.objects.length=0}};let oe=ie;oe.deprecatedWarning1=!1;var mt=(e=>(e[e.start=0]="start",e[e.interrupt=1]="interrupt",e[e.end=2]="end",e[e.dispose=3]="dispose",e[e.complete=4]="complete",e[e.event=5]="event",e))(mt||{});class Ue{start(t){}interrupt(t){}end(t){}dispose(t){}complete(t){}event(t,n){}}const le=class{constructor(e){if(this.animationToMixTime={},this.defaultMix=0,e==null)throw new Error("skeletonData cannot be null.");this.skeletonData=e}setMix(e,t,n){const s=this.skeletonData.findAnimation(e);if(s==null)throw new Error(`Animation not found: ${e}`);const r=this.skeletonData.findAnimation(t);if(r==null)throw new Error(`Animation not found: ${t}`);this.setMixWith(s,r,n)}setMixByName(e,t,n){le.deprecatedWarning1||(le.deprecatedWarning1=!0,console.warn("Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.")),this.setMix(e,t,n)}setMixWith(e,t,n){if(e==null)throw new Error("from cannot be null.");if(t==null)throw new Error("to cannot be null.");const s=`${e.name}.${t.name}`;this.animationToMixTime[s]=n}getMix(e,t){const n=`${e.name}.${t.name}`,s=this.animationToMixTime[n];return s===void 0?this.defaultMix:s}};let he=le;he.deprecatedWarning1=!1;class $e{constructor(t){this.atlas=t}newRegionAttachment(t,n,s){const r=this.atlas.findRegion(s);if(r==null)throw new Error(`Region not found in atlas: ${s} (region attachment: ${n})`);const h=new N(n);return h.region=r,h}newMeshAttachment(t,n,s){const r=this.atlas.findRegion(s);if(r==null)throw new Error(`Region not found in atlas: ${s} (mesh attachment: ${n})`);const h=new Lt(n);return h.region=r,h}newBoundingBoxAttachment(t,n){return new Qt(n)}newPathAttachment(t,n){return new Yt(n)}newPointAttachment(t,n){return new Jt(n)}newClippingAttachment(t,n){return new Kt(n)}}class ce{constructor(t,n,s){if(this.matrix=new We,this.children=new Array,this.x=0,this.y=0,this.rotation=0,this.scaleX=0,this.scaleY=0,this.shearX=0,this.shearY=0,this.ax=0,this.ay=0,this.arotation=0,this.ascaleX=0,this.ascaleY=0,this.ashearX=0,this.ashearY=0,this.appliedValid=!1,this.sorted=!1,this.active=!1,t==null)throw new Error("data cannot be null.");if(n==null)throw new Error("skeleton cannot be null.");this.data=t,this.skeleton=n,this.parent=s,this.setToSetupPose()}get worldX(){return this.matrix.tx}get worldY(){return this.matrix.ty}isActive(){return this.active}update(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransform(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransformWith(t,n,s,r,h,d,o){this.ax=t,this.ay=n,this.arotation=s,this.ascaleX=r,this.ascaleY=h,this.ashearX=d,this.ashearY=o,this.appliedValid=!0;const a=this.parent,i=this.matrix,l=this.skeleton.scaleX,u=ne.yDown?-this.skeleton.scaleY:this.skeleton.scaleY;if(a==null){const g=this.skeleton,x=s+90+o;i.a=A.cosDeg(s+d)*r*l,i.c=A.cosDeg(x)*h*l,i.b=A.sinDeg(s+d)*r*u,i.d=A.sinDeg(x)*h*u,i.tx=t*l+g.x,i.ty=n*u+g.y;return}let m=a.matrix.a,c=a.matrix.c,f=a.matrix.b,p=a.matrix.d;switch(i.tx=m*t+c*n+a.matrix.tx,i.ty=f*t+p*n+a.matrix.ty,this.data.transformMode){case Z.Normal:{const g=s+90+o,x=A.cosDeg(s+d)*r,E=A.cosDeg(g)*h,w=A.sinDeg(s+d)*r,b=A.sinDeg(g)*h;i.a=m*x+c*w,i.c=m*E+c*b,i.b=f*x+p*w,i.d=f*E+p*b;return}case Z.OnlyTranslation:{const g=s+90+o;i.a=A.cosDeg(s+d)*r,i.c=A.cosDeg(g)*h,i.b=A.sinDeg(s+d)*r,i.d=A.sinDeg(g)*h;break}case Z.NoRotationOrReflection:{let g=m*m+f*f,x=0;g>1e-4?(g=Math.abs(m*p-c*f)/g,m/=this.skeleton.scaleX,f/=this.skeleton.scaleY,c=f*g,p=m*g,x=Math.atan2(f,m)*A.radDeg):(m=0,f=0,x=90-Math.atan2(p,c)*A.radDeg);const E=s+d-x,w=s+o-x+90,b=A.cosDeg(E)*r,I=A.cosDeg(w)*h,M=A.sinDeg(E)*r,S=A.sinDeg(w)*h;i.a=m*b-c*M,i.c=m*I-c*S,i.b=f*b+p*M,i.d=f*I+p*S;break}case Z.NoScale:case Z.NoScaleOrReflection:{const g=A.cosDeg(s),x=A.sinDeg(s);let E=(m*g+c*x)/l,w=(f*g+p*x)/u,b=Math.sqrt(E*E+w*w);b>1e-5&&(b=1/b),E*=b,w*=b,b=Math.sqrt(E*E+w*w),this.data.transformMode==Z.NoScale&&m*p-c*f<0!=(ne.yDown?this.skeleton.scaleX<0!=this.skeleton.scaleY>0:this.skeleton.scaleX<0!=this.skeleton.scaleY<0)&&(b=-b);const I=Math.PI/2+Math.atan2(w,E),M=Math.cos(I)*b,S=Math.sin(I)*b,V=A.cosDeg(d)*r,R=A.cosDeg(90+o)*h,k=A.sinDeg(d)*r,L=A.sinDeg(90+o)*h;i.a=E*V+M*k,i.c=E*R+M*L,i.b=w*V+S*k,i.d=w*R+S*L;break}}i.a*=l,i.c*=l,i.b*=u,i.d*=u}setToSetupPose(){const t=this.data;this.x=t.x,this.y=t.y,this.rotation=t.rotation,this.scaleX=t.scaleX,this.scaleY=t.scaleY,this.shearX=t.shearX,this.shearY=t.shearY}getWorldRotationX(){return Math.atan2(this.matrix.b,this.matrix.a)*A.radDeg}getWorldRotationY(){return Math.atan2(this.matrix.d,this.matrix.c)*A.radDeg}getWorldScaleX(){const t=this.matrix;return Math.sqrt(t.a*t.a+t.c*t.c)}getWorldScaleY(){const t=this.matrix;return Math.sqrt(t.b*t.b+t.d*t.d)}updateAppliedTransform(){this.appliedValid=!0;const t=this.parent,n=this.matrix;if(t==null){this.ax=n.tx,this.ay=n.ty,this.arotation=Math.atan2(n.b,n.a)*A.radDeg,this.ascaleX=Math.sqrt(n.a*n.a+n.b*n.b),this.ascaleY=Math.sqrt(n.c*n.c+n.d*n.d),this.ashearX=0,this.ashearY=Math.atan2(n.a*n.c+n.b*n.d,n.a*n.d-n.b*n.c)*A.radDeg;return}const s=t.matrix,r=1/(s.a*s.d-s.b*s.c),h=n.tx-s.tx,d=n.ty-s.ty;this.ax=h*s.d*r-d*s.c*r,this.ay=d*s.a*r-h*s.b*r;const o=r*s.d,a=r*s.a,i=r*s.c,l=r*s.b,u=o*n.a-i*n.b,m=o*n.c-i*n.d,c=a*n.b-l*n.a,f=a*n.d-l*n.c;if(this.ashearX=0,this.ascaleX=Math.sqrt(u*u+c*c),this.ascaleX>1e-4){const p=u*f-m*c;this.ascaleY=p/this.ascaleX,this.ashearY=Math.atan2(u*m+c*f,p)*A.radDeg,this.arotation=Math.atan2(c,u)*A.radDeg}else this.ascaleX=0,this.ascaleY=Math.sqrt(m*m+f*f),this.ashearY=0,this.arotation=90-Math.atan2(f,m)*A.radDeg}worldToLocal(t){const n=this.matrix,s=n.a,r=n.c,h=n.b,d=n.d,o=1/(s*d-r*h),a=t.x-n.tx,i=t.y-n.ty;return t.x=a*d*o-i*r*o,t.y=i*s*o-a*h*o,t}localToWorld(t){const n=this.matrix,s=t.x,r=t.y;return t.x=s*n.a+r*n.c+n.tx,t.y=s*n.b+r*n.d+n.ty,t}worldToLocalRotation(t){const n=A.sinDeg(t),s=A.cosDeg(t),r=this.matrix;return Math.atan2(r.a*n-r.b*s,r.d*s-r.c*n)*A.radDeg}localToWorldRotation(t){const n=A.sinDeg(t),s=A.cosDeg(t),r=this.matrix;return Math.atan2(s*r.b+n*r.d,s*r.a+n*r.c)*A.radDeg}rotateWorld(t){const n=this.matrix,s=n.a,r=n.c,h=n.b,d=n.d,o=A.cosDeg(t),a=A.sinDeg(t);n.a=o*s-a*h,n.c=o*r-a*d,n.b=a*s+o*h,n.d=a*r+o*d,this.appliedValid=!1}}class de{constructor(t,n,s){if(this.x=0,this.y=0,this.rotation=0,this.scaleX=1,this.scaleY=1,this.shearX=0,this.shearY=0,this.transformMode=Z.Normal,this.skinRequired=!1,this.inheritRotation=!0,this.inheritScale=!0,this.color=new _,t<0)throw new Error("index must be >= 0.");if(n==null)throw new Error("name cannot be null.");this.index=t,this.name=n,this.parent=s}}class Zt{constructor(t,n,s){this.name=t,this.order=n,this.skinRequired=s}}class ue{constructor(t,n){if(n==null)throw new Error("data cannot be null.");this.time=t,this.data=n}}class me{constructor(t){this.name=t}}class Ne{constructor(t,n){if(this.bendDirection=0,this.compress=!1,this.stretch=!1,this.mix=1,this.softness=0,this.active=!1,t==null)throw new Error("data cannot be null.");if(n==null)throw new Error("skeleton cannot be null.");this.data=t,this.mix=t.mix,this.softness=t.softness,this.bendDirection=t.bendDirection,this.compress=t.compress,this.stretch=t.stretch,this.bones=new Array;for(let s=0;s<t.bones.length;s++)this.bones.push(n.findBone(t.bones[s].name));this.target=n.findBone(t.target.name)}isActive(){return this.active}apply(){this.update()}update(){const t=this.target,n=this.bones;switch(n.length){case 1:this.apply1(n[0],t.worldX,t.worldY,this.compress,this.stretch,this.data.uniform,this.mix);break;case 2:this.apply2(n[0],n[1],t.worldX,t.worldY,this.bendDirection,this.stretch,this.softness,this.mix);break}}apply1(t,n,s,r,h,d,o){t.appliedValid||t.updateAppliedTransform();const a=t.parent.matrix,i=a.a;let l=a.c;const u=a.b;let m=a.d,c=-t.ashearX-t.arotation,f=0,p=0;switch(t.data.transformMode){case Z.OnlyTranslation:f=n-t.worldX,p=s-t.worldY;break;case Z.NoRotationOrReflection:const E=Math.abs(i*m-l*u)/(i*i+u*u),w=i/t.skeleton.scaleX,b=u/t.skeleton.scaleY;l=-b*E*t.skeleton.scaleX,m=w*E*t.skeleton.scaleY,c+=Math.atan2(b,w)*A.radDeg;default:const I=n-a.tx,M=s-a.ty,S=i*m-l*u;f=(I*m-M*l)/S-t.ax,p=(M*i-I*u)/S-t.ay}c+=Math.atan2(p,f)*A.radDeg,t.ascaleX<0&&(c+=180),c>180?c-=360:c<-180&&(c+=360);let g=t.ascaleX,x=t.ascaleY;if(r||h){switch(t.data.transformMode){case Z.NoScale:case Z.NoScaleOrReflection:f=n-t.worldX,p=s-t.worldY}const E=t.data.length*g,w=Math.sqrt(f*f+p*p);if(r&&w<E||h&&w>E&&E>1e-4){const b=(w/E-1)*o+1;g*=b,d&&(x*=b)}}t.updateWorldTransformWith(t.ax,t.ay,t.arotation+c*o,g,x,t.ashearX,t.ashearY)}apply2(t,n,s,r,h,d,o,a){if(a==0){n.updateWorldTransform();return}t.appliedValid||t.updateAppliedTransform(),n.appliedValid||n.updateAppliedTransform();const i=t.ax,l=t.ay;let u=t.ascaleX,m=u,c=t.ascaleY,f=n.ascaleX;const p=t.matrix;let g=0,x=0,E=0;u<0?(u=-u,g=180,E=-1):(g=0,E=1),c<0&&(c=-c,E=-E),f<0?(f=-f,x=180):x=0;const w=n.ax;let b=0,I=0,M=0,S=p.a,V=p.c,R=p.b,k=p.d;const L=Math.abs(u-c)<=1e-4;L?(b=n.ay,I=S*w+V*b+p.tx,M=R*w+k*b+p.ty):(b=0,I=S*w+p.tx,M=R*w+p.ty);const v=t.parent.matrix;S=v.a,V=v.c,R=v.b,k=v.d;const H=1/(S*k-V*R);let P=I-v.tx,F=M-v.ty;const rt=(P*k-F*V)*H-i,it=(F*S-P*R)*H-l,C=Math.sqrt(rt*rt+it*it);let Y=n.data.length*f,D,W;if(C<1e-4){this.apply1(t,s,r,!1,d,!1,a),n.updateWorldTransformWith(w,b,0,n.ascaleX,n.ascaleY,n.ashearX,n.ashearY);return}P=s-v.tx,F=r-v.ty;let G=(P*k-F*V)*H-i,B=(F*S-P*R)*H-l,X=G*G+B*B;if(o!=0){o*=u*(f+1)/2;const dt=Math.sqrt(X),yt=dt-C-Y*u+o;if(yt>0){let Rt=Math.min(1,yt/(o*2))-1;Rt=(yt-o*(1-Rt*Rt))/dt,G-=Rt*G,B-=Rt*B,X=G*G+B*B}}t:if(L){Y*=u;let dt=(X-C*C-Y*Y)/(2*C*Y);dt<-1?dt=-1:dt>1&&(dt=1,d&&(m*=(Math.sqrt(X)/(C+Y)-1)*a+1)),W=Math.acos(dt)*h,S=C+Y*dt,V=Y*Math.sin(W),D=Math.atan2(B*S-G*V,G*S+B*V)}else{S=u*Y,V=c*Y;const dt=S*S,yt=V*V,Rt=Math.atan2(B,G);R=yt*C*C+dt*X-dt*yt;const Ut=-2*yt*C,Me=yt-dt;if(k=Ut*Ut-4*Me*R,k>=0){let Ot=Math.sqrt(k);Ut<0&&(Ot=-Ot),Ot=-(Ut+Ot)/2;const Re=Ot/Me,Te=R/Ot,Bt=Math.abs(Re)<Math.abs(Te)?Re:Te;if(Bt*Bt<=X){F=Math.sqrt(X-Bt*Bt)*h,D=Rt-Math.atan2(F,Bt),W=Math.atan2(F/c,(Bt-C)/u);break t}}let Ie=A.PI,$t=C-S,te=$t*$t,Se=0,Ae=0,Ht=C+S,ee=Ht*Ht,ye=0;R=-S*C/(dt-yt),R>=-1&&R<=1&&(R=Math.acos(R),P=S*Math.cos(R)+C,F=V*Math.sin(R),k=P*P+F*F,k<te&&(Ie=R,te=k,$t=P,Se=F),k>ee&&(Ae=R,ee=k,Ht=P,ye=F)),X<=(te+ee)/2?(D=Rt-Math.atan2(Se*h,$t),W=Ie*h):(D=Rt-Math.atan2(ye*h,Ht),W=Ae*h)}const wt=Math.atan2(b,w)*E;let Ct=t.arotation;D=(D-wt)*A.radDeg+g-Ct,D>180?D-=360:D<-180&&(D+=360),t.updateWorldTransformWith(i,l,Ct+D*a,m,t.ascaleY,0,0),Ct=n.arotation,W=((W+wt)*A.radDeg-n.ashearX)*E+x-Ct,W>180?W-=360:W<-180&&(W+=360),n.updateWorldTransformWith(w,b,Ct+W*a,n.ascaleX,n.ascaleY,n.ashearX,n.ashearY)}}class fe extends Zt{constructor(t){super(t,0,!1),this.bones=new Array,this.bendDirection=1,this.compress=!1,this.stretch=!1,this.uniform=!1,this.mix=1,this.softness=0}}class ge extends Zt{constructor(t){super(t,0,!1),this.bones=new Array}}var nt=(e=>(e[e.Length=0]="Length",e[e.Fixed=1]="Fixed",e[e.Percent=2]="Percent",e))(nt||{});const Xt=class{constructor(e,t){if(this.position=0,this.spacing=0,this.rotateMix=0,this.translateMix=0,this.spaces=new Array,this.positions=new Array,this.world=new Array,this.curves=new Array,this.lengths=new Array,this.segments=new Array,this.active=!1,e==null)throw new Error("data cannot be null.");if(t==null)throw new Error("skeleton cannot be null.");this.data=e,this.bones=new Array;for(let n=0,s=e.bones.length;n<s;n++)this.bones.push(t.findBone(e.bones[n].name));this.target=t.findSlot(e.target.name),this.position=e.position,this.spacing=e.spacing,this.rotateMix=e.rotateMix,this.translateMix=e.translateMix}isActive(){return this.active}apply(){this.update()}update(){const e=this.target.getAttachment();if(!(e instanceof Yt))return;const t=this.rotateMix,n=this.translateMix,s=n>0,r=t>0;if(!s&&!r)return;const h=this.data,d=h.spacingMode,o=d==nt.Length,a=h.rotateMode,i=a==Tt.Tangent,l=a==Tt.ChainScale,u=this.bones.length,m=i?u:u+1,c=this.bones,f=T.setArraySize(this.spaces,m);let p=null;const g=this.spacing;if(l||o){l&&(p=T.setArraySize(this.lengths,u));for(let M=0,S=m-1;M<S;){const V=c[M],R=V.data.length;if(R<Xt.epsilon)l&&(p[M]=0),f[++M]=0;else{const k=R*V.matrix.a,L=R*V.matrix.b,v=Math.sqrt(k*k+L*L);l&&(p[M]=v),f[++M]=(o?R+g:g)*v/R}}}else for(let M=1;M<m;M++)f[M]=g;const x=this.computeWorldPositions(e,m,i,h.positionMode==Vt.Percent,d==nt.Percent);let E=x[0],w=x[1],b=h.offsetRotation,I=!1;if(b==0)I=a==Tt.Chain;else{I=!1;const M=this.target.bone.matrix;b*=M.a*M.d-M.b*M.c>0?A.degRad:-A.degRad}for(let M=0,S=3;M<u;M++,S+=3){const V=c[M],R=V.matrix;R.tx+=(E-R.tx)*n,R.ty+=(w-R.ty)*n;const k=x[S],L=x[S+1],v=k-E,H=L-w;if(l){const P=p[M];if(P!=0){const F=(Math.sqrt(v*v+H*H)/P-1)*t+1;R.a*=F,R.b*=F}}if(E=k,w=L,r){const P=R.a,F=R.c,rt=R.b,it=R.d;let C=0,Y=0,D=0;if(i&&(i?C=x[S-1]:f[M+1]==0?C=x[S+2]:C=Math.atan2(H,v)),C-=Math.atan2(rt,P),I){Y=Math.cos(C),D=Math.sin(C);const W=V.data.length;E+=(W*(Y*P-D*rt)-v)*t,w+=(W*(D*P+Y*rt)-H)*t}else C+=b;C>A.PI?C-=A.PI2:C<-A.PI&&(C+=A.PI2),C*=t,Y=Math.cos(C),D=Math.sin(C),R.a=Y*P-D*rt,R.c=Y*F-D*it,R.b=D*P+Y*rt,R.d=D*F+Y*it}V.appliedValid=!1}}computeWorldPositions(e,t,n,s,r){const h=this.target;let d=this.position;const o=this.spaces,a=T.setArraySize(this.positions,t*3+2);let i=null;const l=e.closed;let u=e.worldVerticesLength,m=u/6,c=Xt.NONE;if(!e.constantSpeed){const C=e.lengths;m-=l?1:2;const Y=C[m];if(s&&(d*=Y),r)for(let D=0;D<t;D++)o[D]*=Y;i=T.setArraySize(this.world,8);for(let D=0,W=0,G=0;D<t;D++,W+=3){const B=o[D];d+=B;let X=d;if(l)X%=Y,X<0&&(X+=Y),G=0;else if(X<0){c!=Xt.BEFORE&&(c=Xt.BEFORE,e.computeWorldVertices(h,2,4,i,0,2)),this.addBeforePosition(X,i,0,a,W);continue}else if(X>Y){c!=Xt.AFTER&&(c=Xt.AFTER,e.computeWorldVertices(h,u-6,4,i,0,2)),this.addAfterPosition(X-Y,i,0,a,W);continue}for(;;G++){const wt=C[G];if(!(X>wt)){if(G==0)X/=wt;else{const Ct=C[G-1];X=(X-Ct)/(wt-Ct)}break}}G!=c&&(c=G,l&&G==m?(e.computeWorldVertices(h,u-4,4,i,0,2),e.computeWorldVertices(h,0,4,i,4,2)):e.computeWorldVertices(h,G*6+2,8,i,0,2)),this.addCurvePosition(X,i[0],i[1],i[2],i[3],i[4],i[5],i[6],i[7],a,W,n||D>0&&B==0)}return a}l?(u+=2,i=T.setArraySize(this.world,u),e.computeWorldVertices(h,2,u-4,i,0,2),e.computeWorldVertices(h,0,2,i,u-4,2),i[u-2]=i[0],i[u-1]=i[1]):(m--,u-=4,i=T.setArraySize(this.world,u),e.computeWorldVertices(h,2,u,i,0,2));const f=T.setArraySize(this.curves,m);let p=0,g=i[0],x=i[1],E=0,w=0,b=0,I=0,M=0,S=0,V=0,R=0,k=0,L=0,v=0,H=0,P=0,F=0;for(let C=0,Y=2;C<m;C++,Y+=6)E=i[Y],w=i[Y+1],b=i[Y+2],I=i[Y+3],M=i[Y+4],S=i[Y+5],V=(g-E*2+b)*.1875,R=(x-w*2+I)*.1875,k=((E-b)*3-g+M)*.09375,L=((w-I)*3-x+S)*.09375,v=V*2+k,H=R*2+L,P=(E-g)*.75+V+k*.16666667,F=(w-x)*.75+R+L*.16666667,p+=Math.sqrt(P*P+F*F),P+=v,F+=H,v+=k,H+=L,p+=Math.sqrt(P*P+F*F),P+=v,F+=H,p+=Math.sqrt(P*P+F*F),P+=v+k,F+=H+L,p+=Math.sqrt(P*P+F*F),f[C]=p,g=M,x=S;if(s&&(d*=p),r)for(let C=0;C<t;C++)o[C]*=p;const rt=this.segments;let it=0;for(let C=0,Y=0,D=0,W=0;C<t;C++,Y+=3){const G=o[C];d+=G;let B=d;if(l)B%=p,B<0&&(B+=p),D=0;else if(B<0){this.addBeforePosition(B,i,0,a,Y);continue}else if(B>p){this.addAfterPosition(B-p,i,u-4,a,Y);continue}for(;;D++){const X=f[D];if(!(B>X)){if(D==0)B/=X;else{const wt=f[D-1];B=(B-wt)/(X-wt)}break}}if(D!=c){c=D;let X=D*6;for(g=i[X],x=i[X+1],E=i[X+2],w=i[X+3],b=i[X+4],I=i[X+5],M=i[X+6],S=i[X+7],V=(g-E*2+b)*.03,R=(x-w*2+I)*.03,k=((E-b)*3-g+M)*.006,L=((w-I)*3-x+S)*.006,v=V*2+k,H=R*2+L,P=(E-g)*.3+V+k*.16666667,F=(w-x)*.3+R+L*.16666667,it=Math.sqrt(P*P+F*F),rt[0]=it,X=1;X<8;X++)P+=v,F+=H,v+=k,H+=L,it+=Math.sqrt(P*P+F*F),rt[X]=it;P+=v,F+=H,it+=Math.sqrt(P*P+F*F),rt[8]=it,P+=v+k,F+=H+L,it+=Math.sqrt(P*P+F*F),rt[9]=it,W=0}for(B*=it;;W++){const X=rt[W];if(!(B>X)){if(W==0)B/=X;else{const wt=rt[W-1];B=W+(B-wt)/(X-wt)}break}}this.addCurvePosition(B*.1,g,x,E,w,b,I,M,S,a,Y,n||C>0&&G==0)}return a}addBeforePosition(e,t,n,s,r){const h=t[n],d=t[n+1],o=t[n+2]-h,a=t[n+3]-d,i=Math.atan2(a,o);s[r]=h+e*Math.cos(i),s[r+1]=d+e*Math.sin(i),s[r+2]=i}addAfterPosition(e,t,n,s,r){const h=t[n+2],d=t[n+3],o=h-t[n],a=d-t[n+1],i=Math.atan2(a,o);s[r]=h+e*Math.cos(i),s[r+1]=d+e*Math.sin(i),s[r+2]=i}addCurvePosition(e,t,n,s,r,h,d,o,a,i,l,u){(e==0||isNaN(e))&&(e=1e-4);const m=e*e,c=m*e,f=1-e,p=f*f,g=p*f,x=f*e,E=x*3,w=f*E,b=E*e,I=t*g+s*w+h*b+o*c,M=n*g+r*w+d*b+a*c;i[l]=I,i[l+1]=M,u&&(i[l+2]=Math.atan2(M-(n*p+r*x*2+d*m),I-(t*p+s*x*2+h*m)))}};let Wt=Xt;Wt.NONE=-1,Wt.BEFORE=-2,Wt.AFTER=-3,Wt.epsilon=1e-5;class ve{constructor(t,n){if(this.rotateMix=0,this.translateMix=0,this.scaleMix=0,this.shearMix=0,this.temp=new Le,this.active=!1,t==null)throw new Error("data cannot be null.");if(n==null)throw new Error("skeleton cannot be null.");this.data=t,this.rotateMix=t.rotateMix,this.translateMix=t.translateMix,this.scaleMix=t.scaleMix,this.shearMix=t.shearMix,this.bones=new Array;for(let s=0;s<t.bones.length;s++)this.bones.push(n.findBone(t.bones[s].name));this.target=n.findBone(t.target.name)}isActive(){return this.active}apply(){this.update()}update(){this.data.local?this.data.relative?this.applyRelativeLocal():this.applyAbsoluteLocal():this.data.relative?this.applyRelativeWorld():this.applyAbsoluteWorld()}applyAbsoluteWorld(){const t=this.rotateMix,n=this.translateMix,s=this.scaleMix,r=this.shearMix,h=this.target,d=h.matrix,o=d.a,a=d.c,i=d.b,l=d.d,u=o*l-a*i>0?A.degRad:-A.degRad,m=this.data.offsetRotation*u,c=this.data.offsetShearY*u,f=this.bones;for(let p=0,g=f.length;p<g;p++){const x=f[p];let E=!1;const w=x.matrix;if(t!=0){const b=w.a,I=w.c,M=w.b,S=w.d;let V=Math.atan2(i,o)-Math.atan2(M,b)+m;V>A.PI?V-=A.PI2:V<-A.PI&&(V+=A.PI2),V*=t;const R=Math.cos(V),k=Math.sin(V);w.a=R*b-k*M,w.c=R*I-k*S,w.b=k*b+R*M,w.d=k*I+R*S,E=!0}if(n!=0){const b=this.temp;h.localToWorld(b.set(this.data.offsetX,this.data.offsetY)),w.tx+=(b.x-w.tx)*n,w.ty+=(b.y-w.ty)*n,E=!0}if(s>0){let b=Math.sqrt(w.a*w.a+w.b*w.b),I=Math.sqrt(o*o+i*i);b>1e-5&&(b=(b+(I-b+this.data.offsetScaleX)*s)/b),w.a*=b,w.b*=b,b=Math.sqrt(w.c*w.c+w.d*w.d),I=Math.sqrt(a*a+l*l),b>1e-5&&(b=(b+(I-b+this.data.offsetScaleY)*s)/b),w.c*=b,w.d*=b,E=!0}if(r>0){const b=w.c,I=w.d,M=Math.atan2(I,b);let S=Math.atan2(l,a)-Math.atan2(i,o)-(M-Math.atan2(w.b,w.a));S>A.PI?S-=A.PI2:S<-A.PI&&(S+=A.PI2),S=M+(S+c)*r;const V=Math.sqrt(b*b+I*I);w.c=Math.cos(S)*V,w.d=Math.sin(S)*V,E=!0}E&&(x.appliedValid=!1)}}applyRelativeWorld(){const t=this.rotateMix,n=this.translateMix,s=this.scaleMix,r=this.shearMix,h=this.target,d=h.matrix,o=d.a,a=d.c,i=d.b,l=d.d,u=o*l-a*i>0?A.degRad:-A.degRad,m=this.data.offsetRotation*u,c=this.data.offsetShearY*u,f=this.bones;for(let p=0,g=f.length;p<g;p++){const x=f[p];let E=!1;const w=x.matrix;if(t!=0){const b=w.a,I=w.c,M=w.b,S=w.d;let V=Math.atan2(i,o)+m;V>A.PI?V-=A.PI2:V<-A.PI&&(V+=A.PI2),V*=t;const R=Math.cos(V),k=Math.sin(V);w.a=R*b-k*M,w.c=R*I-k*S,w.b=k*b+R*M,w.d=k*I+R*S,E=!0}if(n!=0){const b=this.temp;h.localToWorld(b.set(this.data.offsetX,this.data.offsetY)),w.tx+=b.x*n,w.ty+=b.y*n,E=!0}if(s>0){let b=(Math.sqrt(o*o+i*i)-1+this.data.offsetScaleX)*s+1;w.a*=b,w.b*=b,b=(Math.sqrt(a*a+l*l)-1+this.data.offsetScaleY)*s+1,w.c*=b,w.d*=b,E=!0}if(r>0){let b=Math.atan2(l,a)-Math.atan2(i,o);b>A.PI?b-=A.PI2:b<-A.PI&&(b+=A.PI2);const I=w.c,M=w.d;b=Math.atan2(M,I)+(b-A.PI/2+c)*r;const S=Math.sqrt(I*I+M*M);w.c=Math.cos(b)*S,w.d=Math.sin(b)*S,E=!0}E&&(x.appliedValid=!1)}}applyAbsoluteLocal(){const t=this.rotateMix,n=this.translateMix,s=this.scaleMix,r=this.shearMix,h=this.target;h.appliedValid||h.updateAppliedTransform();const d=this.bones;for(let o=0,a=d.length;o<a;o++){const i=d[o];i.appliedValid||i.updateAppliedTransform();let l=i.arotation;if(t!=0){let g=h.arotation-l+this.data.offsetRotation;g-=(16384-(16384.499999999996-g/360|0))*360,l+=g*t}let u=i.ax,m=i.ay;n!=0&&(u+=(h.ax-u+this.data.offsetX)*n,m+=(h.ay-m+this.data.offsetY)*n);let c=i.ascaleX,f=i.ascaleY;s>0&&(c>1e-5&&(c=(c+(h.ascaleX-c+this.data.offsetScaleX)*s)/c),f>1e-5&&(f=(f+(h.ascaleY-f+this.data.offsetScaleY)*s)/f));const p=i.ashearY;if(r>0){let g=h.ashearY-p+this.data.offsetShearY;g-=(16384-(16384.499999999996-g/360|0))*360,i.shearY+=g*r}i.updateWorldTransformWith(u,m,l,c,f,i.ashearX,p)}}applyRelativeLocal(){const t=this.rotateMix,n=this.translateMix,s=this.scaleMix,r=this.shearMix,h=this.target;h.appliedValid||h.updateAppliedTransform();const d=this.bones;for(let o=0,a=d.length;o<a;o++){const i=d[o];i.appliedValid||i.updateAppliedTransform();let l=i.arotation;t!=0&&(l+=(h.arotation+this.data.offsetRotation)*t);let u=i.ax,m=i.ay;n!=0&&(u+=(h.ax+this.data.offsetX)*n,m+=(h.ay+this.data.offsetY)*n);let c=i.ascaleX,f=i.ascaleY;s>0&&(c>1e-5&&(c*=(h.ascaleX-1+this.data.offsetScaleX)*s+1),f>1e-5&&(f*=(h.ascaleY-1+this.data.offsetScaleY)*s+1));let p=i.ashearY;r>0&&(p+=(h.ashearY+this.data.offsetShearY)*r),i.updateWorldTransformWith(u,m,l,c,f,i.ashearX,p)}}}const qt=class{constructor(e){if(this._updateCache=new Array,this.updateCacheReset=new Array,this.time=0,this.scaleX=1,this.scaleY=1,this.x=0,this.y=0,e==null)throw new Error("data cannot be null.");this.data=e,this.bones=new Array;for(let t=0;t<e.bones.length;t++){const n=e.bones[t];let s;if(n.parent==null)s=new ce(n,this,null);else{const r=this.bones[n.parent.index];s=new ce(n,this,r),r.children.push(s)}this.bones.push(s)}this.slots=new Array,this.drawOrder=new Array;for(let t=0;t<e.slots.length;t++){const n=e.slots[t],s=this.bones[n.boneData.index],r=new ae(n,s);this.slots.push(r),this.drawOrder.push(r)}this.ikConstraints=new Array;for(let t=0;t<e.ikConstraints.length;t++){const n=e.ikConstraints[t];this.ikConstraints.push(new Ne(n,this))}this.transformConstraints=new Array;for(let t=0;t<e.transformConstraints.length;t++){const n=e.transformConstraints[t];this.transformConstraints.push(new ve(n,this))}this.pathConstraints=new Array;for(let t=0;t<e.pathConstraints.length;t++){const n=e.pathConstraints[t];this.pathConstraints.push(new Wt(n,this))}this.color=new _(1,1,1,1),this.updateCache()}updateCache(){const e=this._updateCache;e.length=0,this.updateCacheReset.length=0;const t=this.bones;for(let i=0,l=t.length;i<l;i++){const u=t[i];u.sorted=u.data.skinRequired,u.active=!u.sorted}if(this.skin!=null){const i=this.skin.bones;for(let l=0,u=this.skin.bones.length;l<u;l++){let m=this.bones[i[l].index];do m.sorted=!1,m.active=!0,m=m.parent;while(m!=null)}}const n=this.ikConstraints,s=this.transformConstraints,r=this.pathConstraints,h=n.length,d=s.length,o=r.length,a=h+d+o;t:for(let i=0;i<a;i++){for(let l=0;l<h;l++){const u=n[l];if(u.data.order==i){this.sortIkConstraint(u);continue t}}for(let l=0;l<d;l++){const u=s[l];if(u.data.order==i){this.sortTransformConstraint(u);continue t}}for(let l=0;l<o;l++){const u=r[l];if(u.data.order==i){this.sortPathConstraint(u);continue t}}}for(let i=0,l=t.length;i<l;i++)this.sortBone(t[i])}sortIkConstraint(e){if(e.active=e.target.isActive()&&(!e.data.skinRequired||this.skin!=null&&T.contains(this.skin.constraints,e.data,!0)),!e.active)return;const t=e.target;this.sortBone(t);const n=e.bones,s=n[0];if(this.sortBone(s),n.length>1){const r=n[n.length-1];this._updateCache.indexOf(r)>-1||this.updateCacheReset.push(r)}this._updateCache.push(e),this.sortReset(s.children),n[n.length-1].sorted=!0}sortPathConstraint(e){if(e.active=e.target.bone.isActive()&&(!e.data.skinRequired||this.skin!=null&&T.contains(this.skin.constraints,e.data,!0)),!e.active)return;const t=e.target,n=t.data.index,s=t.bone;this.skin!=null&&this.sortPathConstraintAttachment(this.skin,n,s),this.data.defaultSkin!=null&&this.data.defaultSkin!=this.skin&&this.sortPathConstraintAttachment(this.data.defaultSkin,n,s);for(let o=0,a=this.data.skins.length;o<a;o++)this.sortPathConstraintAttachment(this.data.skins[o],n,s);const r=t.getAttachment();r instanceof Yt&&this.sortPathConstraintAttachmentWith(r,s);const h=e.bones,d=h.length;for(let o=0;o<d;o++)this.sortBone(h[o]);this._updateCache.push(e);for(let o=0;o<d;o++)this.sortReset(h[o].children);for(let o=0;o<d;o++)h[o].sorted=!0}sortTransformConstraint(e){if(e.active=e.target.isActive()&&(!e.data.skinRequired||this.skin!=null&&T.contains(this.skin.constraints,e.data,!0)),!e.active)return;this.sortBone(e.target);const t=e.bones,n=t.length;if(e.data.local)for(let s=0;s<n;s++){const r=t[s];this.sortBone(r.parent),this._updateCache.indexOf(r)>-1||this.updateCacheReset.push(r)}else for(let s=0;s<n;s++)this.sortBone(t[s]);this._updateCache.push(e);for(let s=0;s<n;s++)this.sortReset(t[s].children);for(let s=0;s<n;s++)t[s].sorted=!0}sortPathConstraintAttachment(e,t,n){const s=e.attachments[t];if(s)for(const r in s)this.sortPathConstraintAttachmentWith(s[r],n)}sortPathConstraintAttachmentWith(e,t){if(!(e instanceof Yt))return;const n=e.bones;if(n==null)this.sortBone(t);else{const s=this.bones;let r=0;for(;r<n.length;){const h=n[r++];for(let d=r+h;r<d;r++){const o=n[r];this.sortBone(s[o])}}}}sortBone(e){if(e.sorted)return;const t=e.parent;t!=null&&this.sortBone(t),e.sorted=!0,this._updateCache.push(e)}sortReset(e){for(let t=0,n=e.length;t<n;t++){const s=e[t];s.active&&(s.sorted&&this.sortReset(s.children),s.sorted=!1)}}updateWorldTransform(){const e=this.updateCacheReset;for(let n=0,s=e.length;n<s;n++){const r=e[n];r.ax=r.x,r.ay=r.y,r.arotation=r.rotation,r.ascaleX=r.scaleX,r.ascaleY=r.scaleY,r.ashearX=r.shearX,r.ashearY=r.shearY,r.appliedValid=!0}const t=this._updateCache;for(let n=0,s=t.length;n<s;n++)t[n].update()}setToSetupPose(){this.setBonesToSetupPose(),this.setSlotsToSetupPose()}setBonesToSetupPose(){const e=this.bones;for(let r=0,h=e.length;r<h;r++)e[r].setToSetupPose();const t=this.ikConstraints;for(let r=0,h=t.length;r<h;r++){const d=t[r];d.mix=d.data.mix,d.softness=d.data.softness,d.bendDirection=d.data.bendDirection,d.compress=d.data.compress,d.stretch=d.data.stretch}const n=this.transformConstraints;for(let r=0,h=n.length;r<h;r++){const d=n[r],o=d.data;d.rotateMix=o.rotateMix,d.translateMix=o.translateMix,d.scaleMix=o.scaleMix,d.shearMix=o.shearMix}const s=this.pathConstraints;for(let r=0,h=s.length;r<h;r++){const d=s[r],o=d.data;d.position=o.position,d.spacing=o.spacing,d.rotateMix=o.rotateMix,d.translateMix=o.translateMix}}setSlotsToSetupPose(){const e=this.slots;T.arrayCopy(e,0,this.drawOrder,0,e.length);for(let t=0,n=e.length;t<n;t++)e[t].setToSetupPose()}getRootBone(){return this.bones.length==0?null:this.bones[0]}findBone(e){if(e==null)throw new Error("boneName cannot be null.");const t=this.bones;for(let n=0,s=t.length;n<s;n++){const r=t[n];if(r.data.name==e)return r}return null}findBoneIndex(e){if(e==null)throw new Error("boneName cannot be null.");const t=this.bones;for(let n=0,s=t.length;n<s;n++)if(t[n].data.name==e)return n;return-1}findSlot(e){if(e==null)throw new Error("slotName cannot be null.");const t=this.slots;for(let n=0,s=t.length;n<s;n++){const r=t[n];if(r.data.name==e)return r}return null}findSlotIndex(e){if(e==null)throw new Error("slotName cannot be null.");const t=this.slots;for(let n=0,s=t.length;n<s;n++)if(t[n].data.name==e)return n;return-1}setSkinByName(e){const t=this.data.findSkin(e);if(t==null)throw new Error(`Skin not found: ${e}`);this.setSkin(t)}setSkin(e){if(e!=this.skin){if(e!=null)if(this.skin!=null)e.attachAll(this,this.skin);else{const t=this.slots;for(let n=0,s=t.length;n<s;n++){const r=t[n],h=r.data.attachmentName;if(h!=null){const d=e.getAttachment(n,h);d!=null&&r.setAttachment(d)}}}this.skin=e,this.updateCache()}}getAttachmentByName(e,t){return this.getAttachment(this.data.findSlotIndex(e),t)}getAttachment(e,t){if(t==null)throw new Error("attachmentName cannot be null.");if(this.skin!=null){const n=this.skin.getAttachment(e,t);if(n!=null)return n}return this.data.defaultSkin!=null?this.data.defaultSkin.getAttachment(e,t):null}setAttachment(e,t){if(e==null)throw new Error("slotName cannot be null.");const n=this.slots;for(let s=0,r=n.length;s<r;s++){const h=n[s];if(h.data.name==e){let d=null;if(t!=null&&(d=this.getAttachment(s,t),d==null))throw new Error(`Attachment not found: ${t}, for slot: ${e}`);h.setAttachment(d);return}}throw new Error(`Slot not found: ${e}`)}findIkConstraint(e){if(e==null)throw new Error("constraintName cannot be null.");const t=this.ikConstraints;for(let n=0,s=t.length;n<s;n++){const r=t[n];if(r.data.name==e)return r}return null}findTransformConstraint(e){if(e==null)throw new Error("constraintName cannot be null.");const t=this.transformConstraints;for(let n=0,s=t.length;n<s;n++){const r=t[n];if(r.data.name==e)return r}return null}findPathConstraint(e){if(e==null)throw new Error("constraintName cannot be null.");const t=this.pathConstraints;for(let n=0,s=t.length;n<s;n++){const r=t[n];if(r.data.name==e)return r}return null}getBounds(e,t,n=new Array(2)){if(e==null)throw new Error("offset cannot be null.");if(t==null)throw new Error("size cannot be null.");const s=this.drawOrder;let r=Number.POSITIVE_INFINITY,h=Number.POSITIVE_INFINITY,d=Number.NEGATIVE_INFINITY,o=Number.NEGATIVE_INFINITY;for(let a=0,i=s.length;a<i;a++){const l=s[a];if(!l.bone.active)continue;let u=0,m=null;const c=l.getAttachment();if(c instanceof N)u=8,m=T.setArraySize(n,u,0),c.computeWorldVertices(l.bone,m,0,2);else if(c instanceof Lt){const f=c;u=f.worldVerticesLength,m=T.setArraySize(n,u,0),f.computeWorldVertices(l,0,u,m,0,2)}if(m!=null)for(let f=0,p=m.length;f<p;f+=2){const g=m[f],x=m[f+1];r=Math.min(r,g),h=Math.min(h,x),d=Math.max(d,g),o=Math.max(o,x)}}e.set(r,h),t.set(d-r,o-h)}update(e){this.time+=e}get flipX(){return this.scaleX==-1}set flipX(e){qt.deprecatedWarning1||(qt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleX=e?1:-1}get flipY(){return this.scaleY==-1}set flipY(e){qt.deprecatedWarning1||(qt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleY=e?1:-1}};let pe=qt;pe.deprecatedWarning1=!1;class xe{constructor(){this.bones=new Array,this.slots=new Array,this.skins=new Array,this.events=new Array,this.animations=new Array,this.ikConstraints=new Array,this.transformConstraints=new Array,this.pathConstraints=new Array,this.fps=0}findBone(t){if(t==null)throw new Error("boneName cannot be null.");const n=this.bones;for(let s=0,r=n.length;s<r;s++){const h=n[s];if(h.name==t)return h}return null}findBoneIndex(t){if(t==null)throw new Error("boneName cannot be null.");const n=this.bones;for(let s=0,r=n.length;s<r;s++)if(n[s].name==t)return s;return-1}findSlot(t){if(t==null)throw new Error("slotName cannot be null.");const n=this.slots;for(let s=0,r=n.length;s<r;s++){const h=n[s];if(h.name==t)return h}return null}findSlotIndex(t){if(t==null)throw new Error("slotName cannot be null.");const n=this.slots;for(let s=0,r=n.length;s<r;s++)if(n[s].name==t)return s;return-1}findSkin(t){if(t==null)throw new Error("skinName cannot be null.");const n=this.skins;for(let s=0,r=n.length;s<r;s++){const h=n[s];if(h.name==t)return h}return null}findEvent(t){if(t==null)throw new Error("eventDataName cannot be null.");const n=this.events;for(let s=0,r=n.length;s<r;s++){const h=n[s];if(h.name==t)return h}return null}findAnimation(t){if(t==null)throw new Error("animationName cannot be null.");const n=this.animations;for(let s=0,r=n.length;s<r;s++){const h=n[s];if(h.name==t)return h}return null}findIkConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const n=this.ikConstraints;for(let s=0,r=n.length;s<r;s++){const h=n[s];if(h.name==t)return h}return null}findTransformConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const n=this.transformConstraints;for(let s=0,r=n.length;s<r;s++){const h=n[s];if(h.name==t)return h}return null}findPathConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const n=this.pathConstraints;for(let s=0,r=n.length;s<r;s++){const h=n[s];if(h.name==t)return h}return null}findPathConstraintIndex(t){if(t==null)throw new Error("pathConstraintName cannot be null.");const n=this.pathConstraints;for(let s=0,r=n.length;s<r;s++)if(n[s].name==t)return s;return-1}}class Ee{constructor(t,n,s){if(this.color=new _(1,1,1,1),t<0)throw new Error("index must be >= 0.");if(n==null)throw new Error("name cannot be null.");if(s==null)throw new Error("boneData cannot be null.");this.index=t,this.name=n,this.boneData=s}}class we extends Zt{constructor(t){super(t,0,!1),this.bones=new Array,this.rotateMix=0,this.translateMix=0,this.scaleMix=0,this.shearMix=0,this.offsetRotation=0,this.offsetX=0,this.offsetY=0,this.offsetScaleX=0,this.offsetScaleY=0,this.offsetShearY=0,this.relative=!1,this.local=!1}}class be{constructor(t,n,s){this.slotIndex=t,this.name=n,this.attachment=s}}class zt{constructor(t){if(this.attachments=new Array,this.bones=Array(),this.constraints=new Array,t==null)throw new Error("name cannot be null.");this.name=t}setAttachment(t,n,s){if(s==null)throw new Error("attachment cannot be null.");const r=this.attachments;t>=r.length&&(r.length=t+1),r[t]||(r[t]={}),r[t][n]=s}addSkin(t){for(let s=0;s<t.bones.length;s++){const r=t.bones[s];let h=!1;for(let d=0;d<this.bones.length;d++)if(this.bones[d]==r){h=!0;break}h||this.bones.push(r)}for(let s=0;s<t.constraints.length;s++){const r=t.constraints[s];let h=!1;for(let d=0;d<this.constraints.length;d++)if(this.constraints[d]==r){h=!0;break}h||this.constraints.push(r)}const n=t.getAttachments();for(let s=0;s<n.length;s++){const r=n[s];this.setAttachment(r.slotIndex,r.name,r.attachment)}}copySkin(t){for(let s=0;s<t.bones.length;s++){const r=t.bones[s];let h=!1;for(let d=0;d<this.bones.length;d++)if(this.bones[d]==r){h=!0;break}h||this.bones.push(r)}for(let s=0;s<t.constraints.length;s++){const r=t.constraints[s];let h=!1;for(let d=0;d<this.constraints.length;d++)if(this.constraints[d]==r){h=!0;break}h||this.constraints.push(r)}const n=t.getAttachments();for(let s=0;s<n.length;s++){const r=n[s];r.attachment!=null&&(r.attachment instanceof Lt?(r.attachment=r.attachment.newLinkedMesh(),this.setAttachment(r.slotIndex,r.name,r.attachment)):(r.attachment=r.attachment.copy(),this.setAttachment(r.slotIndex,r.name,r.attachment)))}}getAttachment(t,n){const s=this.attachments[t];return s?s[n]:null}removeAttachment(t,n){const s=this.attachments[t];s&&(s[n]=null)}getAttachments(){const t=new Array;for(let n=0;n<this.attachments.length;n++){const s=this.attachments[n];if(s)for(const r in s){const h=s[r];h&&t.push(new be(n,r,h))}}return t}getAttachmentsForSlot(t,n){const s=this.attachments[t];if(s)for(const r in s){const h=s[r];h&&n.push(new be(t,r,h))}}clear(){this.attachments.length=0,this.bones.length=0,this.constraints.length=0}attachAll(t,n){let s=0;for(let r=0;r<t.slots.length;r++){const h=t.slots[r],d=h.getAttachment();if(d&&s<n.attachments.length){const o=n.attachments[s];for(const a in o){const i=o[a];if(d==i){const l=this.getAttachment(s,a);l!=null&&h.setAttachment(l);break}}}s++}}}const K=class{constructor(e){this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=e}readSkeletonData(e){const t=this.scale,n=new xe;n.name="";const s=new Oe(e);n.hash=s.readString(),n.version=s.readString(),n.version==="3.8.75"&&console.error("Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine."),n.width=s.readFloat(),n.height=s.readFloat();const r=s.readBoolean();r&&(n.imagesPath=s.readString());let h=0;h=s.readInt(!0);for(let o=0;o<h;o++){const a=s.readString(),i=o==0?null:n.bones[s.readInt(!0)],l=new de(o,a,i);l.rotation=s.readFloat(),l.x=s.readFloat()*t,l.y=s.readFloat()*t,l.scaleX=s.readFloat(),l.scaleY=s.readFloat(),l.shearX=s.readFloat(),l.shearY=s.readFloat(),l.length=s.readFloat()*t,l.inheritRotation=s.readBoolean(),l.inheritScale=s.readBoolean();let u=0;!l.inheritRotation&&l.inheritScale&&(u=2),l.inheritRotation&&!l.inheritScale&&(u=3),!l.inheritRotation&&!l.inheritScale&&(u=1),l.transformMode=u,r&&_.rgba8888ToColor(l.color,s.readInt32()),n.bones.push(l)}h=s.readInt(!0);for(let o=0;o<h;o++){const a=s.readString(),i=n.bones[s.readInt(!0)],l=new Ee(o,a,i);_.rgba8888ToColor(l.color,s.readInt32()),l.attachmentName=s.readString(),l.blendMode=K.BlendModeValues[s.readInt(!0)],n.slots.push(l)}h=s.readInt(!0);for(let o=0,a;o<h;o++){const i=s.readString(),l=new fe(i);a=s.readInt(!0);for(let u=0;u<a;u++)l.bones.push(n.bones[s.readInt(!0)]);l.target=n.bones[s.readInt(!0)],l.mix=s.readFloat(),l.bendDirection=s.readByte(),n.ikConstraints.push(l)}h=s.readInt(!0);for(let o=0,a;o<h;o++){const i=s.readString(),l=new we(i);a=s.readInt(!0);for(let u=0;u<a;u++)l.bones.push(n.bones[s.readInt(!0)]);l.target=n.bones[s.readInt(!0)],l.offsetRotation=s.readFloat(),l.offsetX=s.readFloat()*t,l.offsetY=s.readFloat()*t,l.offsetScaleX=s.readFloat(),l.offsetScaleY=s.readFloat(),l.offsetShearY=s.readFloat(),l.rotateMix=s.readFloat(),l.translateMix=s.readFloat(),l.scaleMix=s.readFloat(),l.shearMix=s.readFloat(),n.transformConstraints.push(l)}h=s.readInt(!0);for(let o=0,a;o<h;o++){const i=s.readString(),l=new ge(i);a=s.readInt(!0);for(let u=0;u<a;u++)l.bones.push(n.bones[s.readInt(!0)]);l.target=n.slots[s.readInt(!0)],l.positionMode=K.PositionModeValues[s.readInt(!0)],l.spacingMode=K.SpacingModeValues[s.readInt(!0)],l.rotateMode=K.RotateModeValues[s.readInt(!0)],l.offsetRotation=s.readFloat(),l.position=s.readFloat(),l.positionMode==Vt.Fixed&&(l.position*=t),l.spacing=s.readFloat(),(l.spacingMode==nt.Length||l.spacingMode==nt.Fixed)&&(l.spacing*=t),l.rotateMix=s.readFloat(),l.translateMix=s.readFloat(),n.pathConstraints.push(l)}const d=this.readSkin(s,n,!0,r);d!=null&&(n.defaultSkin=d,n.skins.push(d));{let o=n.skins.length;for(T.setArraySize(n.skins,h=o+s.readInt(!0));o<h;o++)n.skins[o]=this.readSkin(s,n,!1,r)}h=this.linkedMeshes.length;for(let o=0;o<h;o++){const a=this.linkedMeshes[o],i=a.skin==null?n.defaultSkin:n.findSkin(a.skin);if(i==null)throw new Error(`Skin not found: ${a.skin}`);const l=i.getAttachment(a.slotIndex,a.parent);if(l==null)throw new Error(`Parent mesh not found: ${a.parent}`);a.mesh.deformAttachment=a.inheritDeform?l:a.mesh,a.mesh.setParentMesh(l)}this.linkedMeshes.length=0,h=s.readInt(!0);for(let o=0;o<h;o++){const a=new me(s.readStringRef());a.intValue=s.readInt(!1),a.floatValue=s.readFloat(),a.stringValue=s.readString(),a.audioPath=s.readString(),a.audioPath!=null&&(a.volume=s.readFloat(),a.balance=s.readFloat()),n.events.push(a)}h=s.readInt(!0);for(let o=0;o<h;o++)n.animations.push(this.readAnimation(s,s.readString(),n));return n}readSkin(e,t,n,s){let r=null,h=0;if(n){if(h=e.readInt(!0),h==0)return null;r=new zt("default")}else{r=new zt(e.readString()),r.bones.length=e.readInt(!0);for(let d=0,o=r.bones.length;d<o;d++)r.bones[d]=t.bones[e.readInt(!0)];for(let d=0,o=e.readInt(!0);d<o;d++)r.constraints.push(t.ikConstraints[e.readInt(!0)]);for(let d=0,o=e.readInt(!0);d<o;d++)r.constraints.push(t.transformConstraints[e.readInt(!0)]);for(let d=0,o=e.readInt(!0);d<o;d++)r.constraints.push(t.pathConstraints[e.readInt(!0)]);h=e.readInt(!0)}for(let d=0;d<h;d++){const o=e.readInt(!0);for(let a=0,i=e.readInt(!0);a<i;a++){const l=e.readString(),u=this.readAttachment(e,t,r,o,l,s);u!=null&&r.setAttachment(o,l,u)}}return r}readAttachment(e,t,n,s,r,h){const d=this.scale;let o=e.readStringRef();o==null&&(o=r);const a=e.readByte();switch(K.AttachmentTypeValues[a]){case pt.Region:{let i=e.readString();const l=e.readFloat(),u=e.readFloat(),m=e.readFloat(),c=e.readFloat(),f=e.readFloat(),p=e.readFloat(),g=e.readFloat(),x=e.readInt32();i==null&&(i=o);const E=this.attachmentLoader.newRegionAttachment(n,o,i);return E==null?null:(E.path=i,E.x=u*d,E.y=m*d,E.scaleX=c,E.scaleY=f,E.rotation=l,E.width=p*d,E.height=g*d,_.rgba8888ToColor(E.color,x),E)}case pt.BoundingBox:{const i=e.readInt(!0),l=this.readVertices(e,i),u=h?e.readInt32():0,m=this.attachmentLoader.newBoundingBoxAttachment(n,o);return m==null?null:(m.worldVerticesLength=i<<1,m.vertices=l.vertices,m.bones=l.bones,m.cVertices=l.cVertices,h&&_.rgba8888ToColor(m.color,u),m)}case pt.Mesh:{let i=e.readStringRef();const l=e.readInt32(),u=e.readInt(!0),m=this.readFloatArray(e,u<<1,1),c=this.readShortArray(e),f=this.readVertices(e,u),p=e.readInt(!0);let g=null,x=0,E=0;h&&(g=this.readShortArray(e),x=e.readFloat(),E=e.readFloat()),i==null&&(i=o);const w=this.attachmentLoader.newMeshAttachment(n,o,i);return w==null?null:(w.path=i,_.rgba8888ToColor(w.color,l),w.bones=f.bones,w.vertices=f.vertices,w.worldVerticesLength=u<<1,w.triangles=c,w.regionUVs=new Float32Array(m),w.cVertices=f.cVertices,w.hullLength=p<<1,h&&(w.edges=g,w.width=x*d,w.height=E*d),w)}case pt.LinkedMesh:{let i=e.readStringRef();const l=e.readInt32(),u=e.readStringRef(),m=e.readStringRef(),c=e.readBoolean();let f=0,p=0;h&&(f=e.readFloat(),p=e.readFloat()),i==null&&(i=o);const g=this.attachmentLoader.newMeshAttachment(n,o,i);return g==null?null:(g.path=i,_.rgba8888ToColor(g.color,l),h&&(g.width=f*d,g.height=p*d),this.linkedMeshes.push(new He(g,u,s,m,c)),g)}case pt.Path:{const i=e.readBoolean(),l=e.readBoolean(),u=e.readInt(!0),m=this.readVertices(e,u),c=T.newArray(u/3,0);for(let g=0,x=c.length;g<x;g++)c[g]=e.readFloat()*d;const f=h?e.readInt32():0,p=this.attachmentLoader.newPathAttachment(n,o);return p==null?null:(p.closed=i,p.constantSpeed=l,p.worldVerticesLength=u<<1,p.vertices=m.vertices,p.bones=m.bones,p.lengths=c,p.cVertices=m.cVertices,h&&_.rgba8888ToColor(p.color,f),p)}case pt.Point:{const i=e.readFloat(),l=e.readFloat(),u=e.readFloat(),m=h?e.readInt32():0,c=this.attachmentLoader.newPointAttachment(n,o);return c==null?null:(c.x=l*d,c.y=u*d,c.rotation=i,h&&_.rgba8888ToColor(c.color,m),c)}case pt.Clipping:{const i=e.readInt(!0),l=e.readInt(!0),u=this.readVertices(e,l),m=h?e.readInt32():0,c=this.attachmentLoader.newClippingAttachment(n,o);return c==null?null:(c.endSlot=t.slots[i],c.worldVerticesLength=l<<1,c.vertices=u.vertices,c.bones=u.bones,c.cVertices=u.cVertices,h&&_.rgba8888ToColor(c.color,m),c)}}return null}readVertices(e,t){const n=t<<1,s=new Ge,r=this.scale;if(!e.readBoolean())return s.vertices=this.readFloatArray(e,n,r),s;const h=new Array,d=new Array,o=new Array;for(let a=0;a<t;a++){const i=e.readInt(!0);o.push(i),h.push(i);for(let l=0;l<i;l++){const u=e.readInt(!0);o.push(u),h.push(u);const m=e.readFloat()*r,c=e.readFloat()*r,f=e.readFloat();d.push(m),d.push(c),d.push(f),h.push(m),h.push(c),h.push(f)}}return s.vertices=T.toFloatArray(d),s.bones=o,s.cVertices=h,s}readFloatArray(e,t,n){const s=new Array(t);if(n==1)for(let r=0;r<t;r++)s[r]=e.readFloat();else for(let r=0;r<t;r++)s[r]=e.readFloat()*n;return s}readShortArray(e){const t=e.readInt(!0),n=new Array(t);for(let s=0;s<t;s++)n[s]=e.readShort();return n}readAnimation(e,t,n){const s=new Array,r=this.scale;let h=0;const d=new _;for(let i=0,l=e.readInt(!0);i<l;i++){const u=e.readInt(!0);for(let m=0,c=e.readInt(!0);m<c;m++){const f=e.readByte(),p=e.readInt(!0);switch(f){case K.SLOT_ATTACHMENT:{const g=new vt(p);g.slotIndex=u;for(let x=0;x<p;x++){const E=e.readFloat(),w=e.readString();g.setFrame(x,E,w)}s.push(g),h=Math.max(h,g.frames[p-1]);break}case K.SLOT_COLOR:{const g=new lt(p);g.slotIndex=u;for(let x=0;x<p;x++){const E=e.readFloat();_.rgba8888ToColor(d,e.readInt32()),g.setFrame(x,E,d.r,d.g,d.b,d.a),x<p-1&&this.readCurve(e,x,g)}s.push(g),h=Math.max(h,g.frames[(p-1)*lt.ENTRIES]);break}}}}for(let i=0,l=e.readInt(!0);i<l;i++){const u=e.readInt(!0);for(let m=0,c=e.readInt(!0);m<c;m++){const f=e.readByte(),p=e.readInt(!0);switch(f){case K.BONE_ROTATE:{const g=new st(p);g.boneIndex=u;for(let x=0;x<p;x++)g.setFrame(x,e.readFloat(),e.readFloat()),x<p-1&&this.readCurve(e,x,g);s.push(g),h=Math.max(h,g.frames[(p-1)*st.ENTRIES]);break}case K.BONE_TRANSLATE:case K.BONE_SCALE:case K.BONE_SHEAR:{let g,x=1;f==K.BONE_SCALE?g=new ft(p):f==K.BONE_SHEAR?g=new gt(p):(g=new xt(p),x=r),g.boneIndex=u;for(let E=0;E<p;E++){const w=e.readFloat(),b=e.readFloat(),I=e.readFloat();g.setFrame(E,w,b*x,I*x),E<p-1&&this.readCurve(e,E,g)}s.push(g),h=Math.max(h,g.frames[(p-1)*xt.ENTRIES]);break}}}}for(let i=0,l=e.readInt(!0);i<l;i++){const u=e.readInt(!0),m=e.readInt(!0),c=new at(m);c.ikConstraintIndex=u;for(let f=0;f<m;f++){const p=e.readFloat(),g=e.readFloat(),x=e.readByte();c.setFrame(f,p,g,x),f<m-1&&this.readCurve(e,f,c)}s.push(c),h=Math.max(h,c.frames[(m-1)*at.ENTRIES])}for(let i=0,l=e.readInt(!0);i<l;i++){const u=e.readInt(!0),m=e.readInt(!0),c=new ht(m);c.transformConstraintIndex=u;for(let f=0;f<m;f++)c.setFrame(f,e.readFloat(),e.readFloat(),e.readFloat(),e.readFloat(),e.readFloat()),f<m-1&&this.readCurve(e,f,c);s.push(c),h=Math.max(h,c.frames[(m-1)*ht.ENTRIES])}for(let i=0,l=e.readInt(!0);i<l;i++){const u=e.readInt(!0),m=n.pathConstraints[u];for(let c=0,f=e.readInt(!0);c<f;c++){const p=e.readByte(),g=e.readInt(!0);switch(p){case K.PATH_POSITION:case K.PATH_SPACING:{let x,E=1;p==K.PATH_SPACING?(x=new St(g),(m.spacingMode==nt.Length||m.spacingMode==nt.Fixed)&&(E=r)):(x=new At(g),m.positionMode==Vt.Fixed&&(E=r)),x.pathConstraintIndex=u;for(let w=0;w<g;w++){const b=e.readFloat(),I=e.readFloat()*E;x.setFrame(w,b,I),w<g-1&&this.readCurve(e,w,x)}s.push(x),h=Math.max(h,x.frames[(g-1)*At.ENTRIES]);break}case K.PATH_MIX:{const x=new It(g);x.pathConstraintIndex=u;for(let E=0;E<g;E++){const w=e.readFloat(),b=e.readFloat(),I=e.readFloat();x.setFrame(E,w,b,I),E<g-1&&this.readCurve(e,E,x)}s.push(x),h=Math.max(h,x.frames[(g-1)*It.ENTRIES]);break}}}}for(let i=0,l=e.readInt(!0);i<l;i++){const u=n.skins[e.readInt(!0)];for(let m=0,c=e.readInt(!0);m<c;m++){const f=e.readInt(!0);for(let p=0,g=e.readInt(!0);p<g;p++){const x=u==null?void 0:u.getAttachment(f,e.readString()),E=x.bones!=null,w=x.vertices,b=E?w.length/3*2:w.length,I=e.readInt(!0),M=new re(I);M.slotIndex=f,M.attachment=x;for(let S=0;S<I;S++){const V=e.readFloat();let R,k=e.readInt(!0);if(k==0)R=E?T.newFloatArray(b):w;else{R=T.newFloatArray(b);const L=e.readInt(!0);if(k+=L,r==1)for(let v=L;v<k;v++)R[v]=e.readFloat();else for(let v=L;v<k;v++)R[v]=e.readFloat()*r;if(!E)for(let v=0,H=R.length;v<H;v++)R[v]+=w[v]}M.setFrame(S,V,R,u.name),S<I-1&&this.readCurve(e,S,M)}s.push(M),h=Math.max(h,M.frames[I-1])}}}const o=e.readInt(!0);if(o>0){const i=new _t(o),l=n.slots.length;for(let u=0;u<o;u++){const m=e.readFloat(),c=e.readInt(!0),f=T.newArray(l,0);for(let E=l-1;E>=0;E--)f[E]=-1;const p=T.newArray(l-c,0);let g=0,x=0;for(let E=0;E<c;E++){const w=e.readInt(!0);for(;g!=w;)p[x++]=g++;f[g+e.readInt(!0)]=g++}for(;g<l;)p[x++]=g++;for(let E=l-1;E>=0;E--)f[E]==-1&&(f[E]=p[--x]);i.setFrame(u,m,f)}s.push(i),h=Math.max(h,i.frames[o-1])}const a=e.readInt(!0);if(a>0){const i=new Gt(a);for(let l=0;l<a;l++){const u=e.readFloat(),m=n.events[e.readInt(!0)],c=new ue(u,m);c.intValue=e.readInt(!1),c.floatValue=e.readFloat(),c.stringValue=e.readBoolean()?e.readString():m.stringValue,c.data.audioPath!=null&&(c.volume=e.readFloat(),c.balance=e.readFloat()),i.setFrame(l,c)}s.push(i),h=Math.max(h,i.frames[a-1])}return new z(t,s,h)}readCurve(e,t,n){switch(e.readByte()){case K.CURVE_STEPPED:n.setStepped(t);break;case K.CURVE_BEZIER:this.setCurve(n,t,e.readFloat(),e.readFloat(),e.readFloat(),e.readFloat());break}}setCurve(e,t,n,s,r,h){e.setCurve(t,n,s,r,h)}};let J=K;J.AttachmentTypeValues=[0,1,2,3,4,5,6],J.TransformModeValues=[Z.Normal,Z.OnlyTranslation,Z.NoRotationOrReflection,Z.NoScale,Z.NoScaleOrReflection],J.PositionModeValues=[Vt.Fixed,Vt.Percent],J.SpacingModeValues=[nt.Length,nt.Fixed,nt.Percent],J.RotateModeValues=[Tt.Tangent,Tt.Chain,Tt.ChainScale],J.BlendModeValues=[Pt.NORMAL,Pt.ADD,Pt.MULTIPLY,Pt.SCREEN],J.BONE_ROTATE=0,J.BONE_TRANSLATE=1,J.BONE_SCALE=2,J.BONE_SHEAR=3,J.SLOT_ATTACHMENT=0,J.SLOT_COLOR=1,J.SLOT_TWO_COLOR=2,J.PATH_POSITION=0,J.PATH_SPACING=1,J.PATH_MIX=2,J.CURVE_LINEAR=0,J.CURVE_STEPPED=1,J.CURVE_BEZIER=2;class He{constructor(t,n,s,r,h){this.mesh=t,this.skin=n,this.slotIndex=s,this.parent=r,this.inheritDeform=h}}class Ge{constructor(t=null,n=null,s=null){this.bones=t,this.vertices=n,this.cVertices=s}}class je extends Be{}class Dt{constructor(t){this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=t}readSkeletonData(t){const n=this.scale,s=new xe,r=typeof t=="string"?JSON.parse(t):t,h=r.skeleton;if(h!=null){if(s.hash=h.hash,s.version=h.spine,s.version.substr(0,3)!=="3.4"){const d=`Spine 3.4 loader cant load version ${h.spine}. Please configure your pixi-spine bundle`;console.error(d)}s.version==="3.4.75"&&console.error("Unsupported skeleton data, 3.4.75 is deprecated, please export with a newer version of Spine."),s.x=h.x,s.y=h.y,s.width=h.width,s.height=h.height,s.fps=h.fps,s.imagesPath=h.images}if(r.bones)for(let d=0;d<r.bones.length;d++){const o=r.bones[d];let a=null;const i=this.getValue(o,"parent",null);if(i!=null&&(a=s.findBone(i),a==null))throw new Error(`Parent bone not found: ${i}`);const l=new de(s.bones.length,o.name,a);l.length=this.getValue(o,"length",0)*n,l.x=this.getValue(o,"x",0)*n,l.y=this.getValue(o,"y",0)*n,l.rotation=this.getValue(o,"rotation",0),l.scaleX=this.getValue(o,"scaleX",1),l.scaleY=this.getValue(o,"scaleY",1),l.shearX=this.getValue(o,"shearX",0),l.shearY=this.getValue(o,"shearY",0),l.transformMode=Dt.transformModeFromString(this.getValue(o,"transform","normal")),l.skinRequired=this.getValue(o,"skin",!1),s.bones.push(l)}if(r.slots)for(let d=0;d<r.slots.length;d++){const o=r.slots[d],a=o.name,i=o.bone,l=s.findBone(i);if(l==null)throw new Error(`Slot bone not found: ${i}`);const u=new Ee(s.slots.length,a,l),m=this.getValue(o,"color",null);m!=null&&u.color.setFromString(m);const c=this.getValue(o,"dark",null);c!=null&&(u.darkColor=new _(1,1,1,1),u.darkColor.setFromString(c)),u.attachmentName=this.getValue(o,"attachment",null),u.blendMode=Dt.blendModeFromString(this.getValue(o,"blend","normal")),s.slots.push(u)}if(r.ik)for(let d=0;d<r.ik.length;d++){const o=r.ik[d],a=new fe(o.name);a.order=this.getValue(o,"order",0),a.skinRequired=this.getValue(o,"skin",!1);for(let l=0;l<o.bones.length;l++){const u=o.bones[l],m=s.findBone(u);if(m==null)throw new Error(`IK bone not found: ${u}`);a.bones.push(m)}const i=o.target;if(a.target=s.findBone(i),a.target==null)throw new Error(`IK target bone not found: ${i}`);a.mix=this.getValue(o,"mix",1),a.softness=this.getValue(o,"softness",0)*n,a.bendDirection=this.getValue(o,"bendPositive",!0)?1:-1,a.compress=this.getValue(o,"compress",!1),a.stretch=this.getValue(o,"stretch",!1),a.uniform=this.getValue(o,"uniform",!1),s.ikConstraints.push(a)}if(r.transform)for(let d=0;d<r.transform.length;d++){const o=r.transform[d],a=new we(o.name);a.order=this.getValue(o,"order",0),a.skinRequired=this.getValue(o,"skin",!1);for(let l=0;l<o.bones.length;l++){const u=o.bones[l],m=s.findBone(u);if(m==null)throw new Error(`Transform constraint bone not found: ${u}`);a.bones.push(m)}const i=o.target;if(a.target=s.findBone(i),a.target==null)throw new Error(`Transform constraint target bone not found: ${i}`);a.local=this.getValue(o,"local",!1),a.relative=this.getValue(o,"relative",!1),a.offsetRotation=this.getValue(o,"rotation",0),a.offsetX=this.getValue(o,"x",0)*n,a.offsetY=this.getValue(o,"y",0)*n,a.offsetScaleX=this.getValue(o,"scaleX",0),a.offsetScaleY=this.getValue(o,"scaleY",0),a.offsetShearY=this.getValue(o,"shearY",0),a.rotateMix=this.getValue(o,"rotateMix",1),a.translateMix=this.getValue(o,"translateMix",1),a.scaleMix=this.getValue(o,"scaleMix",1),a.shearMix=this.getValue(o,"shearMix",1),s.transformConstraints.push(a)}if(r.path)for(let d=0;d<r.path.length;d++){const o=r.path[d],a=new ge(o.name);a.order=this.getValue(o,"order",0),a.skinRequired=this.getValue(o,"skin",!1);for(let l=0;l<o.bones.length;l++){const u=o.bones[l],m=s.findBone(u);if(m==null)throw new Error(`Transform constraint bone not found: ${u}`);a.bones.push(m)}const i=o.target;if(a.target=s.findSlot(i),a.target==null)throw new Error(`Path target slot not found: ${i}`);a.positionMode=Dt.positionModeFromString(this.getValue(o,"positionMode","percent")),a.spacingMode=Dt.spacingModeFromString(this.getValue(o,"spacingMode","length")),a.rotateMode=Dt.rotateModeFromString(this.getValue(o,"rotateMode","tangent")),a.offsetRotation=this.getValue(o,"rotation",0),a.position=this.getValue(o,"position",0),a.positionMode==Vt.Fixed&&(a.position*=n),a.spacing=this.getValue(o,"spacing",0),(a.spacingMode==nt.Length||a.spacingMode==nt.Fixed)&&(a.spacing*=n),a.rotateMix=this.getValue(o,"rotateMix",1),a.translateMix=this.getValue(o,"translateMix",1),s.pathConstraints.push(a)}if(r.skins)for(let d=0;d<r.skins.length;d++){const o=r.skins[d],a=new zt(o.name);if(o.bones)for(let i=0;i<o.bones.length;i++){const l=s.findBone(o.bones[i]);if(l==null)throw new Error(`Skin bone not found: ${o.bones[d]}`);a.bones.push(l)}if(o.ik)for(let i=0;i<o.ik.length;i++){const l=s.findIkConstraint(o.ik[i]);if(l==null)throw new Error(`Skin IK constraint not found: ${o.ik[d]}`);a.constraints.push(l)}if(o.transform)for(let i=0;i<o.transform.length;i++){const l=s.findTransformConstraint(o.transform[i]);if(l==null)throw new Error(`Skin transform constraint not found: ${o.transform[d]}`);a.constraints.push(l)}if(o.path)for(let i=0;i<o.path.length;i++){const l=s.findPathConstraint(o.path[i]);if(l==null)throw new Error(`Skin path constraint not found: ${o.path[d]}`);a.constraints.push(l)}for(const i in o.attachments){const l=s.findSlot(i);if(l==null)throw new Error(`Slot not found: ${i}`);const u=o.attachments[i];for(const m in u){const c=this.readAttachment(u[m],a,l.index,m,s);c!=null&&a.setAttachment(l.index,m,c)}}s.skins.push(a),a.name=="default"&&(s.defaultSkin=a)}for(let d=0,o=this.linkedMeshes.length;d<o;d++){const a=this.linkedMeshes[d],i=a.skin==null?s.defaultSkin:s.findSkin(a.skin);if(i==null)throw new Error(`Skin not found: ${a.skin}`);const l=i.getAttachment(a.slotIndex,a.parent);if(l==null)throw new Error(`Parent mesh not found: ${a.parent}`);a.mesh.deformAttachment=a.inheritDeform?l:a.mesh,a.mesh.setParentMesh(l)}if(this.linkedMeshes.length=0,r.events)for(const d in r.events){const o=r.events[d],a=new me(d);a.intValue=this.getValue(o,"int",0),a.floatValue=this.getValue(o,"float",0),a.stringValue=this.getValue(o,"string",""),a.audioPath=this.getValue(o,"audio",null),a.audioPath!=null&&(a.volume=this.getValue(o,"volume",1),a.balance=this.getValue(o,"balance",0)),s.events.push(a)}if(r.animations)for(const d in r.animations){const o=r.animations[d];this.readAnimation(o,d,s)}return s}readAttachment(t,n,s,r,h){const d=this.scale;switch(r=this.getValue(t,"name",r),this.getValue(t,"type","region")){case"region":{const o=this.getValue(t,"path",r),a=this.attachmentLoader.newRegionAttachment(n,r,o);if(a==null)return null;a.path=o,a.x=this.getValue(t,"x",0)*d,a.y=this.getValue(t,"y",0)*d,a.scaleX=this.getValue(t,"scaleX",1),a.scaleY=this.getValue(t,"scaleY",1),a.rotation=this.getValue(t,"rotation",0),a.width=t.width*d,a.height=t.height*d;const i=this.getValue(t,"color",null);return i!=null&&a.color.setFromString(i),a}case"boundingbox":{const o=this.attachmentLoader.newBoundingBoxAttachment(n,r);if(o==null)return null;this.readVertices(t,o,t.vertexCount<<1);const a=this.getValue(t,"color",null);return a!=null&&o.color.setFromString(a),o}case"mesh":case"linkedmesh":{const o=this.getValue(t,"path",r),a=this.attachmentLoader.newMeshAttachment(n,r,o);if(a==null)return null;a.path=o;const i=this.getValue(t,"color",null);i!=null&&a.color.setFromString(i),a.width=this.getValue(t,"width",0)*d,a.height=this.getValue(t,"height",0)*d;const l=this.getValue(t,"parent",null);if(l!=null)return this.linkedMeshes.push(new Ze(a,this.getValue(t,"skin",null),s,l,this.getValue(t,"deform",!0))),a;const u=t.uvs;return this.readVertices(t,a,u.length),a.triangles=t.triangles,a.regionUVs=new Float32Array(u),a.edges=this.getValue(t,"edges",null),a.hullLength=this.getValue(t,"hull",0)*2,a}case"path":{const o=this.attachmentLoader.newPathAttachment(n,r);if(o==null)return null;o.closed=this.getValue(t,"closed",!1),o.constantSpeed=this.getValue(t,"constantSpeed",!0);const a=t.vertexCount;this.readVertices(t,o,a<<1);const i=T.newArray(a/3,0);for(let u=0;u<t.lengths.length;u++)i[u]=t.lengths[u]*d;o.lengths=i;const l=this.getValue(t,"color",null);return l!=null&&o.color.setFromString(l),o}case"point":{const o=this.attachmentLoader.newPointAttachment(n,r);if(o==null)return null;o.x=this.getValue(t,"x",0)*d,o.y=this.getValue(t,"y",0)*d,o.rotation=this.getValue(t,"rotation",0);const a=this.getValue(t,"color",null);return a!=null&&o.color.setFromString(a),o}case"clipping":{const o=this.attachmentLoader.newClippingAttachment(n,r);if(o==null)return null;const a=this.getValue(t,"end",null);if(a!=null){const u=h.findSlot(a);if(u==null)throw new Error(`Clipping end slot not found: ${a}`);o.endSlot=u}const i=t.vertexCount;this.readVertices(t,o,i<<1);const l=this.getValue(t,"color",null);return l!=null&&o.color.setFromString(l),o}}return null}readVertices(t,n,s){const r=this.scale;n.worldVerticesLength=s;const h=t.vertices;if(s==h.length){const a=T.toFloatArray(h);if(r!=1)for(let i=0,l=h.length;i<l;i++)a[i]*=r;n.vertices=a;return}const d=new Array,o=new Array;for(let a=0,i=h.length;a<i;){const l=h[a++];o.push(l);for(let u=a+l*4;a<u;a+=4)o.push(h[a]),d.push(h[a+1]*r),d.push(h[a+2]*r),d.push(h[a+3])}n.bones=o,n.vertices=T.toFloatArray(d)}readAnimation(t,n,s){const r=this.scale,h=new Array;let d=0;if(t.slots)for(const a in t.slots){const i=t.slots[a],l=s.findSlotIndex(a);if(l==-1)throw new Error(`Slot not found: ${a}`);for(const u in i){const m=i[u];if(u=="attachment"){const c=new vt(m.length);c.slotIndex=l;let f=0;for(let p=0;p<m.length;p++){const g=m[p];c.setFrame(f++,this.getValue(g,"time",0),g.name)}h.push(c),d=Math.max(d,c.frames[c.getFrameCount()-1])}else if(u=="color"){const c=new lt(m.length);c.slotIndex=l;let f=0;for(let p=0;p<m.length;p++){const g=m[p],x=new _;x.setFromString(g.color||"ffffffff"),c.setFrame(f,this.getValue(g,"time",0),x.r,x.g,x.b,x.a),this.readCurve(g,c,f),f++}h.push(c),d=Math.max(d,c.frames[(c.getFrameCount()-1)*lt.ENTRIES])}else if(u=="twoColor"){const c=new tt(m.length);c.slotIndex=l;let f=0;for(let p=0;p<m.length;p++){const g=m[p],x=new _,E=new _;x.setFromString(g.light),E.setFromString(g.dark),c.setFrame(f,this.getValue(g,"time",0),x.r,x.g,x.b,x.a,E.r,E.g,E.b),this.readCurve(g,c,f),f++}h.push(c),d=Math.max(d,c.frames[(c.getFrameCount()-1)*tt.ENTRIES])}else throw new Error(`Invalid timeline type for a slot: ${u} (${a})`)}}if(t.bones)for(const a in t.bones){const i=t.bones[a],l=s.findBoneIndex(a);if(l==-1)throw new Error(`Bone not found: ${a}`);for(const u in i){const m=i[u];if(u==="rotate"){const c=new st(m.length);c.boneIndex=l;let f=0;for(let p=0;p<m.length;p++){const g=m[p];c.setFrame(f,this.getValue(g,"time",0),this.getValue(g,"angle",0)),this.readCurve(g,c,f),f++}h.push(c),d=Math.max(d,c.frames[(c.getFrameCount()-1)*st.ENTRIES])}else if(u==="translate"||u==="scale"||u==="shear"){let c=null,f=1,p=0;u==="scale"?(c=new ft(m.length),p=1):u==="shear"?c=new gt(m.length):(c=new xt(m.length),f=r),c.boneIndex=l;let g=0;for(let x=0;x<m.length;x++){const E=m[x],w=this.getValue(E,"x",p),b=this.getValue(E,"y",p);c.setFrame(g,this.getValue(E,"time",0),w*f,b*f),this.readCurve(E,c,g),g++}h.push(c),d=Math.max(d,c.frames[(c.getFrameCount()-1)*xt.ENTRIES])}else throw new Error(`Invalid timeline type for a bone: ${u} (${a})`)}}if(t.ik)for(const a in t.ik){const i=t.ik[a],l=s.findIkConstraint(a),u=new at(i.length);u.ikConstraintIndex=s.ikConstraints.indexOf(l);let m=0;for(let c=0;c<i.length;c++){const f=i[c];u.setFrame(m,this.getValue(f,"time",0),this.getValue(f,"mix",1),this.getValue(f,"softness",0)*r),this.readCurve(f,u,m),m++}h.push(u),d=Math.max(d,u.frames[(u.getFrameCount()-1)*at.ENTRIES])}if(t.transform)for(const a in t.transform){const i=t.transform[a],l=s.findTransformConstraint(a),u=new ht(i.length);u.transformConstraintIndex=s.transformConstraints.indexOf(l);let m=0;for(let c=0;c<i.length;c++){const f=i[c];u.setFrame(m,this.getValue(f,"time",0),this.getValue(f,"rotateMix",1),this.getValue(f,"translateMix",1),this.getValue(f,"scaleMix",1),this.getValue(f,"shearMix",1)),this.readCurve(f,u,m),m++}h.push(u),d=Math.max(d,u.frames[(u.getFrameCount()-1)*ht.ENTRIES])}if(t.path)for(const a in t.path){const i=t.path[a],l=s.findPathConstraintIndex(a);if(l==-1)throw new Error(`Path constraint not found: ${a}`);const u=s.pathConstraints[l];for(const m in i){const c=i[m];if(m==="position"||m==="spacing"){let f=null,p=1;m==="spacing"?(f=new St(c.length),(u.spacingMode==nt.Length||u.spacingMode==nt.Fixed)&&(p=r)):(f=new At(c.length),u.positionMode==Vt.Fixed&&(p=r)),f.pathConstraintIndex=l;let g=0;for(let x=0;x<c.length;x++){const E=c[x];f.setFrame(g,this.getValue(E,"time",0),this.getValue(E,m,0)*p),this.readCurve(E,f,g),g++}h.push(f),d=Math.max(d,f.frames[(f.getFrameCount()-1)*At.ENTRIES])}else if(m==="mix"){const f=new It(c.length);f.pathConstraintIndex=l;let p=0;for(let g=0;g<c.length;g++){const x=c[g];f.setFrame(p,this.getValue(x,"time",0),this.getValue(x,"rotateMix",1),this.getValue(x,"translateMix",1)),this.readCurve(x,f,p),p++}h.push(f),d=Math.max(d,f.frames[(f.getFrameCount()-1)*It.ENTRIES])}}}if(t.deform)for(const a in t.deform){const i=t.deform[a],l=s.findSkin(a);if(l==null){if(ne.FAIL_ON_NON_EXISTING_SKIN)throw new Error(`Skin not found: ${a}`);continue}for(const u in i){const m=i[u],c=s.findSlotIndex(u);if(c==-1)throw new Error(`Slot not found: ${m.name}`);for(const f in m){const p=m[f],g=l.getAttachment(c,f);if(g==null)throw new Error(`Deform attachment not found: ${p.name}`);const x=g.bones!=null,E=g.vertices,w=x?E.length/3*2:E.length,b=new re(p.length);b.slotIndex=c,b.attachment=g;let I=0;for(let M=0;M<p.length;M++){const S=p[M];let V;const R=this.getValue(S,"vertices",null);if(R==null)V=x?T.newFloatArray(w):E;else{V=T.newFloatArray(w);const k=this.getValue(S,"offset",0);if(T.arrayCopy(R,0,V,k,R.length),r!=1)for(let L=k,v=L+R.length;L<v;L++)V[L]*=r;if(!x)for(let L=0;L<w;L++)V[L]+=E[L]}b.setFrame(I,this.getValue(S,"time",0),V,l.name),this.readCurve(S,b,I),I++}h.push(b),d=Math.max(d,b.frames[b.getFrameCount()-1])}}}let o=t.drawOrder;if(o==null&&(o=t.draworder),o!=null){const a=new _t(o.length),i=s.slots.length;let l=0;for(let u=0;u<o.length;u++){const m=o[u];let c=null;const f=this.getValue(m,"offsets",null);if(f!=null){c=T.newArray(i,-1);const p=T.newArray(i-f.length,0);let g=0,x=0;for(let E=0;E<f.length;E++){const w=f[E],b=s.findSlotIndex(w.slot);if(b==-1)throw new Error(`Slot not found: ${w.slot}`);for(;g!=b;)p[x++]=g++;c[g+w.offset]=g++}for(;g<i;)p[x++]=g++;for(let E=i-1;E>=0;E--)c[E]==-1&&(c[E]=p[--x])}a.setFrame(l++,this.getValue(m,"time",0),c)}h.push(a),d=Math.max(d,a.frames[a.getFrameCount()-1])}if(t.events){const a=new Gt(t.events.length);let i=0;for(let l=0;l<t.events.length;l++){const u=t.events[l],m=s.findEvent(u.name);if(m==null)throw new Error(`Event not found: ${u.name}`);const c=new ue(T.toSinglePrecision(this.getValue(u,"time",0)),m);c.intValue=this.getValue(u,"int",m.intValue),c.floatValue=this.getValue(u,"float",m.floatValue),c.stringValue=this.getValue(u,"string",m.stringValue),c.data.audioPath!=null&&(c.volume=this.getValue(u,"volume",1),c.balance=this.getValue(u,"balance",0)),a.setFrame(i++,c)}h.push(a),d=Math.max(d,a.frames[a.getFrameCount()-1])}if(isNaN(d))throw new Error("Error while parsing animation, duration is NaN");s.animations.push(new z(n,h,d))}readCurve(t,n,s){if(t.hasOwnProperty("curve"))if(t.curve==="stepped")n.setStepped(s);else{const r=t.curve;n.setCurve(s,r,this.getValue(t,"c2",0),this.getValue(t,"c3",1),this.getValue(t,"c4",1))}}getValue(t,n,s){return t[n]!==void 0?t[n]:s}static blendModeFromString(t){if(t=t.toLowerCase(),t=="normal")return Pt.NORMAL;if(t=="additive")return Pt.ADD;if(t=="multiply")return Pt.MULTIPLY;if(t=="screen")return Pt.SCREEN;throw new Error(`Unknown blend mode: ${t}`)}static positionModeFromString(t){if(t=t.toLowerCase(),t=="fixed")return Vt.Fixed;if(t=="percent")return Vt.Percent;throw new Error(`Unknown position mode: ${t}`)}static spacingModeFromString(t){if(t=t.toLowerCase(),t=="length")return nt.Length;if(t=="fixed")return nt.Fixed;if(t=="percent")return nt.Percent;throw new Error(`Unknown position mode: ${t}`)}static rotateModeFromString(t){if(t=t.toLowerCase(),t=="tangent")return Tt.Tangent;if(t=="chain")return Tt.Chain;if(t=="chainscale")return Tt.ChainScale;throw new Error(`Unknown rotate mode: ${t}`)}static transformModeFromString(t){if(t=t.toLowerCase(),t=="normal")return Z.Normal;if(t=="onlytranslation")return Z.OnlyTranslation;if(t=="norotationorreflection")return Z.NoRotationOrReflection;if(t=="noscale")return Z.NoScale;if(t=="noscaleorreflection")return Z.NoScaleOrReflection;throw new Error(`Unknown transform mode: ${t}`)}}class Ze{constructor(t,n,s,r,h){this.mesh=t,this.skin=n,this.slotIndex=s,this.parent=r,this.inheritDeform=h}}class ze extends _e{createSkeleton(t){this.skeleton=new pe(t),this.skeleton.updateWorldTransform(),this.stateData=new he(t),this.state=new Et(this.stateData)}}export{z as Animation,Et as AnimationState,Ue as AnimationStateAdapter,he as AnimationStateData,$e as AtlasAttachmentLoader,se as Attachment,vt as AttachmentTimeline,ce as Bone,de as BoneData,Qt as BoundingBoxAttachment,Kt as ClippingAttachment,lt as ColorTimeline,Zt as ConstraintData,ut as CurveTimeline,re as DeformTimeline,_t as DrawOrderTimeline,ue as Event,me as EventData,oe as EventQueue,Gt as EventTimeline,mt as EventType,Ne as IkConstraint,fe as IkConstraintData,at as IkConstraintTimeline,qe as JitterEffect,Lt as MeshAttachment,Yt as PathAttachment,Wt as PathConstraint,ge as PathConstraintData,It as PathConstraintMixTimeline,At as PathConstraintPositionTimeline,St as PathConstraintSpacingTimeline,Jt as PointAttachment,N as RegionAttachment,st as RotateTimeline,ft as ScaleTimeline,gt as ShearTimeline,pe as Skeleton,J as SkeletonBinary,je as SkeletonBounds,xe as SkeletonData,Dt as SkeletonJson,zt as Skin,be as SkinEntry,ae as Slot,Ee as SlotData,nt as SpacingMode,ze as Spine,Ce as SwirlEffect,Pe as TimelineType,jt as TrackEntry,ve as TransformConstraint,we as TransformConstraintData,ht as TransformConstraintTimeline,xt as TranslateTimeline,tt as TwoColorTimeline,Ft as VertexAttachment};
//# sourceMappingURL=runtime-3.4.mjs.map
