{"version":3,"file":"runtime-3.4.js","sources":["../src/core/attachments/Attachment.ts","../src/core/attachments/BoundingBoxAttachment.ts","../src/core/attachments/ClippingAttachment.ts","../src/core/attachments/MeshAttachment.ts","../src/core/attachments/PathAttachment.ts","../src/core/attachments/PointAttachment.ts","../src/core/Slot.ts","../src/core/attachments/RegionAttachment.ts","../src/core/vertexeffects/JitterEffect.ts","../src/core/vertexeffects/SwirlEffect.ts","../src/core/Animation.ts","../src/core/AnimationState.ts","../src/core/AnimationStateData.ts","../src/core/AtlasAttachmentLoader.ts","../src/core/Bone.ts","../src/core/BoneData.ts","../src/core/Constraint.ts","../src/core/Event.ts","../src/core/EventData.ts","../src/core/IkConstraint.ts","../src/core/IkConstraintData.ts","../src/core/PathConstraintData.ts","../src/core/PathConstraint.ts","../src/core/TransformConstraint.ts","../src/core/Skeleton.ts","../src/core/SkeletonData.ts","../src/core/SlotData.ts","../src/core/TransformConstraintData.ts","../src/core/Skin.ts","../src/core/SkeletonBinary.ts","../src/core/SkeletonBounds.ts","../src/core/SkeletonJson.ts","../src/Spine.ts"],"sourcesContent":["import { AttachmentType, Utils } from '@pixi-spine/base';\r\nimport type { IAttachment, ArrayLike } from '@pixi-spine/base';\r\n\r\nimport type { Slot } from '../Slot';\r\n\r\n/**\r\n * @public\r\n */\r\nexport abstract class Attachment implements IAttachment {\r\n    name: string;\r\n    type: AttachmentType;\r\n    cVertices: number[];\r\n\r\n    constructor(name: string) {\r\n        if (name == null) throw new Error('name cannot be null.');\r\n        this.name = name;\r\n    }\r\n\r\n    abstract copy(): Attachment;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport abstract class VertexAttachment extends Attachment {\r\n    private static nextID = 0;\r\n\r\n    id = (VertexAttachment.nextID++ & 65535) << 11;\r\n    bones: Array<number>;\r\n    vertices: ArrayLike<number>;\r\n    worldVerticesLength = 0;\r\n    deformAttachment: VertexAttachment = this;\r\n\r\n    constructor(name: string) {\r\n        super(name);\r\n    }\r\n\r\n    computeWorldVerticesOld(slot: Slot, worldVertices: ArrayLike<number>) {\r\n        this.computeWorldVertices(slot, 0, this.worldVerticesLength, worldVertices, 0, 2);\r\n    }\r\n\r\n    /** Transforms local vertices to world coordinates.\r\n     * @param start The index of the first local vertex value to transform. Each vertex has 2 values, x and y.\r\n     * @param count The number of world vertex values to output. Must be <= {@link #getWorldVerticesLength()} - start.\r\n     * @param worldVertices The output world vertices. Must have a length >= offset + count.\r\n     * @param offset The worldVertices index to begin writing values. */\r\n    computeWorldVertices(slot: Slot, start: number, count: number, worldVertices: ArrayLike<number>, offset: number, stride: number) {\r\n        count = offset + (count >> 1) * stride;\r\n        const skeleton = slot.bone.skeleton;\r\n        const deformArray = slot.deform;\r\n        let vertices = this.vertices;\r\n        const bones = this.bones;\r\n\r\n        if (bones == null) {\r\n            if (deformArray.length > 0) vertices = deformArray;\r\n            const mat = slot.bone.matrix;\r\n            const x = mat.tx;\r\n            const y = mat.ty;\r\n            const a = mat.a;\r\n            const b = mat.c;\r\n            const c = mat.b;\r\n            const d = mat.d;\r\n\r\n            for (let v = start, w = offset; w < count; v += 2, w += stride) {\r\n                const vx = vertices[v];\r\n                const vy = vertices[v + 1];\r\n\r\n                worldVertices[w] = vx * a + vy * b + x;\r\n                worldVertices[w + 1] = vx * c + vy * d + y;\r\n            }\r\n\r\n            return;\r\n        }\r\n        let v = 0;\r\n        let skip = 0;\r\n\r\n        for (let i = 0; i < start; i += 2) {\r\n            const n = bones[v];\r\n\r\n            v += n + 1;\r\n            skip += n;\r\n        }\r\n        const skeletonBones = skeleton.bones;\r\n\r\n        if (deformArray.length == 0) {\r\n            for (let w = offset, b = skip * 3; w < count; w += stride) {\r\n                let wx = 0;\r\n                let wy = 0;\r\n                let n = bones[v++];\r\n\r\n                n += v;\r\n                for (; v < n; v++, b += 3) {\r\n                    const mat = skeletonBones[bones[v]].matrix;\r\n                    const vx = vertices[b];\r\n                    const vy = vertices[b + 1];\r\n                    const weight = vertices[b + 2];\r\n\r\n                    wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\r\n                    wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\r\n                }\r\n                worldVertices[w] = wx;\r\n                worldVertices[w + 1] = wy;\r\n            }\r\n        } else {\r\n            const deform = deformArray;\r\n\r\n            for (let w = offset, b = skip * 3, f = skip << 1; w < count; w += stride) {\r\n                let wx = 0;\r\n                let wy = 0;\r\n                let n = bones[v++];\r\n\r\n                n += v;\r\n                for (; v < n; v++, b += 3, f += 2) {\r\n                    const mat = skeletonBones[bones[v]].matrix;\r\n                    const vx = vertices[b] + deform[f];\r\n                    const vy = vertices[b + 1] + deform[f + 1];\r\n                    const weight = vertices[b + 2];\r\n\r\n                    wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\r\n                    wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\r\n                }\r\n                worldVertices[w] = wx;\r\n                worldVertices[w + 1] = wy;\r\n            }\r\n        }\r\n    }\r\n\r\n    copyTo(attachment: VertexAttachment) {\r\n        if (this.bones != null) {\r\n            attachment.bones = new Array<number>(this.bones.length);\r\n            Utils.arrayCopy(this.bones, 0, attachment.bones, 0, this.bones.length);\r\n        } else attachment.bones = null;\r\n\r\n        if (this.vertices != null) {\r\n            attachment.vertices = Utils.newFloatArray(this.vertices.length);\r\n            Utils.arrayCopy(this.vertices, 0, attachment.vertices, 0, this.vertices.length);\r\n        } else attachment.vertices = null;\r\n\r\n        attachment.worldVerticesLength = this.worldVerticesLength;\r\n        attachment.deformAttachment = this.deformAttachment;\r\n    }\r\n}\r\n","import { Attachment, VertexAttachment } from './Attachment';\nimport { AttachmentType, Color } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class BoundingBoxAttachment extends VertexAttachment {\n    type = AttachmentType.BoundingBox;\n    color = new Color(1, 1, 1, 1);\n\n    constructor(name: string) {\n        super(name);\n    }\n\n    copy(): Attachment {\n        const copy = new BoundingBoxAttachment(this.name);\n\n        this.copyTo(copy);\n        copy.color.setFromColor(this.color);\n\n        return copy;\n    }\n}\n","import { Attachment, VertexAttachment } from './Attachment';\nimport { AttachmentType, Color, IClippingAttachment } from '@pixi-spine/base';\nimport type { SlotData } from '../SlotData';\n\n/**\n * @public\n */\nexport class ClippingAttachment extends VertexAttachment implements IClippingAttachment {\n    type = AttachmentType.Clipping;\n    endSlot: SlotData;\n\n    // Nonessential.\n    color = new Color(0.2275, 0.2275, 0.8078, 1); // ce3a3aff\n\n    constructor(name: string) {\n        super(name);\n    }\n\n    copy(): Attachment {\n        const copy = new ClippingAttachment(this.name);\n\n        this.copyTo(copy);\n        copy.endSlot = this.endSlot;\n        copy.color.setFromColor(this.color);\n\n        return copy;\n    }\n}\n","import { Attachment, VertexAttachment } from './Attachment';\nimport { AttachmentType, Color, IMeshAttachment, TextureRegion, Utils } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class MeshAttachment extends VertexAttachment implements IMeshAttachment {\n    type = AttachmentType.Mesh;\n\n    region: TextureRegion;\n    path: string;\n    regionUVs: Float32Array;\n    triangles: Array<number>;\n    color = new Color(1, 1, 1, 1);\n    width: number;\n    height: number;\n    hullLength: number;\n    edges: Array<number>;\n    private parentMesh: MeshAttachment;\n    tempColor = new Color(0, 0, 0, 0);\n\n    constructor(name: string) {\n        super(name);\n    }\n\n    getParentMesh() {\n        return this.parentMesh;\n    }\n\n    /** @param parentMesh May be null. */\n    setParentMesh(parentMesh: MeshAttachment) {\n        this.parentMesh = parentMesh;\n        if (parentMesh != null) {\n            this.bones = parentMesh.bones;\n            this.vertices = parentMesh.vertices;\n            this.worldVerticesLength = parentMesh.worldVerticesLength;\n            this.regionUVs = parentMesh.regionUVs;\n            this.triangles = parentMesh.triangles;\n            this.hullLength = parentMesh.hullLength;\n            this.worldVerticesLength = parentMesh.worldVerticesLength;\n        }\n    }\n\n    copy(): Attachment {\n        if (this.parentMesh != null) return this.newLinkedMesh();\n\n        const copy = new MeshAttachment(this.name);\n\n        copy.region = this.region;\n        copy.path = this.path;\n        copy.color.setFromColor(this.color);\n\n        this.copyTo(copy);\n        copy.regionUVs = new Float32Array(this.regionUVs.length);\n        Utils.arrayCopy(this.regionUVs, 0, copy.regionUVs, 0, this.regionUVs.length);\n        copy.triangles = new Array<number>(this.triangles.length);\n        Utils.arrayCopy(this.triangles, 0, copy.triangles, 0, this.triangles.length);\n        copy.hullLength = this.hullLength;\n\n        // Nonessential.\n        if (this.edges != null) {\n            copy.edges = new Array<number>(this.edges.length);\n            Utils.arrayCopy(this.edges, 0, copy.edges, 0, this.edges.length);\n        }\n        copy.width = this.width;\n        copy.height = this.height;\n\n        return copy;\n    }\n\n    newLinkedMesh(): MeshAttachment {\n        const copy = new MeshAttachment(this.name);\n\n        copy.region = this.region;\n        copy.path = this.path;\n        copy.color.setFromColor(this.color);\n        copy.deformAttachment = this.deformAttachment;\n        copy.setParentMesh(this.parentMesh != null ? this.parentMesh : this);\n        // copy.updateUVs();\n\n        return copy;\n    }\n}\n","import { Attachment, VertexAttachment } from './Attachment';\nimport { AttachmentType, Color, Utils } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class PathAttachment extends VertexAttachment {\n    type = AttachmentType.Path;\n    lengths: Array<number>;\n    closed = false;\n    constantSpeed = false;\n    color = new Color(1, 1, 1, 1);\n\n    constructor(name: string) {\n        super(name);\n    }\n\n    copy(): Attachment {\n        const copy = new PathAttachment(this.name);\n\n        this.copyTo(copy);\n        copy.lengths = new Array<number>(this.lengths.length);\n        Utils.arrayCopy(this.lengths, 0, copy.lengths, 0, this.lengths.length);\n        copy.closed = closed;\n        copy.constantSpeed = this.constantSpeed;\n        copy.color.setFromColor(this.color);\n\n        return copy;\n    }\n}\n","import { Attachment, VertexAttachment } from './Attachment';\nimport { AttachmentType, Color, MathUtils, Vector2 } from '@pixi-spine/base';\nimport type { Bone } from '../Bone';\n\n/**\n * @public\n */\nexport class PointAttachment extends VertexAttachment {\n    type = AttachmentType.Point;\n    x: number;\n    y: number;\n    rotation: number;\n    color = new Color(0.38, 0.94, 0, 1);\n\n    constructor(name: string) {\n        super(name);\n    }\n\n    computeWorldPosition(bone: Bone, point: Vector2) {\n        const mat = bone.matrix;\n\n        point.x = this.x * mat.a + this.y * mat.c + bone.worldX;\n        point.y = this.x * mat.b + this.y * mat.d + bone.worldY;\n\n        return point;\n    }\n\n    computeWorldRotation(bone: Bone) {\n        const mat = bone.matrix;\n        const cos = MathUtils.cosDeg(this.rotation);\n        const sin = MathUtils.sinDeg(this.rotation);\n        const x = cos * mat.a + sin * mat.c;\n        const y = cos * mat.b + sin * mat.d;\n\n        return Math.atan2(y, x) * MathUtils.radDeg;\n    }\n\n    copy(): Attachment {\n        const copy = new PointAttachment(this.name);\n\n        copy.x = this.x;\n        copy.y = this.y;\n        copy.rotation = this.rotation;\n        copy.color.setFromColor(this.color);\n\n        return copy;\n    }\n}\n","import { Color, ISlot } from '@pixi-spine/base';\n\nimport type { Attachment } from './attachments/Attachment';\nimport type { Bone } from './Bone';\nimport type { SlotData } from './SlotData';\n\n/**\n * @public\n */\nexport class Slot implements ISlot {\n    // this is canon\n    blendMode: number;\n    data: SlotData;\n    bone: Bone;\n    color: Color;\n    darkColor: Color;\n    attachment: Attachment;\n    private attachmentTime: number;\n    attachmentState: number;\n    deform = new Array<number>();\n\n    constructor(data: SlotData, bone: Bone) {\n        if (data == null) throw new Error('data cannot be null.');\n        if (bone == null) throw new Error('bone cannot be null.');\n        this.data = data;\n        this.bone = bone;\n        this.color = new Color();\n        this.darkColor = data.darkColor == null ? null : new Color();\n        this.setToSetupPose();\n\n        this.blendMode = this.data.blendMode;\n    }\n\n    /** @return May be null. */\n    getAttachment(): Attachment {\n        return this.attachment;\n    }\n\n    /** Sets the attachment and if it changed, resets {@link #getAttachmentTime()} and clears {@link #getAttachmentVertices()}.\n     * @param attachment May be null. */\n    setAttachment(attachment: Attachment) {\n        if (this.attachment == attachment) return;\n        this.attachment = attachment;\n        this.attachmentTime = this.bone.skeleton.time;\n        this.deform.length = 0;\n    }\n\n    setAttachmentTime(time: number) {\n        this.attachmentTime = this.bone.skeleton.time - time;\n    }\n\n    /** Returns the time since the attachment was set. */\n    getAttachmentTime(): number {\n        return this.bone.skeleton.time - this.attachmentTime;\n    }\n\n    setToSetupPose() {\n        this.color.setFromColor(this.data.color);\n        if (this.darkColor != null) this.darkColor.setFromColor(this.data.darkColor);\n        if (this.data.attachmentName == null) this.attachment = null;\n        else {\n            this.attachment = null;\n            this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));\n        }\n    }\n}\n","import { Attachment } from './Attachment';\nimport { AttachmentType, ArrayLike, Color, TextureRegion, Utils, IRegionAttachment } from '@pixi-spine/base';\n\nimport type { Bone } from '../Bone';\nimport { Slot } from '../Slot';\n\n/**\n * @public\n */\nexport class RegionAttachment extends Attachment implements IRegionAttachment {\n    type = AttachmentType.Region;\n\n    static OX1 = 0;\n    static OY1 = 1;\n    static OX2 = 2;\n    static OY2 = 3;\n    static OX3 = 4;\n    static OY3 = 5;\n    static OX4 = 6;\n    static OY4 = 7;\n\n    static X1 = 0;\n    static Y1 = 1;\n    static C1R = 2;\n    static C1G = 3;\n    static C1B = 4;\n    static C1A = 5;\n    static U1 = 6;\n    static V1 = 7;\n\n    static X2 = 8;\n    static Y2 = 9;\n    static C2R = 10;\n    static C2G = 11;\n    static C2B = 12;\n    static C2A = 13;\n    static U2 = 14;\n    static V2 = 15;\n\n    static X3 = 16;\n    static Y3 = 17;\n    static C3R = 18;\n    static C3G = 19;\n    static C3B = 20;\n    static C3A = 21;\n    static U3 = 22;\n    static V3 = 23;\n\n    static X4 = 24;\n    static Y4 = 25;\n    static C4R = 26;\n    static C4G = 27;\n    static C4B = 28;\n    static C4A = 29;\n    static U4 = 30;\n    static V4 = 31;\n\n    x = 0;\n    y = 0;\n    scaleX = 1;\n    scaleY = 1;\n    rotation = 0;\n    width = 0;\n    height = 0;\n    color = new Color(1, 1, 1, 1);\n\n    path: string;\n    rendererObject: any;\n    region: TextureRegion;\n\n    offset = Utils.newFloatArray(8);\n    uvs = Utils.newFloatArray(8);\n\n    tempColor = new Color(1, 1, 1, 1);\n\n    constructor(name: string) {\n        super(name);\n    }\n\n    updateOffset(): void {\n        const regionScaleX = (this.width / this.region.originalWidth) * this.scaleX;\n        const regionScaleY = (this.height / this.region.originalHeight) * this.scaleY;\n        const localX = (-this.width / 2) * this.scaleX + this.region.offsetX * regionScaleX;\n        const localY = (-this.height / 2) * this.scaleY + this.region.offsetY * regionScaleY;\n        const localX2 = localX + this.region.width * regionScaleX;\n        const localY2 = localY + this.region.height * regionScaleY;\n        const radians = (this.rotation * Math.PI) / 180;\n        const cos = Math.cos(radians);\n        const sin = Math.sin(radians);\n        const localXCos = localX * cos + this.x;\n        const localXSin = localX * sin;\n        const localYCos = localY * cos + this.y;\n        const localYSin = localY * sin;\n        const localX2Cos = localX2 * cos + this.x;\n        const localX2Sin = localX2 * sin;\n        const localY2Cos = localY2 * cos + this.y;\n        const localY2Sin = localY2 * sin;\n        const offset = this.offset;\n\n        offset[RegionAttachment.OX1] = localXCos - localYSin;\n        offset[RegionAttachment.OY1] = localYCos + localXSin;\n        offset[RegionAttachment.OX2] = localXCos - localY2Sin;\n        offset[RegionAttachment.OY2] = localY2Cos + localXSin;\n        offset[RegionAttachment.OX3] = localX2Cos - localY2Sin;\n        offset[RegionAttachment.OY3] = localY2Cos + localX2Sin;\n        offset[RegionAttachment.OX4] = localX2Cos - localYSin;\n        offset[RegionAttachment.OY4] = localYCos + localX2Sin;\n    }\n\n    setRegion(region: TextureRegion): void {\n        this.region = region;\n        const uvs = this.uvs;\n\n        if (region.rotate) {\n            uvs[2] = region.u;\n            uvs[3] = region.v2;\n            uvs[4] = region.u;\n            uvs[5] = region.v;\n            uvs[6] = region.u2;\n            uvs[7] = region.v;\n            uvs[0] = region.u2;\n            uvs[1] = region.v2;\n        } else {\n            uvs[0] = region.u;\n            uvs[1] = region.v2;\n            uvs[2] = region.u;\n            uvs[3] = region.v;\n            uvs[4] = region.u2;\n            uvs[5] = region.v;\n            uvs[6] = region.u2;\n            uvs[7] = region.v2;\n        }\n    }\n\n    computeWorldVertices(bone: Bone | Slot, worldVertices: ArrayLike<number>, offset: number, stride: number) {\n        const vertexOffset = this.offset;\n        const mat = bone instanceof Slot ? bone.bone.matrix : bone.matrix;\n        const x = mat.tx;\n        const y = mat.ty;\n        const a = mat.a;\n        const b = mat.c;\n        const c = mat.b;\n        const d = mat.d;\n        let offsetX = 0;\n        let offsetY = 0;\n\n        offsetX = vertexOffset[RegionAttachment.OX1];\n        offsetY = vertexOffset[RegionAttachment.OY1];\n        worldVertices[offset] = offsetX * a + offsetY * b + x; // br\n        worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n        offset += stride;\n\n        offsetX = vertexOffset[RegionAttachment.OX2];\n        offsetY = vertexOffset[RegionAttachment.OY2];\n        worldVertices[offset] = offsetX * a + offsetY * b + x; // bl\n        worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n        offset += stride;\n\n        offsetX = vertexOffset[RegionAttachment.OX3];\n        offsetY = vertexOffset[RegionAttachment.OY3];\n        worldVertices[offset] = offsetX * a + offsetY * b + x; // ul\n        worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n        offset += stride;\n\n        offsetX = vertexOffset[RegionAttachment.OX4];\n        offsetY = vertexOffset[RegionAttachment.OY4];\n        worldVertices[offset] = offsetX * a + offsetY * b + x; // ur\n        worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n    }\n\n    copy(): Attachment {\n        const copy = new RegionAttachment(this.name);\n\n        copy.region = this.region;\n        copy.rendererObject = this.rendererObject;\n        copy.path = this.path;\n        copy.x = this.x;\n        copy.y = this.y;\n        copy.scaleX = this.scaleX;\n        copy.scaleY = this.scaleY;\n        copy.rotation = this.rotation;\n        copy.width = this.width;\n        copy.height = this.height;\n        Utils.arrayCopy(this.uvs, 0, copy.uvs, 0, 8);\n        Utils.arrayCopy(this.offset, 0, copy.offset, 0, 8);\n        copy.color.setFromColor(this.color);\n\n        return copy;\n    }\n}\n","import type { VertexEffect } from '../VertexEffect';\nimport type { Skeleton } from '../Skeleton';\nimport { Color, MathUtils, Vector2 } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class JitterEffect implements VertexEffect {\n    jitterX = 0;\n    jitterY = 0;\n\n    constructor(jitterX: number, jitterY: number) {\n        this.jitterX = jitterX;\n        this.jitterY = jitterY;\n    }\n\n    begin(skeleton: Skeleton): void {}\n\n    transform(position: Vector2, uv: Vector2, light: Color, dark: Color): void {\n        position.x += MathUtils.randomTriangular(-this.jitterX, this.jitterY);\n        position.y += MathUtils.randomTriangular(-this.jitterX, this.jitterY);\n    }\n\n    end(): void {}\n}\n","import type { VertexEffect } from '../VertexEffect';\nimport type { Skeleton } from '../Skeleton';\nimport { Color, MathUtils, PowOut, Vector2 } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class SwirlEffect implements VertexEffect {\n    static interpolation = new PowOut(2);\n    centerX = 0;\n    centerY = 0;\n    radius = 0;\n    angle = 0;\n    private worldX = 0;\n    private worldY = 0;\n\n    constructor(radius: number) {\n        this.radius = radius;\n    }\n\n    begin(skeleton: Skeleton): void {\n        this.worldX = skeleton.x + this.centerX;\n        this.worldY = skeleton.y + this.centerY;\n    }\n\n    transform(position: Vector2, uv: Vector2, light: Color, dark: Color): void {\n        const radAngle = this.angle * MathUtils.degreesToRadians;\n        const x = position.x - this.worldX;\n        const y = position.y - this.worldY;\n        const dist = Math.sqrt(x * x + y * y);\n\n        if (dist < this.radius) {\n            const theta = SwirlEffect.interpolation.apply(0, radAngle, (this.radius - dist) / this.radius);\n            const cos = Math.cos(theta);\n            const sin = Math.sin(theta);\n\n            position.x = cos * x - sin * y + this.worldX;\n            position.y = sin * x + cos * y + this.worldY;\n        }\n    }\n\n    end(): void {}\n}\n","import type { Event } from './Event';\r\nimport type { Skeleton } from './Skeleton';\r\nimport { Attachment, VertexAttachment } from './attachments';\r\nimport { ArrayLike, MathUtils, Utils, MixBlend, MixDirection } from '@pixi-spine/base';\r\nimport type { Slot } from './Slot';\r\nimport type { IkConstraint } from './IkConstraint';\r\nimport type { TransformConstraint } from './TransformConstraint';\r\nimport type { PathConstraint } from './PathConstraint';\r\n/** A simple container for a list of timelines and a name. */\r\n/**\r\n * @public\r\n */\r\nexport class Animation {\r\n    /** The animation's name, which is unique across all animations in the skeleton. */\r\n    name: string;\r\n    timelines: Array<Timeline>;\r\n    timelineIds: Array<boolean>;\r\n\r\n    /** The duration of the animation in seconds, which is the highest time of all keys in the timeline. */\r\n    duration: number;\r\n\r\n    constructor(name: string, timelines: Array<Timeline>, duration: number) {\r\n        if (name == null) throw new Error('name cannot be null.');\r\n        if (timelines == null) throw new Error('timelines cannot be null.');\r\n        this.name = name;\r\n        this.timelines = timelines;\r\n        this.timelineIds = [];\r\n        for (let i = 0; i < timelines.length; i++) this.timelineIds[timelines[i].getPropertyId()] = true;\r\n        this.duration = duration;\r\n    }\r\n\r\n    hasTimeline(id: number) {\r\n        return this.timelineIds[id] == true;\r\n    }\r\n\r\n    /** Applies all the animation's timelines to the specified skeleton.\r\n     *\r\n     * See Timeline {@link Timeline#apply(Skeleton, float, float, Array, float, MixBlend, MixDirection)}.\r\n     * @param loop If true, the animation repeats after {@link #getDuration()}.\r\n     * @param events May be null to ignore fired events. */\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, loop: boolean, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        if (skeleton == null) throw new Error('skeleton cannot be null.');\r\n\r\n        if (loop && this.duration != 0) {\r\n            time %= this.duration;\r\n            if (lastTime > 0) lastTime %= this.duration;\r\n        }\r\n\r\n        const timelines = this.timelines;\r\n\r\n        for (let i = 0, n = timelines.length; i < n; i++) timelines[i].apply(skeleton, lastTime, time, events, alpha, blend, direction);\r\n    }\r\n\r\n    /** @param target After the first and before the last value.\r\n     * @returns index of first value greater than the target. */\r\n    static binarySearch(values: ArrayLike<number>, target: number, step = 1) {\r\n        let low = 0;\r\n        let high = values.length / step - 2;\r\n\r\n        if (high == 0) return step;\r\n        let current = high >>> 1;\r\n\r\n        while (true) {\r\n            if (values[(current + 1) * step] <= target) low = current + 1;\r\n            else high = current;\r\n            if (low == high) return (low + 1) * step;\r\n            current = (low + high) >>> 1;\r\n        }\r\n    }\r\n\r\n    static linearSearch(values: ArrayLike<number>, target: number, step: number) {\r\n        for (let i = 0, last = values.length - step; i <= last; i += step) if (values[i] > target) return i;\r\n\r\n        return -1;\r\n    }\r\n}\r\n\r\n/** The interface for all timelines. */\r\n/**\r\n * @public\r\n */\r\nexport interface Timeline {\r\n    /** Applies this timeline to the skeleton.\r\n     * @param skeleton The skeleton the timeline is being applied to. This provides access to the bones, slots, and other\r\n     *           skeleton components the timeline may change.\r\n     * @param lastTime The time this timeline was last applied. Timelines such as {@link EventTimeline}} trigger only at specific\r\n     *           times rather than every frame. In that case, the timeline triggers everything between `lastTime`\r\n     *           (exclusive) and `time` (inclusive).\r\n     * @param time The time within the animation. Most timelines find the key before and the key after this time so they can\r\n     *           interpolate between the keys.\r\n     * @param events If any events are fired, they are added to this list. Can be null to ignore fired events or if the timeline\r\n     *           does not fire events.\r\n     * @param alpha 0 applies the current or setup value (depending on `blend`). 1 applies the timeline value.\r\n     *           Between 0 and 1 applies a value between the current or setup value and the timeline value. By adjusting\r\n     *           `alpha` over time, an animation can be mixed in or out. `alpha` can also be useful to\r\n     *           apply animations on top of each other (layering).\r\n     * @param blend Controls how mixing is applied when `alpha` < 1.\r\n     * @param direction Indicates whether the timeline is mixing in or out. Used by timelines which perform instant transitions,\r\n     *           such as {@link DrawOrderTimeline} or {@link AttachmentTimeline}. */\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection): void;\r\n\r\n    /** Uniquely encodes both the type of this timeline and the skeleton property that it affects. */\r\n    getPropertyId(): number;\r\n}\r\n\r\n/** Controls how a timeline value is mixed with the setup pose value or current pose value when a timeline's `alpha`\r\n * < 1.\r\n *\r\n * See Timeline {@link Timeline#apply(Skeleton, float, float, Array, float, MixBlend, MixDirection)}. */\r\n\r\n/**\r\n * @public\r\n */\r\nexport enum TimelineType {\r\n    rotate,\r\n    translate,\r\n    scale,\r\n    shear,\r\n    attachment,\r\n    color,\r\n    deform,\r\n    event,\r\n    drawOrder,\r\n    ikConstraint,\r\n    transformConstraint,\r\n    pathConstraintPosition,\r\n    pathConstraintSpacing,\r\n    pathConstraintMix,\r\n    twoColor,\r\n}\r\n\r\n/** The base class for timelines that use interpolation between key frame values. */\r\n/**\r\n * @public\r\n */\r\nexport abstract class CurveTimeline implements Timeline {\r\n    static LINEAR = 0;\r\n    static STEPPED = 1;\r\n    static BEZIER = 2;\r\n    static BEZIER_SIZE = 10 * 2 - 1;\r\n    curveData: { frameIndex: number; cx1: number; cy1: number; cx2: number; cy2: number }[] = [];\r\n\r\n    private curves: ArrayLike<number>; // type, x, y, ...\r\n\r\n    abstract getPropertyId(): number;\r\n\r\n    constructor(frameCount: number) {\r\n        if (frameCount <= 0) throw new Error(`frameCount must be > 0: ${frameCount}`);\r\n        this.curves = Utils.newFloatArray((frameCount - 1) * CurveTimeline.BEZIER_SIZE);\r\n    }\r\n\r\n    /** The number of key frames for this timeline. */\r\n    getFrameCount() {\r\n        return this.curves.length / CurveTimeline.BEZIER_SIZE + 1;\r\n    }\r\n\r\n    /** Sets the specified key frame to linear interpolation. */\r\n    setLinear(frameIndex: number) {\r\n        this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.LINEAR;\r\n    }\r\n\r\n    /** Sets the specified key frame to stepped interpolation. */\r\n    setStepped(frameIndex: number) {\r\n        this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.STEPPED;\r\n    }\r\n\r\n    /** Returns the interpolation type for the specified key frame.\r\n     * @returns Linear is 0, stepped is 1, Bezier is 2. */\r\n    getCurveType(frameIndex: number): number {\r\n        const index = frameIndex * CurveTimeline.BEZIER_SIZE;\r\n\r\n        if (index == this.curves.length) return CurveTimeline.LINEAR;\r\n        const type = this.curves[index];\r\n\r\n        if (type == CurveTimeline.LINEAR) return CurveTimeline.LINEAR;\r\n        if (type == CurveTimeline.STEPPED) return CurveTimeline.STEPPED;\r\n\r\n        return CurveTimeline.BEZIER;\r\n    }\r\n\r\n    /** Sets the specified key frame to Bezier interpolation. `cx1` and `cx2` are from 0 to 1,\r\n     * representing the percent of time between the two key frames. `cy1` and `cy2` are the percent of the\r\n     * difference between the key frame's values. */\r\n    setCurve(frameIndex: number, cx1: number, cy1: number, cx2: number, cy2: number) {\r\n        this.curveData.push({ frameIndex, cx1, cy1, cx2, cy2 });\r\n        const tmpx = (-cx1 * 2 + cx2) * 0.03;\r\n        const tmpy = (-cy1 * 2 + cy2) * 0.03;\r\n        const dddfx = ((cx1 - cx2) * 3 + 1) * 0.006;\r\n        const dddfy = ((cy1 - cy2) * 3 + 1) * 0.006;\r\n        let ddfx = tmpx * 2 + dddfx;\r\n        let ddfy = tmpy * 2 + dddfy;\r\n        let dfx = cx1 * 0.3 + tmpx + dddfx * 0.16666667;\r\n        let dfy = cy1 * 0.3 + tmpy + dddfy * 0.16666667;\r\n\r\n        let i = frameIndex * CurveTimeline.BEZIER_SIZE;\r\n        const curves = this.curves;\r\n\r\n        curves[i++] = CurveTimeline.BEZIER;\r\n\r\n        let x = dfx;\r\n        let y = dfy;\r\n\r\n        for (let n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\r\n            curves[i] = x;\r\n            curves[i + 1] = y;\r\n            dfx += ddfx;\r\n            dfy += ddfy;\r\n            ddfx += dddfx;\r\n            ddfy += dddfy;\r\n            x += dfx;\r\n            y += dfy;\r\n        }\r\n    }\r\n\r\n    /** Returns the interpolated percentage for the specified key frame and linear percentage. */\r\n    getCurvePercent(frameIndex: number, percent: number) {\r\n        percent = MathUtils.clamp(percent, 0, 1);\r\n        const curves = this.curves;\r\n        let i = frameIndex * CurveTimeline.BEZIER_SIZE;\r\n        const type = curves[i];\r\n\r\n        if (type == CurveTimeline.LINEAR) return percent;\r\n        if (type == CurveTimeline.STEPPED) return 0;\r\n        i++;\r\n        let x = 0;\r\n\r\n        for (let start = i, n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\r\n            x = curves[i];\r\n            if (x >= percent) {\r\n                let prevX: number;\r\n                let prevY: number;\r\n\r\n                if (i == start) {\r\n                    prevX = 0;\r\n                    prevY = 0;\r\n                } else {\r\n                    prevX = curves[i - 2];\r\n                    prevY = curves[i - 1];\r\n                }\r\n\r\n                return prevY + ((curves[i + 1] - prevY) * (percent - prevX)) / (x - prevX);\r\n            }\r\n        }\r\n        const y = curves[i - 1];\r\n\r\n        return y + ((1 - y) * (percent - x)) / (1 - x); // Last point is 1,1.\r\n    }\r\n\r\n    abstract apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection): void;\r\n}\r\n\r\n/** Changes a bone's local {@link Bone#rotation}. */\r\n/**\r\n * @public\r\n */\r\nexport class RotateTimeline extends CurveTimeline {\r\n    static ENTRIES = 2;\r\n    static PREV_TIME = -2;\r\n    static PREV_ROTATION = -1;\r\n    static ROTATION = 1;\r\n\r\n    data: { frameIndex: number; time: number; degrees: number }[] = [];\r\n\r\n    /** The index of the bone in {@link Skeleton#bones} that will be changed. */\r\n    boneIndex: number;\r\n\r\n    /** The time in seconds and rotation in degrees for each key frame. */\r\n    frames: ArrayLike<number>; // time, degrees, ...\r\n\r\n    constructor(frameCount: number) {\r\n        super(frameCount);\r\n        this.frames = Utils.newFloatArray(frameCount << 1);\r\n    }\r\n\r\n    getPropertyId() {\r\n        return (TimelineType.rotate << 24) + this.boneIndex;\r\n    }\r\n\r\n    /** Sets the time and angle of the specified keyframe. */\r\n    setFrame(frameIndex: number, time: number, degrees: number) {\r\n        this.data.push({ frameIndex, time, degrees });\r\n        frameIndex <<= 1;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + RotateTimeline.ROTATION] = degrees;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const frames = this.frames;\r\n\r\n        const bone = skeleton.bones[this.boneIndex];\r\n\r\n        if (!bone.active) return;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.rotation = bone.data.rotation;\r\n\r\n                    return;\r\n                case MixBlend.first:\r\n                    const r = bone.data.rotation - bone.rotation;\r\n\r\n                    bone.rotation += (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * alpha;\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        if (time >= frames[frames.length - RotateTimeline.ENTRIES]) {\r\n            // Time is after last frame.\r\n            let r = frames[frames.length + RotateTimeline.PREV_ROTATION];\r\n\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.rotation = bone.data.rotation + r * alpha;\r\n                    break;\r\n                case MixBlend.first:\r\n                case MixBlend.replace:\r\n                    r += bone.data.rotation - bone.rotation;\r\n                    r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360; // Wrap within -180 and 180.\r\n                case MixBlend.add:\r\n                    bone.rotation += r * alpha;\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        const frame = Animation.binarySearch(frames, time, RotateTimeline.ENTRIES);\r\n        const prevRotation = frames[frame + RotateTimeline.PREV_ROTATION];\r\n        const frameTime = frames[frame];\r\n        const percent = this.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + RotateTimeline.PREV_TIME] - frameTime));\r\n\r\n        let r = frames[frame + RotateTimeline.ROTATION] - prevRotation;\r\n\r\n        r = prevRotation + (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * percent;\r\n        switch (blend) {\r\n            case MixBlend.setup:\r\n                bone.rotation = bone.data.rotation + (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * alpha;\r\n                break;\r\n            case MixBlend.first:\r\n            case MixBlend.replace:\r\n                r += bone.data.rotation - bone.rotation;\r\n            case MixBlend.add:\r\n                bone.rotation += (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a bone's local {@link Bone#x} and {@link Bone#y}. */\r\n/**\r\n * @public\r\n */\r\nexport class TranslateTimeline extends CurveTimeline {\r\n    static ENTRIES = 3;\r\n    static PREV_TIME = -3;\r\n    static PREV_X = -2;\r\n    static PREV_Y = -1;\r\n    static X = 1;\r\n    static Y = 2;\r\n\r\n    data: { frameIndex: number; time: number; x: number; y: number }[] = [];\r\n\r\n    /** The index of the bone in {@link Skeleton#bones} that will be changed. */\r\n    boneIndex: number;\r\n\r\n    /** The time in seconds, x, and y values for each key frame. */\r\n    frames: ArrayLike<number>; // time, x, y, ...\r\n\r\n    constructor(frameCount: number) {\r\n        super(frameCount);\r\n        this.frames = Utils.newFloatArray(frameCount * TranslateTimeline.ENTRIES);\r\n    }\r\n\r\n    getPropertyId() {\r\n        return (TimelineType.translate << 24) + this.boneIndex;\r\n    }\r\n\r\n    /** Sets the time in seconds, x, and y values for the specified key frame. */\r\n    setFrame(frameIndex: number, time: number, x: number, y: number) {\r\n        this.data.push({ frameIndex, time, x, y });\r\n        frameIndex *= TranslateTimeline.ENTRIES;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + TranslateTimeline.X] = x;\r\n        this.frames[frameIndex + TranslateTimeline.Y] = y;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const frames = this.frames;\r\n\r\n        const bone = skeleton.bones[this.boneIndex];\r\n\r\n        if (!bone.active) return;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.x = bone.data.x;\r\n                    bone.y = bone.data.y;\r\n\r\n                    return;\r\n                case MixBlend.first:\r\n                    bone.x += (bone.data.x - bone.x) * alpha;\r\n                    bone.y += (bone.data.y - bone.y) * alpha;\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        let x = 0;\r\n        let y = 0;\r\n\r\n        if (time >= frames[frames.length - TranslateTimeline.ENTRIES]) {\r\n            // Time is after last frame.\r\n            x = frames[frames.length + TranslateTimeline.PREV_X];\r\n            y = frames[frames.length + TranslateTimeline.PREV_Y];\r\n        } else {\r\n            // Interpolate between the previous frame and the current frame.\r\n            const frame = Animation.binarySearch(frames, time, TranslateTimeline.ENTRIES);\r\n\r\n            x = frames[frame + TranslateTimeline.PREV_X];\r\n            y = frames[frame + TranslateTimeline.PREV_Y];\r\n            const frameTime = frames[frame];\r\n            const percent = this.getCurvePercent(frame / TranslateTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TranslateTimeline.PREV_TIME] - frameTime));\r\n\r\n            x += (frames[frame + TranslateTimeline.X] - x) * percent;\r\n            y += (frames[frame + TranslateTimeline.Y] - y) * percent;\r\n        }\r\n        switch (blend) {\r\n            case MixBlend.setup:\r\n                bone.x = bone.data.x + x * alpha;\r\n                bone.y = bone.data.y + y * alpha;\r\n                break;\r\n            case MixBlend.first:\r\n            case MixBlend.replace:\r\n                bone.x += (bone.data.x + x - bone.x) * alpha;\r\n                bone.y += (bone.data.y + y - bone.y) * alpha;\r\n                break;\r\n            case MixBlend.add:\r\n                bone.x += x * alpha;\r\n                bone.y += y * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a bone's local {@link Bone#scaleX)} and {@link Bone#scaleY}. */\r\n/**\r\n * @public\r\n */\r\nexport class ScaleTimeline extends TranslateTimeline {\r\n    constructor(frameCount: number) {\r\n        super(frameCount);\r\n    }\r\n\r\n    getPropertyId() {\r\n        return (TimelineType.scale << 24) + this.boneIndex;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const frames = this.frames;\r\n\r\n        const bone = skeleton.bones[this.boneIndex];\r\n\r\n        if (!bone.active) return;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.scaleX = bone.data.scaleX;\r\n                    bone.scaleY = bone.data.scaleY;\r\n\r\n                    return;\r\n                case MixBlend.first:\r\n                    bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;\r\n                    bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        let x = 0;\r\n        let y = 0;\r\n\r\n        if (time >= frames[frames.length - ScaleTimeline.ENTRIES]) {\r\n            // Time is after last frame.\r\n            x = frames[frames.length + ScaleTimeline.PREV_X] * bone.data.scaleX;\r\n            y = frames[frames.length + ScaleTimeline.PREV_Y] * bone.data.scaleY;\r\n        } else {\r\n            // Interpolate between the previous frame and the current frame.\r\n            const frame = Animation.binarySearch(frames, time, ScaleTimeline.ENTRIES);\r\n\r\n            x = frames[frame + ScaleTimeline.PREV_X];\r\n            y = frames[frame + ScaleTimeline.PREV_Y];\r\n            const frameTime = frames[frame];\r\n            const percent = this.getCurvePercent(frame / ScaleTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ScaleTimeline.PREV_TIME] - frameTime));\r\n\r\n            x = (x + (frames[frame + ScaleTimeline.X] - x) * percent) * bone.data.scaleX;\r\n            y = (y + (frames[frame + ScaleTimeline.Y] - y) * percent) * bone.data.scaleY;\r\n        }\r\n        if (alpha == 1) {\r\n            if (blend == MixBlend.add) {\r\n                bone.scaleX += x - bone.data.scaleX;\r\n                bone.scaleY += y - bone.data.scaleY;\r\n            } else {\r\n                bone.scaleX = x;\r\n                bone.scaleY = y;\r\n            }\r\n        } else {\r\n            let bx = 0;\r\n            let by = 0;\r\n\r\n            if (direction == MixDirection.mixOut) {\r\n                switch (blend) {\r\n                    case MixBlend.setup:\r\n                        bx = bone.data.scaleX;\r\n                        by = bone.data.scaleY;\r\n                        bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\r\n                        bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\r\n                        break;\r\n                    case MixBlend.first:\r\n                    case MixBlend.replace:\r\n                        bx = bone.scaleX;\r\n                        by = bone.scaleY;\r\n                        bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\r\n                        bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\r\n                        break;\r\n                    case MixBlend.add:\r\n                        bx = bone.scaleX;\r\n                        by = bone.scaleY;\r\n                        bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bone.data.scaleX) * alpha;\r\n                        bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - bone.data.scaleY) * alpha;\r\n                }\r\n            } else {\r\n                switch (blend) {\r\n                    case MixBlend.setup:\r\n                        bx = Math.abs(bone.data.scaleX) * MathUtils.signum(x);\r\n                        by = Math.abs(bone.data.scaleY) * MathUtils.signum(y);\r\n                        bone.scaleX = bx + (x - bx) * alpha;\r\n                        bone.scaleY = by + (y - by) * alpha;\r\n                        break;\r\n                    case MixBlend.first:\r\n                    case MixBlend.replace:\r\n                        bx = Math.abs(bone.scaleX) * MathUtils.signum(x);\r\n                        by = Math.abs(bone.scaleY) * MathUtils.signum(y);\r\n                        bone.scaleX = bx + (x - bx) * alpha;\r\n                        bone.scaleY = by + (y - by) * alpha;\r\n                        break;\r\n                    case MixBlend.add:\r\n                        bx = MathUtils.signum(x);\r\n                        by = MathUtils.signum(y);\r\n                        bone.scaleX = Math.abs(bone.scaleX) * bx + (x - Math.abs(bone.data.scaleX) * bx) * alpha;\r\n                        bone.scaleY = Math.abs(bone.scaleY) * by + (y - Math.abs(bone.data.scaleY) * by) * alpha;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a bone's local {@link Bone#shearX} and {@link Bone#shearY}. */\r\n/**\r\n * @public\r\n */\r\nexport class ShearTimeline extends TranslateTimeline {\r\n    constructor(frameCount: number) {\r\n        super(frameCount);\r\n    }\r\n\r\n    getPropertyId() {\r\n        return (TimelineType.shear << 24) + this.boneIndex;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const frames = this.frames;\r\n\r\n        const bone = skeleton.bones[this.boneIndex];\r\n\r\n        if (!bone.active) return;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.shearX = bone.data.shearX;\r\n                    bone.shearY = bone.data.shearY;\r\n\r\n                    return;\r\n                case MixBlend.first:\r\n                    bone.shearX += (bone.data.shearX - bone.shearX) * alpha;\r\n                    bone.shearY += (bone.data.shearY - bone.shearY) * alpha;\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        let x = 0;\r\n        let y = 0;\r\n\r\n        if (time >= frames[frames.length - ShearTimeline.ENTRIES]) {\r\n            // Time is after last frame.\r\n            x = frames[frames.length + ShearTimeline.PREV_X];\r\n            y = frames[frames.length + ShearTimeline.PREV_Y];\r\n        } else {\r\n            // Interpolate between the previous frame and the current frame.\r\n            const frame = Animation.binarySearch(frames, time, ShearTimeline.ENTRIES);\r\n\r\n            x = frames[frame + ShearTimeline.PREV_X];\r\n            y = frames[frame + ShearTimeline.PREV_Y];\r\n            const frameTime = frames[frame];\r\n            const percent = this.getCurvePercent(frame / ShearTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ShearTimeline.PREV_TIME] - frameTime));\r\n\r\n            x = x + (frames[frame + ShearTimeline.X] - x) * percent;\r\n            y = y + (frames[frame + ShearTimeline.Y] - y) * percent;\r\n        }\r\n        switch (blend) {\r\n            case MixBlend.setup:\r\n                bone.shearX = bone.data.shearX + x * alpha;\r\n                bone.shearY = bone.data.shearY + y * alpha;\r\n                break;\r\n            case MixBlend.first:\r\n            case MixBlend.replace:\r\n                bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;\r\n                bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;\r\n                break;\r\n            case MixBlend.add:\r\n                bone.shearX += x * alpha;\r\n                bone.shearY += y * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a slot's {@link Slot#color}. */\r\n/**\r\n * @public\r\n */\r\nexport class ColorTimeline extends CurveTimeline {\r\n    static ENTRIES = 5;\r\n    static PREV_TIME = -5;\r\n    static PREV_R = -4;\r\n    static PREV_G = -3;\r\n    static PREV_B = -2;\r\n    static PREV_A = -1;\r\n    static R = 1;\r\n    static G = 2;\r\n    static B = 3;\r\n    static A = 4;\r\n\r\n    /** The index of the slot in {@link Skeleton#slots} that will be changed. */\r\n    slotIndex: number;\r\n\r\n    /** The time in seconds, red, green, blue, and alpha values for each key frame. */\r\n    frames: ArrayLike<number>; // time, r, g, b, a, ...\r\n\r\n    data: { frameIndex: number; time: number; r: number; g: number; b: number; a: number }[] = [];\r\n\r\n    constructor(frameCount: number) {\r\n        super(frameCount);\r\n        this.frames = Utils.newFloatArray(frameCount * ColorTimeline.ENTRIES);\r\n    }\r\n\r\n    getPropertyId() {\r\n        return (TimelineType.color << 24) + this.slotIndex;\r\n    }\r\n\r\n    /** Sets the time in seconds, red, green, blue, and alpha for the specified key frame. */\r\n    setFrame(frameIndex: number, time: number, r: number, g: number, b: number, a: number) {\r\n        this.data.push({ frameIndex, time, r, g, b, a });\r\n        frameIndex *= ColorTimeline.ENTRIES;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + ColorTimeline.R] = r;\r\n        this.frames[frameIndex + ColorTimeline.G] = g;\r\n        this.frames[frameIndex + ColorTimeline.B] = b;\r\n        this.frames[frameIndex + ColorTimeline.A] = a;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const slot = skeleton.slots[this.slotIndex];\r\n\r\n        if (!slot.bone.active) return;\r\n        const frames = this.frames;\r\n\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    slot.color.setFromColor(slot.data.color);\r\n\r\n                    return;\r\n                case MixBlend.first:\r\n                    const color = slot.color;\r\n                    const setup = slot.data.color;\r\n\r\n                    color.add((setup.r - color.r) * alpha, (setup.g - color.g) * alpha, (setup.b - color.b) * alpha, (setup.a - color.a) * alpha);\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        let r = 0;\r\n        let g = 0;\r\n        let b = 0;\r\n        let a = 0;\r\n\r\n        if (time >= frames[frames.length - ColorTimeline.ENTRIES]) {\r\n            // Time is after last frame.\r\n            const i = frames.length;\r\n\r\n            r = frames[i + ColorTimeline.PREV_R];\r\n            g = frames[i + ColorTimeline.PREV_G];\r\n            b = frames[i + ColorTimeline.PREV_B];\r\n            a = frames[i + ColorTimeline.PREV_A];\r\n        } else {\r\n            // Interpolate between the previous frame and the current frame.\r\n            const frame = Animation.binarySearch(frames, time, ColorTimeline.ENTRIES);\r\n\r\n            r = frames[frame + ColorTimeline.PREV_R];\r\n            g = frames[frame + ColorTimeline.PREV_G];\r\n            b = frames[frame + ColorTimeline.PREV_B];\r\n            a = frames[frame + ColorTimeline.PREV_A];\r\n            const frameTime = frames[frame];\r\n            const percent = this.getCurvePercent(frame / ColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ColorTimeline.PREV_TIME] - frameTime));\r\n\r\n            r += (frames[frame + ColorTimeline.R] - r) * percent;\r\n            g += (frames[frame + ColorTimeline.G] - g) * percent;\r\n            b += (frames[frame + ColorTimeline.B] - b) * percent;\r\n            a += (frames[frame + ColorTimeline.A] - a) * percent;\r\n        }\r\n        if (alpha == 1) slot.color.set(r, g, b, a);\r\n        else {\r\n            const color = slot.color;\r\n\r\n            if (blend == MixBlend.setup) color.setFromColor(slot.data.color);\r\n            color.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a slot's {@link Slot#color} and {@link Slot#darkColor} for two color tinting. */\r\n/**\r\n * @public\r\n */\r\nexport class TwoColorTimeline extends CurveTimeline {\r\n    static ENTRIES = 8;\r\n    static PREV_TIME = -8;\r\n    static PREV_R = -7;\r\n    static PREV_G = -6;\r\n    static PREV_B = -5;\r\n    static PREV_A = -4;\r\n    static PREV_R2 = -3;\r\n    static PREV_G2 = -2;\r\n    static PREV_B2 = -1;\r\n    static R = 1;\r\n    static G = 2;\r\n    static B = 3;\r\n    static A = 4;\r\n    static R2 = 5;\r\n    static G2 = 6;\r\n    static B2 = 7;\r\n\r\n    /** The index of the slot in {@link Skeleton#slots()} that will be changed. The {@link Slot#darkColor()} must not be\r\n     * null. */\r\n    slotIndex: number;\r\n\r\n    /** The time in seconds, red, green, blue, and alpha values of the color, red, green, blue of the dark color, for each key frame. */\r\n    frames: ArrayLike<number>; // time, r, g, b, a, r2, g2, b2, ...\r\n\r\n    data: { frameIndex: number; time: number; r: number; g: number; b: number; a: number; r2: number; g2: number; b2: number }[] = [];\r\n    constructor(frameCount: number) {\r\n        super(frameCount);\r\n        this.frames = Utils.newFloatArray(frameCount * TwoColorTimeline.ENTRIES);\r\n    }\r\n\r\n    getPropertyId() {\r\n        return (TimelineType.twoColor << 24) + this.slotIndex;\r\n    }\r\n\r\n    /** Sets the time in seconds, light, and dark colors for the specified key frame. */\r\n    setFrame(frameIndex: number, time: number, r: number, g: number, b: number, a: number, r2: number, g2: number, b2: number) {\r\n        this.data.push({ frameIndex, time, r, g, b, a, r2, g2, b2 });\r\n        frameIndex *= TwoColorTimeline.ENTRIES;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + TwoColorTimeline.R] = r;\r\n        this.frames[frameIndex + TwoColorTimeline.G] = g;\r\n        this.frames[frameIndex + TwoColorTimeline.B] = b;\r\n        this.frames[frameIndex + TwoColorTimeline.A] = a;\r\n        this.frames[frameIndex + TwoColorTimeline.R2] = r2;\r\n        this.frames[frameIndex + TwoColorTimeline.G2] = g2;\r\n        this.frames[frameIndex + TwoColorTimeline.B2] = b2;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const slot = skeleton.slots[this.slotIndex];\r\n\r\n        if (!slot.bone.active) return;\r\n        const frames = this.frames;\r\n\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    slot.color.setFromColor(slot.data.color);\r\n                    slot.darkColor.setFromColor(slot.data.darkColor);\r\n\r\n                    return;\r\n                case MixBlend.first:\r\n                    const light = slot.color;\r\n                    const dark = slot.darkColor;\r\n                    const setupLight = slot.data.color;\r\n                    const setupDark = slot.data.darkColor;\r\n\r\n                    light.add((setupLight.r - light.r) * alpha, (setupLight.g - light.g) * alpha, (setupLight.b - light.b) * alpha, (setupLight.a - light.a) * alpha);\r\n                    dark.add((setupDark.r - dark.r) * alpha, (setupDark.g - dark.g) * alpha, (setupDark.b - dark.b) * alpha, 0);\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        let r = 0;\r\n        let g = 0;\r\n        let b = 0;\r\n        let a = 0;\r\n        let r2 = 0;\r\n        let g2 = 0;\r\n        let b2 = 0;\r\n\r\n        if (time >= frames[frames.length - TwoColorTimeline.ENTRIES]) {\r\n            // Time is after last frame.\r\n            const i = frames.length;\r\n\r\n            r = frames[i + TwoColorTimeline.PREV_R];\r\n            g = frames[i + TwoColorTimeline.PREV_G];\r\n            b = frames[i + TwoColorTimeline.PREV_B];\r\n            a = frames[i + TwoColorTimeline.PREV_A];\r\n            r2 = frames[i + TwoColorTimeline.PREV_R2];\r\n            g2 = frames[i + TwoColorTimeline.PREV_G2];\r\n            b2 = frames[i + TwoColorTimeline.PREV_B2];\r\n        } else {\r\n            // Interpolate between the previous frame and the current frame.\r\n            const frame = Animation.binarySearch(frames, time, TwoColorTimeline.ENTRIES);\r\n\r\n            r = frames[frame + TwoColorTimeline.PREV_R];\r\n            g = frames[frame + TwoColorTimeline.PREV_G];\r\n            b = frames[frame + TwoColorTimeline.PREV_B];\r\n            a = frames[frame + TwoColorTimeline.PREV_A];\r\n            r2 = frames[frame + TwoColorTimeline.PREV_R2];\r\n            g2 = frames[frame + TwoColorTimeline.PREV_G2];\r\n            b2 = frames[frame + TwoColorTimeline.PREV_B2];\r\n            const frameTime = frames[frame];\r\n            const percent = this.getCurvePercent(frame / TwoColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TwoColorTimeline.PREV_TIME] - frameTime));\r\n\r\n            r += (frames[frame + TwoColorTimeline.R] - r) * percent;\r\n            g += (frames[frame + TwoColorTimeline.G] - g) * percent;\r\n            b += (frames[frame + TwoColorTimeline.B] - b) * percent;\r\n            a += (frames[frame + TwoColorTimeline.A] - a) * percent;\r\n            r2 += (frames[frame + TwoColorTimeline.R2] - r2) * percent;\r\n            g2 += (frames[frame + TwoColorTimeline.G2] - g2) * percent;\r\n            b2 += (frames[frame + TwoColorTimeline.B2] - b2) * percent;\r\n        }\r\n        if (alpha == 1) {\r\n            slot.color.set(r, g, b, a);\r\n            slot.darkColor.set(r2, g2, b2, 1);\r\n        } else {\r\n            const light = slot.color;\r\n            const dark = slot.darkColor;\r\n\r\n            if (blend == MixBlend.setup) {\r\n                light.setFromColor(slot.data.color);\r\n                dark.setFromColor(slot.data.darkColor);\r\n            }\r\n            light.add((r - light.r) * alpha, (g - light.g) * alpha, (b - light.b) * alpha, (a - light.a) * alpha);\r\n            dark.add((r2 - dark.r) * alpha, (g2 - dark.g) * alpha, (b2 - dark.b) * alpha, 0);\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a slot's {@link Slot#attachment}. */\r\n/**\r\n * @public\r\n */\r\nexport class AttachmentTimeline implements Timeline {\r\n    /** The index of the slot in {@link Skeleton#slots} that will be changed. */\r\n    slotIndex: number;\r\n\r\n    /** The time in seconds for each key frame. */\r\n    frames: ArrayLike<number>; // time, ...\r\n\r\n    /** The attachment name for each key frame. May contain null values to clear the attachment. */\r\n    attachmentNames: Array<string>;\r\n\r\n    data: { frameIndex: number; time: number; attachmentName: string }[] = [];\r\n    constructor(frameCount: number) {\r\n        this.frames = Utils.newFloatArray(frameCount);\r\n        this.attachmentNames = new Array<string>(frameCount);\r\n    }\r\n\r\n    getPropertyId() {\r\n        return (TimelineType.attachment << 24) + this.slotIndex;\r\n    }\r\n\r\n    /** The number of key frames for this timeline. */\r\n    getFrameCount() {\r\n        return this.frames.length;\r\n    }\r\n\r\n    /** Sets the time in seconds and the attachment name for the specified key frame. */\r\n    setFrame(frameIndex: number, time: number, attachmentName: string) {\r\n        this.data.push({ frameIndex, time, attachmentName });\r\n        this.frames[frameIndex] = time;\r\n        this.attachmentNames[frameIndex] = attachmentName;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const slot = skeleton.slots[this.slotIndex];\r\n\r\n        if (!slot.bone.active) return;\r\n        if (direction == MixDirection.mixOut) {\r\n            if (blend == MixBlend.setup) this.setAttachment(skeleton, slot, slot.data.attachmentName);\r\n\r\n            return;\r\n        }\r\n\r\n        const frames = this.frames;\r\n\r\n        if (time < frames[0]) {\r\n            if (blend == MixBlend.setup || blend == MixBlend.first) this.setAttachment(skeleton, slot, slot.data.attachmentName);\r\n\r\n            return;\r\n        }\r\n\r\n        let frameIndex = 0;\r\n\r\n        if (time >= frames[frames.length - 1])\r\n            // Time is after last frame.\r\n            frameIndex = frames.length - 1;\r\n        else frameIndex = Animation.binarySearch(frames, time, 1) - 1;\r\n\r\n        const attachmentName = this.attachmentNames[frameIndex];\r\n\r\n        skeleton.slots[this.slotIndex].setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\r\n    }\r\n\r\n    setAttachment(skeleton: Skeleton, slot: Slot, attachmentName: string) {\r\n        slot.setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\r\n    }\r\n}\r\n\r\nlet zeros: ArrayLike<number> = null;\r\n\r\n/** Changes a slot's {@link Slot#deform} to deform a {@link VertexAttachment}. */\r\n/**\r\n * @public\r\n */\r\nexport class DeformTimeline extends CurveTimeline {\r\n    /** The index of the slot in {@link Skeleton#getSlots()} that will be changed. */\r\n    slotIndex: number;\r\n\r\n    /** The attachment that will be deformed. */\r\n    attachment: VertexAttachment;\r\n\r\n    /** The time in seconds for each key frame. */\r\n    frames: ArrayLike<number>; // time, ...\r\n\r\n    /** The vertices for each key frame. */\r\n    frameVertices: Array<ArrayLike<number>>;\r\n\r\n    data: { frameIndex: number; time: number; vertices: ArrayLike<number>; skin: string }[] = [];\r\n    constructor(frameCount: number) {\r\n        super(frameCount);\r\n        this.frames = Utils.newFloatArray(frameCount);\r\n        this.frameVertices = new Array<ArrayLike<number>>(frameCount);\r\n        if (zeros == null) zeros = Utils.newFloatArray(64);\r\n    }\r\n\r\n    getPropertyId() {\r\n        return (TimelineType.deform << 27) + Number(this.attachment.id) + this.slotIndex;\r\n    }\r\n\r\n    /** Sets the time in seconds and the vertices for the specified key frame.\r\n     * @param vertices Vertex positions for an unweighted VertexAttachment, or deform offsets if it has weights. */\r\n    setFrame(frameIndex: number, time: number, vertices: ArrayLike<number>, skin: string) {\r\n        this.data.push({ frameIndex, time, vertices, skin });\r\n        this.frames[frameIndex] = time;\r\n        this.frameVertices[frameIndex] = vertices;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const slot: Slot = skeleton.slots[this.slotIndex];\r\n\r\n        if (!slot.bone.active) return;\r\n        const slotAttachment: Attachment = slot.getAttachment();\r\n\r\n        if (!(slotAttachment instanceof VertexAttachment) || !((<VertexAttachment>slotAttachment).deformAttachment == this.attachment)) return;\r\n\r\n        const deformArray: Array<number> = slot.deform || [];\r\n\r\n        if (deformArray.length == 0) blend = MixBlend.setup;\r\n\r\n        const frameVertices = this.frameVertices;\r\n        const vertexCount = frameVertices[0].length;\r\n\r\n        const frames = this.frames;\r\n\r\n        if (time < frames[0]) {\r\n            const vertexAttachment = <VertexAttachment>slotAttachment;\r\n\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    deformArray.length = 0;\r\n\r\n                    return;\r\n                case MixBlend.first:\r\n                    if (alpha == 1) {\r\n                        deformArray.length = 0;\r\n                        break;\r\n                    }\r\n                    const deform: Array<number> = Utils.setArraySize(deformArray, vertexCount);\r\n\r\n                    if (vertexAttachment.bones == null) {\r\n                        // Unweighted vertex positions.\r\n                        const setupVertices = vertexAttachment.vertices;\r\n\r\n                        for (let i = 0; i < vertexCount; i++) deform[i] += (setupVertices[i] - deform[i]) * alpha;\r\n                    } else {\r\n                        // Weighted deform offsets.\r\n                        alpha = 1 - alpha;\r\n                        for (let i = 0; i < vertexCount; i++) deform[i] *= alpha;\r\n                    }\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        const deform: Array<number> = Utils.setArraySize(deformArray, vertexCount);\r\n\r\n        if (time >= frames[frames.length - 1]) {\r\n            // Time is after last frame.\r\n            const lastVertices = frameVertices[frames.length - 1];\r\n\r\n            if (alpha == 1) {\r\n                if (blend == MixBlend.add) {\r\n                    const vertexAttachment = slotAttachment as VertexAttachment;\r\n\r\n                    if (vertexAttachment.bones == null) {\r\n                        // Unweighted vertex positions, with alpha.\r\n                        const setupVertices = vertexAttachment.vertices;\r\n\r\n                        for (let i = 0; i < vertexCount; i++) {\r\n                            deform[i] += lastVertices[i] - setupVertices[i];\r\n                        }\r\n                    } else {\r\n                        // Weighted deform offsets, with alpha.\r\n                        for (let i = 0; i < vertexCount; i++) deform[i] += lastVertices[i];\r\n                    }\r\n                } else {\r\n                    Utils.arrayCopy(lastVertices, 0, deform, 0, vertexCount);\r\n                }\r\n            } else {\r\n                switch (blend) {\r\n                    case MixBlend.setup: {\r\n                        const vertexAttachment = slotAttachment as VertexAttachment;\r\n\r\n                        if (vertexAttachment.bones == null) {\r\n                            // Unweighted vertex positions, with alpha.\r\n                            const setupVertices = vertexAttachment.vertices;\r\n\r\n                            for (let i = 0; i < vertexCount; i++) {\r\n                                const setup = setupVertices[i];\r\n\r\n                                deform[i] = setup + (lastVertices[i] - setup) * alpha;\r\n                            }\r\n                        } else {\r\n                            // Weighted deform offsets, with alpha.\r\n                            for (let i = 0; i < vertexCount; i++) deform[i] = lastVertices[i] * alpha;\r\n                        }\r\n                        break;\r\n                    }\r\n                    case MixBlend.first:\r\n                    case MixBlend.replace:\r\n                        for (let i = 0; i < vertexCount; i++) deform[i] += (lastVertices[i] - deform[i]) * alpha;\r\n                        break;\r\n                    case MixBlend.add:\r\n                        const vertexAttachment = slotAttachment as VertexAttachment;\r\n\r\n                        if (vertexAttachment.bones == null) {\r\n                            // Unweighted vertex positions, with alpha.\r\n                            const setupVertices = vertexAttachment.vertices;\r\n\r\n                            for (let i = 0; i < vertexCount; i++) {\r\n                                deform[i] += (lastVertices[i] - setupVertices[i]) * alpha;\r\n                            }\r\n                        } else {\r\n                            // Weighted deform offsets, with alpha.\r\n                            for (let i = 0; i < vertexCount; i++) deform[i] += lastVertices[i] * alpha;\r\n                        }\r\n                }\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        const frame = Animation.binarySearch(frames, time);\r\n        const prevVertices = frameVertices[frame - 1];\r\n        const nextVertices = frameVertices[frame];\r\n        const frameTime = frames[frame];\r\n        const percent = this.getCurvePercent(frame - 1, 1 - (time - frameTime) / (frames[frame - 1] - frameTime));\r\n\r\n        if (alpha == 1) {\r\n            if (blend == MixBlend.add) {\r\n                const vertexAttachment = slotAttachment as VertexAttachment;\r\n\r\n                if (vertexAttachment.bones == null) {\r\n                    // Unweighted vertex positions, with alpha.\r\n                    const setupVertices = vertexAttachment.vertices;\r\n\r\n                    for (let i = 0; i < vertexCount; i++) {\r\n                        const prev = prevVertices[i];\r\n\r\n                        deform[i] += prev + (nextVertices[i] - prev) * percent - setupVertices[i];\r\n                    }\r\n                } else {\r\n                    // Weighted deform offsets, with alpha.\r\n                    for (let i = 0; i < vertexCount; i++) {\r\n                        const prev = prevVertices[i];\r\n\r\n                        deform[i] += prev + (nextVertices[i] - prev) * percent;\r\n                    }\r\n                }\r\n            } else {\r\n                for (let i = 0; i < vertexCount; i++) {\r\n                    const prev = prevVertices[i];\r\n\r\n                    deform[i] = prev + (nextVertices[i] - prev) * percent;\r\n                }\r\n            }\r\n        } else {\r\n            switch (blend) {\r\n                case MixBlend.setup: {\r\n                    const vertexAttachment = slotAttachment as VertexAttachment;\r\n\r\n                    if (vertexAttachment.bones == null) {\r\n                        // Unweighted vertex positions, with alpha.\r\n                        const setupVertices = vertexAttachment.vertices;\r\n\r\n                        for (let i = 0; i < vertexCount; i++) {\r\n                            const prev = prevVertices[i];\r\n                            const setup = setupVertices[i];\r\n\r\n                            deform[i] = setup + (prev + (nextVertices[i] - prev) * percent - setup) * alpha;\r\n                        }\r\n                    } else {\r\n                        // Weighted deform offsets, with alpha.\r\n                        for (let i = 0; i < vertexCount; i++) {\r\n                            const prev = prevVertices[i];\r\n\r\n                            deform[i] = (prev + (nextVertices[i] - prev) * percent) * alpha;\r\n                        }\r\n                    }\r\n                    break;\r\n                }\r\n                case MixBlend.first:\r\n                case MixBlend.replace:\r\n                    for (let i = 0; i < vertexCount; i++) {\r\n                        const prev = prevVertices[i];\r\n\r\n                        deform[i] += (prev + (nextVertices[i] - prev) * percent - deform[i]) * alpha;\r\n                    }\r\n                    break;\r\n                case MixBlend.add:\r\n                    const vertexAttachment = slotAttachment as VertexAttachment;\r\n\r\n                    if (vertexAttachment.bones == null) {\r\n                        // Unweighted vertex positions, with alpha.\r\n                        const setupVertices = vertexAttachment.vertices;\r\n\r\n                        for (let i = 0; i < vertexCount; i++) {\r\n                            const prev = prevVertices[i];\r\n\r\n                            deform[i] += (prev + (nextVertices[i] - prev) * percent - setupVertices[i]) * alpha;\r\n                        }\r\n                    } else {\r\n                        // Weighted deform offsets, with alpha.\r\n                        for (let i = 0; i < vertexCount; i++) {\r\n                            const prev = prevVertices[i];\r\n\r\n                            deform[i] += (prev + (nextVertices[i] - prev) * percent) * alpha;\r\n                        }\r\n                    }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/** Fires an {@link Event} when specific animation times are reached. */\r\n/**\r\n * @public\r\n */\r\nexport class EventTimeline implements Timeline {\r\n    /** The time in seconds for each key frame. */\r\n    frames: ArrayLike<number>; // time, ...\r\n\r\n    /** The event for each key frame. */\r\n    events: Array<Event>;\r\n\r\n    data: { frameIndex: number; event: Event }[] = [];\r\n    constructor(frameCount: number) {\r\n        this.frames = Utils.newFloatArray(frameCount);\r\n        this.events = new Array<Event>(frameCount);\r\n    }\r\n\r\n    getPropertyId() {\r\n        return TimelineType.event << 24;\r\n    }\r\n\r\n    /** The number of key frames for this timeline. */\r\n    getFrameCount() {\r\n        return this.frames.length;\r\n    }\r\n\r\n    /** Sets the time in seconds and the event for the specified key frame. */\r\n    setFrame(frameIndex: number, event: Event) {\r\n        this.data.push({ frameIndex, event });\r\n        this.frames[frameIndex] = event.time;\r\n        this.events[frameIndex] = event;\r\n    }\r\n\r\n    /** Fires events for frames > `lastTime` and <= `time`. */\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        if (firedEvents == null) return;\r\n        const frames = this.frames;\r\n        const frameCount = this.frames.length;\r\n\r\n        if (lastTime > time) {\r\n            // Fire events after last time for looped animations.\r\n            this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, blend, direction);\r\n            lastTime = -1;\r\n        } else if (lastTime >= frames[frameCount - 1])\r\n            // Last time is after last frame.\r\n            return;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        let frame = 0;\r\n\r\n        if (lastTime < frames[0]) frame = 0;\r\n        else {\r\n            frame = Animation.binarySearch(frames, lastTime);\r\n            const frameTime = frames[frame];\r\n\r\n            while (frame > 0) {\r\n                // Fire multiple events with the same frame.\r\n                if (frames[frame - 1] != frameTime) break;\r\n                frame--;\r\n            }\r\n        }\r\n        for (; frame < frameCount && time >= frames[frame]; frame++) firedEvents.push(this.events[frame]);\r\n    }\r\n}\r\n\r\n/** Changes a skeleton's {@link Skeleton#drawOrder}. */\r\n/**\r\n * @public\r\n */\r\nexport class DrawOrderTimeline implements Timeline {\r\n    /** The time in seconds for each key frame. */\r\n    frames: ArrayLike<number>; // time, ...\r\n\r\n    /** The draw order for each key frame. See {@link #setFrame(int, float, int[])}. */\r\n    drawOrders: Array<Array<number>>;\r\n\r\n    data: { frameIndex: number; time: number; drawOrder: Array<number> }[] = [];\r\n    constructor(frameCount: number) {\r\n        this.frames = Utils.newFloatArray(frameCount);\r\n        this.drawOrders = new Array<Array<number>>(frameCount);\r\n    }\r\n\r\n    getPropertyId() {\r\n        return TimelineType.drawOrder << 24;\r\n    }\r\n\r\n    /** The number of key frames for this timeline. */\r\n    getFrameCount() {\r\n        return this.frames.length;\r\n    }\r\n\r\n    /** Sets the time in seconds and the draw order for the specified key frame.\r\n     * @param drawOrder For each slot in {@link Skeleton#slots}, the index of the new draw order. May be null to use setup pose\r\n     *           draw order. */\r\n    setFrame(frameIndex: number, time: number, drawOrder: Array<number>) {\r\n        this.data.push({ frameIndex, time, drawOrder });\r\n        this.frames[frameIndex] = time;\r\n        this.drawOrders[frameIndex] = drawOrder;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const drawOrder: Array<Slot> = skeleton.drawOrder;\r\n        const slots: Array<Slot> = skeleton.slots;\r\n\r\n        if (direction == MixDirection.mixOut && blend == MixBlend.setup) {\r\n            Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\r\n\r\n            return;\r\n        }\r\n\r\n        const frames = this.frames;\r\n\r\n        if (time < frames[0]) {\r\n            if (blend == MixBlend.setup || blend == MixBlend.first) Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\r\n\r\n            return;\r\n        }\r\n\r\n        let frame = 0;\r\n\r\n        if (time >= frames[frames.length - 1])\r\n            // Time is after last frame.\r\n            frame = frames.length - 1;\r\n        else frame = Animation.binarySearch(frames, time) - 1;\r\n\r\n        const drawOrderToSetupIndex = this.drawOrders[frame];\r\n\r\n        if (drawOrderToSetupIndex == null) Utils.arrayCopy(slots, 0, drawOrder, 0, slots.length);\r\n        else {\r\n            for (let i = 0, n = drawOrderToSetupIndex.length; i < n; i++) drawOrder[i] = slots[drawOrderToSetupIndex[i]];\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes an IK constraint's {@link IkConstraint#mix}, {@link IkConstraint#softness},\r\n * {@link IkConstraint#bendDirection}, {@link IkConstraint#stretch}, and {@link IkConstraint#compress}. */\r\n/**\r\n * @public\r\n */\r\nexport class IkConstraintTimeline extends CurveTimeline {\r\n    static ENTRIES = 6;\r\n    static PREV_TIME = -6;\r\n    static PREV_MIX = -5;\r\n    static PREV_SOFTNESS = -4;\r\n    static PREV_BEND_DIRECTION = -3;\r\n    static PREV_COMPRESS = -2;\r\n    static PREV_STRETCH = -1;\r\n    static MIX = 1;\r\n    static SOFTNESS = 2;\r\n    static BEND_DIRECTION = 3;\r\n    static COMPRESS = 4;\r\n    static STRETCH = 5;\r\n\r\n    /** The index of the IK constraint slot in {@link Skeleton#ikConstraints} that will be changed. */\r\n    ikConstraintIndex: number;\r\n\r\n    /** The time in seconds, mix, softness, bend direction, compress, and stretch for each key frame. */\r\n    frames: ArrayLike<number>; // time, mix, softness, bendDirection, compress, stretch, ...\r\n\r\n    data: { frameIndex: number; time: number; mix: number; bendDirection: number }[] = [];\r\n    constructor(frameCount: number) {\r\n        super(frameCount);\r\n        this.frames = Utils.newFloatArray(frameCount * IkConstraintTimeline.ENTRIES);\r\n    }\r\n\r\n    getPropertyId() {\r\n        return (TimelineType.ikConstraint << 24) + this.ikConstraintIndex;\r\n    }\r\n\r\n    /** Sets the time, mix and bend direction of the specified keyframe. */\r\n    setFrame(frameIndex: number, time: number, mix: number, bendDirection: number) {\r\n        this.data.push({ frameIndex, time, mix, bendDirection });\r\n        frameIndex *= IkConstraintTimeline.ENTRIES;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + IkConstraintTimeline.MIX] = mix;\r\n        this.frames[frameIndex + IkConstraintTimeline.BEND_DIRECTION] = bendDirection;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const frames = this.frames;\r\n        const constraint: IkConstraint = skeleton.ikConstraints[this.ikConstraintIndex];\r\n\r\n        if (!constraint.active) return;\r\n\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    constraint.mix = constraint.data.mix;\r\n                    constraint.softness = constraint.data.softness;\r\n                    constraint.bendDirection = constraint.data.bendDirection;\r\n                    constraint.compress = constraint.data.compress;\r\n                    constraint.stretch = constraint.data.stretch;\r\n\r\n                    return;\r\n                case MixBlend.first:\r\n                    constraint.mix += (constraint.data.mix - constraint.mix) * alpha;\r\n                    constraint.softness += (constraint.data.softness - constraint.softness) * alpha;\r\n                    constraint.bendDirection = constraint.data.bendDirection;\r\n                    constraint.compress = constraint.data.compress;\r\n                    constraint.stretch = constraint.data.stretch;\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        if (time >= frames[frames.length - IkConstraintTimeline.ENTRIES]) {\r\n            // Time is after last frame.\r\n            if (blend === MixBlend.setup) {\r\n                constraint.mix = constraint.data.mix + (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.data.mix) * alpha;\r\n                constraint.softness = constraint.data.softness + (frames[frames.length + IkConstraintTimeline.PREV_SOFTNESS] - constraint.data.softness) * alpha;\r\n                if (direction === MixDirection.mixOut) {\r\n                    constraint.bendDirection = constraint.data.bendDirection;\r\n                    constraint.compress = constraint.data.compress;\r\n                    constraint.stretch = constraint.data.stretch;\r\n                } else {\r\n                    constraint.bendDirection = frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION];\r\n                    constraint.compress = frames[frames.length + IkConstraintTimeline.PREV_COMPRESS] !== 0;\r\n                    constraint.stretch = frames[frames.length + IkConstraintTimeline.PREV_STRETCH] !== 0;\r\n                }\r\n            } else {\r\n                constraint.mix += (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.mix) * alpha;\r\n                constraint.softness += (frames[frames.length + IkConstraintTimeline.PREV_SOFTNESS] - constraint.softness) * alpha;\r\n                if (direction === MixDirection.mixIn) {\r\n                    constraint.bendDirection = frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION];\r\n                    constraint.compress = frames[frames.length + IkConstraintTimeline.PREV_COMPRESS] !== 0;\r\n                    constraint.stretch = frames[frames.length + IkConstraintTimeline.PREV_STRETCH] !== 0;\r\n                }\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        const frame = Animation.binarySearch(frames, time, IkConstraintTimeline.ENTRIES);\r\n        const mix = frames[frame + IkConstraintTimeline.PREV_MIX];\r\n        const frameTime = frames[frame];\r\n        const percent = this.getCurvePercent(frame / IkConstraintTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + IkConstraintTimeline.PREV_TIME] - frameTime));\r\n\r\n        constraint.mix += (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.mix) * alpha;\r\n        constraint.bendDirection = Math.floor(frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION]);\r\n    }\r\n}\r\n\r\n/** Changes a transform constraint's {@link TransformConstraint#rotateMix}, {@link TransformConstraint#translateMix},\r\n * {@link TransformConstraint#scaleMix}, and {@link TransformConstraint#shearMix}. */\r\n/**\r\n * @public\r\n */\r\nexport class TransformConstraintTimeline extends CurveTimeline {\r\n    static ENTRIES = 5;\r\n    static PREV_TIME = -5;\r\n    static PREV_ROTATE = -4;\r\n    static PREV_TRANSLATE = -3;\r\n    static PREV_SCALE = -2;\r\n    static PREV_SHEAR = -1;\r\n    static ROTATE = 1;\r\n    static TRANSLATE = 2;\r\n    static SCALE = 3;\r\n    static SHEAR = 4;\r\n\r\n    /** The index of the transform constraint slot in {@link Skeleton#transformConstraints} that will be changed. */\r\n    transformConstraintIndex: number;\r\n\r\n    /** The time in seconds, rotate mix, translate mix, scale mix, and shear mix for each key frame. */\r\n    frames: ArrayLike<number>; // time, rotate mix, translate mix, scale mix, shear mix, ...\r\n\r\n    data: { frameIndex: number; time: number; rotateMix: number; translateMix: number; scaleMix: number; shearMix: number }[] = [];\r\n    constructor(frameCount: number) {\r\n        super(frameCount);\r\n        this.frames = Utils.newFloatArray(frameCount * TransformConstraintTimeline.ENTRIES);\r\n    }\r\n\r\n    getPropertyId() {\r\n        return (TimelineType.transformConstraint << 24) + this.transformConstraintIndex;\r\n    }\r\n\r\n    /** The time in seconds, rotate mix, translate mix, scale mix, and shear mix for the specified key frame. */\r\n    setFrame(frameIndex: number, time: number, rotateMix: number, translateMix: number, scaleMix: number, shearMix: number) {\r\n        this.data.push({ frameIndex, time, rotateMix, translateMix, scaleMix, shearMix });\r\n        frameIndex *= TransformConstraintTimeline.ENTRIES;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + TransformConstraintTimeline.ROTATE] = rotateMix;\r\n        this.frames[frameIndex + TransformConstraintTimeline.TRANSLATE] = translateMix;\r\n        this.frames[frameIndex + TransformConstraintTimeline.SCALE] = scaleMix;\r\n        this.frames[frameIndex + TransformConstraintTimeline.SHEAR] = shearMix;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const frames = this.frames;\r\n\r\n        const constraint: TransformConstraint = skeleton.transformConstraints[this.transformConstraintIndex];\r\n\r\n        if (!constraint.active) return;\r\n        if (time < frames[0]) {\r\n            const data = constraint.data;\r\n\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    constraint.rotateMix = data.rotateMix;\r\n                    constraint.translateMix = data.translateMix;\r\n                    constraint.scaleMix = data.scaleMix;\r\n                    constraint.shearMix = data.shearMix;\r\n\r\n                    return;\r\n                case MixBlend.first:\r\n                    constraint.rotateMix += (data.rotateMix - constraint.rotateMix) * alpha;\r\n                    constraint.translateMix += (data.translateMix - constraint.translateMix) * alpha;\r\n                    constraint.scaleMix += (data.scaleMix - constraint.scaleMix) * alpha;\r\n                    constraint.shearMix += (data.shearMix - constraint.shearMix) * alpha;\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        let rotate = 0;\r\n        let translate = 0;\r\n        let scale = 0;\r\n        let shear = 0;\r\n\r\n        if (time >= frames[frames.length - TransformConstraintTimeline.ENTRIES]) {\r\n            // Time is after last frame.\r\n            const i = frames.length;\r\n\r\n            rotate = frames[i + TransformConstraintTimeline.PREV_ROTATE];\r\n            translate = frames[i + TransformConstraintTimeline.PREV_TRANSLATE];\r\n            scale = frames[i + TransformConstraintTimeline.PREV_SCALE];\r\n            shear = frames[i + TransformConstraintTimeline.PREV_SHEAR];\r\n        } else {\r\n            // Interpolate between the previous frame and the current frame.\r\n            const frame = Animation.binarySearch(frames, time, TransformConstraintTimeline.ENTRIES);\r\n\r\n            rotate = frames[frame + TransformConstraintTimeline.PREV_ROTATE];\r\n            translate = frames[frame + TransformConstraintTimeline.PREV_TRANSLATE];\r\n            scale = frames[frame + TransformConstraintTimeline.PREV_SCALE];\r\n            shear = frames[frame + TransformConstraintTimeline.PREV_SHEAR];\r\n            const frameTime = frames[frame];\r\n            const percent = this.getCurvePercent(\r\n                frame / TransformConstraintTimeline.ENTRIES - 1,\r\n                1 - (time - frameTime) / (frames[frame + TransformConstraintTimeline.PREV_TIME] - frameTime)\r\n            );\r\n\r\n            rotate += (frames[frame + TransformConstraintTimeline.ROTATE] - rotate) * percent;\r\n            translate += (frames[frame + TransformConstraintTimeline.TRANSLATE] - translate) * percent;\r\n            scale += (frames[frame + TransformConstraintTimeline.SCALE] - scale) * percent;\r\n            shear += (frames[frame + TransformConstraintTimeline.SHEAR] - shear) * percent;\r\n        }\r\n        if (blend == MixBlend.setup) {\r\n            const data = constraint.data;\r\n\r\n            constraint.rotateMix = data.rotateMix + (rotate - data.rotateMix) * alpha;\r\n            constraint.translateMix = data.translateMix + (translate - data.translateMix) * alpha;\r\n            constraint.scaleMix = data.scaleMix + (scale - data.scaleMix) * alpha;\r\n            constraint.shearMix = data.shearMix + (shear - data.shearMix) * alpha;\r\n        } else {\r\n            constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;\r\n            constraint.translateMix += (translate - constraint.translateMix) * alpha;\r\n            constraint.scaleMix += (scale - constraint.scaleMix) * alpha;\r\n            constraint.shearMix += (shear - constraint.shearMix) * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a path constraint's {@link PathConstraint#position}. */\r\n/**\r\n * @public\r\n */\r\nexport class PathConstraintPositionTimeline extends CurveTimeline {\r\n    static ENTRIES = 2;\r\n    static PREV_TIME = -2;\r\n    static PREV_VALUE = -1;\r\n    static VALUE = 1;\r\n\r\n    /** The index of the path constraint slot in {@link Skeleton#pathConstraints} that will be changed. */\r\n    pathConstraintIndex: number;\r\n\r\n    /** The time in seconds and path constraint position for each key frame. */\r\n    frames: ArrayLike<number>; // time, position, ...\r\n\r\n    data: { frameIndex: number; time: number; value: number }[] = [];\r\n    constructor(frameCount: number) {\r\n        super(frameCount);\r\n        this.frames = Utils.newFloatArray(frameCount * PathConstraintPositionTimeline.ENTRIES);\r\n    }\r\n\r\n    getPropertyId() {\r\n        return (TimelineType.pathConstraintPosition << 24) + this.pathConstraintIndex;\r\n    }\r\n\r\n    /** Sets the time in seconds and path constraint position for the specified key frame. */\r\n    setFrame(frameIndex: number, time: number, value: number) {\r\n        this.data.push({ frameIndex, time, value });\r\n        frameIndex *= PathConstraintPositionTimeline.ENTRIES;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + PathConstraintPositionTimeline.VALUE] = value;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const frames = this.frames;\r\n        const constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\r\n\r\n        if (!constraint.active) return;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    constraint.position = constraint.data.position;\r\n\r\n                    return;\r\n                case MixBlend.first:\r\n                    constraint.position += (constraint.data.position - constraint.position) * alpha;\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        let position = 0;\r\n\r\n        if (time >= frames[frames.length - PathConstraintPositionTimeline.ENTRIES])\r\n            // Time is after last frame.\r\n            position = frames[frames.length + PathConstraintPositionTimeline.PREV_VALUE];\r\n        else {\r\n            // Interpolate between the previous frame and the current frame.\r\n            const frame = Animation.binarySearch(frames, time, PathConstraintPositionTimeline.ENTRIES);\r\n\r\n            position = frames[frame + PathConstraintPositionTimeline.PREV_VALUE];\r\n            const frameTime = frames[frame];\r\n            const percent = this.getCurvePercent(\r\n                frame / PathConstraintPositionTimeline.ENTRIES - 1,\r\n                1 - (time - frameTime) / (frames[frame + PathConstraintPositionTimeline.PREV_TIME] - frameTime)\r\n            );\r\n\r\n            position += (frames[frame + PathConstraintPositionTimeline.VALUE] - position) * percent;\r\n        }\r\n        if (blend == MixBlend.setup) constraint.position = constraint.data.position + (position - constraint.data.position) * alpha;\r\n        else constraint.position += (position - constraint.position) * alpha;\r\n    }\r\n}\r\n\r\n/** Changes a path constraint's {@link PathConstraint#spacing}. */\r\n/**\r\n * @public\r\n */\r\nexport class PathConstraintSpacingTimeline extends PathConstraintPositionTimeline {\r\n    constructor(frameCount: number) {\r\n        super(frameCount);\r\n    }\r\n\r\n    getPropertyId() {\r\n        return (TimelineType.pathConstraintSpacing << 24) + this.pathConstraintIndex;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const frames = this.frames;\r\n        const constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\r\n\r\n        if (!constraint.active) return;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    constraint.spacing = constraint.data.spacing;\r\n\r\n                    return;\r\n                case MixBlend.first:\r\n                    constraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha;\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        let spacing = 0;\r\n\r\n        if (time >= frames[frames.length - PathConstraintSpacingTimeline.ENTRIES])\r\n            // Time is after last frame.\r\n            spacing = frames[frames.length + PathConstraintSpacingTimeline.PREV_VALUE];\r\n        else {\r\n            // Interpolate between the previous frame and the current frame.\r\n            const frame = Animation.binarySearch(frames, time, PathConstraintSpacingTimeline.ENTRIES);\r\n\r\n            spacing = frames[frame + PathConstraintSpacingTimeline.PREV_VALUE];\r\n            const frameTime = frames[frame];\r\n            const percent = this.getCurvePercent(\r\n                frame / PathConstraintSpacingTimeline.ENTRIES - 1,\r\n                1 - (time - frameTime) / (frames[frame + PathConstraintSpacingTimeline.PREV_TIME] - frameTime)\r\n            );\r\n\r\n            spacing += (frames[frame + PathConstraintSpacingTimeline.VALUE] - spacing) * percent;\r\n        }\r\n\r\n        if (blend == MixBlend.setup) constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha;\r\n        else constraint.spacing += (spacing - constraint.spacing) * alpha;\r\n    }\r\n}\r\n\r\n/** Changes a transform constraint's {@link PathConstraint#rotateMix} and\r\n * {@link TransformConstraint#translateMix}. */\r\n/**\r\n * @public\r\n */\r\nexport class PathConstraintMixTimeline extends CurveTimeline {\r\n    static ENTRIES = 3;\r\n    static PREV_TIME = -3;\r\n    static PREV_ROTATE = -2;\r\n    static PREV_TRANSLATE = -1;\r\n    static ROTATE = 1;\r\n    static TRANSLATE = 2;\r\n\r\n    /** The index of the path constraint slot in {@link Skeleton#getPathConstraints()} that will be changed. */\r\n    pathConstraintIndex: number;\r\n\r\n    /** The time in seconds, rotate mix, and translate mix for each key frame. */\r\n    frames: ArrayLike<number>; // time, rotate mix, translate mix, ...\r\n\r\n    data: { frameIndex: number; time: number; rotateMix: number; translateMix: number }[] = [];\r\n    constructor(frameCount: number) {\r\n        super(frameCount);\r\n        this.frames = Utils.newFloatArray(frameCount * PathConstraintMixTimeline.ENTRIES);\r\n    }\r\n\r\n    getPropertyId() {\r\n        return (TimelineType.pathConstraintMix << 24) + this.pathConstraintIndex;\r\n    }\r\n\r\n    /** The time in seconds, rotate mix, and translate mix for the specified key frame. */\r\n    setFrame(frameIndex: number, time: number, rotateMix: number, translateMix: number) {\r\n        this.data.push({ frameIndex, time, rotateMix, translateMix });\r\n        frameIndex *= PathConstraintMixTimeline.ENTRIES;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + PathConstraintMixTimeline.ROTATE] = rotateMix;\r\n        this.frames[frameIndex + PathConstraintMixTimeline.TRANSLATE] = translateMix;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const frames = this.frames;\r\n        const constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\r\n\r\n        if (!constraint.active) return;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    constraint.rotateMix = constraint.data.rotateMix;\r\n                    constraint.translateMix = constraint.data.translateMix;\r\n\r\n                    return;\r\n                case MixBlend.first:\r\n                    constraint.rotateMix += (constraint.data.rotateMix - constraint.rotateMix) * alpha;\r\n                    constraint.translateMix += (constraint.data.translateMix - constraint.translateMix) * alpha;\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        let rotate = 0;\r\n        let translate = 0;\r\n\r\n        if (time >= frames[frames.length - PathConstraintMixTimeline.ENTRIES]) {\r\n            // Time is after last frame.\r\n            rotate = frames[frames.length + PathConstraintMixTimeline.PREV_ROTATE];\r\n            translate = frames[frames.length + PathConstraintMixTimeline.PREV_TRANSLATE];\r\n        } else {\r\n            // Interpolate between the previous frame and the current frame.\r\n            const frame = Animation.binarySearch(frames, time, PathConstraintMixTimeline.ENTRIES);\r\n\r\n            rotate = frames[frame + PathConstraintMixTimeline.PREV_ROTATE];\r\n            translate = frames[frame + PathConstraintMixTimeline.PREV_TRANSLATE];\r\n            const frameTime = frames[frame];\r\n            const percent = this.getCurvePercent(\r\n                frame / PathConstraintMixTimeline.ENTRIES - 1,\r\n                1 - (time - frameTime) / (frames[frame + PathConstraintMixTimeline.PREV_TIME] - frameTime)\r\n            );\r\n\r\n            rotate += (frames[frame + PathConstraintMixTimeline.ROTATE] - rotate) * percent;\r\n            translate += (frames[frame + PathConstraintMixTimeline.TRANSLATE] - translate) * percent;\r\n        }\r\n\r\n        if (blend == MixBlend.setup) {\r\n            constraint.rotateMix = constraint.data.rotateMix + (rotate - constraint.data.rotateMix) * alpha;\r\n            constraint.translateMix = constraint.data.translateMix + (translate - constraint.data.translateMix) * alpha;\r\n        } else {\r\n            constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;\r\n            constraint.translateMix += (translate - constraint.translateMix) * alpha;\r\n        }\r\n    }\r\n}\r\n","import { IAnimationState, IAnimationStateListener, ITrackEntry, MixBlend, MixDirection, MathUtils, Pool, IntSet, Utils } from '@pixi-spine/base';\nimport { Animation, AttachmentTimeline, DrawOrderTimeline, EventTimeline, RotateTimeline, Timeline } from './Animation';\nimport type { AnimationStateData } from './AnimationStateData';\nimport type { Event } from './Event';\nimport type { Skeleton } from './Skeleton';\nimport type { Slot } from './Slot';\n\n/** Applies animations over time, queues animations for later playback, mixes (crossfading) between animations, and applies\n * multiple animations on top of each other (layering).\n *\n * See [Applying Animations](http://esotericsoftware.com/spine-applying-animations/) in the Spine Runtimes Guide. */\n/**\n * @public\n */\nexport class AnimationState implements IAnimationState<AnimationStateData> {\n    static emptyAnimation = new Animation('<empty>', [], 0);\n\n    /** 1. A previously applied timeline has set this property.\n     *\n     * Result: Mix from the current pose to the timeline pose. */\n    static SUBSEQUENT = 0;\n    /** 1. This is the first timeline to set this property.\n     * 2. The next track entry applied after this one does not have a timeline to set this property.\n     *\n     * Result: Mix from the setup pose to the timeline pose. */\n    static FIRST = 1;\n    /** 1) A previously applied timeline has set this property.<br>\n     * 2) The next track entry to be applied does have a timeline to set this property.<br>\n     * 3) The next track entry after that one does not have a timeline to set this property.<br>\n     * Result: Mix from the current pose to the timeline pose, but do not mix out. This avoids \"dipping\" when crossfading\n     * animations that key the same property. A subsequent timeline will set this property using a mix. */\n    static HOLD_SUBSEQUENT = 2;\n    /** 1) This is the first timeline to set this property.<br>\n     * 2) The next track entry to be applied does have a timeline to set this property.<br>\n     * 3) The next track entry after that one does not have a timeline to set this property.<br>\n     * Result: Mix from the setup pose to the timeline pose, but do not mix out. This avoids \"dipping\" when crossfading animations\n     * that key the same property. A subsequent timeline will set this property using a mix. */\n    static HOLD_FIRST = 3;\n    /** 1. This is the first timeline to set this property.\n     * 2. The next track entry to be applied does have a timeline to set this property.\n     * 3. The next track entry after that one does have a timeline to set this property.\n     * 4. timelineHoldMix stores the first subsequent track entry that does not have a timeline to set this property.\n     *\n     * Result: The same as HOLD except the mix percentage from the timelineHoldMix track entry is used. This handles when more than\n     * 2 track entries in a row have a timeline that sets the same property.\n     *\n     * Eg, A -> B -> C -> D where A, B, and C have a timeline setting same property, but D does not. When A is applied, to avoid\n     * \"dipping\" A is not mixed out, however D (the first entry that doesn't set the property) mixing in is used to mix out A\n     * (which affects B and C). Without using D to mix out, A would be applied fully until mixing completes, then snap into\n     * place. */\n    static HOLD_MIX = 4;\n\n    static SETUP = 1;\n    static CURRENT = 2;\n\n    /** The AnimationStateData to look up mix durations. */\n    data: AnimationStateData;\n\n    /** The list of tracks that currently have animations, which may contain null entries. */\n    tracks = new Array<TrackEntry>();\n\n    /** Multiplier for the delta time when the animation state is updated, causing time for all animations and mixes to play slower\n     * or faster. Defaults to 1.\n     *\n     * See TrackEntry {@link TrackEntry#timeScale} for affecting a single animation. */\n    timeScale = 1;\n    unkeyedState = 0;\n\n    events = new Array<Event>();\n    listeners = new Array<AnimationStateListener>();\n    queue = new EventQueue(this);\n    propertyIDs = new IntSet();\n    animationsChanged = false;\n\n    trackEntryPool = new Pool<TrackEntry>(() => new TrackEntry());\n\n    constructor(data: AnimationStateData) {\n        this.data = data;\n    }\n\n    /** Increments each track entry {@link TrackEntry#trackTime()}, setting queued animations as current if needed. */\n    update(delta: number) {\n        delta *= this.timeScale;\n        const tracks = this.tracks;\n\n        for (let i = 0, n = tracks.length; i < n; i++) {\n            const current = tracks[i];\n\n            if (current == null) continue;\n\n            current.animationLast = current.nextAnimationLast;\n            current.trackLast = current.nextTrackLast;\n\n            let currentDelta = delta * current.timeScale;\n\n            if (current.delay > 0) {\n                current.delay -= currentDelta;\n                if (current.delay > 0) continue;\n                currentDelta = -current.delay;\n                current.delay = 0;\n            }\n\n            let next = current.next;\n\n            if (next != null) {\n                // When the next entry's delay is passed, change to the next entry, preserving leftover time.\n                const nextTime = current.trackLast - next.delay;\n\n                if (nextTime >= 0) {\n                    next.delay = 0;\n                    next.trackTime += current.timeScale == 0 ? 0 : (nextTime / current.timeScale + delta) * next.timeScale;\n                    current.trackTime += currentDelta;\n                    this.setCurrent(i, next, true);\n                    while (next.mixingFrom != null) {\n                        next.mixTime += delta;\n                        next = next.mixingFrom;\n                    }\n                    continue;\n                }\n            } else if (current.trackLast >= current.trackEnd && current.mixingFrom == null) {\n                tracks[i] = null;\n                this.queue.end(current);\n                this.disposeNext(current);\n                continue;\n            }\n            if (current.mixingFrom != null && this.updateMixingFrom(current, delta)) {\n                // End mixing from entries once all have completed.\n                let from = current.mixingFrom;\n\n                current.mixingFrom = null;\n                if (from != null) from.mixingTo = null;\n                while (from != null) {\n                    this.queue.end(from);\n                    from = from.mixingFrom;\n                }\n            }\n\n            current.trackTime += currentDelta;\n        }\n\n        this.queue.drain();\n    }\n\n    /** Returns true when all mixing from entries are complete. */\n    updateMixingFrom(to: TrackEntry, delta: number): boolean {\n        const from = to.mixingFrom;\n\n        if (from == null) return true;\n\n        const finished = this.updateMixingFrom(from, delta);\n\n        from.animationLast = from.nextAnimationLast;\n        from.trackLast = from.nextTrackLast;\n\n        // Require mixTime > 0 to ensure the mixing from entry was applied at least once.\n        if (to.mixTime > 0 && to.mixTime >= to.mixDuration) {\n            // Require totalAlpha == 0 to ensure mixing is complete, unless mixDuration == 0 (the transition is a single frame).\n            if (from.totalAlpha == 0 || to.mixDuration == 0) {\n                to.mixingFrom = from.mixingFrom;\n                if (from.mixingFrom != null) from.mixingFrom.mixingTo = to;\n                to.interruptAlpha = from.interruptAlpha;\n                this.queue.end(from);\n            }\n\n            return finished;\n        }\n\n        from.trackTime += delta * from.timeScale;\n        to.mixTime += delta;\n\n        return false;\n    }\n\n    /** Poses the skeleton using the track entry animations. There are no side effects other than invoking listeners, so the\n     * animation state can be applied to multiple skeletons to pose them identically.\n     * @returns True if any animations were applied. */\n    apply(skeleton: Skeleton): boolean {\n        if (skeleton == null) throw new Error('skeleton cannot be null.');\n        if (this.animationsChanged) this._animationsChanged();\n\n        const events = this.events;\n        const tracks = this.tracks;\n        let applied = false;\n\n        for (let i = 0, n = tracks.length; i < n; i++) {\n            const current = tracks[i];\n\n            if (current == null || current.delay > 0) continue;\n            applied = true;\n            const blend: MixBlend = i == 0 ? MixBlend.first : current.mixBlend;\n\n            // Apply mixing from entries first.\n            let mix = current.alpha;\n\n            if (current.mixingFrom != null) mix *= this.applyMixingFrom(current, skeleton, blend);\n            else if (current.trackTime >= current.trackEnd && current.next == null) mix = 0;\n\n            // Apply current entry.\n            const animationLast = current.animationLast;\n            const animationTime = current.getAnimationTime();\n            const timelineCount = current.animation.timelines.length;\n            const timelines = current.animation.timelines;\n\n            if ((i == 0 && mix == 1) || blend == MixBlend.add) {\n                for (let ii = 0; ii < timelineCount; ii++) {\n                    // Fixes issue #302 on IOS9 where mix, blend sometimes became undefined and caused assets\n                    // to sometimes stop rendering when using color correction, as their RGBA values become NaN.\n                    // (https://github.com/pixijs/pixi-spine/issues/302)\n                    Utils.webkit602BugfixHelper(mix, blend);\n                    const timeline = timelines[ii];\n\n                    if (timeline instanceof AttachmentTimeline) this.applyAttachmentTimeline(timeline, skeleton, animationTime, blend, true);\n                    else timeline.apply(skeleton, animationLast, animationTime, events, mix, blend, MixDirection.mixIn);\n                }\n            } else {\n                const timelineMode = current.timelineMode;\n\n                const firstFrame = current.timelinesRotation.length == 0;\n\n                if (firstFrame) Utils.setArraySize(current.timelinesRotation, timelineCount << 1, null);\n                const timelinesRotation = current.timelinesRotation;\n\n                for (let ii = 0; ii < timelineCount; ii++) {\n                    const timeline = timelines[ii];\n                    const timelineBlend = timelineMode[ii] == AnimationState.SUBSEQUENT ? blend : MixBlend.setup;\n\n                    if (timeline instanceof RotateTimeline) {\n                        this.applyRotateTimeline(timeline, skeleton, animationTime, mix, timelineBlend, timelinesRotation, ii << 1, firstFrame);\n                    } else if (timeline instanceof AttachmentTimeline) {\n                        this.applyAttachmentTimeline(timeline, skeleton, animationTime, blend, true);\n                    } else {\n                        // This fixes the WebKit 602 specific issue described at http://esotericsoftware.com/forum/iOS-10-disappearing-graphics-10109\n                        Utils.webkit602BugfixHelper(mix, blend);\n                        timeline.apply(skeleton, animationLast, animationTime, events, mix, timelineBlend, MixDirection.mixIn);\n                    }\n                }\n            }\n            this.queueEvents(current, animationTime);\n            events.length = 0;\n            current.nextAnimationLast = animationTime;\n            current.nextTrackLast = current.trackTime;\n        }\n\n        // Set slots attachments to the setup pose, if needed. This occurs if an animation that is mixing out sets attachments so\n        // subsequent timelines see any deform, but the subsequent timelines don't set an attachment (eg they are also mixing out or\n        // the time is before the first key).\n        const setupState = this.unkeyedState + AnimationState.SETUP;\n        const slots = skeleton.slots;\n\n        for (let i = 0, n = skeleton.slots.length; i < n; i++) {\n            const slot = slots[i];\n\n            if (slot.attachmentState == setupState) {\n                const attachmentName = slot.data.attachmentName;\n\n                slot.setAttachment(attachmentName == null ? null : skeleton.getAttachment(slot.data.index, attachmentName));\n            }\n        }\n        this.unkeyedState += 2; // Increasing after each use avoids the need to reset attachmentState for every slot.\n\n        this.queue.drain();\n\n        return applied;\n    }\n\n    applyMixingFrom(to: TrackEntry, skeleton: Skeleton, blend: MixBlend) {\n        const from = to.mixingFrom;\n\n        if (from.mixingFrom != null) this.applyMixingFrom(from, skeleton, blend);\n\n        let mix = 0;\n\n        if (to.mixDuration == 0) {\n            // Single frame mix to undo mixingFrom changes.\n            mix = 1;\n            if (blend == MixBlend.first) blend = MixBlend.setup;\n        } else {\n            mix = to.mixTime / to.mixDuration;\n            if (mix > 1) mix = 1;\n            if (blend != MixBlend.first) blend = from.mixBlend;\n        }\n\n        const events = mix < from.eventThreshold ? this.events : null;\n        const attachments = mix < from.attachmentThreshold;\n        const drawOrder = mix < from.drawOrderThreshold;\n        const animationLast = from.animationLast;\n        const animationTime = from.getAnimationTime();\n        const timelineCount = from.animation.timelines.length;\n        const timelines = from.animation.timelines;\n        const alphaHold = from.alpha * to.interruptAlpha;\n        const alphaMix = alphaHold * (1 - mix);\n\n        if (blend == MixBlend.add) {\n            for (let i = 0; i < timelineCount; i++) timelines[i].apply(skeleton, animationLast, animationTime, events, alphaMix, blend, MixDirection.mixOut);\n        } else {\n            const timelineMode = from.timelineMode;\n            const timelineHoldMix = from.timelineHoldMix;\n\n            const firstFrame = from.timelinesRotation.length == 0;\n\n            if (firstFrame) Utils.setArraySize(from.timelinesRotation, timelineCount << 1, null);\n            const timelinesRotation = from.timelinesRotation;\n\n            from.totalAlpha = 0;\n            for (let i = 0; i < timelineCount; i++) {\n                const timeline = timelines[i];\n                let direction = MixDirection.mixOut;\n                let timelineBlend: MixBlend;\n                let alpha = 0;\n\n                switch (timelineMode[i]) {\n                    case AnimationState.SUBSEQUENT:\n                        if (!drawOrder && timeline instanceof DrawOrderTimeline) continue;\n                        timelineBlend = blend;\n                        alpha = alphaMix;\n                        break;\n                    case AnimationState.FIRST:\n                        timelineBlend = MixBlend.setup;\n                        alpha = alphaMix;\n                        break;\n                    case AnimationState.HOLD_SUBSEQUENT:\n                        timelineBlend = blend;\n                        alpha = alphaHold;\n                        break;\n                    case AnimationState.HOLD_FIRST:\n                        timelineBlend = MixBlend.setup;\n                        alpha = alphaHold;\n                        break;\n                    default:\n                        timelineBlend = MixBlend.setup;\n                        const holdMix = timelineHoldMix[i];\n\n                        alpha = alphaHold * Math.max(0, 1 - holdMix.mixTime / holdMix.mixDuration);\n                        break;\n                }\n                from.totalAlpha += alpha;\n\n                if (timeline instanceof RotateTimeline) this.applyRotateTimeline(timeline, skeleton, animationTime, alpha, timelineBlend, timelinesRotation, i << 1, firstFrame);\n                else if (timeline instanceof AttachmentTimeline) this.applyAttachmentTimeline(timeline, skeleton, animationTime, timelineBlend, attachments);\n                else {\n                    // This fixes the WebKit 602 specific issue described at http://esotericsoftware.com/forum/iOS-10-disappearing-graphics-10109\n                    Utils.webkit602BugfixHelper(alpha, blend);\n                    if (drawOrder && timeline instanceof DrawOrderTimeline && timelineBlend == MixBlend.setup) direction = MixDirection.mixIn;\n                    timeline.apply(skeleton, animationLast, animationTime, events, alpha, timelineBlend, direction);\n                }\n            }\n        }\n\n        if (to.mixDuration > 0) this.queueEvents(from, animationTime);\n        this.events.length = 0;\n        from.nextAnimationLast = animationTime;\n        from.nextTrackLast = from.trackTime;\n\n        return mix;\n    }\n\n    applyAttachmentTimeline(timeline: AttachmentTimeline, skeleton: Skeleton, time: number, blend: MixBlend, attachments: boolean) {\n        const slot = skeleton.slots[timeline.slotIndex];\n\n        if (!slot.bone.active) return;\n\n        const frames = timeline.frames;\n\n        if (time < frames[0]) {\n            // Time is before first frame.\n            if (blend == MixBlend.setup || blend == MixBlend.first) this.setAttachment(skeleton, slot, slot.data.attachmentName, attachments);\n        } else {\n            let frameIndex;\n\n            if (time >= frames[frames.length - 1])\n                // Time is after last frame.\n                frameIndex = frames.length - 1;\n            else frameIndex = Animation.binarySearch(frames, time) - 1;\n            this.setAttachment(skeleton, slot, timeline.attachmentNames[frameIndex], attachments);\n        }\n\n        // If an attachment wasn't set (ie before the first frame or attachments is false), set the setup attachment later.\n        if (slot.attachmentState <= this.unkeyedState) slot.attachmentState = this.unkeyedState + AnimationState.SETUP;\n    }\n\n    setAttachment(skeleton: Skeleton, slot: Slot, attachmentName: string, attachments: boolean) {\n        slot.setAttachment(attachmentName == null ? null : skeleton.getAttachment(slot.data.index, attachmentName));\n        if (attachments) slot.attachmentState = this.unkeyedState + AnimationState.CURRENT;\n    }\n\n    applyRotateTimeline(timeline: Timeline, skeleton: Skeleton, time: number, alpha: number, blend: MixBlend, timelinesRotation: Array<number>, i: number, firstFrame: boolean) {\n        if (firstFrame) timelinesRotation[i] = 0;\n\n        if (alpha == 1) {\n            timeline.apply(skeleton, 0, time, null, 1, blend, MixDirection.mixIn);\n\n            return;\n        }\n\n        const rotateTimeline = timeline as RotateTimeline;\n        const frames = rotateTimeline.frames;\n        const bone = skeleton.bones[rotateTimeline.boneIndex];\n\n        if (!bone.active) return;\n        let r1 = 0;\n        let r2 = 0;\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.rotation = bone.data.rotation;\n                default:\n                    return;\n                case MixBlend.first:\n                    r1 = bone.rotation;\n                    r2 = bone.data.rotation;\n            }\n        } else {\n            r1 = blend == MixBlend.setup ? bone.data.rotation : bone.rotation;\n            if (time >= frames[frames.length - RotateTimeline.ENTRIES])\n                // Time is after last frame.\n                r2 = bone.data.rotation + frames[frames.length + RotateTimeline.PREV_ROTATION];\n            else {\n                // Interpolate between the previous frame and the current frame.\n                const frame = Animation.binarySearch(frames, time, RotateTimeline.ENTRIES);\n                const prevRotation = frames[frame + RotateTimeline.PREV_ROTATION];\n                const frameTime = frames[frame];\n                const percent = rotateTimeline.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + RotateTimeline.PREV_TIME] - frameTime));\n\n                r2 = frames[frame + RotateTimeline.ROTATION] - prevRotation;\n                r2 -= (16384 - ((16384.499999999996 - r2 / 360) | 0)) * 360;\n                r2 = prevRotation + r2 * percent + bone.data.rotation;\n                r2 -= (16384 - ((16384.499999999996 - r2 / 360) | 0)) * 360;\n            }\n        }\n\n        // Mix between rotations using the direction of the shortest route on the first frame while detecting crosses.\n        let total = 0;\n        let diff = r2 - r1;\n\n        diff -= (16384 - ((16384.499999999996 - diff / 360) | 0)) * 360;\n        if (diff == 0) {\n            total = timelinesRotation[i];\n        } else {\n            let lastTotal = 0;\n            let lastDiff = 0;\n\n            if (firstFrame) {\n                lastTotal = 0;\n                lastDiff = diff;\n            } else {\n                lastTotal = timelinesRotation[i]; // Angle and direction of mix, including loops.\n                lastDiff = timelinesRotation[i + 1]; // Difference between bones.\n            }\n            const current = diff > 0;\n            let dir = lastTotal >= 0;\n            // Detect cross at 0 (not 180).\n\n            if (MathUtils.signum(lastDiff) != MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {\n                // A cross after a 360 rotation is a loop.\n                if (Math.abs(lastTotal) > 180) lastTotal += 360 * MathUtils.signum(lastTotal);\n                dir = current;\n            }\n            total = diff + lastTotal - (lastTotal % 360); // Store loops as part of lastTotal.\n            if (dir != current) total += 360 * MathUtils.signum(lastTotal);\n            timelinesRotation[i] = total;\n        }\n        timelinesRotation[i + 1] = diff;\n        r1 += total * alpha;\n        bone.rotation = r1 - (16384 - ((16384.499999999996 - r1 / 360) | 0)) * 360;\n    }\n\n    queueEvents(entry: TrackEntry, animationTime: number) {\n        const animationStart = entry.animationStart;\n        const animationEnd = entry.animationEnd;\n        const duration = animationEnd - animationStart;\n        const trackLastWrapped = entry.trackLast % duration;\n\n        // Queue events before complete.\n        const events = this.events;\n        let i = 0;\n        const n = events.length;\n\n        for (; i < n; i++) {\n            const event = events[i];\n\n            if (event.time < trackLastWrapped) break;\n            if (event.time > animationEnd) continue; // Discard events outside animation start/end.\n            this.queue.event(entry, event);\n        }\n\n        // Queue complete if completed a loop iteration or the animation.\n        let complete = false;\n\n        if (entry.loop) complete = duration == 0 || trackLastWrapped > entry.trackTime % duration;\n        else complete = animationTime >= animationEnd && entry.animationLast < animationEnd;\n        if (complete) this.queue.complete(entry);\n\n        // Queue events after complete.\n        for (; i < n; i++) {\n            const event = events[i];\n\n            if (event.time < animationStart) continue; // Discard events outside animation start/end.\n            this.queue.event(entry, events[i]);\n        }\n    }\n\n    /** Removes all animations from all tracks, leaving skeletons in their current pose.\n     *\n     * It may be desired to use {@link AnimationState#setEmptyAnimation()} to mix the skeletons back to the setup pose,\n     * rather than leaving them in their current pose. */\n    clearTracks() {\n        const oldDrainDisabled = this.queue.drainDisabled;\n\n        this.queue.drainDisabled = true;\n        for (let i = 0, n = this.tracks.length; i < n; i++) this.clearTrack(i);\n        this.tracks.length = 0;\n        this.queue.drainDisabled = oldDrainDisabled;\n        this.queue.drain();\n    }\n\n    /** Removes all animations from the track, leaving skeletons in their current pose.\n     *\n     * It may be desired to use {@link AnimationState#setEmptyAnimation()} to mix the skeletons back to the setup pose,\n     * rather than leaving them in their current pose. */\n    clearTrack(trackIndex: number) {\n        if (trackIndex >= this.tracks.length) return;\n        const current = this.tracks[trackIndex];\n\n        if (current == null) return;\n\n        this.queue.end(current);\n\n        this.disposeNext(current);\n\n        let entry = current;\n\n        while (true) {\n            const from = entry.mixingFrom;\n\n            if (from == null) break;\n            this.queue.end(from);\n            entry.mixingFrom = null;\n            entry.mixingTo = null;\n            entry = from;\n        }\n\n        this.tracks[current.trackIndex] = null;\n\n        this.queue.drain();\n    }\n\n    setCurrent(index: number, current: TrackEntry, interrupt: boolean) {\n        const from = this.expandToIndex(index);\n\n        this.tracks[index] = current;\n\n        if (from != null) {\n            if (interrupt) this.queue.interrupt(from);\n            current.mixingFrom = from;\n            from.mixingTo = current;\n            current.mixTime = 0;\n\n            // Store the interrupted mix percentage.\n            if (from.mixingFrom != null && from.mixDuration > 0) current.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);\n\n            from.timelinesRotation.length = 0; // Reset rotation for mixing out, in case entry was mixed in.\n        }\n\n        this.queue.start(current);\n    }\n\n    /** Sets an animation by name.\n     *\n     * {@link #setAnimationWith(}. */\n    setAnimation(trackIndex: number, animationName: string, loop: boolean) {\n        const animation = this.data.skeletonData.findAnimation(animationName);\n\n        if (animation == null) throw new Error(`Animation not found: ${animationName}`);\n\n        return this.setAnimationWith(trackIndex, animation, loop);\n    }\n\n    /** Sets the current animation for a track, discarding any queued animations. If the formerly current track entry was never\n     * applied to a skeleton, it is replaced (not mixed from).\n     * @param loop If true, the animation will repeat. If false it will not, instead its last frame is applied if played beyond its\n     *           duration. In either case {@link TrackEntry#trackEnd} determines when the track is cleared.\n     * @returns A track entry to allow further customization of animation playback. References to the track entry must not be kept\n     *         after the {@link AnimationStateListener#dispose()} event occurs. */\n    setAnimationWith(trackIndex: number, animation: Animation, loop: boolean) {\n        if (animation == null) throw new Error('animation cannot be null.');\n        let interrupt = true;\n        let current = this.expandToIndex(trackIndex);\n\n        if (current != null) {\n            if (current.nextTrackLast == -1) {\n                // Don't mix from an entry that was never applied.\n                this.tracks[trackIndex] = current.mixingFrom;\n                this.queue.interrupt(current);\n                this.queue.end(current);\n                this.disposeNext(current);\n                current = current.mixingFrom;\n                interrupt = false;\n            } else this.disposeNext(current);\n        }\n        const entry = this.trackEntry(trackIndex, animation, loop, current);\n\n        this.setCurrent(trackIndex, entry, interrupt);\n        this.queue.drain();\n\n        return entry;\n    }\n\n    /** Queues an animation by name.\n     *\n     * See {@link #addAnimationWith()}. */\n    addAnimation(trackIndex: number, animationName: string, loop: boolean, delay: number) {\n        const animation = this.data.skeletonData.findAnimation(animationName);\n\n        if (animation == null) throw new Error(`Animation not found: ${animationName}`);\n\n        return this.addAnimationWith(trackIndex, animation, loop, delay);\n    }\n\n    /** Adds an animation to be played after the current or last queued animation for a track. If the track is empty, it is\n     * equivalent to calling {@link #setAnimationWith()}.\n     * @param delay If > 0, sets {@link TrackEntry#delay}. If <= 0, the delay set is the duration of the previous track entry\n     *           minus any mix duration (from the {@link AnimationStateData}) plus the specified `delay` (ie the mix\n     *           ends at (`delay` = 0) or before (`delay` < 0) the previous track entry duration). If the\n     *           previous entry is looping, its next loop completion is used instead of its duration.\n     * @returns A track entry to allow further customization of animation playback. References to the track entry must not be kept\n     *         after the {@link AnimationStateListener#dispose()} event occurs. */\n    addAnimationWith(trackIndex: number, animation: Animation, loop: boolean, delay: number) {\n        if (animation == null) throw new Error('animation cannot be null.');\n\n        let last = this.expandToIndex(trackIndex);\n\n        if (last != null) {\n            while (last.next != null) last = last.next;\n        }\n\n        const entry = this.trackEntry(trackIndex, animation, loop, last);\n\n        if (last == null) {\n            this.setCurrent(trackIndex, entry, true);\n            this.queue.drain();\n        } else {\n            last.next = entry;\n            if (delay <= 0) {\n                const duration = last.animationEnd - last.animationStart;\n\n                if (duration != 0) {\n                    if (last.loop) delay += duration * (1 + ((last.trackTime / duration) | 0));\n                    else delay += Math.max(duration, last.trackTime);\n                    delay -= this.data.getMix(last.animation, animation);\n                } else delay = last.trackTime;\n            }\n        }\n\n        entry.delay = delay;\n\n        return entry;\n    }\n\n    /** Sets an empty animation for a track, discarding any queued animations, and sets the track entry's\n     * {@link TrackEntry#mixduration}. An empty animation has no timelines and serves as a placeholder for mixing in or out.\n     *\n     * Mixing out is done by setting an empty animation with a mix duration using either {@link #setEmptyAnimation()},\n     * {@link #setEmptyAnimations()}, or {@link #addEmptyAnimation()}. Mixing to an empty animation causes\n     * the previous animation to be applied less and less over the mix duration. Properties keyed in the previous animation\n     * transition to the value from lower tracks or to the setup pose value if no lower tracks key the property. A mix duration of\n     * 0 still mixes out over one frame.\n     *\n     * Mixing in is done by first setting an empty animation, then adding an animation using\n     * {@link #addAnimation()} and on the returned track entry, set the\n     * {@link TrackEntry#setMixDuration()}. Mixing from an empty animation causes the new animation to be applied more and\n     * more over the mix duration. Properties keyed in the new animation transition from the value from lower tracks or from the\n     * setup pose value if no lower tracks key the property to the value keyed in the new animation. */\n    setEmptyAnimation(trackIndex: number, mixDuration: number) {\n        const entry = this.setAnimationWith(trackIndex, AnimationState.emptyAnimation, false);\n\n        entry.mixDuration = mixDuration;\n        entry.trackEnd = mixDuration;\n\n        return entry;\n    }\n\n    /** Adds an empty animation to be played after the current or last queued animation for a track, and sets the track entry's\n     * {@link TrackEntry#mixDuration}. If the track is empty, it is equivalent to calling\n     * {@link #setEmptyAnimation()}.\n     *\n     * See {@link #setEmptyAnimation()}.\n     * @param delay If > 0, sets {@link TrackEntry#delay}. If <= 0, the delay set is the duration of the previous track entry\n     *           minus any mix duration plus the specified `delay` (ie the mix ends at (`delay` = 0) or\n     *           before (`delay` < 0) the previous track entry duration). If the previous entry is looping, its next\n     *           loop completion is used instead of its duration.\n     * @return A track entry to allow further customization of animation playback. References to the track entry must not be kept\n     *         after the {@link AnimationStateListener#dispose()} event occurs. */\n    addEmptyAnimation(trackIndex: number, mixDuration: number, delay: number) {\n        if (delay <= 0) delay -= mixDuration;\n        const entry = this.addAnimationWith(trackIndex, AnimationState.emptyAnimation, false, delay);\n\n        entry.mixDuration = mixDuration;\n        entry.trackEnd = mixDuration;\n\n        return entry;\n    }\n\n    /** Sets an empty animation for every track, discarding any queued animations, and mixes to it over the specified mix\n     * duration. */\n    setEmptyAnimations(mixDuration: number) {\n        const oldDrainDisabled = this.queue.drainDisabled;\n\n        this.queue.drainDisabled = true;\n        for (let i = 0, n = this.tracks.length; i < n; i++) {\n            const current = this.tracks[i];\n\n            if (current != null) this.setEmptyAnimation(current.trackIndex, mixDuration);\n        }\n        this.queue.drainDisabled = oldDrainDisabled;\n        this.queue.drain();\n    }\n\n    expandToIndex(index: number) {\n        if (index < this.tracks.length) return this.tracks[index];\n        Utils.ensureArrayCapacity(this.tracks, index + 1, null);\n        this.tracks.length = index + 1;\n\n        return null;\n    }\n\n    /** @param last May be null. */\n    trackEntry(trackIndex: number, animation: Animation, loop: boolean, last: TrackEntry) {\n        const entry = this.trackEntryPool.obtain();\n\n        entry.trackIndex = trackIndex;\n        entry.animation = animation;\n        entry.loop = loop;\n        entry.holdPrevious = false;\n\n        entry.eventThreshold = 0;\n        entry.attachmentThreshold = 0;\n        entry.drawOrderThreshold = 0;\n\n        entry.animationStart = 0;\n        entry.animationEnd = animation.duration;\n        entry.animationLast = -1;\n        entry.nextAnimationLast = -1;\n\n        entry.delay = 0;\n        entry.trackTime = 0;\n        entry.trackLast = -1;\n        entry.nextTrackLast = -1;\n        entry.trackEnd = Number.MAX_VALUE;\n        entry.timeScale = 1;\n\n        entry.alpha = 1;\n        entry.interruptAlpha = 1;\n        entry.mixTime = 0;\n        entry.mixDuration = last == null ? 0 : this.data.getMix(last.animation, animation);\n        entry.mixBlend = MixBlend.replace;\n\n        return entry;\n    }\n\n    disposeNext(entry: TrackEntry) {\n        let next = entry.next;\n\n        while (next != null) {\n            this.queue.dispose(next);\n            next = next.next;\n        }\n        entry.next = null;\n    }\n\n    _animationsChanged() {\n        this.animationsChanged = false;\n\n        this.propertyIDs.clear();\n\n        for (let i = 0, n = this.tracks.length; i < n; i++) {\n            let entry = this.tracks[i];\n\n            if (entry == null) continue;\n            while (entry.mixingFrom != null) entry = entry.mixingFrom;\n\n            do {\n                if (entry.mixingFrom == null || entry.mixBlend != MixBlend.add) this.computeHold(entry);\n                entry = entry.mixingTo;\n            } while (entry != null);\n        }\n    }\n\n    computeHold(entry: TrackEntry) {\n        const to = entry.mixingTo;\n        const timelines = entry.animation.timelines;\n        const timelinesCount = entry.animation.timelines.length;\n        const timelineMode = Utils.setArraySize(entry.timelineMode, timelinesCount);\n\n        entry.timelineHoldMix.length = 0;\n        const timelineDipMix = Utils.setArraySize(entry.timelineHoldMix, timelinesCount);\n        const propertyIDs = this.propertyIDs;\n\n        if (to != null && to.holdPrevious) {\n            for (let i = 0; i < timelinesCount; i++) {\n                timelineMode[i] = propertyIDs.add(timelines[i].getPropertyId()) ? AnimationState.HOLD_FIRST : AnimationState.HOLD_SUBSEQUENT;\n            }\n\n            return;\n        }\n\n        // eslint-disable-next-line no-restricted-syntax, no-labels\n        outer: for (let i = 0; i < timelinesCount; i++) {\n            const timeline = timelines[i];\n            const id = timeline.getPropertyId();\n\n            if (!propertyIDs.add(id)) timelineMode[i] = AnimationState.SUBSEQUENT;\n            else if (\n                to == null ||\n                timeline instanceof AttachmentTimeline ||\n                timeline instanceof DrawOrderTimeline ||\n                timeline instanceof EventTimeline ||\n                !to.animation.hasTimeline(id)\n            ) {\n                timelineMode[i] = AnimationState.FIRST;\n            } else {\n                for (let next = to.mixingTo; next != null; next = next.mixingTo) {\n                    if (next.animation.hasTimeline(id)) continue;\n                    if (entry.mixDuration > 0) {\n                        timelineMode[i] = AnimationState.HOLD_MIX;\n                        timelineDipMix[i] = next;\n                        // eslint-disable-next-line no-labels\n                        continue outer;\n                    }\n                    break;\n                }\n                timelineMode[i] = AnimationState.HOLD_FIRST;\n            }\n        }\n    }\n\n    /** Returns the track entry for the animation currently playing on the track, or null if no animation is currently playing. */\n    getCurrent(trackIndex: number) {\n        if (trackIndex >= this.tracks.length) return null;\n\n        return this.tracks[trackIndex];\n    }\n\n    /** Adds a listener to receive events for all track entries. */\n    addListener(listener: AnimationStateListener) {\n        if (listener == null) throw new Error('listener cannot be null.');\n        this.listeners.push(listener);\n    }\n\n    /** Removes the listener added with {@link #addListener()}. */\n    removeListener(listener: AnimationStateListener) {\n        const index = this.listeners.indexOf(listener);\n\n        if (index >= 0) this.listeners.splice(index, 1);\n    }\n\n    /** Removes all listeners added with {@link #addListener()}. */\n    clearListeners() {\n        this.listeners.length = 0;\n    }\n\n    /** Discards all listener notifications that have not yet been delivered. This can be useful to call from an\n     * {@link AnimationStateListener} when it is known that further notifications that may have been already queued for delivery\n     * are not wanted because new animations are being set. */\n    clearListenerNotifications() {\n        this.queue.clear();\n    }\n\n    // deprecated stuff\n    onComplete: (trackIndex: number, loopCount: number) => any;\n    onEvent: (trackIndex: number, event: Event) => any;\n    onStart: (trackIndex: number) => any;\n    onEnd: (trackIndex: number) => any;\n\n    private static deprecatedWarning1 = false;\n\n    setAnimationByName(trackIndex: number, animationName: string, loop: boolean) {\n        if (!AnimationState.deprecatedWarning1) {\n            AnimationState.deprecatedWarning1 = true;\n            console.warn('Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.');\n        }\n        this.setAnimation(trackIndex, animationName, loop);\n    }\n\n    private static deprecatedWarning2 = false;\n\n    addAnimationByName(trackIndex: number, animationName: string, loop: boolean, delay: number) {\n        if (!AnimationState.deprecatedWarning2) {\n            AnimationState.deprecatedWarning2 = true;\n            console.warn('Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.');\n        }\n        this.addAnimation(trackIndex, animationName, loop, delay);\n    }\n\n    private static deprecatedWarning3 = false;\n\n    hasAnimation(animationName: string): boolean {\n        const animation = this.data.skeletonData.findAnimation(animationName);\n\n        return animation !== null;\n    }\n\n    hasAnimationByName(animationName: string): boolean {\n        if (!AnimationState.deprecatedWarning3) {\n            AnimationState.deprecatedWarning3 = true;\n            console.warn('Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.');\n        }\n\n        return this.hasAnimation(animationName);\n    }\n}\n\n/** Stores settings and other state for the playback of an animation on an {@link AnimationState} track.\n *\n * References to a track entry must not be kept after the {@link AnimationStateListener#dispose()} event occurs. */\n/**\n * @public\n */\nexport class TrackEntry implements ITrackEntry {\n    /** The animation to apply for this track entry. */\n    animation: Animation;\n\n    /** The animation queued to start after this animation, or null. `next` makes up a linked list. */\n    next: TrackEntry;\n\n    /** The track entry for the previous animation when mixing from the previous animation to this animation, or null if no\n     * mixing is currently occuring. When mixing from multiple animations, `mixingFrom` makes up a linked list. */\n    mixingFrom: TrackEntry;\n\n    /** The track entry for the next animation when mixing from this animation to the next animation, or null if no mixing is\n     * currently occuring. When mixing to multiple animations, `mixingTo` makes up a linked list. */\n    mixingTo: TrackEntry;\n\n    /** The listener for events generated by this track entry, or null.\n     *\n     * A track entry returned from {@link AnimationState#setAnimation()} is already the current animation\n     * for the track, so the track entry listener {@link AnimationStateListener#start()} will not be called. */\n    listener: AnimationStateListener;\n\n    /** The index of the track where this track entry is either current or queued.\n     *\n     * See {@link AnimationState#getCurrent()}. */\n    trackIndex: number;\n\n    /** If true, the animation will repeat. If false it will not, instead its last frame is applied if played beyond its\n     * duration. */\n    loop: boolean;\n\n    /** If true, when mixing from the previous animation to this animation, the previous animation is applied as normal instead\n     * of being mixed out.\n     *\n     * When mixing between animations that key the same property, if a lower track also keys that property then the value will\n     * briefly dip toward the lower track value during the mix. This happens because the first animation mixes from 100% to 0%\n     * while the second animation mixes from 0% to 100%. Setting `holdPrevious` to true applies the first animation\n     * at 100% during the mix so the lower track value is overwritten. Such dipping does not occur on the lowest track which\n     * keys the property, only when a higher track also keys the property.\n     *\n     * Snapping will occur if `holdPrevious` is true and this animation does not key all the same properties as the\n     * previous animation. */\n    holdPrevious: boolean;\n\n    /** When the mix percentage ({@link #mixTime} / {@link #mixDuration}) is less than the\n     * `eventThreshold`, event timelines are applied while this animation is being mixed out. Defaults to 0, so event\n     * timelines are not applied while this animation is being mixed out. */\n    eventThreshold: number;\n\n    /** When the mix percentage ({@link #mixtime} / {@link #mixDuration}) is less than the\n     * `attachmentThreshold`, attachment timelines are applied while this animation is being mixed out. Defaults to\n     * 0, so attachment timelines are not applied while this animation is being mixed out. */\n    attachmentThreshold: number;\n\n    /** When the mix percentage ({@link #mixTime} / {@link #mixDuration}) is less than the\n     * `drawOrderThreshold`, draw order timelines are applied while this animation is being mixed out. Defaults to 0,\n     * so draw order timelines are not applied while this animation is being mixed out. */\n    drawOrderThreshold: number;\n\n    /** Seconds when this animation starts, both initially and after looping. Defaults to 0.\n     *\n     * When changing the `animationStart` time, it often makes sense to set {@link #animationLast} to the same\n     * value to prevent timeline keys before the start time from triggering. */\n    animationStart: number;\n\n    /** Seconds for the last frame of this animation. Non-looping animations won't play past this time. Looping animations will\n     * loop back to {@link #animationStart} at this time. Defaults to the animation {@link Animation#duration}. */\n    animationEnd: number;\n\n    /** The time in seconds this animation was last applied. Some timelines use this for one-time triggers. Eg, when this\n     * animation is applied, event timelines will fire all events between the `animationLast` time (exclusive) and\n     * `animationTime` (inclusive). Defaults to -1 to ensure triggers on frame 0 happen the first time this animation\n     * is applied. */\n    animationLast: number;\n\n    nextAnimationLast: number;\n\n    /** Seconds to postpone playing the animation. When this track entry is the current track entry, `delay`\n     * postpones incrementing the {@link #trackTime}. When this track entry is queued, `delay` is the time from\n     * the start of the previous animation to when this track entry will become the current track entry (ie when the previous\n     * track entry {@link TrackEntry#trackTime} >= this track entry's `delay`).\n     *\n     * {@link #timeScale} affects the delay. */\n    delay: number;\n\n    /** Current time in seconds this track entry has been the current track entry. The track time determines\n     * {@link #animationTime}. The track time can be set to start the animation at a time other than 0, without affecting\n     * looping. */\n    trackTime: number;\n\n    trackLast: number;\n    nextTrackLast: number;\n\n    /** The track time in seconds when this animation will be removed from the track. Defaults to the highest possible float\n     * value, meaning the animation will be applied until a new animation is set or the track is cleared. If the track end time\n     * is reached, no other animations are queued for playback, and mixing from any previous animations is complete, then the\n     * properties keyed by the animation are set to the setup pose and the track is cleared.\n     *\n     * It may be desired to use {@link AnimationState#addEmptyAnimation()} rather than have the animation\n     * abruptly cease being applied. */\n    trackEnd: number;\n\n    /** Multiplier for the delta time when this track entry is updated, causing time for this animation to pass slower or\n     * faster. Defaults to 1.\n     *\n     * {@link #mixTime} is not affected by track entry time scale, so {@link #mixDuration} may need to be adjusted to\n     * match the animation speed.\n     *\n     * When using {@link AnimationState#addAnimation()} with a `delay` <= 0, note the\n     * {@link #delay} is set using the mix duration from the {@link AnimationStateData}, assuming time scale to be 1. If\n     * the time scale is not 1, the delay may need to be adjusted.\n     *\n     * See AnimationState {@link AnimationState#timeScale} for affecting all animations. */\n    timeScale: number;\n\n    /** Values < 1 mix this animation with the skeleton's current pose (usually the pose resulting from lower tracks). Defaults\n     * to 1, which overwrites the skeleton's current pose with this animation.\n     *\n     * Typically track 0 is used to completely pose the skeleton, then alpha is used on higher tracks. It doesn't make sense to\n     * use alpha on track 0 if the skeleton pose is from the last frame render. */\n    alpha: number;\n\n    /** Seconds from 0 to the {@link #getMixDuration()} when mixing from the previous animation to this animation. May be\n     * slightly more than `mixDuration` when the mix is complete. */\n    mixTime: number;\n\n    /** Seconds for mixing from the previous animation to this animation. Defaults to the value provided by AnimationStateData\n     * {@link AnimationStateData#getMix()} based on the animation before this animation (if any).\n     *\n     * A mix duration of 0 still mixes out over one frame to provide the track entry being mixed out a chance to revert the\n     * properties it was animating.\n     *\n     * The `mixDuration` can be set manually rather than use the value from\n     * {@link AnimationStateData#getMix()}. In that case, the `mixDuration` can be set for a new\n     * track entry only before {@link AnimationState#update(float)} is first called.\n     *\n     * When using {@link AnimationState#addAnimation()} with a `delay` <= 0, note the\n     * {@link #delay} is set using the mix duration from the {@link AnimationStateData}, not a mix duration set\n     * afterward. */\n    mixDuration: number;\n    interruptAlpha: number;\n    totalAlpha: number;\n\n    /** Controls how properties keyed in the animation are mixed with lower tracks. Defaults to {@link MixBlend#replace}, which\n     * replaces the values from the lower tracks with the animation values. {@link MixBlend#add} adds the animation values to\n     * the values from the lower tracks.\n     *\n     * The `mixBlend` can be set for a new track entry only before {@link AnimationState#apply()} is first\n     * called. */\n    mixBlend = MixBlend.replace;\n    timelineMode = new Array<number>();\n    timelineHoldMix = new Array<TrackEntry>();\n    timelinesRotation = new Array<number>();\n\n    reset() {\n        this.next = null;\n        this.mixingFrom = null;\n        this.mixingTo = null;\n        this.animation = null;\n        this.listener = null;\n        this.timelineMode.length = 0;\n        this.timelineHoldMix.length = 0;\n        this.timelinesRotation.length = 0;\n    }\n\n    /** Uses {@link #trackTime} to compute the `animationTime`, which is between {@link #animationStart}\n     * and {@link #animationEnd}. When the `trackTime` is 0, the `animationTime` is equal to the\n     * `animationStart` time. */\n    getAnimationTime() {\n        if (this.loop) {\n            const duration = this.animationEnd - this.animationStart;\n\n            if (duration == 0) return this.animationStart;\n\n            return (this.trackTime % duration) + this.animationStart;\n        }\n\n        return Math.min(this.trackTime + this.animationStart, this.animationEnd);\n    }\n\n    setAnimationLast(animationLast: number) {\n        this.animationLast = animationLast;\n        this.nextAnimationLast = animationLast;\n    }\n\n    /** Returns true if at least one loop has been completed.\n     *\n     * See {@link AnimationStateListener#complete()}. */\n    isComplete() {\n        return this.trackTime >= this.animationEnd - this.animationStart;\n    }\n\n    /** Resets the rotation directions for mixing this entry's rotate timelines. This can be useful to avoid bones rotating the\n     * long way around when using {@link #alpha} and starting animations on other tracks.\n     *\n     * Mixing with {@link MixBlend#replace} involves finding a rotation between two others, which has two possible solutions:\n     * the short way or the long way around. The two rotations likely change over time, so which direction is the short or long\n     * way also changes. If the short way was always chosen, bones would flip to the other side when that direction became the\n     * long way. TrackEntry chooses the short way the first time it is applied and remembers that direction. */\n    resetRotationDirections() {\n        this.timelinesRotation.length = 0;\n    }\n\n    // deprecated stuff\n    onComplete: (trackIndex: number, loopCount: number) => any;\n    onEvent: (trackIndex: number, event: Event) => any;\n    onStart: (trackIndex: number) => any;\n    onEnd: (trackIndex: number) => any;\n\n    private static deprecatedWarning1: Boolean = false;\n    private static deprecatedWarning2: Boolean = false;\n\n    get time() {\n        if (!TrackEntry.deprecatedWarning1) {\n            TrackEntry.deprecatedWarning1 = true;\n            console.warn('Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.');\n        }\n\n        return this.trackTime;\n    }\n\n    set time(value: number) {\n        if (!TrackEntry.deprecatedWarning1) {\n            TrackEntry.deprecatedWarning1 = true;\n            console.warn('Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.');\n        }\n        this.trackTime = value;\n    }\n\n    get endTime() {\n        if (!TrackEntry.deprecatedWarning2) {\n            TrackEntry.deprecatedWarning2 = true;\n            console.warn('Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.');\n        }\n\n        return this.trackTime;\n    }\n\n    set endTime(value: number) {\n        if (!TrackEntry.deprecatedWarning2) {\n            TrackEntry.deprecatedWarning2 = true;\n            console.warn('Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.');\n        }\n        this.trackTime = value;\n    }\n\n    loopsCount() {\n        return Math.floor(this.trackTime / this.trackEnd);\n    }\n}\n\n/**\n * @public\n */\nexport class EventQueue {\n    objects: Array<any> = [];\n    drainDisabled = false;\n    animState: AnimationState;\n\n    constructor(animState: AnimationState) {\n        this.animState = animState;\n    }\n\n    start(entry: TrackEntry) {\n        this.objects.push(EventType.start);\n        this.objects.push(entry);\n        this.animState.animationsChanged = true;\n    }\n\n    interrupt(entry: TrackEntry) {\n        this.objects.push(EventType.interrupt);\n        this.objects.push(entry);\n    }\n\n    end(entry: TrackEntry) {\n        this.objects.push(EventType.end);\n        this.objects.push(entry);\n        this.animState.animationsChanged = true;\n    }\n\n    dispose(entry: TrackEntry) {\n        this.objects.push(EventType.dispose);\n        this.objects.push(entry);\n    }\n\n    complete(entry: TrackEntry) {\n        this.objects.push(EventType.complete);\n        this.objects.push(entry);\n    }\n\n    event(entry: TrackEntry, event: Event) {\n        this.objects.push(EventType.event);\n        this.objects.push(entry);\n        this.objects.push(event);\n    }\n\n    private static deprecatedWarning1: Boolean = false;\n\n    deprecateStuff() {\n        if (!EventQueue.deprecatedWarning1) {\n            EventQueue.deprecatedWarning1 = true;\n            console.warn(\n                \"Spine Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'\"\n            );\n        }\n\n        return true;\n    }\n\n    drain() {\n        if (this.drainDisabled) return;\n        this.drainDisabled = true;\n\n        const objects = this.objects;\n        const listeners = this.animState.listeners;\n\n        for (let i = 0; i < objects.length; i += 2) {\n            const type = objects[i] as EventType;\n            const entry = objects[i + 1] as TrackEntry;\n\n            switch (type) {\n                case EventType.start:\n                    if (entry.listener != null && entry.listener.start) entry.listener.start(entry);\n                    for (let ii = 0; ii < listeners.length; ii++) if (listeners[ii].start) listeners[ii].start(entry);\n                    // deprecation\n                    entry.onStart && this.deprecateStuff() && entry.onStart(entry.trackIndex);\n                    this.animState.onStart && this.deprecateStuff() && this.deprecateStuff && this.animState.onStart(entry.trackIndex);\n                    break;\n                case EventType.interrupt:\n                    if (entry.listener != null && entry.listener.interrupt) entry.listener.interrupt(entry);\n                    for (let ii = 0; ii < listeners.length; ii++) if (listeners[ii].interrupt) listeners[ii].interrupt(entry);\n                    break;\n                case EventType.end:\n                    if (entry.listener != null && entry.listener.end) entry.listener.end(entry);\n                    for (let ii = 0; ii < listeners.length; ii++) if (listeners[ii].end) listeners[ii].end(entry);\n                    // deprecation\n                    entry.onEnd && this.deprecateStuff() && entry.onEnd(entry.trackIndex);\n                    this.animState.onEnd && this.deprecateStuff() && this.animState.onEnd(entry.trackIndex);\n                // Fall through.\n                case EventType.dispose:\n                    if (entry.listener != null && entry.listener.dispose) entry.listener.dispose(entry);\n                    for (let ii = 0; ii < listeners.length; ii++) if (listeners[ii].dispose) listeners[ii].dispose(entry);\n                    this.animState.trackEntryPool.free(entry);\n                    break;\n                case EventType.complete:\n                    if (entry.listener != null && entry.listener.complete) entry.listener.complete(entry);\n                    for (let ii = 0; ii < listeners.length; ii++) if (listeners[ii].complete) listeners[ii].complete(entry);\n                    // deprecation\n\n                    const count = MathUtils.toInt(entry.loopsCount());\n\n                    entry.onComplete && this.deprecateStuff() && entry.onComplete(entry.trackIndex, count);\n                    this.animState.onComplete && this.deprecateStuff() && this.animState.onComplete(entry.trackIndex, count);\n                    break;\n                case EventType.event:\n                    const event = objects[i++ + 2] as Event;\n\n                    if (entry.listener != null && entry.listener.event) entry.listener.event(entry, event);\n                    for (let ii = 0; ii < listeners.length; ii++) if (listeners[ii].event) listeners[ii].event(entry, event);\n                    // deprecation\n                    entry.onEvent && this.deprecateStuff() && entry.onEvent(entry.trackIndex, event);\n                    this.animState.onEvent && this.deprecateStuff() && this.animState.onEvent(entry.trackIndex, event);\n                    break;\n            }\n        }\n        this.clear();\n\n        this.drainDisabled = false;\n    }\n\n    clear() {\n        this.objects.length = 0;\n    }\n}\n\n/**\n * @public\n */\nexport enum EventType {\n    start,\n    interrupt,\n    end,\n    dispose,\n    complete,\n    event,\n}\n\n/**\n * @public\n */\nexport interface AnimationStateListener extends IAnimationStateListener {\n    /** Invoked when this entry has been set as the current entry. */\n    start?(entry: TrackEntry): void;\n\n    /** Invoked when another entry has replaced this entry as the current entry. This entry may continue being applied for\n     * mixing. */\n    interrupt?(entry: TrackEntry): void;\n\n    /** Invoked when this entry is no longer the current entry and will never be applied again. */\n    end?(entry: TrackEntry): void;\n\n    /** Invoked when this entry will be disposed. This may occur without the entry ever being set as the current entry.\n     * References to the entry should not be kept after dispose is called, as it may be destroyed or reused. */\n    dispose?(entry: TrackEntry): void;\n\n    /** Invoked every time this entry's animation completes a loop. */\n    complete?(entry: TrackEntry): void;\n\n    /** Invoked when this entry's animation triggers an event. */\n    event?(entry: TrackEntry, event: Event): void;\n}\n\n/**\n * @public\n */\nexport abstract class AnimationStateAdapter implements AnimationStateListener {\n    start(entry: TrackEntry) {}\n\n    interrupt(entry: TrackEntry) {}\n\n    end(entry: TrackEntry) {}\n\n    dispose(entry: TrackEntry) {}\n\n    complete(entry: TrackEntry) {}\n\n    event(entry: TrackEntry, event: Event) {}\n}\n","import type { SkeletonData } from './SkeletonData';\nimport type { IAnimation, IAnimationStateData, Map } from '@pixi-spine/base';\nimport type { Animation } from './Animation';\n\n/**\n * @public\n */\nexport class AnimationStateData implements IAnimationStateData<SkeletonData, Animation> {\n    skeletonData: SkeletonData;\n    animationToMixTime: Map<number> = {};\n    defaultMix = 0;\n\n    constructor(skeletonData: SkeletonData) {\n        if (skeletonData == null) throw new Error('skeletonData cannot be null.');\n        this.skeletonData = skeletonData;\n    }\n\n    setMix(fromName: string, toName: string, duration: number) {\n        const from = this.skeletonData.findAnimation(fromName);\n\n        if (from == null) throw new Error(`Animation not found: ${fromName}`);\n        const to = this.skeletonData.findAnimation(toName);\n\n        if (to == null) throw new Error(`Animation not found: ${toName}`);\n        this.setMixWith(from, to, duration);\n    }\n\n    private static deprecatedWarning1 = false;\n\n    setMixByName(fromName: string, toName: string, duration: number) {\n        if (!AnimationStateData.deprecatedWarning1) {\n            AnimationStateData.deprecatedWarning1 = true;\n            console.warn('Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.');\n        }\n        this.setMix(fromName, toName, duration);\n    }\n\n    setMixWith(from: IAnimation, to: IAnimation, duration: number) {\n        if (from == null) throw new Error('from cannot be null.');\n        if (to == null) throw new Error('to cannot be null.');\n        const key = `${from.name}.${to.name}`;\n\n        this.animationToMixTime[key] = duration;\n    }\n\n    getMix(from: IAnimation, to: IAnimation) {\n        const key = `${from.name}.${to.name}`;\n        const value = this.animationToMixTime[key];\n\n        return value === undefined ? this.defaultMix : value;\n    }\n}\n","import { AttachmentLoader, RegionAttachment, MeshAttachment, BoundingBoxAttachment, PathAttachment, PointAttachment, ClippingAttachment } from './attachments';\nimport type { TextureAtlas } from '@pixi-spine/base';\nimport type { Skin } from './Skin';\n\n/**\n * @public\n */\nexport class AtlasAttachmentLoader implements AttachmentLoader {\n    atlas: TextureAtlas;\n\n    constructor(atlas: TextureAtlas) {\n        this.atlas = atlas;\n    }\n\n    /** @return May be null to not load an attachment. */\n    newRegionAttachment(skin: Skin, name: string, path: string): RegionAttachment {\n        const region = this.atlas.findRegion(path);\n\n        if (region == null) throw new Error(`Region not found in atlas: ${path} (region attachment: ${name})`);\n        const attachment = new RegionAttachment(name);\n\n        attachment.region = region;\n\n        return attachment;\n    }\n\n    /** @return May be null to not load an attachment. */\n    newMeshAttachment(skin: Skin, name: string, path: string): MeshAttachment {\n        const region = this.atlas.findRegion(path);\n\n        if (region == null) throw new Error(`Region not found in atlas: ${path} (mesh attachment: ${name})`);\n        const attachment = new MeshAttachment(name);\n\n        attachment.region = region;\n\n        return attachment;\n    }\n\n    /** @return May be null to not load an attachment. */\n    newBoundingBoxAttachment(skin: Skin, name: string): BoundingBoxAttachment {\n        return new BoundingBoxAttachment(name);\n    }\n\n    /** @return May be null to not load an attachment */\n    newPathAttachment(skin: Skin, name: string): PathAttachment {\n        return new PathAttachment(name);\n    }\n\n    newPointAttachment(skin: Skin, name: string): PointAttachment {\n        return new PointAttachment(name);\n    }\n\n    newClippingAttachment(skin: Skin, name: string): ClippingAttachment {\n        return new ClippingAttachment(name);\n    }\n}\n","import { Matrix } from '@pixi/core';\nimport type { Updatable } from './Updatable';\nimport type { BoneData } from './BoneData';\nimport type { Skeleton } from './Skeleton';\nimport { IBone, MathUtils, settings, TransformMode, Vector2 } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class Bone implements Updatable, IBone {\n    // be careful! Spine b,c is c,b in pixi matrix\n    matrix = new Matrix();\n\n    get worldX(): number {\n        return this.matrix.tx;\n    }\n\n    get worldY(): number {\n        return this.matrix.ty;\n    }\n\n    data: BoneData;\n    skeleton: Skeleton;\n    parent: Bone;\n    children = new Array<Bone>();\n    x = 0;\n    y = 0;\n    rotation = 0;\n    scaleX = 0;\n    scaleY = 0;\n    shearX = 0;\n    shearY = 0;\n    ax = 0;\n    ay = 0;\n    arotation = 0;\n    ascaleX = 0;\n    ascaleY = 0;\n    ashearX = 0;\n    ashearY = 0;\n    appliedValid = false;\n\n    sorted = false;\n    active = false;\n\n    /** @param parent May be null. */\n    constructor(data: BoneData, skeleton: Skeleton, parent: Bone) {\n        if (data == null) throw new Error('data cannot be null.');\n        if (skeleton == null) throw new Error('skeleton cannot be null.');\n        this.data = data;\n        this.skeleton = skeleton;\n        this.parent = parent;\n        this.setToSetupPose();\n    }\n\n    isActive() {\n        return this.active;\n    }\n\n    /** Same as {@link #updateWorldTransform()}. This method exists for Bone to implement {@link Updatable}. */\n    update() {\n        this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\n    }\n\n    /** Computes the world transform using the parent bone and this bone's local transform. */\n    updateWorldTransform() {\n        this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\n    }\n\n    /** Computes the world transform using the parent bone and the specified local transform. */\n    updateWorldTransformWith(x: number, y: number, rotation: number, scaleX: number, scaleY: number, shearX: number, shearY: number) {\n        this.ax = x;\n        this.ay = y;\n        this.arotation = rotation;\n        this.ascaleX = scaleX;\n        this.ascaleY = scaleY;\n        this.ashearX = shearX;\n        this.ashearY = shearY;\n        this.appliedValid = true;\n\n        const parent = this.parent;\n        const m = this.matrix;\n\n        const sx = this.skeleton.scaleX;\n        const sy = settings.yDown ? -this.skeleton.scaleY : this.skeleton.scaleY;\n\n        if (parent == null) {\n            // Root bone.\n            const skeleton = this.skeleton;\n            const rotationY = rotation + 90 + shearY;\n\n            m.a = MathUtils.cosDeg(rotation + shearX) * scaleX * sx;\n            m.c = MathUtils.cosDeg(rotationY) * scaleY * sx;\n            m.b = MathUtils.sinDeg(rotation + shearX) * scaleX * sy;\n            m.d = MathUtils.sinDeg(rotationY) * scaleY * sy;\n            m.tx = x * sx + skeleton.x;\n            m.ty = y * sy + skeleton.y;\n\n            return;\n        }\n\n        let pa = parent.matrix.a;\n        let pb = parent.matrix.c;\n        let pc = parent.matrix.b;\n        let pd = parent.matrix.d;\n\n        m.tx = pa * x + pb * y + parent.matrix.tx;\n        m.ty = pc * x + pd * y + parent.matrix.ty;\n        switch (this.data.transformMode) {\n            case TransformMode.Normal: {\n                const rotationY = rotation + 90 + shearY;\n                const la = MathUtils.cosDeg(rotation + shearX) * scaleX;\n                const lb = MathUtils.cosDeg(rotationY) * scaleY;\n                const lc = MathUtils.sinDeg(rotation + shearX) * scaleX;\n                const ld = MathUtils.sinDeg(rotationY) * scaleY;\n\n                m.a = pa * la + pb * lc;\n                m.c = pa * lb + pb * ld;\n                m.b = pc * la + pd * lc;\n                m.d = pc * lb + pd * ld;\n\n                return;\n            }\n            case TransformMode.OnlyTranslation: {\n                const rotationY = rotation + 90 + shearY;\n\n                m.a = MathUtils.cosDeg(rotation + shearX) * scaleX;\n                m.c = MathUtils.cosDeg(rotationY) * scaleY;\n                m.b = MathUtils.sinDeg(rotation + shearX) * scaleX;\n                m.d = MathUtils.sinDeg(rotationY) * scaleY;\n                break;\n            }\n            case TransformMode.NoRotationOrReflection: {\n                let s = pa * pa + pc * pc;\n                let prx = 0;\n\n                if (s > 0.0001) {\n                    s = Math.abs(pa * pd - pb * pc) / s;\n                    pa /= this.skeleton.scaleX;\n                    pc /= this.skeleton.scaleY;\n                    pb = pc * s;\n                    pd = pa * s;\n                    prx = Math.atan2(pc, pa) * MathUtils.radDeg;\n                } else {\n                    pa = 0;\n                    pc = 0;\n                    prx = 90 - Math.atan2(pd, pb) * MathUtils.radDeg;\n                }\n                const rx = rotation + shearX - prx;\n                const ry = rotation + shearY - prx + 90;\n                const la = MathUtils.cosDeg(rx) * scaleX;\n                const lb = MathUtils.cosDeg(ry) * scaleY;\n                const lc = MathUtils.sinDeg(rx) * scaleX;\n                const ld = MathUtils.sinDeg(ry) * scaleY;\n\n                m.a = pa * la - pb * lc;\n                m.c = pa * lb - pb * ld;\n                m.b = pc * la + pd * lc;\n                m.d = pc * lb + pd * ld;\n                break;\n            }\n            case TransformMode.NoScale:\n            case TransformMode.NoScaleOrReflection: {\n                const cos = MathUtils.cosDeg(rotation);\n                const sin = MathUtils.sinDeg(rotation);\n                let za = (pa * cos + pb * sin) / sx;\n                let zc = (pc * cos + pd * sin) / sy;\n                let s = Math.sqrt(za * za + zc * zc);\n\n                if (s > 0.00001) s = 1 / s;\n                za *= s;\n                zc *= s;\n                s = Math.sqrt(za * za + zc * zc);\n                if (\n                    this.data.transformMode == TransformMode.NoScale &&\n                    pa * pd - pb * pc < 0 != (settings.yDown ? this.skeleton.scaleX < 0 != this.skeleton.scaleY > 0 : this.skeleton.scaleX < 0 != this.skeleton.scaleY < 0)\n                )\n                    s = -s;\n                const r = Math.PI / 2 + Math.atan2(zc, za);\n                const zb = Math.cos(r) * s;\n                const zd = Math.sin(r) * s;\n                const la = MathUtils.cosDeg(shearX) * scaleX;\n                const lb = MathUtils.cosDeg(90 + shearY) * scaleY;\n                const lc = MathUtils.sinDeg(shearX) * scaleX;\n                const ld = MathUtils.sinDeg(90 + shearY) * scaleY;\n\n                m.a = za * la + zb * lc;\n                m.c = za * lb + zb * ld;\n                m.b = zc * la + zd * lc;\n                m.d = zc * lb + zd * ld;\n                break;\n            }\n        }\n        m.a *= sx;\n        m.c *= sx;\n        m.b *= sy;\n        m.d *= sy;\n    }\n\n    setToSetupPose() {\n        const data = this.data;\n\n        this.x = data.x;\n        this.y = data.y;\n        this.rotation = data.rotation;\n        this.scaleX = data.scaleX;\n        this.scaleY = data.scaleY;\n        this.shearX = data.shearX;\n        this.shearY = data.shearY;\n    }\n\n    getWorldRotationX() {\n        return Math.atan2(this.matrix.b, this.matrix.a) * MathUtils.radDeg;\n    }\n\n    getWorldRotationY() {\n        return Math.atan2(this.matrix.d, this.matrix.c) * MathUtils.radDeg;\n    }\n\n    getWorldScaleX() {\n        const m = this.matrix;\n\n        return Math.sqrt(m.a * m.a + m.c * m.c);\n    }\n\n    getWorldScaleY() {\n        const m = this.matrix;\n\n        return Math.sqrt(m.b * m.b + m.d * m.d);\n    }\n\n    /** Computes the individual applied transform values from the world transform. This can be useful to perform processing using\n     * the applied transform after the world transform has been modified directly (eg, by a constraint).\n     * <p>\n     * Some information is ambiguous in the world transform, such as -1,-1 scale versus 180 rotation. */\n    updateAppliedTransform() {\n        this.appliedValid = true;\n        const parent = this.parent;\n        const m = this.matrix;\n\n        if (parent == null) {\n            this.ax = m.tx;\n            this.ay = m.ty;\n            this.arotation = Math.atan2(m.b, m.a) * MathUtils.radDeg;\n            this.ascaleX = Math.sqrt(m.a * m.a + m.b * m.b);\n            this.ascaleY = Math.sqrt(m.c * m.c + m.d * m.d);\n            this.ashearX = 0;\n            this.ashearY = Math.atan2(m.a * m.c + m.b * m.d, m.a * m.d - m.b * m.c) * MathUtils.radDeg;\n\n            return;\n        }\n        const pm = parent.matrix;\n        const pid = 1 / (pm.a * pm.d - pm.b * pm.c);\n        const dx = m.tx - pm.tx;\n        const dy = m.ty - pm.ty;\n\n        this.ax = dx * pm.d * pid - dy * pm.c * pid;\n        this.ay = dy * pm.a * pid - dx * pm.b * pid;\n        const ia = pid * pm.d;\n        const id = pid * pm.a;\n        const ib = pid * pm.c;\n        const ic = pid * pm.b;\n        const ra = ia * m.a - ib * m.b;\n        const rb = ia * m.c - ib * m.d;\n        const rc = id * m.b - ic * m.a;\n        const rd = id * m.d - ic * m.c;\n\n        this.ashearX = 0;\n        this.ascaleX = Math.sqrt(ra * ra + rc * rc);\n        if (this.ascaleX > 0.0001) {\n            const det = ra * rd - rb * rc;\n\n            this.ascaleY = det / this.ascaleX;\n            this.ashearY = Math.atan2(ra * rb + rc * rd, det) * MathUtils.radDeg;\n            this.arotation = Math.atan2(rc, ra) * MathUtils.radDeg;\n        } else {\n            this.ascaleX = 0;\n            this.ascaleY = Math.sqrt(rb * rb + rd * rd);\n            this.ashearY = 0;\n            this.arotation = 90 - Math.atan2(rd, rb) * MathUtils.radDeg;\n        }\n    }\n\n    worldToLocal(world: Vector2) {\n        const m = this.matrix;\n        const a = m.a;\n        const b = m.c;\n        const c = m.b;\n        const d = m.d;\n        const invDet = 1 / (a * d - b * c);\n        const x = world.x - m.tx;\n        const y = world.y - m.ty;\n\n        world.x = x * d * invDet - y * b * invDet;\n        world.y = y * a * invDet - x * c * invDet;\n\n        return world;\n    }\n\n    localToWorld(local: Vector2) {\n        const m = this.matrix;\n        const x = local.x;\n        const y = local.y;\n\n        local.x = x * m.a + y * m.c + m.tx;\n        local.y = x * m.b + y * m.d + m.ty;\n\n        return local;\n    }\n\n    worldToLocalRotation(worldRotation: number) {\n        const sin = MathUtils.sinDeg(worldRotation);\n        const cos = MathUtils.cosDeg(worldRotation);\n        const mat = this.matrix;\n\n        return Math.atan2(mat.a * sin - mat.b * cos, mat.d * cos - mat.c * sin) * MathUtils.radDeg;\n    }\n\n    localToWorldRotation(localRotation: number) {\n        const sin = MathUtils.sinDeg(localRotation);\n        const cos = MathUtils.cosDeg(localRotation);\n        const mat = this.matrix;\n\n        return Math.atan2(cos * mat.b + sin * mat.d, cos * mat.a + sin * mat.c) * MathUtils.radDeg;\n    }\n\n    rotateWorld(degrees: number) {\n        const mat = this.matrix;\n        const a = mat.a;\n        const b = mat.c;\n        const c = mat.b;\n        const d = mat.d;\n        const cos = MathUtils.cosDeg(degrees);\n        const sin = MathUtils.sinDeg(degrees);\n\n        mat.a = cos * a - sin * c;\n        mat.c = cos * b - sin * d;\n        mat.b = sin * a + cos * c;\n        mat.d = sin * b + cos * d;\n        this.appliedValid = false;\n    }\n}\n","import { Color, TransformMode } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class BoneData {\n    index: number;\n    name: string;\n    parent: BoneData;\n    length: number;\n    x = 0;\n    y = 0;\n    rotation = 0;\n    scaleX = 1;\n    scaleY = 1;\n    shearX = 0;\n    shearY = 0;\n    transformMode = TransformMode.Normal;\n    skinRequired = false;\n    inheritRotation = true;\n    inheritScale = true;\n    color = new Color();\n\n    constructor(index: number, name: string, parent: BoneData) {\n        if (index < 0) throw new Error('index must be >= 0.');\n        if (name == null) throw new Error('name cannot be null.');\n        this.index = index;\n        this.name = name;\n        this.parent = parent;\n    }\n}\n","/**\n * @public\n */\nexport abstract class ConstraintData {\n    constructor(public name: string, public order: number, public skinRequired: boolean) {}\n}\n","import type { EventData } from './EventData';\nimport type { IEvent } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class Event implements IEvent {\n    data: EventData;\n    intValue: number;\n    floatValue: number;\n    stringValue: string;\n    time: number;\n    volume: number;\n    balance: number;\n\n    constructor(time: number, data: EventData) {\n        if (data == null) throw new Error('data cannot be null.');\n        this.time = time;\n        this.data = data;\n    }\n}\n","import type { IEventData } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class EventData implements IEventData {\n    name: string;\n    intValue: number;\n    floatValue: number;\n    stringValue: string;\n    audioPath: string;\n    volume: number;\n    balance: number;\n\n    constructor(name: string) {\n        this.name = name;\n    }\n}\n","import type { Updatable } from './Updatable';\nimport type { IkConstraintData } from './IkConstraintData';\nimport type { Bone } from './Bone';\nimport type { Skeleton } from './Skeleton';\nimport { IIkConstraint, MathUtils, TransformMode } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class IkConstraint implements IIkConstraint, Updatable {\n    data: IkConstraintData;\n    bones: Array<Bone>;\n    target: Bone;\n    bendDirection = 0;\n    compress = false;\n    stretch = false;\n    mix = 1;\n    softness = 0;\n    active = false;\n\n    constructor(data: IkConstraintData, skeleton: Skeleton) {\n        if (data == null) throw new Error('data cannot be null.');\n        if (skeleton == null) throw new Error('skeleton cannot be null.');\n        this.data = data;\n        this.mix = data.mix;\n        this.softness = data.softness;\n        this.bendDirection = data.bendDirection;\n        this.compress = data.compress;\n        this.stretch = data.stretch;\n\n        this.bones = new Array<Bone>();\n        for (let i = 0; i < data.bones.length; i++) this.bones.push(skeleton.findBone(data.bones[i].name));\n        this.target = skeleton.findBone(data.target.name);\n    }\n\n    isActive() {\n        return this.active;\n    }\n\n    apply() {\n        this.update();\n    }\n\n    update() {\n        const target = this.target;\n        const bones = this.bones;\n\n        switch (bones.length) {\n            case 1:\n                this.apply1(bones[0], target.worldX, target.worldY, this.compress, this.stretch, this.data.uniform, this.mix);\n                break;\n            case 2:\n                this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.stretch, this.softness, this.mix);\n                break;\n        }\n    }\n\n    /** Adjusts the bone rotation so the tip is as close to the target position as possible. The target is specified in the world\n     * coordinate system. */\n    apply1(bone: Bone, targetX: number, targetY: number, compress: boolean, stretch: boolean, uniform: boolean, alpha: number) {\n        if (!bone.appliedValid) bone.updateAppliedTransform();\n        const p = bone.parent.matrix;\n\n        const pa = p.a;\n        let pb = p.c;\n        const pc = p.b;\n        let pd = p.d;\n        let rotationIK = -bone.ashearX - bone.arotation;\n        let tx = 0;\n        let ty = 0;\n\n        switch (bone.data.transformMode) {\n            case TransformMode.OnlyTranslation:\n                tx = targetX - bone.worldX;\n                ty = targetY - bone.worldY;\n                break;\n            case TransformMode.NoRotationOrReflection:\n                const s = Math.abs(pa * pd - pb * pc) / (pa * pa + pc * pc);\n                const sa = pa / bone.skeleton.scaleX;\n                const sc = pc / bone.skeleton.scaleY;\n\n                pb = -sc * s * bone.skeleton.scaleX;\n                pd = sa * s * bone.skeleton.scaleY;\n                rotationIK += Math.atan2(sc, sa) * MathUtils.radDeg;\n            // Fall through\n            default:\n                const x = targetX - p.tx;\n                const y = targetY - p.ty;\n                const d = pa * pd - pb * pc;\n\n                tx = (x * pd - y * pb) / d - bone.ax;\n                ty = (y * pa - x * pc) / d - bone.ay;\n        }\n        rotationIK += Math.atan2(ty, tx) * MathUtils.radDeg;\n\n        if (bone.ascaleX < 0) rotationIK += 180;\n        if (rotationIK > 180) rotationIK -= 360;\n        else if (rotationIK < -180) rotationIK += 360;\n        let sx = bone.ascaleX;\n        let sy = bone.ascaleY;\n\n        if (compress || stretch) {\n            switch (bone.data.transformMode) {\n                case TransformMode.NoScale:\n                case TransformMode.NoScaleOrReflection:\n                    tx = targetX - bone.worldX;\n                    ty = targetY - bone.worldY;\n            }\n            const b = bone.data.length * sx;\n            const dd = Math.sqrt(tx * tx + ty * ty);\n\n            if ((compress && dd < b) || (stretch && dd > b && b > 0.0001)) {\n                const s = (dd / b - 1) * alpha + 1;\n\n                sx *= s;\n                if (uniform) sy *= s;\n            }\n        }\n        bone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, sx, sy, bone.ashearX, bone.ashearY);\n    }\n\n    /** Adjusts the parent and child bone rotations so the tip of the child is as close to the target position as possible. The\n     * target is specified in the world coordinate system.\n     * @param child A direct descendant of the parent bone. */\n    apply2(parent: Bone, child: Bone, targetX: number, targetY: number, bendDir: number, stretch: boolean, softness: number, alpha: number) {\n        if (alpha == 0) {\n            child.updateWorldTransform();\n\n            return;\n        }\n        if (!parent.appliedValid) parent.updateAppliedTransform();\n        if (!child.appliedValid) child.updateAppliedTransform();\n        const px = parent.ax;\n        const py = parent.ay;\n        let psx = parent.ascaleX;\n        let sx = psx;\n        let psy = parent.ascaleY;\n        let csx = child.ascaleX;\n        const pmat = parent.matrix;\n        let os1 = 0;\n        let os2 = 0;\n        let s2 = 0;\n\n        if (psx < 0) {\n            psx = -psx;\n            os1 = 180;\n            s2 = -1;\n        } else {\n            os1 = 0;\n            s2 = 1;\n        }\n        if (psy < 0) {\n            psy = -psy;\n            s2 = -s2;\n        }\n        if (csx < 0) {\n            csx = -csx;\n            os2 = 180;\n        } else os2 = 0;\n        const cx = child.ax;\n        let cy = 0;\n        let cwx = 0;\n        let cwy = 0;\n        let a = pmat.a;\n        let b = pmat.c;\n        let c = pmat.b;\n        let d = pmat.d;\n        const u = Math.abs(psx - psy) <= 0.0001;\n\n        if (!u) {\n            cy = 0;\n            cwx = a * cx + pmat.tx;\n            cwy = c * cx + pmat.ty;\n        } else {\n            cy = child.ay;\n            cwx = a * cx + b * cy + pmat.tx;\n            cwy = c * cx + d * cy + pmat.ty;\n        }\n        const pp = parent.parent.matrix;\n\n        a = pp.a;\n        b = pp.c;\n        c = pp.b;\n        d = pp.d;\n        const id = 1 / (a * d - b * c);\n        let x = cwx - pp.tx;\n        let y = cwy - pp.ty;\n        const dx = (x * d - y * b) * id - px;\n        const dy = (y * a - x * c) * id - py;\n        const l1 = Math.sqrt(dx * dx + dy * dy);\n        let l2 = child.data.length * csx;\n        let a1;\n        let a2;\n\n        if (l1 < 0.0001) {\n            this.apply1(parent, targetX, targetY, false, stretch, false, alpha);\n            child.updateWorldTransformWith(cx, cy, 0, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\n\n            return;\n        }\n        x = targetX - pp.tx;\n        y = targetY - pp.ty;\n        let tx = (x * d - y * b) * id - px;\n        let ty = (y * a - x * c) * id - py;\n        let dd = tx * tx + ty * ty;\n\n        if (softness != 0) {\n            softness *= (psx * (csx + 1)) / 2;\n            const td = Math.sqrt(dd);\n            const sd = td - l1 - l2 * psx + softness;\n\n            if (sd > 0) {\n                let p = Math.min(1, sd / (softness * 2)) - 1;\n\n                p = (sd - softness * (1 - p * p)) / td;\n                tx -= p * tx;\n                ty -= p * ty;\n                dd = tx * tx + ty * ty;\n            }\n        }\n        // eslint-disable-next-line no-restricted-syntax, no-labels\n        outer: if (u) {\n            l2 *= psx;\n            let cos = (dd - l1 * l1 - l2 * l2) / (2 * l1 * l2);\n\n            if (cos < -1) cos = -1;\n            else if (cos > 1) {\n                cos = 1;\n                if (stretch) sx *= (Math.sqrt(dd) / (l1 + l2) - 1) * alpha + 1;\n            }\n            a2 = Math.acos(cos) * bendDir;\n            a = l1 + l2 * cos;\n            b = l2 * Math.sin(a2);\n            a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);\n        } else {\n            a = psx * l2;\n            b = psy * l2;\n            const aa = a * a;\n            const bb = b * b;\n            const ta = Math.atan2(ty, tx);\n\n            c = bb * l1 * l1 + aa * dd - aa * bb;\n            const c1 = -2 * bb * l1;\n            const c2 = bb - aa;\n\n            d = c1 * c1 - 4 * c2 * c;\n            if (d >= 0) {\n                let q = Math.sqrt(d);\n\n                if (c1 < 0) q = -q;\n                q = -(c1 + q) / 2;\n                const r0 = q / c2;\n                const r1 = c / q;\n                const r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;\n\n                if (r * r <= dd) {\n                    y = Math.sqrt(dd - r * r) * bendDir;\n                    a1 = ta - Math.atan2(y, r);\n                    a2 = Math.atan2(y / psy, (r - l1) / psx);\n                    // eslint-disable-next-line no-labels\n                    break outer;\n                }\n            }\n            let minAngle = MathUtils.PI;\n            let minX = l1 - a;\n            let minDist = minX * minX;\n            let minY = 0;\n            let maxAngle = 0;\n            let maxX = l1 + a;\n            let maxDist = maxX * maxX;\n            let maxY = 0;\n\n            c = (-a * l1) / (aa - bb);\n            if (c >= -1 && c <= 1) {\n                c = Math.acos(c);\n                x = a * Math.cos(c) + l1;\n                y = b * Math.sin(c);\n                d = x * x + y * y;\n                if (d < minDist) {\n                    minAngle = c;\n                    minDist = d;\n                    minX = x;\n                    minY = y;\n                }\n                if (d > maxDist) {\n                    maxAngle = c;\n                    maxDist = d;\n                    maxX = x;\n                    maxY = y;\n                }\n            }\n            if (dd <= (minDist + maxDist) / 2) {\n                a1 = ta - Math.atan2(minY * bendDir, minX);\n                a2 = minAngle * bendDir;\n            } else {\n                a1 = ta - Math.atan2(maxY * bendDir, maxX);\n                a2 = maxAngle * bendDir;\n            }\n        }\n        const os = Math.atan2(cy, cx) * s2;\n        let rotation = parent.arotation;\n\n        a1 = (a1 - os) * MathUtils.radDeg + os1 - rotation;\n        if (a1 > 180) a1 -= 360;\n        else if (a1 < -180) a1 += 360;\n        parent.updateWorldTransformWith(px, py, rotation + a1 * alpha, sx, parent.ascaleY, 0, 0);\n        rotation = child.arotation;\n        a2 = ((a2 + os) * MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;\n        if (a2 > 180) a2 -= 360;\n        else if (a2 < -180) a2 += 360;\n        child.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\n    }\n}\n","import { ConstraintData } from './Constraint';\nimport type { BoneData } from './BoneData';\nimport type { IIkConstraintData } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class IkConstraintData extends ConstraintData implements IIkConstraintData {\n    bones = new Array<BoneData>();\n    target: BoneData;\n    bendDirection = 1;\n    compress = false;\n    stretch = false;\n    uniform = false;\n    mix = 1;\n    softness = 0;\n\n    constructor(name: string) {\n        super(name, 0, false);\n    }\n}\n","import { ConstraintData } from './Constraint';\nimport type { SlotData } from './SlotData';\nimport type { BoneData } from './BoneData';\nimport type { RotateMode, PositionMode } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class PathConstraintData extends ConstraintData {\n    bones = new Array<BoneData>();\n    target: SlotData;\n    positionMode: PositionMode;\n    spacingMode: SpacingMode;\n    rotateMode: RotateMode;\n    offsetRotation: number;\n    position: number;\n    spacing: number;\n    rotateMix: number;\n    translateMix: number;\n\n    constructor(name: string) {\n        super(name, 0, false);\n    }\n}\n/**\n * @public\n */\nexport enum SpacingMode {\n    Length,\n    Fixed,\n    Percent,\n}\n","import { PathAttachment } from './attachments';\nimport type { Updatable } from './Updatable';\nimport { PathConstraintData, SpacingMode } from './PathConstraintData';\nimport type { Bone } from './Bone';\nimport type { Slot } from './Slot';\nimport type { Skeleton } from './Skeleton';\nimport { MathUtils, PositionMode, RotateMode, Utils } from '@pixi-spine/base';\n/**\n * @public\n */\nexport class PathConstraint implements Updatable {\n    static NONE = -1;\n    static BEFORE = -2;\n    static AFTER = -3;\n    static epsilon = 0.00001;\n\n    data: PathConstraintData;\n    bones: Array<Bone>;\n    target: Slot;\n    position = 0;\n    spacing = 0;\n    rotateMix = 0;\n    translateMix = 0;\n\n    spaces = new Array<number>();\n    positions = new Array<number>();\n    world = new Array<number>();\n    curves = new Array<number>();\n    lengths = new Array<number>();\n    segments = new Array<number>();\n\n    active = false;\n\n    constructor(data: PathConstraintData, skeleton: Skeleton) {\n        if (data == null) throw new Error('data cannot be null.');\n        if (skeleton == null) throw new Error('skeleton cannot be null.');\n        this.data = data;\n        this.bones = new Array<Bone>();\n        for (let i = 0, n = data.bones.length; i < n; i++) this.bones.push(skeleton.findBone(data.bones[i].name));\n        this.target = skeleton.findSlot(data.target.name);\n        this.position = data.position;\n        this.spacing = data.spacing;\n        this.rotateMix = data.rotateMix;\n        this.translateMix = data.translateMix;\n    }\n\n    isActive() {\n        return this.active;\n    }\n\n    apply() {\n        this.update();\n    }\n\n    update() {\n        const attachment = this.target.getAttachment();\n\n        if (!(attachment instanceof PathAttachment)) return;\n\n        const rotateMix = this.rotateMix;\n        const translateMix = this.translateMix;\n        const translate = translateMix > 0;\n        const rotate = rotateMix > 0;\n\n        if (!translate && !rotate) return;\n\n        const data = this.data;\n        const spacingMode = data.spacingMode;\n        const lengthSpacing = spacingMode == SpacingMode.Length;\n        const rotateMode = data.rotateMode;\n        const tangents = rotateMode == RotateMode.Tangent;\n        const scale = rotateMode == RotateMode.ChainScale;\n        const boneCount = this.bones.length;\n        const spacesCount = tangents ? boneCount : boneCount + 1;\n        const bones = this.bones;\n        const spaces = Utils.setArraySize(this.spaces, spacesCount);\n        let lengths: Array<number> = null;\n        const spacing = this.spacing;\n\n        if (scale || lengthSpacing) {\n            if (scale) lengths = Utils.setArraySize(this.lengths, boneCount);\n            for (let i = 0, n = spacesCount - 1; i < n; ) {\n                const bone = bones[i];\n                const setupLength = bone.data.length;\n\n                if (setupLength < PathConstraint.epsilon) {\n                    if (scale) lengths[i] = 0;\n                    spaces[++i] = 0;\n                } else {\n                    const x = setupLength * bone.matrix.a;\n                    const y = setupLength * bone.matrix.b;\n                    const length = Math.sqrt(x * x + y * y);\n\n                    if (scale) lengths[i] = length;\n                    spaces[++i] = ((lengthSpacing ? setupLength + spacing : spacing) * length) / setupLength;\n                }\n            }\n        } else {\n            for (let i = 1; i < spacesCount; i++) spaces[i] = spacing;\n        }\n\n        const positions = this.computeWorldPositions(\n            <PathAttachment>attachment,\n            spacesCount,\n            tangents,\n            data.positionMode == PositionMode.Percent,\n            spacingMode == SpacingMode.Percent\n        );\n        let boneX = positions[0];\n        let boneY = positions[1];\n        let offsetRotation = data.offsetRotation;\n        let tip = false;\n\n        if (offsetRotation == 0) tip = rotateMode == RotateMode.Chain;\n        else {\n            tip = false;\n            const p = this.target.bone.matrix;\n\n            offsetRotation *= p.a * p.d - p.b * p.c > 0 ? MathUtils.degRad : -MathUtils.degRad;\n        }\n        for (let i = 0, p = 3; i < boneCount; i++, p += 3) {\n            const bone = bones[i];\n            const mat = bone.matrix;\n\n            mat.tx += (boneX - mat.tx) * translateMix;\n            mat.ty += (boneY - mat.ty) * translateMix;\n            const x = positions[p];\n            const y = positions[p + 1];\n            const dx = x - boneX;\n            const dy = y - boneY;\n\n            if (scale) {\n                const length = lengths[i];\n\n                if (length != 0) {\n                    const s = (Math.sqrt(dx * dx + dy * dy) / length - 1) * rotateMix + 1;\n\n                    mat.a *= s;\n                    mat.b *= s;\n                }\n            }\n            boneX = x;\n            boneY = y;\n            if (rotate) {\n                const a = mat.a;\n                const b = mat.c;\n                const c = mat.b;\n                const d = mat.d;\n                let r = 0;\n                let cos = 0;\n                let sin = 0;\n\n                if (tangents)\n                    if (tangents) r = positions[p - 1];\n                    else if (spaces[i + 1] == 0) r = positions[p + 2];\n                    else r = Math.atan2(dy, dx);\n                r -= Math.atan2(c, a);\n                if (tip) {\n                    cos = Math.cos(r);\n                    sin = Math.sin(r);\n                    const length = bone.data.length;\n\n                    boneX += (length * (cos * a - sin * c) - dx) * rotateMix;\n                    boneY += (length * (sin * a + cos * c) - dy) * rotateMix;\n                } else {\n                    r += offsetRotation;\n                }\n                if (r > MathUtils.PI) r -= MathUtils.PI2;\n                else if (r < -MathUtils.PI)\n                    //\n                    r += MathUtils.PI2;\n                r *= rotateMix;\n                cos = Math.cos(r);\n                sin = Math.sin(r);\n                mat.a = cos * a - sin * c;\n                mat.c = cos * b - sin * d;\n                mat.b = sin * a + cos * c;\n                mat.d = sin * b + cos * d;\n            }\n            bone.appliedValid = false;\n        }\n    }\n\n    computeWorldPositions(path: PathAttachment, spacesCount: number, tangents: boolean, percentPosition: boolean, percentSpacing: boolean) {\n        const target = this.target;\n        let position = this.position;\n        const spaces = this.spaces;\n        const out = Utils.setArraySize(this.positions, spacesCount * 3 + 2);\n        let world: Array<number> = null;\n        const closed = path.closed;\n        let verticesLength = path.worldVerticesLength;\n        let curveCount = verticesLength / 6;\n        let prevCurve = PathConstraint.NONE;\n\n        if (!path.constantSpeed) {\n            const lengths = path.lengths;\n\n            curveCount -= closed ? 1 : 2;\n            const pathLength = lengths[curveCount];\n\n            if (percentPosition) position *= pathLength;\n            if (percentSpacing) {\n                for (let i = 0; i < spacesCount; i++) spaces[i] *= pathLength;\n            }\n            world = Utils.setArraySize(this.world, 8);\n            for (let i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {\n                const space = spaces[i];\n\n                position += space;\n                let p = position;\n\n                if (closed) {\n                    p %= pathLength;\n                    if (p < 0) p += pathLength;\n                    curve = 0;\n                } else if (p < 0) {\n                    if (prevCurve != PathConstraint.BEFORE) {\n                        prevCurve = PathConstraint.BEFORE;\n                        path.computeWorldVertices(target, 2, 4, world, 0, 2);\n                    }\n                    this.addBeforePosition(p, world, 0, out, o);\n                    continue;\n                } else if (p > pathLength) {\n                    if (prevCurve != PathConstraint.AFTER) {\n                        prevCurve = PathConstraint.AFTER;\n                        path.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2);\n                    }\n                    this.addAfterPosition(p - pathLength, world, 0, out, o);\n                    continue;\n                }\n\n                // Determine curve containing position.\n                for (; ; curve++) {\n                    const length = lengths[curve];\n\n                    if (p > length) continue;\n                    if (curve == 0) p /= length;\n                    else {\n                        const prev = lengths[curve - 1];\n\n                        p = (p - prev) / (length - prev);\n                    }\n                    break;\n                }\n                if (curve != prevCurve) {\n                    prevCurve = curve;\n                    if (closed && curve == curveCount) {\n                        path.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);\n                        path.computeWorldVertices(target, 0, 4, world, 4, 2);\n                    } else path.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2);\n                }\n                this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o, tangents || (i > 0 && space == 0));\n            }\n\n            return out;\n        }\n\n        // World vertices.\n        if (closed) {\n            verticesLength += 2;\n            world = Utils.setArraySize(this.world, verticesLength);\n            path.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);\n            path.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);\n            world[verticesLength - 2] = world[0];\n            world[verticesLength - 1] = world[1];\n        } else {\n            curveCount--;\n            verticesLength -= 4;\n            world = Utils.setArraySize(this.world, verticesLength);\n            path.computeWorldVertices(target, 2, verticesLength, world, 0, 2);\n        }\n\n        // Curve lengths.\n        const curves = Utils.setArraySize(this.curves, curveCount);\n        let pathLength = 0;\n        let x1 = world[0];\n        let y1 = world[1];\n        let cx1 = 0;\n        let cy1 = 0;\n        let cx2 = 0;\n        let cy2 = 0;\n        let x2 = 0;\n        let y2 = 0;\n        let tmpx = 0;\n        let tmpy = 0;\n        let dddfx = 0;\n        let dddfy = 0;\n        let ddfx = 0;\n        let ddfy = 0;\n        let dfx = 0;\n        let dfy = 0;\n\n        for (let i = 0, w = 2; i < curveCount; i++, w += 6) {\n            cx1 = world[w];\n            cy1 = world[w + 1];\n            cx2 = world[w + 2];\n            cy2 = world[w + 3];\n            x2 = world[w + 4];\n            y2 = world[w + 5];\n            tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;\n            tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;\n            dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;\n            dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;\n            ddfx = tmpx * 2 + dddfx;\n            ddfy = tmpy * 2 + dddfy;\n            dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;\n            dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n            dfx += ddfx;\n            dfy += ddfy;\n            ddfx += dddfx;\n            ddfy += dddfy;\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n            dfx += ddfx;\n            dfy += ddfy;\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n            dfx += ddfx + dddfx;\n            dfy += ddfy + dddfy;\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n            curves[i] = pathLength;\n            x1 = x2;\n            y1 = y2;\n        }\n        if (percentPosition) position *= pathLength;\n        if (percentSpacing) {\n            for (let i = 0; i < spacesCount; i++) spaces[i] *= pathLength;\n        }\n\n        const segments = this.segments;\n        let curveLength = 0;\n\n        for (let i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {\n            const space = spaces[i];\n\n            position += space;\n            let p = position;\n\n            if (closed) {\n                p %= pathLength;\n                if (p < 0) p += pathLength;\n                curve = 0;\n            } else if (p < 0) {\n                this.addBeforePosition(p, world, 0, out, o);\n                continue;\n            } else if (p > pathLength) {\n                this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);\n                continue;\n            }\n\n            // Determine curve containing position.\n            for (; ; curve++) {\n                const length = curves[curve];\n\n                if (p > length) continue;\n                if (curve == 0) p /= length;\n                else {\n                    const prev = curves[curve - 1];\n\n                    p = (p - prev) / (length - prev);\n                }\n                break;\n            }\n\n            // Curve segment lengths.\n            if (curve != prevCurve) {\n                prevCurve = curve;\n                let ii = curve * 6;\n\n                x1 = world[ii];\n                y1 = world[ii + 1];\n                cx1 = world[ii + 2];\n                cy1 = world[ii + 3];\n                cx2 = world[ii + 4];\n                cy2 = world[ii + 5];\n                x2 = world[ii + 6];\n                y2 = world[ii + 7];\n                tmpx = (x1 - cx1 * 2 + cx2) * 0.03;\n                tmpy = (y1 - cy1 * 2 + cy2) * 0.03;\n                dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.006;\n                dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.006;\n                ddfx = tmpx * 2 + dddfx;\n                ddfy = tmpy * 2 + dddfy;\n                dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;\n                dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;\n                curveLength = Math.sqrt(dfx * dfx + dfy * dfy);\n                segments[0] = curveLength;\n                for (ii = 1; ii < 8; ii++) {\n                    dfx += ddfx;\n                    dfy += ddfy;\n                    ddfx += dddfx;\n                    ddfy += dddfy;\n                    curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                    segments[ii] = curveLength;\n                }\n                dfx += ddfx;\n                dfy += ddfy;\n                curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                segments[8] = curveLength;\n                dfx += ddfx + dddfx;\n                dfy += ddfy + dddfy;\n                curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                segments[9] = curveLength;\n                segment = 0;\n            }\n\n            // Weight by segment length.\n            p *= curveLength;\n            for (; ; segment++) {\n                const length = segments[segment];\n\n                if (p > length) continue;\n                if (segment == 0) p /= length;\n                else {\n                    const prev = segments[segment - 1];\n\n                    p = segment + (p - prev) / (length - prev);\n                }\n                break;\n            }\n            this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || (i > 0 && space == 0));\n        }\n\n        return out;\n    }\n\n    addBeforePosition(p: number, temp: Array<number>, i: number, out: Array<number>, o: number) {\n        const x1 = temp[i];\n        const y1 = temp[i + 1];\n        const dx = temp[i + 2] - x1;\n        const dy = temp[i + 3] - y1;\n        const r = Math.atan2(dy, dx);\n\n        out[o] = x1 + p * Math.cos(r);\n        out[o + 1] = y1 + p * Math.sin(r);\n        out[o + 2] = r;\n    }\n\n    addAfterPosition(p: number, temp: Array<number>, i: number, out: Array<number>, o: number) {\n        const x1 = temp[i + 2];\n        const y1 = temp[i + 3];\n        const dx = x1 - temp[i];\n        const dy = y1 - temp[i + 1];\n        const r = Math.atan2(dy, dx);\n\n        out[o] = x1 + p * Math.cos(r);\n        out[o + 1] = y1 + p * Math.sin(r);\n        out[o + 2] = r;\n    }\n\n    addCurvePosition(\n        p: number,\n        x1: number,\n        y1: number,\n        cx1: number,\n        cy1: number,\n        cx2: number,\n        cy2: number,\n        x2: number,\n        y2: number,\n        out: Array<number>,\n        o: number,\n        tangents: boolean\n    ) {\n        if (p == 0 || isNaN(p)) p = 0.0001;\n        const tt = p * p;\n        const ttt = tt * p;\n        const u = 1 - p;\n        const uu = u * u;\n        const uuu = uu * u;\n        const ut = u * p;\n        const ut3 = ut * 3;\n        const uut3 = u * ut3;\n        const utt3 = ut3 * p;\n        const x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt;\n        const y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;\n\n        out[o] = x;\n        out[o + 1] = y;\n        if (tangents) out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));\n    }\n}\n","import type { Updatable } from './Updatable';\nimport type { TransformConstraintData } from './TransformConstraintData';\nimport type { Bone } from './Bone';\nimport { MathUtils, Vector2 } from '@pixi-spine/base';\nimport type { Skeleton } from './Skeleton';\n\n/**\n * @public\n */\nexport class TransformConstraint implements Updatable {\n    data: TransformConstraintData;\n    bones: Array<Bone>;\n    target: Bone;\n    rotateMix = 0;\n    translateMix = 0;\n    scaleMix = 0;\n    shearMix = 0;\n    temp = new Vector2();\n    active = false;\n\n    constructor(data: TransformConstraintData, skeleton: Skeleton) {\n        if (data == null) throw new Error('data cannot be null.');\n        if (skeleton == null) throw new Error('skeleton cannot be null.');\n        this.data = data;\n        this.rotateMix = data.rotateMix;\n        this.translateMix = data.translateMix;\n        this.scaleMix = data.scaleMix;\n        this.shearMix = data.shearMix;\n        this.bones = new Array<Bone>();\n        for (let i = 0; i < data.bones.length; i++) this.bones.push(skeleton.findBone(data.bones[i].name));\n        this.target = skeleton.findBone(data.target.name);\n    }\n\n    isActive() {\n        return this.active;\n    }\n\n    apply() {\n        this.update();\n    }\n\n    update() {\n        if (this.data.local) {\n            if (this.data.relative) this.applyRelativeLocal();\n            else this.applyAbsoluteLocal();\n        } else if (this.data.relative) this.applyRelativeWorld();\n        else this.applyAbsoluteWorld();\n    }\n\n    applyAbsoluteWorld() {\n        const rotateMix = this.rotateMix;\n        const translateMix = this.translateMix;\n        const scaleMix = this.scaleMix;\n        const shearMix = this.shearMix;\n        const target = this.target;\n        const targetMat = target.matrix;\n        const ta = targetMat.a;\n        const tb = targetMat.c;\n        const tc = targetMat.b;\n        const td = targetMat.d;\n        const degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;\n        const offsetRotation = this.data.offsetRotation * degRadReflect;\n        const offsetShearY = this.data.offsetShearY * degRadReflect;\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) {\n            const bone = bones[i];\n            let modified = false;\n            const mat = bone.matrix;\n\n            if (rotateMix != 0) {\n                const a = mat.a;\n                const b = mat.c;\n                const c = mat.b;\n                const d = mat.d;\n                let r = Math.atan2(tc, ta) - Math.atan2(c, a) + offsetRotation;\n\n                if (r > MathUtils.PI) r -= MathUtils.PI2;\n                else if (r < -MathUtils.PI) r += MathUtils.PI2;\n                r *= rotateMix;\n                const cos = Math.cos(r);\n                const sin = Math.sin(r);\n\n                mat.a = cos * a - sin * c;\n                mat.c = cos * b - sin * d;\n                mat.b = sin * a + cos * c;\n                mat.d = sin * b + cos * d;\n                modified = true;\n            }\n\n            if (translateMix != 0) {\n                const temp = this.temp;\n\n                target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\n                mat.tx += (temp.x - mat.tx) * translateMix;\n                mat.ty += (temp.y - mat.ty) * translateMix;\n                modified = true;\n            }\n\n            if (scaleMix > 0) {\n                let s = Math.sqrt(mat.a * mat.a + mat.b * mat.b);\n                let ts = Math.sqrt(ta * ta + tc * tc);\n\n                if (s > 0.00001) s = (s + (ts - s + this.data.offsetScaleX) * scaleMix) / s;\n                mat.a *= s;\n                mat.b *= s;\n                s = Math.sqrt(mat.c * mat.c + mat.d * mat.d);\n                ts = Math.sqrt(tb * tb + td * td);\n                if (s > 0.00001) s = (s + (ts - s + this.data.offsetScaleY) * scaleMix) / s;\n                mat.c *= s;\n                mat.d *= s;\n                modified = true;\n            }\n\n            if (shearMix > 0) {\n                const b = mat.c;\n                const d = mat.d;\n                const by = Math.atan2(d, b);\n                let r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(mat.b, mat.a));\n\n                if (r > MathUtils.PI) r -= MathUtils.PI2;\n                else if (r < -MathUtils.PI) r += MathUtils.PI2;\n                r = by + (r + offsetShearY) * shearMix;\n                const s = Math.sqrt(b * b + d * d);\n\n                mat.c = Math.cos(r) * s;\n                mat.d = Math.sin(r) * s;\n                modified = true;\n            }\n\n            if (modified) bone.appliedValid = false;\n        }\n    }\n\n    applyRelativeWorld() {\n        const rotateMix = this.rotateMix;\n        const translateMix = this.translateMix;\n        const scaleMix = this.scaleMix;\n        const shearMix = this.shearMix;\n        const target = this.target;\n        const targetMat = target.matrix;\n        const ta = targetMat.a;\n        const tb = targetMat.c;\n        const tc = targetMat.b;\n        const td = targetMat.d;\n        const degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;\n        const offsetRotation = this.data.offsetRotation * degRadReflect;\n        const offsetShearY = this.data.offsetShearY * degRadReflect;\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) {\n            const bone = bones[i];\n            let modified = false;\n            const mat = bone.matrix;\n\n            if (rotateMix != 0) {\n                const a = mat.a;\n                const b = mat.c;\n                const c = mat.b;\n                const d = mat.d;\n                let r = Math.atan2(tc, ta) + offsetRotation;\n\n                if (r > MathUtils.PI) r -= MathUtils.PI2;\n                else if (r < -MathUtils.PI) r += MathUtils.PI2;\n                r *= rotateMix;\n                const cos = Math.cos(r);\n                const sin = Math.sin(r);\n\n                mat.a = cos * a - sin * c;\n                mat.c = cos * b - sin * d;\n                mat.b = sin * a + cos * c;\n                mat.d = sin * b + cos * d;\n                modified = true;\n            }\n\n            if (translateMix != 0) {\n                const temp = this.temp;\n\n                target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\n                mat.tx += temp.x * translateMix;\n                mat.ty += temp.y * translateMix;\n                modified = true;\n            }\n\n            if (scaleMix > 0) {\n                let s = (Math.sqrt(ta * ta + tc * tc) - 1 + this.data.offsetScaleX) * scaleMix + 1;\n\n                mat.a *= s;\n                mat.b *= s;\n                s = (Math.sqrt(tb * tb + td * td) - 1 + this.data.offsetScaleY) * scaleMix + 1;\n                mat.c *= s;\n                mat.d *= s;\n                modified = true;\n            }\n\n            if (shearMix > 0) {\n                let r = Math.atan2(td, tb) - Math.atan2(tc, ta);\n\n                if (r > MathUtils.PI) r -= MathUtils.PI2;\n                else if (r < -MathUtils.PI) r += MathUtils.PI2;\n                const b = mat.c;\n                const d = mat.d;\n\n                r = Math.atan2(d, b) + (r - MathUtils.PI / 2 + offsetShearY) * shearMix;\n                const s = Math.sqrt(b * b + d * d);\n\n                mat.c = Math.cos(r) * s;\n                mat.d = Math.sin(r) * s;\n                modified = true;\n            }\n\n            if (modified) bone.appliedValid = false;\n        }\n    }\n\n    applyAbsoluteLocal() {\n        const rotateMix = this.rotateMix;\n        const translateMix = this.translateMix;\n        const scaleMix = this.scaleMix;\n        const shearMix = this.shearMix;\n        const target = this.target;\n\n        if (!target.appliedValid) target.updateAppliedTransform();\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) {\n            const bone = bones[i];\n\n            if (!bone.appliedValid) bone.updateAppliedTransform();\n\n            let rotation = bone.arotation;\n\n            if (rotateMix != 0) {\n                let r = target.arotation - rotation + this.data.offsetRotation;\n\n                r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\n                rotation += r * rotateMix;\n            }\n\n            let x = bone.ax;\n            let y = bone.ay;\n\n            if (translateMix != 0) {\n                x += (target.ax - x + this.data.offsetX) * translateMix;\n                y += (target.ay - y + this.data.offsetY) * translateMix;\n            }\n\n            let scaleX = bone.ascaleX;\n            let scaleY = bone.ascaleY;\n\n            if (scaleMix > 0) {\n                if (scaleX > 0.00001) scaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * scaleMix) / scaleX;\n                if (scaleY > 0.00001) scaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * scaleMix) / scaleY;\n            }\n\n            const shearY = bone.ashearY;\n\n            if (shearMix > 0) {\n                let r = target.ashearY - shearY + this.data.offsetShearY;\n\n                r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\n                bone.shearY += r * shearMix;\n            }\n\n            bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\n        }\n    }\n\n    applyRelativeLocal() {\n        const rotateMix = this.rotateMix;\n        const translateMix = this.translateMix;\n        const scaleMix = this.scaleMix;\n        const shearMix = this.shearMix;\n        const target = this.target;\n\n        if (!target.appliedValid) target.updateAppliedTransform();\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) {\n            const bone = bones[i];\n\n            if (!bone.appliedValid) bone.updateAppliedTransform();\n\n            let rotation = bone.arotation;\n\n            if (rotateMix != 0) rotation += (target.arotation + this.data.offsetRotation) * rotateMix;\n\n            let x = bone.ax;\n            let y = bone.ay;\n\n            if (translateMix != 0) {\n                x += (target.ax + this.data.offsetX) * translateMix;\n                y += (target.ay + this.data.offsetY) * translateMix;\n            }\n\n            let scaleX = bone.ascaleX;\n            let scaleY = bone.ascaleY;\n\n            if (scaleMix > 0) {\n                if (scaleX > 0.00001) scaleX *= (target.ascaleX - 1 + this.data.offsetScaleX) * scaleMix + 1;\n                if (scaleY > 0.00001) scaleY *= (target.ascaleY - 1 + this.data.offsetScaleY) * scaleMix + 1;\n            }\n\n            let shearY = bone.ashearY;\n\n            if (shearMix > 0) shearY += (target.ashearY + this.data.offsetShearY) * shearMix;\n\n            bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\n        }\n    }\n}\n","import { Attachment, RegionAttachment, MeshAttachment, PathAttachment } from './attachments';\nimport { Bone } from './Bone';\nimport { Slot } from './Slot';\nimport type { Updatable } from './Updatable';\nimport type { SkeletonData } from './SkeletonData';\nimport { IkConstraint } from './IkConstraint';\nimport { TransformConstraint } from './TransformConstraint';\nimport { PathConstraint } from './PathConstraint';\nimport type { Skin } from './Skin';\nimport { Color, Utils, Vector2, ISkeleton } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class Skeleton implements ISkeleton<SkeletonData, Bone, Slot, Skin> {\n    data: SkeletonData;\n    bones: Array<Bone>;\n    slots: Array<Slot>;\n    drawOrder: Array<Slot>;\n    ikConstraints: Array<IkConstraint>;\n    transformConstraints: Array<TransformConstraint>;\n    pathConstraints: Array<PathConstraint>;\n    _updateCache = new Array<Updatable>();\n    updateCacheReset = new Array<Updatable>();\n    skin: Skin;\n    color: Color;\n    time = 0;\n    scaleX = 1;\n    scaleY = 1;\n    x = 0;\n    y = 0;\n\n    constructor(data: SkeletonData) {\n        if (data == null) throw new Error('data cannot be null.');\n        this.data = data;\n\n        this.bones = new Array<Bone>();\n        for (let i = 0; i < data.bones.length; i++) {\n            const boneData = data.bones[i];\n            let bone: Bone;\n\n            if (boneData.parent == null) bone = new Bone(boneData, this, null);\n            else {\n                const parent = this.bones[boneData.parent.index];\n\n                bone = new Bone(boneData, this, parent);\n                parent.children.push(bone);\n            }\n            this.bones.push(bone);\n        }\n\n        this.slots = new Array<Slot>();\n        this.drawOrder = new Array<Slot>();\n        for (let i = 0; i < data.slots.length; i++) {\n            const slotData = data.slots[i];\n            const bone = this.bones[slotData.boneData.index];\n            const slot = new Slot(slotData, bone);\n\n            this.slots.push(slot);\n            this.drawOrder.push(slot);\n        }\n\n        this.ikConstraints = new Array<IkConstraint>();\n        for (let i = 0; i < data.ikConstraints.length; i++) {\n            const ikConstraintData = data.ikConstraints[i];\n\n            this.ikConstraints.push(new IkConstraint(ikConstraintData, this));\n        }\n\n        this.transformConstraints = new Array<TransformConstraint>();\n        for (let i = 0; i < data.transformConstraints.length; i++) {\n            const transformConstraintData = data.transformConstraints[i];\n\n            this.transformConstraints.push(new TransformConstraint(transformConstraintData, this));\n        }\n\n        this.pathConstraints = new Array<PathConstraint>();\n        for (let i = 0; i < data.pathConstraints.length; i++) {\n            const pathConstraintData = data.pathConstraints[i];\n\n            this.pathConstraints.push(new PathConstraint(pathConstraintData, this));\n        }\n\n        this.color = new Color(1, 1, 1, 1);\n        this.updateCache();\n    }\n\n    updateCache() {\n        const updateCache = this._updateCache;\n\n        updateCache.length = 0;\n        this.updateCacheReset.length = 0;\n\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) {\n            const bone = bones[i];\n\n            bone.sorted = bone.data.skinRequired;\n            bone.active = !bone.sorted;\n        }\n\n        if (this.skin != null) {\n            const skinBones = this.skin.bones;\n\n            for (let i = 0, n = this.skin.bones.length; i < n; i++) {\n                let bone = this.bones[skinBones[i].index];\n\n                do {\n                    bone.sorted = false;\n                    bone.active = true;\n                    bone = bone.parent;\n                } while (bone != null);\n            }\n        }\n\n        // IK first, lowest hierarchy depth first.\n        const ikConstraints = this.ikConstraints;\n        const transformConstraints = this.transformConstraints;\n        const pathConstraints = this.pathConstraints;\n        const ikCount = ikConstraints.length;\n        const transformCount = transformConstraints.length;\n        const pathCount = pathConstraints.length;\n        const constraintCount = ikCount + transformCount + pathCount;\n\n        // eslint-disable-next-line no-restricted-syntax, no-labels\n        outer: for (let i = 0; i < constraintCount; i++) {\n            for (let ii = 0; ii < ikCount; ii++) {\n                const constraint = ikConstraints[ii];\n\n                if (constraint.data.order == i) {\n                    this.sortIkConstraint(constraint);\n                    // eslint-disable-next-line no-labels\n                    continue outer;\n                }\n            }\n            for (let ii = 0; ii < transformCount; ii++) {\n                const constraint = transformConstraints[ii];\n\n                if (constraint.data.order == i) {\n                    this.sortTransformConstraint(constraint);\n                    // eslint-disable-next-line no-labels\n                    continue outer;\n                }\n            }\n            for (let ii = 0; ii < pathCount; ii++) {\n                const constraint = pathConstraints[ii];\n\n                if (constraint.data.order == i) {\n                    this.sortPathConstraint(constraint);\n                    // eslint-disable-next-line no-labels\n                    continue outer;\n                }\n            }\n        }\n\n        for (let i = 0, n = bones.length; i < n; i++) this.sortBone(bones[i]);\n    }\n\n    sortIkConstraint(constraint: IkConstraint) {\n        constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || (this.skin != null && Utils.contains(this.skin.constraints, constraint.data, true)));\n        if (!constraint.active) return;\n\n        const target = constraint.target;\n\n        this.sortBone(target);\n\n        const constrained = constraint.bones;\n        const parent = constrained[0];\n\n        this.sortBone(parent);\n\n        if (constrained.length > 1) {\n            const child = constrained[constrained.length - 1];\n\n            if (!(this._updateCache.indexOf(child) > -1)) this.updateCacheReset.push(child);\n        }\n\n        this._updateCache.push(constraint);\n\n        this.sortReset(parent.children);\n        constrained[constrained.length - 1].sorted = true;\n    }\n\n    sortPathConstraint(constraint: PathConstraint) {\n        constraint.active =\n            constraint.target.bone.isActive() && (!constraint.data.skinRequired || (this.skin != null && Utils.contains(this.skin.constraints, constraint.data, true)));\n        if (!constraint.active) return;\n\n        const slot = constraint.target;\n        const slotIndex = slot.data.index;\n        const slotBone = slot.bone;\n\n        if (this.skin != null) this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);\n        if (this.data.defaultSkin != null && this.data.defaultSkin != this.skin) this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);\n        for (let i = 0, n = this.data.skins.length; i < n; i++) this.sortPathConstraintAttachment(this.data.skins[i], slotIndex, slotBone);\n\n        const attachment = slot.getAttachment();\n\n        if (attachment instanceof PathAttachment) this.sortPathConstraintAttachmentWith(attachment, slotBone);\n\n        const constrained = constraint.bones;\n        const boneCount = constrained.length;\n\n        for (let i = 0; i < boneCount; i++) this.sortBone(constrained[i]);\n\n        this._updateCache.push(constraint);\n\n        for (let i = 0; i < boneCount; i++) this.sortReset(constrained[i].children);\n        for (let i = 0; i < boneCount; i++) constrained[i].sorted = true;\n    }\n\n    sortTransformConstraint(constraint: TransformConstraint) {\n        constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || (this.skin != null && Utils.contains(this.skin.constraints, constraint.data, true)));\n        if (!constraint.active) return;\n\n        this.sortBone(constraint.target);\n\n        const constrained = constraint.bones;\n        const boneCount = constrained.length;\n\n        if (constraint.data.local) {\n            for (let i = 0; i < boneCount; i++) {\n                const child = constrained[i];\n\n                this.sortBone(child.parent);\n                if (!(this._updateCache.indexOf(child) > -1)) this.updateCacheReset.push(child);\n            }\n        } else {\n            for (let i = 0; i < boneCount; i++) {\n                this.sortBone(constrained[i]);\n            }\n        }\n\n        this._updateCache.push(constraint);\n\n        for (let ii = 0; ii < boneCount; ii++) this.sortReset(constrained[ii].children);\n        for (let ii = 0; ii < boneCount; ii++) constrained[ii].sorted = true;\n    }\n\n    sortPathConstraintAttachment(skin: Skin, slotIndex: number, slotBone: Bone) {\n        const attachments = skin.attachments[slotIndex];\n\n        if (!attachments) return;\n        for (const key in attachments) {\n            this.sortPathConstraintAttachmentWith(attachments[key], slotBone);\n        }\n    }\n\n    sortPathConstraintAttachmentWith(attachment: Attachment, slotBone: Bone) {\n        if (!(attachment instanceof PathAttachment)) return;\n        const pathBones = (<PathAttachment>attachment).bones;\n\n        if (pathBones == null) this.sortBone(slotBone);\n        else {\n            const bones = this.bones;\n            let i = 0;\n\n            while (i < pathBones.length) {\n                const boneCount = pathBones[i++];\n\n                for (let n = i + boneCount; i < n; i++) {\n                    const boneIndex = pathBones[i];\n\n                    this.sortBone(bones[boneIndex]);\n                }\n            }\n        }\n    }\n\n    sortBone(bone: Bone) {\n        if (bone.sorted) return;\n        const parent = bone.parent;\n\n        if (parent != null) this.sortBone(parent);\n        bone.sorted = true;\n        this._updateCache.push(bone);\n    }\n\n    sortReset(bones: Array<Bone>) {\n        for (let i = 0, n = bones.length; i < n; i++) {\n            const bone = bones[i];\n\n            if (!bone.active) continue;\n            if (bone.sorted) this.sortReset(bone.children);\n            bone.sorted = false;\n        }\n    }\n\n    /** Updates the world transform for each bone and applies constraints. */\n    updateWorldTransform() {\n        const updateCacheReset = this.updateCacheReset;\n\n        for (let i = 0, n = updateCacheReset.length; i < n; i++) {\n            const bone = updateCacheReset[i] as Bone;\n\n            bone.ax = bone.x;\n            bone.ay = bone.y;\n            bone.arotation = bone.rotation;\n            bone.ascaleX = bone.scaleX;\n            bone.ascaleY = bone.scaleY;\n            bone.ashearX = bone.shearX;\n            bone.ashearY = bone.shearY;\n            bone.appliedValid = true;\n        }\n        const updateCache = this._updateCache;\n\n        for (let i = 0, n = updateCache.length; i < n; i++) updateCache[i].update();\n    }\n\n    /** Sets the bones, constraints, and slots to their setup pose values. */\n    setToSetupPose() {\n        this.setBonesToSetupPose();\n        this.setSlotsToSetupPose();\n    }\n\n    /** Sets the bones and constraints to their setup pose values. */\n    setBonesToSetupPose() {\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) bones[i].setToSetupPose();\n\n        const ikConstraints = this.ikConstraints;\n\n        for (let i = 0, n = ikConstraints.length; i < n; i++) {\n            const constraint = ikConstraints[i];\n\n            constraint.mix = constraint.data.mix;\n            constraint.softness = constraint.data.softness;\n            constraint.bendDirection = constraint.data.bendDirection;\n            constraint.compress = constraint.data.compress;\n            constraint.stretch = constraint.data.stretch;\n        }\n\n        const transformConstraints = this.transformConstraints;\n\n        for (let i = 0, n = transformConstraints.length; i < n; i++) {\n            const constraint = transformConstraints[i];\n            const data = constraint.data;\n\n            constraint.rotateMix = data.rotateMix;\n            constraint.translateMix = data.translateMix;\n            constraint.scaleMix = data.scaleMix;\n            constraint.shearMix = data.shearMix;\n        }\n\n        const pathConstraints = this.pathConstraints;\n\n        for (let i = 0, n = pathConstraints.length; i < n; i++) {\n            const constraint = pathConstraints[i];\n            const data = constraint.data;\n\n            constraint.position = data.position;\n            constraint.spacing = data.spacing;\n            constraint.rotateMix = data.rotateMix;\n            constraint.translateMix = data.translateMix;\n        }\n    }\n\n    setSlotsToSetupPose() {\n        const slots = this.slots;\n\n        Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);\n        for (let i = 0, n = slots.length; i < n; i++) slots[i].setToSetupPose();\n    }\n\n    /** @return May return null. */\n    getRootBone() {\n        if (this.bones.length == 0) return null;\n\n        return this.bones[0];\n    }\n\n    /** @return May be null. */\n    findBone(boneName: string) {\n        if (boneName == null) throw new Error('boneName cannot be null.');\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) {\n            const bone = bones[i];\n\n            if (bone.data.name == boneName) return bone;\n        }\n\n        return null;\n    }\n\n    /** @return -1 if the bone was not found. */\n    findBoneIndex(boneName: string) {\n        if (boneName == null) throw new Error('boneName cannot be null.');\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) if (bones[i].data.name == boneName) return i;\n\n        return -1;\n    }\n\n    /** @return May be null. */\n    findSlot(slotName: string) {\n        if (slotName == null) throw new Error('slotName cannot be null.');\n        const slots = this.slots;\n\n        for (let i = 0, n = slots.length; i < n; i++) {\n            const slot = slots[i];\n\n            if (slot.data.name == slotName) return slot;\n        }\n\n        return null;\n    }\n\n    /** @return -1 if the bone was not found. */\n    findSlotIndex(slotName: string) {\n        if (slotName == null) throw new Error('slotName cannot be null.');\n        const slots = this.slots;\n\n        for (let i = 0, n = slots.length; i < n; i++) if (slots[i].data.name == slotName) return i;\n\n        return -1;\n    }\n\n    /** Sets a skin by name.\n     * @see #setSkin(Skin) */\n    setSkinByName(skinName: string) {\n        const skin = this.data.findSkin(skinName);\n\n        if (skin == null) throw new Error(`Skin not found: ${skinName}`);\n        this.setSkin(skin);\n    }\n\n    /** Sets the skin used to look up attachments before looking in the {@link SkeletonData#getDefaultSkin() default skin}.\n     * Attachments from the new skin are attached if the corresponding attachment from the old skin was attached. If there was no\n     * old skin, each slot's setup mode attachment is attached from the new skin.\n     * @param newSkin May be null. */\n    setSkin(newSkin: Skin) {\n        if (newSkin == this.skin) return;\n        if (newSkin != null) {\n            if (this.skin != null) newSkin.attachAll(this, this.skin);\n            else {\n                const slots = this.slots;\n\n                for (let i = 0, n = slots.length; i < n; i++) {\n                    const slot = slots[i];\n                    const name = slot.data.attachmentName;\n\n                    if (name != null) {\n                        const attachment: Attachment = newSkin.getAttachment(i, name);\n\n                        if (attachment != null) slot.setAttachment(attachment);\n                    }\n                }\n            }\n        }\n        this.skin = newSkin;\n        this.updateCache();\n    }\n\n    /** @return May be null. */\n    getAttachmentByName(slotName: string, attachmentName: string): Attachment {\n        return this.getAttachment(this.data.findSlotIndex(slotName), attachmentName);\n    }\n\n    /** @return May be null. */\n    getAttachment(slotIndex: number, attachmentName: string): Attachment {\n        if (attachmentName == null) throw new Error('attachmentName cannot be null.');\n        if (this.skin != null) {\n            const attachment: Attachment = this.skin.getAttachment(slotIndex, attachmentName);\n\n            if (attachment != null) return attachment;\n        }\n        if (this.data.defaultSkin != null) return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);\n\n        return null;\n    }\n\n    /** @param attachmentName May be null. */\n    setAttachment(slotName: string, attachmentName?: string) {\n        if (slotName == null) throw new Error('slotName cannot be null.');\n        const slots = this.slots;\n\n        for (let i = 0, n = slots.length; i < n; i++) {\n            const slot = slots[i];\n\n            if (slot.data.name == slotName) {\n                let attachment: Attachment = null;\n\n                if (attachmentName != null) {\n                    attachment = this.getAttachment(i, attachmentName);\n                    if (attachment == null) throw new Error(`Attachment not found: ${attachmentName}, for slot: ${slotName}`);\n                }\n                slot.setAttachment(attachment);\n\n                return;\n            }\n        }\n        throw new Error(`Slot not found: ${slotName}`);\n    }\n\n    /** @return May be null. */\n    findIkConstraint(constraintName: string) {\n        if (constraintName == null) throw new Error('constraintName cannot be null.');\n        const ikConstraints = this.ikConstraints;\n\n        for (let i = 0, n = ikConstraints.length; i < n; i++) {\n            const ikConstraint = ikConstraints[i];\n\n            if (ikConstraint.data.name == constraintName) return ikConstraint;\n        }\n\n        return null;\n    }\n\n    /** @return May be null. */\n    findTransformConstraint(constraintName: string) {\n        if (constraintName == null) throw new Error('constraintName cannot be null.');\n        const transformConstraints = this.transformConstraints;\n\n        for (let i = 0, n = transformConstraints.length; i < n; i++) {\n            const constraint = transformConstraints[i];\n\n            if (constraint.data.name == constraintName) return constraint;\n        }\n\n        return null;\n    }\n\n    /** @return May be null. */\n    findPathConstraint(constraintName: string) {\n        if (constraintName == null) throw new Error('constraintName cannot be null.');\n        const pathConstraints = this.pathConstraints;\n\n        for (let i = 0, n = pathConstraints.length; i < n; i++) {\n            const constraint = pathConstraints[i];\n\n            if (constraint.data.name == constraintName) return constraint;\n        }\n\n        return null;\n    }\n\n    /** Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose.\n     * @param offset The distance from the skeleton origin to the bottom left corner of the AABB.\n     * @param size The width and height of the AABB.\n     * @param temp Working memory */\n    getBounds(offset: Vector2, size: Vector2, temp: Array<number> = new Array<number>(2)) {\n        if (offset == null) throw new Error('offset cannot be null.');\n        if (size == null) throw new Error('size cannot be null.');\n        const drawOrder = this.drawOrder;\n        let minX = Number.POSITIVE_INFINITY;\n        let minY = Number.POSITIVE_INFINITY;\n        let maxX = Number.NEGATIVE_INFINITY;\n        let maxY = Number.NEGATIVE_INFINITY;\n\n        for (let i = 0, n = drawOrder.length; i < n; i++) {\n            const slot = drawOrder[i];\n\n            if (!slot.bone.active) continue;\n            let verticesLength = 0;\n            let vertices: ArrayLike<number> = null;\n            const attachment = slot.getAttachment();\n\n            if (attachment instanceof RegionAttachment) {\n                verticesLength = 8;\n                vertices = Utils.setArraySize(temp, verticesLength, 0);\n                (<RegionAttachment>attachment).computeWorldVertices(slot.bone, vertices, 0, 2);\n            } else if (attachment instanceof MeshAttachment) {\n                const mesh = <MeshAttachment>attachment;\n\n                verticesLength = mesh.worldVerticesLength;\n                vertices = Utils.setArraySize(temp, verticesLength, 0);\n                mesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);\n            }\n            if (vertices != null) {\n                for (let ii = 0, nn = vertices.length; ii < nn; ii += 2) {\n                    const x = vertices[ii];\n                    const y = vertices[ii + 1];\n\n                    minX = Math.min(minX, x);\n                    minY = Math.min(minY, y);\n                    maxX = Math.max(maxX, x);\n                    maxY = Math.max(maxY, y);\n                }\n            }\n        }\n        offset.set(minX, minY);\n        size.set(maxX - minX, maxY - minY);\n    }\n\n    update(delta: number) {\n        this.time += delta;\n    }\n\n    get flipX(): boolean {\n        return this.scaleX == -1;\n    }\n\n    set flipX(value: boolean) {\n        if (!Skeleton.deprecatedWarning1) {\n            Skeleton.deprecatedWarning1 = true;\n            console.warn('Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY');\n        }\n        this.scaleX = value ? 1.0 : -1.0;\n    }\n\n    get flipY(): boolean {\n        return this.scaleY == -1;\n    }\n\n    set flipY(value: boolean) {\n        if (!Skeleton.deprecatedWarning1) {\n            Skeleton.deprecatedWarning1 = true;\n            console.warn('Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY');\n        }\n        this.scaleY = value ? 1.0 : -1.0;\n    }\n\n    private static deprecatedWarning1 = false;\n}\n","import type { ISkeletonData } from '@pixi-spine/base';\nimport type { Animation } from './Animation';\nimport type { BoneData } from './BoneData';\nimport type { SlotData } from './SlotData';\nimport type { Skin } from './Skin';\nimport type { EventData } from './EventData';\nimport type { IkConstraintData } from './IkConstraintData';\nimport type { TransformConstraintData } from './TransformConstraintData';\nimport type { PathConstraintData } from './PathConstraintData';\n\n/**\n * @public\n */\nexport class SkeletonData implements ISkeletonData<BoneData, SlotData, Skin, Animation, EventData, IkConstraintData, TransformConstraintData, PathConstraintData> {\n    name: string;\n    bones = new Array<BoneData>(); // Ordered parents first.\n    slots = new Array<SlotData>(); // Setup pose draw order.\n    skins = new Array<Skin>();\n    defaultSkin: Skin;\n    events = new Array<EventData>();\n    animations = new Array<Animation>();\n    ikConstraints = new Array<IkConstraintData>();\n    transformConstraints = new Array<TransformConstraintData>();\n    pathConstraints = new Array<PathConstraintData>();\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n    version: string;\n    hash: string;\n\n    // Nonessential\n    fps = 0;\n    imagesPath: string;\n    audioPath: string;\n\n    findBone(boneName: string) {\n        if (boneName == null) throw new Error('boneName cannot be null.');\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) {\n            const bone = bones[i];\n\n            if (bone.name == boneName) return bone;\n        }\n\n        return null;\n    }\n\n    findBoneIndex(boneName: string) {\n        if (boneName == null) throw new Error('boneName cannot be null.');\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) if (bones[i].name == boneName) return i;\n\n        return -1;\n    }\n\n    findSlot(slotName: string) {\n        if (slotName == null) throw new Error('slotName cannot be null.');\n        const slots = this.slots;\n\n        for (let i = 0, n = slots.length; i < n; i++) {\n            const slot = slots[i];\n\n            if (slot.name == slotName) return slot;\n        }\n\n        return null;\n    }\n\n    findSlotIndex(slotName: string) {\n        if (slotName == null) throw new Error('slotName cannot be null.');\n        const slots = this.slots;\n\n        for (let i = 0, n = slots.length; i < n; i++) if (slots[i].name == slotName) return i;\n\n        return -1;\n    }\n\n    findSkin(skinName: string) {\n        if (skinName == null) throw new Error('skinName cannot be null.');\n        const skins = this.skins;\n\n        for (let i = 0, n = skins.length; i < n; i++) {\n            const skin = skins[i];\n\n            if (skin.name == skinName) return skin;\n        }\n\n        return null;\n    }\n\n    findEvent(eventDataName: string) {\n        if (eventDataName == null) throw new Error('eventDataName cannot be null.');\n        const events = this.events;\n\n        for (let i = 0, n = events.length; i < n; i++) {\n            const event = events[i];\n\n            if (event.name == eventDataName) return event;\n        }\n\n        return null;\n    }\n\n    findAnimation(animationName: string) {\n        if (animationName == null) throw new Error('animationName cannot be null.');\n        const animations = this.animations;\n\n        for (let i = 0, n = animations.length; i < n; i++) {\n            const animation = animations[i];\n\n            if (animation.name == animationName) return animation;\n        }\n\n        return null;\n    }\n\n    findIkConstraint(constraintName: string) {\n        if (constraintName == null) throw new Error('constraintName cannot be null.');\n        const ikConstraints = this.ikConstraints;\n\n        for (let i = 0, n = ikConstraints.length; i < n; i++) {\n            const constraint = ikConstraints[i];\n\n            if (constraint.name == constraintName) return constraint;\n        }\n\n        return null;\n    }\n\n    findTransformConstraint(constraintName: string) {\n        if (constraintName == null) throw new Error('constraintName cannot be null.');\n        const transformConstraints = this.transformConstraints;\n\n        for (let i = 0, n = transformConstraints.length; i < n; i++) {\n            const constraint = transformConstraints[i];\n\n            if (constraint.name == constraintName) return constraint;\n        }\n\n        return null;\n    }\n\n    findPathConstraint(constraintName: string) {\n        if (constraintName == null) throw new Error('constraintName cannot be null.');\n        const pathConstraints = this.pathConstraints;\n\n        for (let i = 0, n = pathConstraints.length; i < n; i++) {\n            const constraint = pathConstraints[i];\n\n            if (constraint.name == constraintName) return constraint;\n        }\n\n        return null;\n    }\n\n    findPathConstraintIndex(pathConstraintName: string) {\n        if (pathConstraintName == null) throw new Error('pathConstraintName cannot be null.');\n        const pathConstraints = this.pathConstraints;\n\n        for (let i = 0, n = pathConstraints.length; i < n; i++) if (pathConstraints[i].name == pathConstraintName) return i;\n\n        return -1;\n    }\n}\n","import { Color } from '@pixi-spine/base';\n\nimport type { ISlotData } from '@pixi-spine/base';\nimport type { BLEND_MODES } from '@pixi/core';\nimport type { BoneData } from './BoneData';\n\n/**\n * @public\n */\nexport class SlotData implements ISlotData {\n    index: number;\n    name: string;\n    boneData: BoneData;\n    color = new Color(1, 1, 1, 1);\n    darkColor: Color;\n    attachmentName: string;\n    blendMode: BLEND_MODES;\n\n    constructor(index: number, name: string, boneData: BoneData) {\n        if (index < 0) throw new Error('index must be >= 0.');\n        if (name == null) throw new Error('name cannot be null.');\n        if (boneData == null) throw new Error('boneData cannot be null.');\n        this.index = index;\n        this.name = name;\n        this.boneData = boneData;\n    }\n}\n","import type { BoneData } from './BoneData';\nimport { ConstraintData } from './Constraint';\n\n/**\n * @public\n */\nexport class TransformConstraintData extends ConstraintData {\n    bones = new Array<BoneData>();\n    target: BoneData;\n    rotateMix = 0;\n    translateMix = 0;\n    scaleMix = 0;\n    shearMix = 0;\n    offsetRotation = 0;\n    offsetX = 0;\n    offsetY = 0;\n    offsetScaleX = 0;\n    offsetScaleY = 0;\n    offsetShearY = 0;\n    relative = false;\n    local = false;\n\n    constructor(name: string) {\n        super(name, 0, false);\n    }\n}\n","import { Attachment, MeshAttachment } from './attachments';\nimport type { BoneData } from './BoneData';\nimport type { ConstraintData } from './Constraint';\nimport type { Skeleton } from './Skeleton';\n\nimport type { Map, ISkin } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class SkinEntry {\n    constructor(public slotIndex: number, public name: string, public attachment: Attachment) {}\n}\n\n/**\n * @public\n */\nexport class Skin implements ISkin {\n    name: string;\n    attachments = new Array<Map<Attachment>>();\n    bones = Array<BoneData>();\n    constraints = new Array<ConstraintData>();\n\n    constructor(name: string) {\n        if (name == null) throw new Error('name cannot be null.');\n        this.name = name;\n    }\n\n    setAttachment(slotIndex: number, name: string, attachment: Attachment) {\n        if (attachment == null) throw new Error('attachment cannot be null.');\n        const attachments = this.attachments;\n\n        if (slotIndex >= attachments.length) attachments.length = slotIndex + 1;\n        if (!attachments[slotIndex]) attachments[slotIndex] = {};\n        attachments[slotIndex][name] = attachment;\n    }\n\n    addSkin(skin: Skin) {\n        for (let i = 0; i < skin.bones.length; i++) {\n            const bone = skin.bones[i];\n            let contained = false;\n\n            for (let j = 0; j < this.bones.length; j++) {\n                if (this.bones[j] == bone) {\n                    contained = true;\n                    break;\n                }\n            }\n            if (!contained) this.bones.push(bone);\n        }\n\n        for (let i = 0; i < skin.constraints.length; i++) {\n            const constraint = skin.constraints[i];\n            let contained = false;\n\n            for (let j = 0; j < this.constraints.length; j++) {\n                if (this.constraints[j] == constraint) {\n                    contained = true;\n                    break;\n                }\n            }\n            if (!contained) this.constraints.push(constraint);\n        }\n\n        const attachments = skin.getAttachments();\n\n        for (let i = 0; i < attachments.length; i++) {\n            const attachment = attachments[i];\n\n            this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\n        }\n    }\n\n    copySkin(skin: Skin) {\n        for (let i = 0; i < skin.bones.length; i++) {\n            const bone = skin.bones[i];\n            let contained = false;\n\n            for (let j = 0; j < this.bones.length; j++) {\n                if (this.bones[j] == bone) {\n                    contained = true;\n                    break;\n                }\n            }\n            if (!contained) this.bones.push(bone);\n        }\n\n        for (let i = 0; i < skin.constraints.length; i++) {\n            const constraint = skin.constraints[i];\n            let contained = false;\n\n            for (let j = 0; j < this.constraints.length; j++) {\n                if (this.constraints[j] == constraint) {\n                    contained = true;\n                    break;\n                }\n            }\n            if (!contained) this.constraints.push(constraint);\n        }\n\n        const attachments = skin.getAttachments();\n\n        for (let i = 0; i < attachments.length; i++) {\n            const attachment = attachments[i];\n\n            if (attachment.attachment == null) continue;\n            if (attachment.attachment instanceof MeshAttachment) {\n                attachment.attachment = attachment.attachment.newLinkedMesh();\n                this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\n            } else {\n                attachment.attachment = attachment.attachment.copy();\n                this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\n            }\n        }\n    }\n\n    /** @return May be null. */\n    getAttachment(slotIndex: number, name: string): Attachment {\n        const dictionary = this.attachments[slotIndex];\n\n        return dictionary ? dictionary[name] : null;\n    }\n\n    removeAttachment(slotIndex: number, name: string) {\n        const dictionary = this.attachments[slotIndex];\n\n        if (dictionary) dictionary[name] = null;\n    }\n\n    getAttachments(): Array<SkinEntry> {\n        const entries = new Array<SkinEntry>();\n\n        for (let i = 0; i < this.attachments.length; i++) {\n            const slotAttachments = this.attachments[i];\n\n            if (slotAttachments) {\n                for (const name in slotAttachments) {\n                    const attachment = slotAttachments[name];\n\n                    if (attachment) entries.push(new SkinEntry(i, name, attachment));\n                }\n            }\n        }\n\n        return entries;\n    }\n\n    getAttachmentsForSlot(slotIndex: number, attachments: Array<SkinEntry>) {\n        const slotAttachments = this.attachments[slotIndex];\n\n        if (slotAttachments) {\n            for (const name in slotAttachments) {\n                const attachment = slotAttachments[name];\n\n                if (attachment) attachments.push(new SkinEntry(slotIndex, name, attachment));\n            }\n        }\n    }\n\n    clear() {\n        this.attachments.length = 0;\n        this.bones.length = 0;\n        this.constraints.length = 0;\n    }\n\n    /** Attach each attachment in this skin if the corresponding attachment in the old skin is currently attached. */\n    attachAll(skeleton: Skeleton, oldSkin: Skin) {\n        let slotIndex = 0;\n\n        for (let i = 0; i < skeleton.slots.length; i++) {\n            const slot = skeleton.slots[i];\n            const slotAttachment = slot.getAttachment();\n\n            if (slotAttachment && slotIndex < oldSkin.attachments.length) {\n                const dictionary = oldSkin.attachments[slotIndex];\n\n                for (const key in dictionary) {\n                    const skinAttachment: Attachment = dictionary[key];\n\n                    if (slotAttachment == skinAttachment) {\n                        const attachment = this.getAttachment(slotIndex, key);\n\n                        if (attachment != null) slot.setAttachment(attachment);\n                        break;\n                    }\n                }\n            }\n            slotIndex++;\n        }\n    }\n}\n","import type { Attachment, AttachmentLoader, MeshAttachment, VertexAttachment } from './attachments';\r\nimport { Event } from './Event';\r\nimport { SkeletonData } from './SkeletonData';\r\nimport { SlotData } from './SlotData';\r\nimport { BoneData } from './BoneData';\r\nimport { IkConstraintData } from './IkConstraintData';\r\nimport { TransformConstraintData } from './TransformConstraintData';\r\nimport { PathConstraintData, SpacingMode } from './PathConstraintData';\r\nimport { Skin } from './Skin';\r\nimport { EventData } from './EventData';\r\nimport {\r\n    Animation,\r\n    AttachmentTimeline,\r\n    ColorTimeline,\r\n    CurveTimeline,\r\n    DeformTimeline,\r\n    DrawOrderTimeline,\r\n    EventTimeline,\r\n    IkConstraintTimeline,\r\n    PathConstraintMixTimeline,\r\n    PathConstraintPositionTimeline,\r\n    PathConstraintSpacingTimeline,\r\n    RotateTimeline,\r\n    ScaleTimeline,\r\n    ShearTimeline,\r\n    Timeline,\r\n    TransformConstraintTimeline,\r\n    TranslateTimeline,\r\n} from './Animation';\r\nimport { AttachmentType, BinaryInput, Color, PositionMode, RotateMode, TransformMode, Utils } from '@pixi-spine/base';\r\nimport { BLEND_MODES } from '@pixi/core';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class SkeletonBinary {\r\n    static AttachmentTypeValues = [\r\n        0 /* AttachmentType.Region*/, 1 /* AttachmentType.BoundingBox*/, 2 /* AttachmentType.Mesh*/, 3 /* AttachmentType.LinkedMesh*/, 4 /* AttachmentType.Path*/,\r\n        5 /* AttachmentType.Point*/, 6 /* AttachmentType.Clipping*/,\r\n    ];\r\n    static TransformModeValues = [\r\n        TransformMode.Normal,\r\n        TransformMode.OnlyTranslation,\r\n        TransformMode.NoRotationOrReflection,\r\n        TransformMode.NoScale,\r\n        TransformMode.NoScaleOrReflection,\r\n    ];\r\n    static PositionModeValues = [PositionMode.Fixed, PositionMode.Percent];\r\n    static SpacingModeValues = [SpacingMode.Length, SpacingMode.Fixed, SpacingMode.Percent];\r\n    static RotateModeValues = [RotateMode.Tangent, RotateMode.Chain, RotateMode.ChainScale];\r\n    static BlendModeValues = [BLEND_MODES.NORMAL, BLEND_MODES.ADD, BLEND_MODES.MULTIPLY, BLEND_MODES.SCREEN];\r\n\r\n    static BONE_ROTATE = 0;\r\n    static BONE_TRANSLATE = 1;\r\n    static BONE_SCALE = 2;\r\n    static BONE_SHEAR = 3;\r\n\r\n    static SLOT_ATTACHMENT = 0;\r\n    static SLOT_COLOR = 1;\r\n    static SLOT_TWO_COLOR = 2;\r\n\r\n    static PATH_POSITION = 0;\r\n    static PATH_SPACING = 1;\r\n    static PATH_MIX = 2;\r\n\r\n    static CURVE_LINEAR = 0;\r\n    static CURVE_STEPPED = 1;\r\n    static CURVE_BEZIER = 2;\r\n\r\n    attachmentLoader: AttachmentLoader;\r\n    scale = 1;\r\n    private linkedMeshes = new Array<LinkedMesh>();\r\n\r\n    constructor(attachmentLoader: AttachmentLoader) {\r\n        this.attachmentLoader = attachmentLoader;\r\n    }\r\n\r\n    readSkeletonData(binary: Uint8Array): SkeletonData {\r\n        const scale = this.scale;\r\n\r\n        const skeletonData = new SkeletonData();\r\n\r\n        skeletonData.name = ''; // BOZO\r\n\r\n        const input = new BinaryInput(binary);\r\n\r\n        skeletonData.hash = input.readString();\r\n        skeletonData.version = input.readString();\r\n        if (skeletonData.version === '3.8.75') {\r\n            const error = `Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine.`;\r\n\r\n            console.error(error);\r\n        }\r\n        skeletonData.width = input.readFloat();\r\n        skeletonData.height = input.readFloat();\r\n\r\n        const nonessential = input.readBoolean();\r\n\r\n        if (nonessential) {\r\n            skeletonData.imagesPath = input.readString();\r\n        }\r\n\r\n        let n = 0;\r\n\r\n        // Bones.\r\n        n = input.readInt(true);\r\n        for (let i = 0; i < n; i++) {\r\n            const name = input.readString();\r\n            const parent = i == 0 ? null : skeletonData.bones[input.readInt(true)];\r\n            const data = new BoneData(i, name, parent);\r\n\r\n            data.rotation = input.readFloat();\r\n            data.x = input.readFloat() * scale;\r\n            data.y = input.readFloat() * scale;\r\n            data.scaleX = input.readFloat();\r\n            data.scaleY = input.readFloat();\r\n            data.shearX = input.readFloat();\r\n            data.shearY = input.readFloat();\r\n            data.length = input.readFloat() * scale;\r\n            data.inheritRotation = input.readBoolean();\r\n            data.inheritScale = input.readBoolean();\r\n            let transform = 0;\r\n            if (!data.inheritRotation && data.inheritScale) transform = 2;\r\n            if (data.inheritRotation && !data.inheritScale) transform = 3;\r\n            if (!data.inheritRotation && !data.inheritScale) transform = 1;\r\n            data.transformMode = transform;\r\n\r\n            if (nonessential) Color.rgba8888ToColor(data.color, input.readInt32());\r\n            skeletonData.bones.push(data);\r\n        }\r\n\r\n        // Slots.\r\n        n = input.readInt(true);\r\n        for (let i = 0; i < n; i++) {\r\n            const slotName = input.readString();\r\n            const boneData = skeletonData.bones[input.readInt(true)];\r\n            const data = new SlotData(i, slotName, boneData);\r\n\r\n            Color.rgba8888ToColor(data.color, input.readInt32());\r\n            data.attachmentName = input.readString();\r\n            data.blendMode = SkeletonBinary.BlendModeValues[input.readInt(true)];\r\n            skeletonData.slots.push(data);\r\n        }\r\n\r\n        // IK constraints.\r\n        n = input.readInt(true);\r\n        for (let i = 0, nn; i < n; i++) {\r\n            const name = input.readString();\r\n            const data = new IkConstraintData(name);\r\n\r\n            nn = input.readInt(true);\r\n            for (let ii = 0; ii < nn; ii++) data.bones.push(skeletonData.bones[input.readInt(true)]);\r\n            data.target = skeletonData.bones[input.readInt(true)];\r\n            data.mix = input.readFloat();\r\n            data.bendDirection = input.readByte();\r\n            skeletonData.ikConstraints.push(data);\r\n        }\r\n\r\n        // Transform constraints.\r\n        n = input.readInt(true);\r\n        for (let i = 0, nn; i < n; i++) {\r\n            const name = input.readString();\r\n            const data = new TransformConstraintData(name);\r\n\r\n            nn = input.readInt(true);\r\n            for (let ii = 0; ii < nn; ii++) data.bones.push(skeletonData.bones[input.readInt(true)]);\r\n            data.target = skeletonData.bones[input.readInt(true)];\r\n            data.offsetRotation = input.readFloat();\r\n            data.offsetX = input.readFloat() * scale;\r\n            data.offsetY = input.readFloat() * scale;\r\n            data.offsetScaleX = input.readFloat();\r\n            data.offsetScaleY = input.readFloat();\r\n            data.offsetShearY = input.readFloat();\r\n            data.rotateMix = input.readFloat();\r\n            data.translateMix = input.readFloat();\r\n            data.scaleMix = input.readFloat();\r\n            data.shearMix = input.readFloat();\r\n            skeletonData.transformConstraints.push(data);\r\n        }\r\n\r\n        // Path constraints.\r\n        n = input.readInt(true);\r\n        for (let i = 0, nn; i < n; i++) {\r\n            const name = input.readString();\r\n            const data = new PathConstraintData(name);\r\n\r\n            nn = input.readInt(true);\r\n            for (let ii = 0; ii < nn; ii++) data.bones.push(skeletonData.bones[input.readInt(true)]);\r\n            data.target = skeletonData.slots[input.readInt(true)];\r\n            data.positionMode = SkeletonBinary.PositionModeValues[input.readInt(true)];\r\n            data.spacingMode = SkeletonBinary.SpacingModeValues[input.readInt(true)];\r\n            data.rotateMode = SkeletonBinary.RotateModeValues[input.readInt(true)];\r\n            data.offsetRotation = input.readFloat();\r\n            data.position = input.readFloat();\r\n            if (data.positionMode == PositionMode.Fixed) data.position *= scale;\r\n            data.spacing = input.readFloat();\r\n            if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) data.spacing *= scale;\r\n            data.rotateMix = input.readFloat();\r\n            data.translateMix = input.readFloat();\r\n            skeletonData.pathConstraints.push(data);\r\n        }\r\n\r\n        // Default skin.\r\n        const defaultSkin = this.readSkin(input, skeletonData, true, nonessential);\r\n\r\n        if (defaultSkin != null) {\r\n            skeletonData.defaultSkin = defaultSkin;\r\n            skeletonData.skins.push(defaultSkin);\r\n        }\r\n\r\n        // Skins.\r\n        {\r\n            let i = skeletonData.skins.length;\r\n\r\n            Utils.setArraySize(skeletonData.skins, (n = i + input.readInt(true)));\r\n            for (; i < n; i++) skeletonData.skins[i] = this.readSkin(input, skeletonData, false, nonessential);\r\n        }\r\n\r\n        // Linked meshes.\r\n        n = this.linkedMeshes.length;\r\n        for (let i = 0; i < n; i++) {\r\n            const linkedMesh = this.linkedMeshes[i];\r\n            const skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\r\n\r\n            if (skin == null) throw new Error(`Skin not found: ${linkedMesh.skin}`);\r\n            const parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\r\n\r\n            if (parent == null) throw new Error(`Parent mesh not found: ${linkedMesh.parent}`);\r\n            linkedMesh.mesh.deformAttachment = linkedMesh.inheritDeform ? (parent as VertexAttachment) : linkedMesh.mesh;\r\n            linkedMesh.mesh.setParentMesh(parent as MeshAttachment);\r\n            // linkedMesh.mesh.updateUVs();\r\n        }\r\n        this.linkedMeshes.length = 0;\r\n\r\n        // Events.\r\n        n = input.readInt(true);\r\n        for (let i = 0; i < n; i++) {\r\n            const data = new EventData(input.readStringRef());\r\n\r\n            data.intValue = input.readInt(false);\r\n            data.floatValue = input.readFloat();\r\n            data.stringValue = input.readString();\r\n            data.audioPath = input.readString();\r\n            if (data.audioPath != null) {\r\n                data.volume = input.readFloat();\r\n                data.balance = input.readFloat();\r\n            }\r\n            skeletonData.events.push(data);\r\n        }\r\n\r\n        // Animations.\r\n        n = input.readInt(true);\r\n        for (let i = 0; i < n; i++) skeletonData.animations.push(this.readAnimation(input, input.readString(), skeletonData));\r\n\r\n        return skeletonData;\r\n    }\r\n\r\n    private readSkin(input: BinaryInput, skeletonData: SkeletonData, defaultSkin: boolean, nonessential: boolean): Skin {\r\n        let skin = null;\r\n        let slotCount = 0;\r\n\r\n        if (defaultSkin) {\r\n            slotCount = input.readInt(true);\r\n            if (slotCount == 0) return null;\r\n            skin = new Skin('default');\r\n        } else {\r\n            skin = new Skin(input.readString());\r\n            skin.bones.length = input.readInt(true);\r\n            for (let i = 0, n = skin.bones.length; i < n; i++) skin.bones[i] = skeletonData.bones[input.readInt(true)];\r\n\r\n            for (let i = 0, n = input.readInt(true); i < n; i++) skin.constraints.push(skeletonData.ikConstraints[input.readInt(true)]);\r\n            for (let i = 0, n = input.readInt(true); i < n; i++) skin.constraints.push(skeletonData.transformConstraints[input.readInt(true)]);\r\n            for (let i = 0, n = input.readInt(true); i < n; i++) skin.constraints.push(skeletonData.pathConstraints[input.readInt(true)]);\r\n\r\n            slotCount = input.readInt(true);\r\n        }\r\n\r\n        for (let i = 0; i < slotCount; i++) {\r\n            const slotIndex = input.readInt(true);\r\n\r\n            for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\r\n                const name = input.readString();\r\n                const attachment = this.readAttachment(input, skeletonData, skin, slotIndex, name, nonessential);\r\n\r\n                if (attachment != null) skin.setAttachment(slotIndex, name, attachment);\r\n            }\r\n        }\r\n\r\n        return skin;\r\n    }\r\n\r\n    private readAttachment(input: BinaryInput, skeletonData: SkeletonData, skin: Skin, slotIndex: number, attachmentName: string, nonessential: boolean): Attachment {\r\n        const scale = this.scale;\r\n\r\n        let name = input.readStringRef();\r\n\r\n        if (name == null) name = attachmentName;\r\n\r\n        const typeIndex = input.readByte();\r\n        const type = SkeletonBinary.AttachmentTypeValues[typeIndex];\r\n\r\n        switch (type) {\r\n            case AttachmentType.Region: {\r\n                let path = input.readString();\r\n                const rotation = input.readFloat();\r\n                const x = input.readFloat();\r\n                const y = input.readFloat();\r\n                const scaleX = input.readFloat();\r\n                const scaleY = input.readFloat();\r\n                const width = input.readFloat();\r\n                const height = input.readFloat();\r\n                const color = input.readInt32();\r\n\r\n                if (path == null) path = name;\r\n                const region = this.attachmentLoader.newRegionAttachment(skin, name, path);\r\n\r\n                if (region == null) return null;\r\n                region.path = path;\r\n                region.x = x * scale;\r\n                region.y = y * scale;\r\n                region.scaleX = scaleX;\r\n                region.scaleY = scaleY;\r\n                region.rotation = rotation;\r\n                region.width = width * scale;\r\n                region.height = height * scale;\r\n                Color.rgba8888ToColor(region.color, color);\r\n                // region.updateOffset();\r\n                return region;\r\n            }\r\n            case AttachmentType.BoundingBox: {\r\n                const vertexCount = input.readInt(true);\r\n                const vertices = this.readVertices(input, vertexCount);\r\n                const color = nonessential ? input.readInt32() : 0;\r\n\r\n                const box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\r\n\r\n                if (box == null) return null;\r\n                box.worldVerticesLength = vertexCount << 1;\r\n                box.vertices = vertices.vertices;\r\n                box.bones = vertices.bones;\r\n                box.cVertices = vertices.cVertices;\r\n                if (nonessential) Color.rgba8888ToColor(box.color, color);\r\n\r\n                return box;\r\n            }\r\n            case AttachmentType.Mesh: {\r\n                let path = input.readStringRef();\r\n                const color = input.readInt32();\r\n                const vertexCount = input.readInt(true);\r\n                const uvs = this.readFloatArray(input, vertexCount << 1, 1);\r\n                const triangles = this.readShortArray(input);\r\n                const vertices = this.readVertices(input, vertexCount);\r\n                const hullLength = input.readInt(true);\r\n                let edges = null;\r\n                let width = 0;\r\n                let height = 0;\r\n\r\n                if (nonessential) {\r\n                    edges = this.readShortArray(input);\r\n                    width = input.readFloat();\r\n                    height = input.readFloat();\r\n                }\r\n\r\n                if (path == null) path = name;\r\n                const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\r\n\r\n                if (mesh == null) return null;\r\n                mesh.path = path;\r\n                Color.rgba8888ToColor(mesh.color, color);\r\n                mesh.bones = vertices.bones;\r\n                mesh.vertices = vertices.vertices;\r\n                mesh.worldVerticesLength = vertexCount << 1;\r\n                mesh.triangles = triangles;\r\n                mesh.regionUVs = new Float32Array(uvs);\r\n                mesh.cVertices = vertices.cVertices;\r\n                // mesh.updateUVs();\r\n                mesh.hullLength = hullLength << 1;\r\n                if (nonessential) {\r\n                    mesh.edges = edges;\r\n                    mesh.width = width * scale;\r\n                    mesh.height = height * scale;\r\n                }\r\n\r\n                return mesh;\r\n            }\r\n            case AttachmentType.LinkedMesh: {\r\n                let path = input.readStringRef();\r\n                const color = input.readInt32();\r\n                const skinName = input.readStringRef();\r\n                const parent = input.readStringRef();\r\n                const inheritDeform = input.readBoolean();\r\n                let width = 0;\r\n                let height = 0;\r\n\r\n                if (nonessential) {\r\n                    width = input.readFloat();\r\n                    height = input.readFloat();\r\n                }\r\n\r\n                if (path == null) path = name;\r\n                const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\r\n\r\n                if (mesh == null) return null;\r\n                mesh.path = path;\r\n                Color.rgba8888ToColor(mesh.color, color);\r\n                if (nonessential) {\r\n                    mesh.width = width * scale;\r\n                    mesh.height = height * scale;\r\n                }\r\n                this.linkedMeshes.push(new LinkedMesh(mesh, skinName, slotIndex, parent, inheritDeform));\r\n\r\n                return mesh;\r\n            }\r\n            case AttachmentType.Path: {\r\n                const closed = input.readBoolean();\r\n                const constantSpeed = input.readBoolean();\r\n                const vertexCount = input.readInt(true);\r\n                const vertices = this.readVertices(input, vertexCount);\r\n                const lengths = Utils.newArray(vertexCount / 3, 0);\r\n\r\n                for (let i = 0, n = lengths.length; i < n; i++) lengths[i] = input.readFloat() * scale;\r\n                const color = nonessential ? input.readInt32() : 0;\r\n\r\n                const path = this.attachmentLoader.newPathAttachment(skin, name);\r\n\r\n                if (path == null) return null;\r\n                path.closed = closed;\r\n                path.constantSpeed = constantSpeed;\r\n                path.worldVerticesLength = vertexCount << 1;\r\n                path.vertices = vertices.vertices;\r\n                path.bones = vertices.bones;\r\n                path.lengths = lengths;\r\n                path.cVertices = vertices.cVertices;\r\n                if (nonessential) Color.rgba8888ToColor(path.color, color);\r\n\r\n                return path;\r\n            }\r\n            case AttachmentType.Point: {\r\n                const rotation = input.readFloat();\r\n                const x = input.readFloat();\r\n                const y = input.readFloat();\r\n                const color = nonessential ? input.readInt32() : 0;\r\n\r\n                const point = this.attachmentLoader.newPointAttachment(skin, name);\r\n\r\n                if (point == null) return null;\r\n                point.x = x * scale;\r\n                point.y = y * scale;\r\n                point.rotation = rotation;\r\n                if (nonessential) Color.rgba8888ToColor(point.color, color);\r\n\r\n                return point;\r\n            }\r\n            case AttachmentType.Clipping: {\r\n                const endSlotIndex = input.readInt(true);\r\n                const vertexCount = input.readInt(true);\r\n                const vertices = this.readVertices(input, vertexCount);\r\n                const color = nonessential ? input.readInt32() : 0;\r\n\r\n                const clip = this.attachmentLoader.newClippingAttachment(skin, name);\r\n\r\n                if (clip == null) return null;\r\n                clip.endSlot = skeletonData.slots[endSlotIndex];\r\n                clip.worldVerticesLength = vertexCount << 1;\r\n                clip.vertices = vertices.vertices;\r\n                clip.bones = vertices.bones;\r\n                clip.cVertices = vertices.cVertices;\r\n                if (nonessential) Color.rgba8888ToColor(clip.color, color);\r\n\r\n                return clip;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private readVertices(input: BinaryInput, vertexCount: number): Vertices {\r\n        const verticesLength = vertexCount << 1;\r\n        const vertices = new Vertices();\r\n        const scale = this.scale;\r\n\r\n        if (!input.readBoolean()) {\r\n            vertices.vertices = this.readFloatArray(input, verticesLength, scale);\r\n\r\n            return vertices;\r\n        }\r\n        const myVertices = new Array<number>();\r\n        const weights = new Array<number>();\r\n        const bonesArray = new Array<number>();\r\n\r\n        for (let i = 0; i < vertexCount; i++) {\r\n            const boneCount = input.readInt(true);\r\n\r\n            bonesArray.push(boneCount);\r\n            myVertices.push(boneCount);\r\n            for (let ii = 0; ii < boneCount; ii++) {\r\n                const bone2 = input.readInt(true);\r\n\r\n                bonesArray.push(bone2);\r\n                myVertices.push(bone2);\r\n                const weight1 = input.readFloat() * scale;\r\n                const weight2 = input.readFloat() * scale;\r\n                const weight3 = input.readFloat();\r\n\r\n                weights.push(weight1);\r\n                weights.push(weight2);\r\n                weights.push(weight3);\r\n                myVertices.push(weight1);\r\n                myVertices.push(weight2);\r\n                myVertices.push(weight3);\r\n            }\r\n        }\r\n        vertices.vertices = Utils.toFloatArray(weights);\r\n        vertices.bones = bonesArray;\r\n        vertices.cVertices = myVertices;\r\n\r\n        return vertices;\r\n    }\r\n\r\n    private readFloatArray(input: BinaryInput, n: number, scale: number): number[] {\r\n        const array = new Array<number>(n);\r\n\r\n        if (scale == 1) {\r\n            for (let i = 0; i < n; i++) array[i] = input.readFloat();\r\n        } else {\r\n            for (let i = 0; i < n; i++) array[i] = input.readFloat() * scale;\r\n        }\r\n\r\n        return array;\r\n    }\r\n\r\n    private readShortArray(input: BinaryInput): number[] {\r\n        const n = input.readInt(true);\r\n        const array = new Array<number>(n);\r\n\r\n        for (let i = 0; i < n; i++) array[i] = input.readShort();\r\n\r\n        return array;\r\n    }\r\n\r\n    private readAnimation(input: BinaryInput, name: string, skeletonData: SkeletonData): Animation {\r\n        const timelines = new Array<Timeline>();\r\n        const scale = this.scale;\r\n        let duration = 0;\r\n        const tempColor1 = new Color();\r\n\r\n        // Slot timelines.\r\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\r\n            const slotIndex = input.readInt(true);\r\n\r\n            for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\r\n                const timelineType = input.readByte();\r\n                const frameCount = input.readInt(true);\r\n\r\n                switch (timelineType) {\r\n                    case SkeletonBinary.SLOT_ATTACHMENT: {\r\n                        const timeline = new AttachmentTimeline(frameCount);\r\n\r\n                        timeline.slotIndex = slotIndex;\r\n                        for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n                            const time = input.readFloat();\r\n                            const attachmentName = input.readString();\r\n\r\n                            timeline.setFrame(frameIndex, time, attachmentName);\r\n                        }\r\n                        timelines.push(timeline);\r\n                        duration = Math.max(duration, timeline.frames[frameCount - 1]);\r\n                        break;\r\n                    }\r\n                    case SkeletonBinary.SLOT_COLOR: {\r\n                        const timeline = new ColorTimeline(frameCount);\r\n\r\n                        timeline.slotIndex = slotIndex;\r\n                        for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n                            const time = input.readFloat();\r\n\r\n                            Color.rgba8888ToColor(tempColor1, input.readInt32());\r\n                            timeline.setFrame(frameIndex, time, tempColor1.r, tempColor1.g, tempColor1.b, tempColor1.a);\r\n                            if (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);\r\n                        }\r\n                        timelines.push(timeline);\r\n                        duration = Math.max(duration, timeline.frames[(frameCount - 1) * ColorTimeline.ENTRIES]);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Bone timelines.\r\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\r\n            const boneIndex = input.readInt(true);\r\n\r\n            for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\r\n                const timelineType = input.readByte();\r\n                const frameCount = input.readInt(true);\r\n\r\n                switch (timelineType) {\r\n                    case SkeletonBinary.BONE_ROTATE: {\r\n                        const timeline = new RotateTimeline(frameCount);\r\n\r\n                        timeline.boneIndex = boneIndex;\r\n\r\n                        for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n                            timeline.setFrame(frameIndex, input.readFloat(), input.readFloat());\r\n                            if (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);\r\n                        }\r\n                        timelines.push(timeline);\r\n                        duration = Math.max(duration, timeline.frames[(frameCount - 1) * RotateTimeline.ENTRIES]);\r\n                        break;\r\n                    }\r\n                    case SkeletonBinary.BONE_TRANSLATE:\r\n                    case SkeletonBinary.BONE_SCALE:\r\n                    case SkeletonBinary.BONE_SHEAR: {\r\n                        let timeline;\r\n                        let timelineScale = 1;\r\n\r\n                        if (timelineType == SkeletonBinary.BONE_SCALE) timeline = new ScaleTimeline(frameCount);\r\n                        else if (timelineType == SkeletonBinary.BONE_SHEAR) timeline = new ShearTimeline(frameCount);\r\n                        else {\r\n                            timeline = new TranslateTimeline(frameCount);\r\n                            timelineScale = scale;\r\n                        }\r\n                        timeline.boneIndex = boneIndex;\r\n                        for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n                            const time = input.readFloat();\r\n                            const x = input.readFloat();\r\n                            const y = input.readFloat();\r\n\r\n                            timeline.setFrame(frameIndex, time, x * timelineScale, y * timelineScale);\r\n                            if (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);\r\n                        }\r\n                        timelines.push(timeline);\r\n                        duration = Math.max(duration, timeline.frames[(frameCount - 1) * TranslateTimeline.ENTRIES]);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // IK constraint timelines.\r\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\r\n            const index = input.readInt(true);\r\n            const frameCount = input.readInt(true);\r\n            const timeline = new IkConstraintTimeline(frameCount);\r\n\r\n            timeline.ikConstraintIndex = index;\r\n            for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n                const time = input.readFloat();\r\n                const mix = input.readFloat();\r\n                const softness = input.readByte();\r\n\r\n                timeline.setFrame(frameIndex, time, mix, softness);\r\n                if (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);\r\n            }\r\n            timelines.push(timeline);\r\n            duration = Math.max(duration, timeline.frames[(frameCount - 1) * IkConstraintTimeline.ENTRIES]);\r\n        }\r\n\r\n        // Transform constraint timelines.\r\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\r\n            const index = input.readInt(true);\r\n            const frameCount = input.readInt(true);\r\n            const timeline = new TransformConstraintTimeline(frameCount);\r\n\r\n            timeline.transformConstraintIndex = index;\r\n            for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n                timeline.setFrame(frameIndex, input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat());\r\n                if (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);\r\n            }\r\n            timelines.push(timeline);\r\n            duration = Math.max(duration, timeline.frames[(frameCount - 1) * TransformConstraintTimeline.ENTRIES]);\r\n        }\r\n\r\n        // Path constraint timelines.\r\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\r\n            const index = input.readInt(true);\r\n            const data = skeletonData.pathConstraints[index];\r\n\r\n            for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\r\n                const timelineType = input.readByte();\r\n                const frameCount = input.readInt(true);\r\n\r\n                switch (timelineType) {\r\n                    case SkeletonBinary.PATH_POSITION:\r\n                    case SkeletonBinary.PATH_SPACING: {\r\n                        let timeline;\r\n                        let timelineScale = 1;\r\n\r\n                        if (timelineType == SkeletonBinary.PATH_SPACING) {\r\n                            timeline = new PathConstraintSpacingTimeline(frameCount);\r\n                            if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) timelineScale = scale;\r\n                        } else {\r\n                            timeline = new PathConstraintPositionTimeline(frameCount);\r\n                            if (data.positionMode == PositionMode.Fixed) timelineScale = scale;\r\n                        }\r\n                        timeline.pathConstraintIndex = index;\r\n                        for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n                            const time = input.readFloat();\r\n                            const value = input.readFloat() * timelineScale;\r\n\r\n                            timeline.setFrame(frameIndex, time, value);\r\n                            if (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);\r\n                        }\r\n                        timelines.push(timeline);\r\n                        duration = Math.max(duration, timeline.frames[(frameCount - 1) * PathConstraintPositionTimeline.ENTRIES]);\r\n                        break;\r\n                    }\r\n                    case SkeletonBinary.PATH_MIX: {\r\n                        const timeline = new PathConstraintMixTimeline(frameCount);\r\n\r\n                        timeline.pathConstraintIndex = index;\r\n                        for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n                            const time = input.readFloat();\r\n                            const rotateMix = input.readFloat();\r\n                            const translateMix = input.readFloat();\r\n\r\n                            timeline.setFrame(frameIndex, time, rotateMix, translateMix);\r\n                            if (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);\r\n                        }\r\n                        timelines.push(timeline);\r\n                        duration = Math.max(duration, timeline.frames[(frameCount - 1) * PathConstraintMixTimeline.ENTRIES]);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Deform timelines.\r\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\r\n            const skin = skeletonData.skins[input.readInt(true)];\r\n\r\n            for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\r\n                const slotIndex = input.readInt(true);\r\n\r\n                for (let iii = 0, nnn = input.readInt(true); iii < nnn; iii++) {\r\n                    const attachment = skin?.getAttachment(slotIndex, input.readString()) as VertexAttachment;\r\n                    const weighted = attachment.bones != null;\r\n                    const vertices = attachment.vertices;\r\n                    const deformLength = weighted ? (vertices.length / 3) * 2 : vertices.length;\r\n\r\n                    const frameCount = input.readInt(true);\r\n                    const timeline = new DeformTimeline(frameCount);\r\n\r\n                    timeline.slotIndex = slotIndex;\r\n                    timeline.attachment = attachment;\r\n\r\n                    for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n                        const time = input.readFloat();\r\n                        let deform;\r\n                        let end = input.readInt(true);\r\n\r\n                        if (end == 0) deform = weighted ? Utils.newFloatArray(deformLength) : vertices;\r\n                        else {\r\n                            deform = Utils.newFloatArray(deformLength);\r\n                            const start = input.readInt(true);\r\n\r\n                            end += start;\r\n                            if (scale == 1) {\r\n                                for (let v = start; v < end; v++) deform[v] = input.readFloat();\r\n                            } else {\r\n                                for (let v = start; v < end; v++) deform[v] = input.readFloat() * scale;\r\n                            }\r\n                            if (!weighted) {\r\n                                for (let v = 0, vn = deform.length; v < vn; v++) deform[v] += vertices[v];\r\n                            }\r\n                        }\r\n\r\n                        timeline.setFrame(frameIndex, time, deform, skin.name);\r\n                        if (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);\r\n                    }\r\n                    timelines.push(timeline);\r\n                    duration = Math.max(duration, timeline.frames[frameCount - 1]);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Draw order timeline.\r\n        const drawOrderCount = input.readInt(true);\r\n\r\n        if (drawOrderCount > 0) {\r\n            const timeline = new DrawOrderTimeline(drawOrderCount);\r\n            const slotCount = skeletonData.slots.length;\r\n\r\n            for (let i = 0; i < drawOrderCount; i++) {\r\n                const time = input.readFloat();\r\n                const offsetCount = input.readInt(true);\r\n                const drawOrder = Utils.newArray(slotCount, 0);\r\n\r\n                for (let ii = slotCount - 1; ii >= 0; ii--) drawOrder[ii] = -1;\r\n                const unchanged = Utils.newArray(slotCount - offsetCount, 0);\r\n                let originalIndex = 0;\r\n                let unchangedIndex = 0;\r\n\r\n                for (let ii = 0; ii < offsetCount; ii++) {\r\n                    const slotIndex = input.readInt(true);\r\n                    // Collect unchanged items.\r\n\r\n                    while (originalIndex != slotIndex) unchanged[unchangedIndex++] = originalIndex++;\r\n                    // Set changed items.\r\n                    drawOrder[originalIndex + input.readInt(true)] = originalIndex++;\r\n                }\r\n                // Collect remaining unchanged items.\r\n                while (originalIndex < slotCount) unchanged[unchangedIndex++] = originalIndex++;\r\n                // Fill in unchanged items.\r\n                for (let ii = slotCount - 1; ii >= 0; ii--) if (drawOrder[ii] == -1) drawOrder[ii] = unchanged[--unchangedIndex];\r\n                timeline.setFrame(i, time, drawOrder);\r\n            }\r\n            timelines.push(timeline);\r\n            duration = Math.max(duration, timeline.frames[drawOrderCount - 1]);\r\n        }\r\n\r\n        // Event timeline.\r\n        const eventCount = input.readInt(true);\r\n\r\n        if (eventCount > 0) {\r\n            const timeline = new EventTimeline(eventCount);\r\n\r\n            for (let i = 0; i < eventCount; i++) {\r\n                const time = input.readFloat();\r\n                const eventData = skeletonData.events[input.readInt(true)];\r\n                const event = new Event(time, eventData);\r\n\r\n                event.intValue = input.readInt(false);\r\n                event.floatValue = input.readFloat();\r\n                event.stringValue = input.readBoolean() ? input.readString() : eventData.stringValue;\r\n                if (event.data.audioPath != null) {\r\n                    event.volume = input.readFloat();\r\n                    event.balance = input.readFloat();\r\n                }\r\n                timeline.setFrame(i, event);\r\n            }\r\n            timelines.push(timeline);\r\n            duration = Math.max(duration, timeline.frames[eventCount - 1]);\r\n        }\r\n\r\n        return new Animation(name, timelines, duration);\r\n    }\r\n\r\n    private readCurve(input: BinaryInput, frameIndex: number, timeline: CurveTimeline) {\r\n        switch (input.readByte()) {\r\n            case SkeletonBinary.CURVE_STEPPED:\r\n                timeline.setStepped(frameIndex);\r\n                break;\r\n            case SkeletonBinary.CURVE_BEZIER:\r\n                this.setCurve(timeline, frameIndex, input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat());\r\n                break;\r\n        }\r\n    }\r\n\r\n    setCurve(timeline: CurveTimeline, frameIndex: number, cx1: number, cy1: number, cx2: number, cy2: number) {\r\n        timeline.setCurve(frameIndex, cx1, cy1, cx2, cy2);\r\n    }\r\n}\r\n\r\nclass LinkedMesh {\r\n    parent: string;\r\n    skin: string;\r\n    slotIndex: number;\r\n    mesh: MeshAttachment;\r\n    inheritDeform: boolean;\r\n\r\n    constructor(mesh: MeshAttachment, skin: string, slotIndex: number, parent: string, inheritDeform: boolean) {\r\n        this.mesh = mesh;\r\n        this.skin = skin;\r\n        this.slotIndex = slotIndex;\r\n        this.parent = parent;\r\n        this.inheritDeform = inheritDeform;\r\n    }\r\n}\r\n\r\nclass Vertices {\r\n    constructor(public bones: Array<number> = null, public vertices: Array<number> | Float32Array = null, public cVertices: Array<number> = null) {}\r\n}\r\n","import type { BoundingBoxAttachment } from './attachments';\nimport { SkeletonBoundsBase } from '@pixi-spine/base';\n\n/** Collects each visible {@link BoundingBoxAttachment} and computes the world vertices for its polygon. The polygon vertices are\n * provided along with convenience methods for doing hit detection.\n * @public\n * */\nexport class SkeletonBounds extends SkeletonBoundsBase<BoundingBoxAttachment> {}\n","import type { Attachment, AttachmentLoader, MeshAttachment, VertexAttachment } from './attachments';\r\nimport { Event } from './Event';\r\nimport { SkeletonData } from './SkeletonData';\r\nimport { SlotData } from './SlotData';\r\nimport { BoneData } from './BoneData';\r\nimport { IkConstraintData } from './IkConstraintData';\r\nimport { TransformConstraintData } from './TransformConstraintData';\r\nimport { PathConstraintData, SpacingMode } from './PathConstraintData';\r\nimport { Skin } from './Skin';\r\nimport { EventData } from './EventData';\r\nimport {\r\n    Animation,\r\n    AttachmentTimeline,\r\n    ColorTimeline,\r\n    CurveTimeline,\r\n    DeformTimeline,\r\n    DrawOrderTimeline,\r\n    EventTimeline,\r\n    IkConstraintTimeline,\r\n    PathConstraintMixTimeline,\r\n    PathConstraintPositionTimeline,\r\n    PathConstraintSpacingTimeline,\r\n    RotateTimeline,\r\n    ScaleTimeline,\r\n    ShearTimeline,\r\n    Timeline,\r\n    TransformConstraintTimeline,\r\n    TranslateTimeline,\r\n    TwoColorTimeline,\r\n} from './Animation';\r\nimport { ArrayLike, Color, PositionMode, RotateMode, TransformMode, Utils, settings } from '@pixi-spine/base';\r\nimport { BLEND_MODES } from '@pixi/core';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class SkeletonJson {\r\n    attachmentLoader: AttachmentLoader;\r\n    scale = 1;\r\n    private linkedMeshes = new Array<LinkedMesh>();\r\n\r\n    constructor(attachmentLoader: AttachmentLoader) {\r\n        this.attachmentLoader = attachmentLoader;\r\n    }\r\n\r\n    readSkeletonData(json: string | any): SkeletonData {\r\n        const scale = this.scale;\r\n        const skeletonData = new SkeletonData();\r\n        const root = typeof json === 'string' ? JSON.parse(json) : json;\r\n\r\n        // Skeleton\r\n        const skeletonMap = root.skeleton;\r\n\r\n        if (skeletonMap != null) {\r\n            skeletonData.hash = skeletonMap.hash;\r\n            skeletonData.version = skeletonMap.spine;\r\n            if (skeletonData.version.substr(0, 3) !== '3.4') {\r\n                const error = `Spine 3.4 loader cant load version ${skeletonMap.spine}. Please configure your pixi-spine bundle`;\r\n\r\n                console.error(error);\r\n            }\r\n            if (skeletonData.version === '3.4.75') {\r\n                const error = `Unsupported skeleton data, 3.4.75 is deprecated, please export with a newer version of Spine.`;\r\n\r\n                console.error(error);\r\n            }\r\n            skeletonData.x = skeletonMap.x;\r\n            skeletonData.y = skeletonMap.y;\r\n            skeletonData.width = skeletonMap.width;\r\n            skeletonData.height = skeletonMap.height;\r\n            skeletonData.fps = skeletonMap.fps;\r\n            skeletonData.imagesPath = skeletonMap.images;\r\n        }\r\n\r\n        // Bones\r\n        if (root.bones) {\r\n            for (let i = 0; i < root.bones.length; i++) {\r\n                const boneMap = root.bones[i];\r\n\r\n                let parent: BoneData = null;\r\n                const parentName: string = this.getValue(boneMap, 'parent', null);\r\n\r\n                if (parentName != null) {\r\n                    parent = skeletonData.findBone(parentName);\r\n                    if (parent == null) throw new Error(`Parent bone not found: ${parentName}`);\r\n                }\r\n                const data = new BoneData(skeletonData.bones.length, boneMap.name, parent);\r\n\r\n                data.length = this.getValue(boneMap, 'length', 0) * scale;\r\n                data.x = this.getValue(boneMap, 'x', 0) * scale;\r\n                data.y = this.getValue(boneMap, 'y', 0) * scale;\r\n                data.rotation = this.getValue(boneMap, 'rotation', 0);\r\n                data.scaleX = this.getValue(boneMap, 'scaleX', 1);\r\n                data.scaleY = this.getValue(boneMap, 'scaleY', 1);\r\n                data.shearX = this.getValue(boneMap, 'shearX', 0);\r\n                data.shearY = this.getValue(boneMap, 'shearY', 0);\r\n                data.transformMode = SkeletonJson.transformModeFromString(this.getValue(boneMap, 'transform', 'normal'));\r\n                data.skinRequired = this.getValue(boneMap, 'skin', false);\r\n\r\n                skeletonData.bones.push(data);\r\n            }\r\n        }\r\n\r\n        // Slots.\r\n        if (root.slots) {\r\n            for (let i = 0; i < root.slots.length; i++) {\r\n                const slotMap = root.slots[i];\r\n                const slotName: string = slotMap.name;\r\n                const boneName: string = slotMap.bone;\r\n                const boneData = skeletonData.findBone(boneName);\r\n\r\n                if (boneData == null) throw new Error(`Slot bone not found: ${boneName}`);\r\n                const data = new SlotData(skeletonData.slots.length, slotName, boneData);\r\n\r\n                const color: string = this.getValue(slotMap, 'color', null);\r\n\r\n                if (color != null) data.color.setFromString(color);\r\n\r\n                const dark: string = this.getValue(slotMap, 'dark', null);\r\n\r\n                if (dark != null) {\r\n                    data.darkColor = new Color(1, 1, 1, 1);\r\n                    data.darkColor.setFromString(dark);\r\n                }\r\n\r\n                data.attachmentName = this.getValue(slotMap, 'attachment', null);\r\n                data.blendMode = SkeletonJson.blendModeFromString(this.getValue(slotMap, 'blend', 'normal'));\r\n                skeletonData.slots.push(data);\r\n            }\r\n        }\r\n\r\n        // IK constraints\r\n        if (root.ik) {\r\n            for (let i = 0; i < root.ik.length; i++) {\r\n                const constraintMap = root.ik[i];\r\n                const data = new IkConstraintData(constraintMap.name);\r\n\r\n                data.order = this.getValue(constraintMap, 'order', 0);\r\n                data.skinRequired = this.getValue(constraintMap, 'skin', false);\r\n\r\n                for (let j = 0; j < constraintMap.bones.length; j++) {\r\n                    const boneName = constraintMap.bones[j];\r\n                    const bone = skeletonData.findBone(boneName);\r\n\r\n                    if (bone == null) throw new Error(`IK bone not found: ${boneName}`);\r\n                    data.bones.push(bone);\r\n                }\r\n\r\n                const targetName: string = constraintMap.target;\r\n\r\n                data.target = skeletonData.findBone(targetName);\r\n                if (data.target == null) throw new Error(`IK target bone not found: ${targetName}`);\r\n\r\n                data.mix = this.getValue(constraintMap, 'mix', 1);\r\n                data.softness = this.getValue(constraintMap, 'softness', 0) * scale;\r\n                data.bendDirection = this.getValue(constraintMap, 'bendPositive', true) ? 1 : -1;\r\n                data.compress = this.getValue(constraintMap, 'compress', false);\r\n                data.stretch = this.getValue(constraintMap, 'stretch', false);\r\n                data.uniform = this.getValue(constraintMap, 'uniform', false);\r\n\r\n                skeletonData.ikConstraints.push(data);\r\n            }\r\n        }\r\n\r\n        // Transform constraints.\r\n        if (root.transform) {\r\n            for (let i = 0; i < root.transform.length; i++) {\r\n                const constraintMap = root.transform[i];\r\n                const data = new TransformConstraintData(constraintMap.name);\r\n\r\n                data.order = this.getValue(constraintMap, 'order', 0);\r\n                data.skinRequired = this.getValue(constraintMap, 'skin', false);\r\n\r\n                for (let j = 0; j < constraintMap.bones.length; j++) {\r\n                    const boneName = constraintMap.bones[j];\r\n                    const bone = skeletonData.findBone(boneName);\r\n\r\n                    if (bone == null) throw new Error(`Transform constraint bone not found: ${boneName}`);\r\n                    data.bones.push(bone);\r\n                }\r\n\r\n                const targetName: string = constraintMap.target;\r\n\r\n                data.target = skeletonData.findBone(targetName);\r\n                if (data.target == null) throw new Error(`Transform constraint target bone not found: ${targetName}`);\r\n\r\n                data.local = this.getValue(constraintMap, 'local', false);\r\n                data.relative = this.getValue(constraintMap, 'relative', false);\r\n                data.offsetRotation = this.getValue(constraintMap, 'rotation', 0);\r\n                data.offsetX = this.getValue(constraintMap, 'x', 0) * scale;\r\n                data.offsetY = this.getValue(constraintMap, 'y', 0) * scale;\r\n                data.offsetScaleX = this.getValue(constraintMap, 'scaleX', 0);\r\n                data.offsetScaleY = this.getValue(constraintMap, 'scaleY', 0);\r\n                data.offsetShearY = this.getValue(constraintMap, 'shearY', 0);\r\n\r\n                data.rotateMix = this.getValue(constraintMap, 'rotateMix', 1);\r\n                data.translateMix = this.getValue(constraintMap, 'translateMix', 1);\r\n                data.scaleMix = this.getValue(constraintMap, 'scaleMix', 1);\r\n                data.shearMix = this.getValue(constraintMap, 'shearMix', 1);\r\n\r\n                skeletonData.transformConstraints.push(data);\r\n            }\r\n        }\r\n\r\n        // Path constraints.\r\n        if (root.path) {\r\n            for (let i = 0; i < root.path.length; i++) {\r\n                const constraintMap = root.path[i];\r\n                const data = new PathConstraintData(constraintMap.name);\r\n\r\n                data.order = this.getValue(constraintMap, 'order', 0);\r\n                data.skinRequired = this.getValue(constraintMap, 'skin', false);\r\n\r\n                for (let j = 0; j < constraintMap.bones.length; j++) {\r\n                    const boneName = constraintMap.bones[j];\r\n                    const bone = skeletonData.findBone(boneName);\r\n\r\n                    if (bone == null) throw new Error(`Transform constraint bone not found: ${boneName}`);\r\n                    data.bones.push(bone);\r\n                }\r\n\r\n                const targetName: string = constraintMap.target;\r\n\r\n                data.target = skeletonData.findSlot(targetName);\r\n                if (data.target == null) throw new Error(`Path target slot not found: ${targetName}`);\r\n\r\n                data.positionMode = SkeletonJson.positionModeFromString(this.getValue(constraintMap, 'positionMode', 'percent'));\r\n                data.spacingMode = SkeletonJson.spacingModeFromString(this.getValue(constraintMap, 'spacingMode', 'length'));\r\n                data.rotateMode = SkeletonJson.rotateModeFromString(this.getValue(constraintMap, 'rotateMode', 'tangent'));\r\n                data.offsetRotation = this.getValue(constraintMap, 'rotation', 0);\r\n                data.position = this.getValue(constraintMap, 'position', 0);\r\n                if (data.positionMode == PositionMode.Fixed) data.position *= scale;\r\n                data.spacing = this.getValue(constraintMap, 'spacing', 0);\r\n                if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) data.spacing *= scale;\r\n                data.rotateMix = this.getValue(constraintMap, 'rotateMix', 1);\r\n                data.translateMix = this.getValue(constraintMap, 'translateMix', 1);\r\n\r\n                skeletonData.pathConstraints.push(data);\r\n            }\r\n        }\r\n\r\n        // Skins.\r\n        if (root.skins) {\r\n            for (let i = 0; i < root.skins.length; i++) {\r\n                const skinMap = root.skins[i];\r\n                const skin = new Skin(skinMap.name);\r\n\r\n                if (skinMap.bones) {\r\n                    for (let ii = 0; ii < skinMap.bones.length; ii++) {\r\n                        const bone = skeletonData.findBone(skinMap.bones[ii]);\r\n\r\n                        if (bone == null) throw new Error(`Skin bone not found: ${skinMap.bones[i]}`);\r\n                        skin.bones.push(bone);\r\n                    }\r\n                }\r\n\r\n                if (skinMap.ik) {\r\n                    for (let ii = 0; ii < skinMap.ik.length; ii++) {\r\n                        const constraint = skeletonData.findIkConstraint(skinMap.ik[ii]);\r\n\r\n                        if (constraint == null) throw new Error(`Skin IK constraint not found: ${skinMap.ik[i]}`);\r\n                        skin.constraints.push(constraint);\r\n                    }\r\n                }\r\n\r\n                if (skinMap.transform) {\r\n                    for (let ii = 0; ii < skinMap.transform.length; ii++) {\r\n                        const constraint = skeletonData.findTransformConstraint(skinMap.transform[ii]);\r\n\r\n                        if (constraint == null) throw new Error(`Skin transform constraint not found: ${skinMap.transform[i]}`);\r\n                        skin.constraints.push(constraint);\r\n                    }\r\n                }\r\n\r\n                if (skinMap.path) {\r\n                    for (let ii = 0; ii < skinMap.path.length; ii++) {\r\n                        const constraint = skeletonData.findPathConstraint(skinMap.path[ii]);\r\n\r\n                        if (constraint == null) throw new Error(`Skin path constraint not found: ${skinMap.path[i]}`);\r\n                        skin.constraints.push(constraint);\r\n                    }\r\n                }\r\n\r\n                for (const slotName in skinMap.attachments) {\r\n                    const slot = skeletonData.findSlot(slotName);\r\n\r\n                    if (slot == null) throw new Error(`Slot not found: ${slotName}`);\r\n                    const slotMap = skinMap.attachments[slotName];\r\n\r\n                    for (const entryName in slotMap) {\r\n                        const attachment = this.readAttachment(slotMap[entryName], skin, slot.index, entryName, skeletonData);\r\n\r\n                        if (attachment != null) skin.setAttachment(slot.index, entryName, attachment);\r\n                    }\r\n                }\r\n                skeletonData.skins.push(skin);\r\n                if (skin.name == 'default') skeletonData.defaultSkin = skin;\r\n            }\r\n        }\r\n\r\n        // Linked meshes.\r\n        for (let i = 0, n = this.linkedMeshes.length; i < n; i++) {\r\n            const linkedMesh = this.linkedMeshes[i];\r\n            const skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\r\n\r\n            if (skin == null) throw new Error(`Skin not found: ${linkedMesh.skin}`);\r\n            const parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\r\n\r\n            if (parent == null) throw new Error(`Parent mesh not found: ${linkedMesh.parent}`);\r\n            linkedMesh.mesh.deformAttachment = linkedMesh.inheritDeform ? <VertexAttachment>parent : <VertexAttachment>linkedMesh.mesh;\r\n            linkedMesh.mesh.setParentMesh(<MeshAttachment>parent);\r\n            // linkedMesh.mesh.updateUVs();\r\n        }\r\n        this.linkedMeshes.length = 0;\r\n\r\n        // Events.\r\n        if (root.events) {\r\n            for (const eventName in root.events) {\r\n                const eventMap = root.events[eventName];\r\n                const data = new EventData(eventName);\r\n\r\n                data.intValue = this.getValue(eventMap, 'int', 0);\r\n                data.floatValue = this.getValue(eventMap, 'float', 0);\r\n                data.stringValue = this.getValue(eventMap, 'string', '');\r\n                data.audioPath = this.getValue(eventMap, 'audio', null);\r\n                if (data.audioPath != null) {\r\n                    data.volume = this.getValue(eventMap, 'volume', 1);\r\n                    data.balance = this.getValue(eventMap, 'balance', 0);\r\n                }\r\n                skeletonData.events.push(data);\r\n            }\r\n        }\r\n\r\n        // Animations.\r\n        if (root.animations) {\r\n            for (const animationName in root.animations) {\r\n                const animationMap = root.animations[animationName];\r\n\r\n                this.readAnimation(animationMap, animationName, skeletonData);\r\n            }\r\n        }\r\n\r\n        return skeletonData;\r\n    }\r\n\r\n    readAttachment(map: any, skin: Skin, slotIndex: number, name: string, skeletonData: SkeletonData): Attachment {\r\n        const scale = this.scale;\r\n\r\n        name = this.getValue(map, 'name', name);\r\n\r\n        const type = this.getValue(map, 'type', 'region');\r\n\r\n        switch (type) {\r\n            case 'region': {\r\n                const path = this.getValue(map, 'path', name);\r\n                const region = this.attachmentLoader.newRegionAttachment(skin, name, path);\r\n\r\n                if (region == null) return null;\r\n                region.path = path;\r\n                region.x = this.getValue(map, 'x', 0) * scale;\r\n                region.y = this.getValue(map, 'y', 0) * scale;\r\n                region.scaleX = this.getValue(map, 'scaleX', 1);\r\n                region.scaleY = this.getValue(map, 'scaleY', 1);\r\n                region.rotation = this.getValue(map, 'rotation', 0);\r\n                region.width = map.width * scale;\r\n                region.height = map.height * scale;\r\n\r\n                const color: string = this.getValue(map, 'color', null);\r\n\r\n                if (color != null) region.color.setFromString(color);\r\n\r\n                // region.updateOffset();\r\n                return region;\r\n            }\r\n            case 'boundingbox': {\r\n                const box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\r\n\r\n                if (box == null) return null;\r\n                this.readVertices(map, box, map.vertexCount << 1);\r\n                const color: string = this.getValue(map, 'color', null);\r\n\r\n                if (color != null) box.color.setFromString(color);\r\n\r\n                return box;\r\n            }\r\n            case 'mesh':\r\n            case 'linkedmesh': {\r\n                const path = this.getValue(map, 'path', name);\r\n                const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\r\n\r\n                if (mesh == null) return null;\r\n                mesh.path = path;\r\n\r\n                const color = this.getValue(map, 'color', null);\r\n\r\n                if (color != null) mesh.color.setFromString(color);\r\n\r\n                mesh.width = this.getValue(map, 'width', 0) * scale;\r\n                mesh.height = this.getValue(map, 'height', 0) * scale;\r\n\r\n                const parent: string = this.getValue(map, 'parent', null);\r\n\r\n                if (parent != null) {\r\n                    this.linkedMeshes.push(new LinkedMesh(mesh, <string>this.getValue(map, 'skin', null), slotIndex, parent, this.getValue(map, 'deform', true)));\r\n\r\n                    return mesh;\r\n                }\r\n\r\n                const uvs: Array<number> = map.uvs;\r\n\r\n                this.readVertices(map, mesh, uvs.length);\r\n                mesh.triangles = map.triangles;\r\n                mesh.regionUVs = new Float32Array(uvs);\r\n                // mesh.updateUVs();\r\n\r\n                mesh.edges = this.getValue(map, 'edges', null);\r\n                mesh.hullLength = this.getValue(map, 'hull', 0) * 2;\r\n\r\n                return mesh;\r\n            }\r\n            case 'path': {\r\n                const path = this.attachmentLoader.newPathAttachment(skin, name);\r\n\r\n                if (path == null) return null;\r\n                path.closed = this.getValue(map, 'closed', false);\r\n                path.constantSpeed = this.getValue(map, 'constantSpeed', true);\r\n\r\n                const vertexCount = map.vertexCount;\r\n\r\n                this.readVertices(map, path, vertexCount << 1);\r\n\r\n                const lengths: Array<number> = Utils.newArray(vertexCount / 3, 0);\r\n\r\n                for (let i = 0; i < map.lengths.length; i++) lengths[i] = map.lengths[i] * scale;\r\n                path.lengths = lengths;\r\n\r\n                const color: string = this.getValue(map, 'color', null);\r\n\r\n                if (color != null) path.color.setFromString(color);\r\n\r\n                return path;\r\n            }\r\n            case 'point': {\r\n                const point = this.attachmentLoader.newPointAttachment(skin, name);\r\n\r\n                if (point == null) return null;\r\n                point.x = this.getValue(map, 'x', 0) * scale;\r\n                point.y = this.getValue(map, 'y', 0) * scale;\r\n                point.rotation = this.getValue(map, 'rotation', 0);\r\n\r\n                const color = this.getValue(map, 'color', null);\r\n\r\n                if (color != null) point.color.setFromString(color);\r\n\r\n                return point;\r\n            }\r\n            case 'clipping': {\r\n                const clip = this.attachmentLoader.newClippingAttachment(skin, name);\r\n\r\n                if (clip == null) return null;\r\n\r\n                const end = this.getValue(map, 'end', null);\r\n\r\n                if (end != null) {\r\n                    const slot = skeletonData.findSlot(end);\r\n\r\n                    if (slot == null) throw new Error(`Clipping end slot not found: ${end}`);\r\n                    clip.endSlot = slot;\r\n                }\r\n\r\n                const vertexCount = map.vertexCount;\r\n\r\n                this.readVertices(map, clip, vertexCount << 1);\r\n\r\n                const color: string = this.getValue(map, 'color', null);\r\n\r\n                if (color != null) clip.color.setFromString(color);\r\n\r\n                return clip;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    readVertices(map: any, attachment: VertexAttachment, verticesLength: number) {\r\n        const scale = this.scale;\r\n\r\n        attachment.worldVerticesLength = verticesLength;\r\n        const vertices: Array<number> = map.vertices;\r\n\r\n        if (verticesLength == vertices.length) {\r\n            const scaledVertices = Utils.toFloatArray(vertices);\r\n\r\n            if (scale != 1) {\r\n                for (let i = 0, n = vertices.length; i < n; i++) scaledVertices[i] *= scale;\r\n            }\r\n            attachment.vertices = scaledVertices;\r\n\r\n            return;\r\n        }\r\n        const weights = new Array<number>();\r\n        const bones = new Array<number>();\r\n\r\n        for (let i = 0, n = vertices.length; i < n; ) {\r\n            const boneCount = vertices[i++];\r\n\r\n            bones.push(boneCount);\r\n            for (let nn = i + boneCount * 4; i < nn; i += 4) {\r\n                bones.push(vertices[i]);\r\n                weights.push(vertices[i + 1] * scale);\r\n                weights.push(vertices[i + 2] * scale);\r\n                weights.push(vertices[i + 3]);\r\n            }\r\n        }\r\n        attachment.bones = bones;\r\n        attachment.vertices = Utils.toFloatArray(weights);\r\n    }\r\n\r\n    readAnimation(map: any, name: string, skeletonData: SkeletonData) {\r\n        const scale = this.scale;\r\n        const timelines = new Array<Timeline>();\r\n        let duration = 0;\r\n\r\n        // Slot timelines.\r\n        if (map.slots) {\r\n            for (const slotName in map.slots) {\r\n                const slotMap = map.slots[slotName];\r\n                const slotIndex = skeletonData.findSlotIndex(slotName);\r\n\r\n                if (slotIndex == -1) throw new Error(`Slot not found: ${slotName}`);\r\n                for (const timelineName in slotMap) {\r\n                    const timelineMap = slotMap[timelineName];\r\n\r\n                    if (timelineName == 'attachment') {\r\n                        const timeline = new AttachmentTimeline(timelineMap.length);\r\n\r\n                        timeline.slotIndex = slotIndex;\r\n\r\n                        let frameIndex = 0;\r\n\r\n                        for (let i = 0; i < timelineMap.length; i++) {\r\n                            const valueMap = timelineMap[i];\r\n\r\n                            timeline.setFrame(frameIndex++, this.getValue(valueMap, 'time', 0), valueMap.name);\r\n                        }\r\n                        timelines.push(timeline);\r\n                        duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n                    } else if (timelineName == 'color') {\r\n                        const timeline = new ColorTimeline(timelineMap.length);\r\n\r\n                        timeline.slotIndex = slotIndex;\r\n\r\n                        let frameIndex = 0;\r\n\r\n                        for (let i = 0; i < timelineMap.length; i++) {\r\n                            const valueMap = timelineMap[i];\r\n                            const color = new Color();\r\n\r\n                            color.setFromString(valueMap.color || 'ffffffff');\r\n                            timeline.setFrame(frameIndex, this.getValue(valueMap, 'time', 0), color.r, color.g, color.b, color.a);\r\n                            this.readCurve(valueMap, timeline, frameIndex);\r\n                            frameIndex++;\r\n                        }\r\n                        timelines.push(timeline);\r\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * ColorTimeline.ENTRIES]);\r\n                    } else if (timelineName == 'twoColor') {\r\n                        const timeline = new TwoColorTimeline(timelineMap.length);\r\n\r\n                        timeline.slotIndex = slotIndex;\r\n\r\n                        let frameIndex = 0;\r\n\r\n                        for (let i = 0; i < timelineMap.length; i++) {\r\n                            const valueMap = timelineMap[i];\r\n                            const light = new Color();\r\n                            const dark = new Color();\r\n\r\n                            light.setFromString(valueMap.light);\r\n                            dark.setFromString(valueMap.dark);\r\n                            timeline.setFrame(frameIndex, this.getValue(valueMap, 'time', 0), light.r, light.g, light.b, light.a, dark.r, dark.g, dark.b);\r\n                            this.readCurve(valueMap, timeline, frameIndex);\r\n                            frameIndex++;\r\n                        }\r\n                        timelines.push(timeline);\r\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TwoColorTimeline.ENTRIES]);\r\n                    } else throw new Error(`Invalid timeline type for a slot: ${timelineName} (${slotName})`);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Bone timelines.\r\n        if (map.bones) {\r\n            for (const boneName in map.bones) {\r\n                const boneMap = map.bones[boneName];\r\n                const boneIndex = skeletonData.findBoneIndex(boneName);\r\n\r\n                if (boneIndex == -1) throw new Error(`Bone not found: ${boneName}`);\r\n                for (const timelineName in boneMap) {\r\n                    const timelineMap = boneMap[timelineName];\r\n\r\n                    if (timelineName === 'rotate') {\r\n                        const timeline = new RotateTimeline(timelineMap.length);\r\n\r\n                        timeline.boneIndex = boneIndex;\r\n\r\n                        let frameIndex = 0;\r\n\r\n                        for (let i = 0; i < timelineMap.length; i++) {\r\n                            const valueMap = timelineMap[i];\r\n\r\n                            timeline.setFrame(frameIndex, this.getValue(valueMap, 'time', 0), this.getValue(valueMap, 'angle', 0));\r\n                            this.readCurve(valueMap, timeline, frameIndex);\r\n                            frameIndex++;\r\n                        }\r\n                        timelines.push(timeline);\r\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * RotateTimeline.ENTRIES]);\r\n                    } else if (timelineName === 'translate' || timelineName === 'scale' || timelineName === 'shear') {\r\n                        let timeline: TranslateTimeline = null;\r\n                        let timelineScale = 1;\r\n                        let defaultValue = 0;\r\n\r\n                        if (timelineName === 'scale') {\r\n                            timeline = new ScaleTimeline(timelineMap.length);\r\n                            defaultValue = 1;\r\n                        } else if (timelineName === 'shear') timeline = new ShearTimeline(timelineMap.length);\r\n                        else {\r\n                            timeline = new TranslateTimeline(timelineMap.length);\r\n                            timelineScale = scale;\r\n                        }\r\n                        timeline.boneIndex = boneIndex;\r\n\r\n                        let frameIndex = 0;\r\n\r\n                        for (let i = 0; i < timelineMap.length; i++) {\r\n                            const valueMap = timelineMap[i];\r\n                            const x = this.getValue(valueMap, 'x', defaultValue);\r\n                            const y = this.getValue(valueMap, 'y', defaultValue);\r\n\r\n                            timeline.setFrame(frameIndex, this.getValue(valueMap, 'time', 0), x * timelineScale, y * timelineScale);\r\n                            this.readCurve(valueMap, timeline, frameIndex);\r\n                            frameIndex++;\r\n                        }\r\n                        timelines.push(timeline);\r\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TranslateTimeline.ENTRIES]);\r\n                    } else throw new Error(`Invalid timeline type for a bone: ${timelineName} (${boneName})`);\r\n                }\r\n            }\r\n        }\r\n\r\n        // IK constraint timelines.\r\n        if (map.ik) {\r\n            for (const constraintName in map.ik) {\r\n                const constraintMap = map.ik[constraintName];\r\n                const constraint = skeletonData.findIkConstraint(constraintName);\r\n                const timeline = new IkConstraintTimeline(constraintMap.length);\r\n\r\n                timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(constraint);\r\n                let frameIndex = 0;\r\n\r\n                for (let i = 0; i < constraintMap.length; i++) {\r\n                    const valueMap = constraintMap[i];\r\n\r\n                    timeline.setFrame(\r\n                        frameIndex,\r\n                        this.getValue(valueMap, 'time', 0),\r\n                        this.getValue(valueMap, 'mix', 1),\r\n                        this.getValue(valueMap, 'softness', 0) * scale\r\n                        // TODO: JSON fix\r\n                        // this.getValue(valueMap, 'bendPositive', true) ? 1 : -1,\r\n                        // this.getValue(valueMap, 'compress', false),\r\n                        // this.getValue(valueMap, 'stretch', false)\r\n                    );\r\n                    this.readCurve(valueMap, timeline, frameIndex);\r\n                    frameIndex++;\r\n                }\r\n                timelines.push(timeline);\r\n                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * IkConstraintTimeline.ENTRIES]);\r\n            }\r\n        }\r\n\r\n        // Transform constraint timelines.\r\n        if (map.transform) {\r\n            for (const constraintName in map.transform) {\r\n                const constraintMap = map.transform[constraintName];\r\n                const constraint = skeletonData.findTransformConstraint(constraintName);\r\n                const timeline = new TransformConstraintTimeline(constraintMap.length);\r\n\r\n                timeline.transformConstraintIndex = skeletonData.transformConstraints.indexOf(constraint);\r\n                let frameIndex = 0;\r\n\r\n                for (let i = 0; i < constraintMap.length; i++) {\r\n                    const valueMap = constraintMap[i];\r\n\r\n                    timeline.setFrame(\r\n                        frameIndex,\r\n                        this.getValue(valueMap, 'time', 0),\r\n                        this.getValue(valueMap, 'rotateMix', 1),\r\n                        this.getValue(valueMap, 'translateMix', 1),\r\n                        this.getValue(valueMap, 'scaleMix', 1),\r\n                        this.getValue(valueMap, 'shearMix', 1)\r\n                    );\r\n                    this.readCurve(valueMap, timeline, frameIndex);\r\n                    frameIndex++;\r\n                }\r\n                timelines.push(timeline);\r\n                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TransformConstraintTimeline.ENTRIES]);\r\n            }\r\n        }\r\n\r\n        // Path constraint timelines.\r\n        if (map.path) {\r\n            for (const constraintName in map.path) {\r\n                const constraintMap = map.path[constraintName];\r\n                const index = skeletonData.findPathConstraintIndex(constraintName);\r\n\r\n                if (index == -1) throw new Error(`Path constraint not found: ${constraintName}`);\r\n                const data = skeletonData.pathConstraints[index];\r\n\r\n                for (const timelineName in constraintMap) {\r\n                    const timelineMap = constraintMap[timelineName];\r\n\r\n                    if (timelineName === 'position' || timelineName === 'spacing') {\r\n                        let timeline: PathConstraintPositionTimeline = null;\r\n                        let timelineScale = 1;\r\n\r\n                        if (timelineName === 'spacing') {\r\n                            timeline = new PathConstraintSpacingTimeline(timelineMap.length);\r\n                            if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) timelineScale = scale;\r\n                        } else {\r\n                            timeline = new PathConstraintPositionTimeline(timelineMap.length);\r\n                            if (data.positionMode == PositionMode.Fixed) timelineScale = scale;\r\n                        }\r\n                        timeline.pathConstraintIndex = index;\r\n                        let frameIndex = 0;\r\n\r\n                        for (let i = 0; i < timelineMap.length; i++) {\r\n                            const valueMap = timelineMap[i];\r\n\r\n                            timeline.setFrame(frameIndex, this.getValue(valueMap, 'time', 0), this.getValue(valueMap, timelineName, 0) * timelineScale);\r\n                            this.readCurve(valueMap, timeline, frameIndex);\r\n                            frameIndex++;\r\n                        }\r\n                        timelines.push(timeline);\r\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * PathConstraintPositionTimeline.ENTRIES]);\r\n                    } else if (timelineName === 'mix') {\r\n                        const timeline = new PathConstraintMixTimeline(timelineMap.length);\r\n\r\n                        timeline.pathConstraintIndex = index;\r\n                        let frameIndex = 0;\r\n\r\n                        for (let i = 0; i < timelineMap.length; i++) {\r\n                            const valueMap = timelineMap[i];\r\n\r\n                            timeline.setFrame(frameIndex, this.getValue(valueMap, 'time', 0), this.getValue(valueMap, 'rotateMix', 1), this.getValue(valueMap, 'translateMix', 1));\r\n                            this.readCurve(valueMap, timeline, frameIndex);\r\n                            frameIndex++;\r\n                        }\r\n                        timelines.push(timeline);\r\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * PathConstraintMixTimeline.ENTRIES]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Deform timelines.\r\n        if (map.deform) {\r\n            for (const deformName in map.deform) {\r\n                const deformMap = map.deform[deformName];\r\n                const skin = skeletonData.findSkin(deformName);\r\n\r\n                if (skin == null) {\r\n                    if (settings.FAIL_ON_NON_EXISTING_SKIN) {\r\n                        throw new Error(`Skin not found: ${deformName}`);\r\n                    } else {\r\n                        continue;\r\n                    }\r\n                }\r\n                for (const slotName in deformMap) {\r\n                    const slotMap = deformMap[slotName];\r\n                    const slotIndex = skeletonData.findSlotIndex(slotName);\r\n\r\n                    if (slotIndex == -1) throw new Error(`Slot not found: ${slotMap.name}`);\r\n                    for (const timelineName in slotMap) {\r\n                        const timelineMap = slotMap[timelineName];\r\n                        const attachment = <VertexAttachment>skin.getAttachment(slotIndex, timelineName);\r\n\r\n                        if (attachment == null) throw new Error(`Deform attachment not found: ${timelineMap.name}`);\r\n                        const weighted = attachment.bones != null;\r\n                        const vertices = attachment.vertices;\r\n                        const deformLength = weighted ? (vertices.length / 3) * 2 : vertices.length;\r\n\r\n                        const timeline = new DeformTimeline(timelineMap.length);\r\n\r\n                        timeline.slotIndex = slotIndex;\r\n                        timeline.attachment = attachment;\r\n\r\n                        let frameIndex = 0;\r\n\r\n                        for (let j = 0; j < timelineMap.length; j++) {\r\n                            const valueMap = timelineMap[j];\r\n                            let deform: ArrayLike<number>;\r\n                            const verticesValue: Array<Number> = this.getValue(valueMap, 'vertices', null);\r\n\r\n                            if (verticesValue == null) deform = weighted ? Utils.newFloatArray(deformLength) : vertices;\r\n                            else {\r\n                                deform = Utils.newFloatArray(deformLength);\r\n                                const start = <number>this.getValue(valueMap, 'offset', 0);\r\n\r\n                                Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);\r\n                                if (scale != 1) {\r\n                                    for (let i = start, n = i + verticesValue.length; i < n; i++) deform[i] *= scale;\r\n                                }\r\n                                if (!weighted) {\r\n                                    for (let i = 0; i < deformLength; i++) deform[i] += vertices[i];\r\n                                }\r\n                            }\r\n\r\n                            timeline.setFrame(frameIndex, this.getValue(valueMap, 'time', 0), deform, skin.name);\r\n                            this.readCurve(valueMap, timeline, frameIndex);\r\n                            frameIndex++;\r\n                        }\r\n                        timelines.push(timeline);\r\n                        duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Draw order timeline.\r\n        let drawOrderNode = map.drawOrder;\r\n\r\n        if (drawOrderNode == null) drawOrderNode = map.draworder;\r\n        if (drawOrderNode != null) {\r\n            const timeline = new DrawOrderTimeline(drawOrderNode.length);\r\n            const slotCount = skeletonData.slots.length;\r\n            let frameIndex = 0;\r\n\r\n            for (let j = 0; j < drawOrderNode.length; j++) {\r\n                const drawOrderMap = drawOrderNode[j];\r\n                let drawOrder: Array<number> = null;\r\n                const offsets = this.getValue(drawOrderMap, 'offsets', null);\r\n\r\n                if (offsets != null) {\r\n                    drawOrder = Utils.newArray<number>(slotCount, -1);\r\n                    const unchanged = Utils.newArray<number>(slotCount - offsets.length, 0);\r\n                    let originalIndex = 0;\r\n                    let unchangedIndex = 0;\r\n\r\n                    for (let i = 0; i < offsets.length; i++) {\r\n                        const offsetMap = offsets[i];\r\n                        const slotIndex = skeletonData.findSlotIndex(offsetMap.slot);\r\n\r\n                        if (slotIndex == -1) throw new Error(`Slot not found: ${offsetMap.slot}`);\r\n                        // Collect unchanged items.\r\n                        while (originalIndex != slotIndex) unchanged[unchangedIndex++] = originalIndex++;\r\n                        // Set changed items.\r\n                        drawOrder[originalIndex + offsetMap.offset] = originalIndex++;\r\n                    }\r\n                    // Collect remaining unchanged items.\r\n                    while (originalIndex < slotCount) unchanged[unchangedIndex++] = originalIndex++;\r\n                    // Fill in unchanged items.\r\n                    for (let i = slotCount - 1; i >= 0; i--) if (drawOrder[i] == -1) drawOrder[i] = unchanged[--unchangedIndex];\r\n                }\r\n                timeline.setFrame(frameIndex++, this.getValue(drawOrderMap, 'time', 0), drawOrder);\r\n            }\r\n            timelines.push(timeline);\r\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n        }\r\n\r\n        // Event timeline.\r\n        if (map.events) {\r\n            const timeline = new EventTimeline(map.events.length);\r\n            let frameIndex = 0;\r\n\r\n            for (let i = 0; i < map.events.length; i++) {\r\n                const eventMap = map.events[i];\r\n                const eventData = skeletonData.findEvent(eventMap.name);\r\n\r\n                if (eventData == null) throw new Error(`Event not found: ${eventMap.name}`);\r\n                const event = new Event(Utils.toSinglePrecision(this.getValue(eventMap, 'time', 0)), eventData);\r\n\r\n                event.intValue = this.getValue(eventMap, 'int', eventData.intValue);\r\n                event.floatValue = this.getValue(eventMap, 'float', eventData.floatValue);\r\n                event.stringValue = this.getValue(eventMap, 'string', eventData.stringValue);\r\n                if (event.data.audioPath != null) {\r\n                    event.volume = this.getValue(eventMap, 'volume', 1);\r\n                    event.balance = this.getValue(eventMap, 'balance', 0);\r\n                }\r\n                timeline.setFrame(frameIndex++, event);\r\n            }\r\n            timelines.push(timeline);\r\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n        }\r\n\r\n        if (isNaN(duration)) {\r\n            throw new Error('Error while parsing animation, duration is NaN');\r\n        }\r\n\r\n        skeletonData.animations.push(new Animation(name, timelines, duration));\r\n    }\r\n\r\n    readCurve(map: any, timeline: CurveTimeline, frameIndex: number) {\r\n        if (!map.hasOwnProperty('curve')) return;\r\n        if (map.curve === 'stepped') timeline.setStepped(frameIndex);\r\n        else {\r\n            const curve: number = map.curve;\r\n\r\n            timeline.setCurve(frameIndex, curve, this.getValue(map, 'c2', 0), this.getValue(map, 'c3', 1), this.getValue(map, 'c4', 1));\r\n        }\r\n    }\r\n\r\n    getValue(map: any, prop: string, defaultValue: any) {\r\n        return map[prop] !== undefined ? map[prop] : defaultValue;\r\n    }\r\n\r\n    static blendModeFromString(str: string) {\r\n        str = str.toLowerCase();\r\n        if (str == 'normal') return BLEND_MODES.NORMAL;\r\n        if (str == 'additive') return BLEND_MODES.ADD;\r\n        if (str == 'multiply') return BLEND_MODES.MULTIPLY;\r\n        if (str == 'screen') return BLEND_MODES.SCREEN;\r\n        throw new Error(`Unknown blend mode: ${str}`);\r\n    }\r\n\r\n    static positionModeFromString(str: string) {\r\n        str = str.toLowerCase();\r\n        if (str == 'fixed') return PositionMode.Fixed;\r\n        if (str == 'percent') return PositionMode.Percent;\r\n        throw new Error(`Unknown position mode: ${str}`);\r\n    }\r\n\r\n    static spacingModeFromString(str: string) {\r\n        str = str.toLowerCase();\r\n        if (str == 'length') return SpacingMode.Length;\r\n        if (str == 'fixed') return SpacingMode.Fixed;\r\n        if (str == 'percent') return SpacingMode.Percent;\r\n        throw new Error(`Unknown position mode: ${str}`);\r\n    }\r\n\r\n    static rotateModeFromString(str: string) {\r\n        str = str.toLowerCase();\r\n        if (str == 'tangent') return RotateMode.Tangent;\r\n        if (str == 'chain') return RotateMode.Chain;\r\n        if (str == 'chainscale') return RotateMode.ChainScale;\r\n        throw new Error(`Unknown rotate mode: ${str}`);\r\n    }\r\n\r\n    static transformModeFromString(str: string) {\r\n        str = str.toLowerCase();\r\n        if (str == 'normal') return TransformMode.Normal;\r\n        if (str == 'onlytranslation') return TransformMode.OnlyTranslation;\r\n        if (str == 'norotationorreflection') return TransformMode.NoRotationOrReflection;\r\n        if (str == 'noscale') return TransformMode.NoScale;\r\n        if (str == 'noscaleorreflection') return TransformMode.NoScaleOrReflection;\r\n        throw new Error(`Unknown transform mode: ${str}`);\r\n    }\r\n}\r\n\r\nclass LinkedMesh {\r\n    parent: string;\r\n    skin: string;\r\n    slotIndex: number;\r\n    mesh: MeshAttachment;\r\n    inheritDeform: boolean;\r\n\r\n    constructor(mesh: MeshAttachment, skin: string, slotIndex: number, parent: string, inheritDeform: boolean) {\r\n        this.mesh = mesh;\r\n        this.skin = skin;\r\n        this.slotIndex = slotIndex;\r\n        this.parent = parent;\r\n        this.inheritDeform = inheritDeform;\r\n    }\r\n}\r\n","import { SpineBase } from '@pixi-spine/base';\nimport { Skeleton } from './core/Skeleton';\nimport type { SkeletonData } from './core/SkeletonData';\nimport { AnimationState } from './core/AnimationState';\nimport { AnimationStateData } from './core/AnimationStateData';\n\n/**\n * @public\n */\nexport class Spine extends SpineBase<Skeleton, SkeletonData, AnimationState, AnimationStateData> {\n    createSkeleton(spineData: SkeletonData) {\n        this.skeleton = new Skeleton(spineData);\n        this.skeleton.updateWorldTransform();\n        this.stateData = new AnimationStateData(spineData);\n        this.state = new AnimationState(this.stateData);\n    }\n}\n"],"names":["Attachment","name","_VertexAttachment","slot","worldVertices","start","count","offset","stride","skeleton","deformArray","vertices","bones","mat","x","y","a","b","c","d","v","w","vx","vy","skip","i","n","skeletonBones","wx","wy","weight","deform","f","attachment","Utils","VertexAttachment","BoundingBoxAttachment","AttachmentType","Color","copy","ClippingAttachment","MeshAttachment","parentMesh","PathAttachment","PointAttachment","bone","point","cos","MathUtils","sin","Slot","data","time","_RegionAttachment","regionScaleX","regionScaleY","localX","localY","localX2","localY2","radians","localXCos","localXSin","localYCos","localYSin","localX2Cos","localX2Sin","localY2Cos","localY2Sin","region","uvs","vertexOffset","offsetX","offsetY","RegionAttachment","JitterEffect","jitterX","jitterY","position","uv","light","dark","_SwirlEffect","radius","radAngle","dist","theta","SwirlEffect","PowOut","Animation","timelines","duration","id","lastTime","loop","events","alpha","blend","direction","values","target","step","low","high","current","last","TimelineType","s","_CurveTimeline","frameCount","frameIndex","index","type","cx1","cy1","cx2","cy2","tmpx","tmpy","dddfx","dddfy","ddfx","ddfy","dfx","dfy","curves","percent","prevX","prevY","CurveTimeline","_RotateTimeline","degrees","frames","MixBlend","r","frame","prevRotation","frameTime","RotateTimeline","_TranslateTimeline","TranslateTimeline","ScaleTimeline","bx","by","MixDirection","ShearTimeline","_ColorTimeline","g","color","setup","ColorTimeline","_TwoColorTimeline","r2","g2","b2","setupLight","setupDark","TwoColorTimeline","AttachmentTimeline","attachmentName","zeros","DeformTimeline","skin","firedEvents","slotAttachment","frameVertices","vertexCount","vertexAttachment","setupVertices","lastVertices","prevVertices","nextVertices","prev","EventTimeline","event","DrawOrderTimeline","drawOrder","slots","drawOrderToSetupIndex","_IkConstraintTimeline","mix","bendDirection","constraint","IkConstraintTimeline","_TransformConstraintTimeline","rotateMix","translateMix","scaleMix","shearMix","rotate","translate","scale","shear","TransformConstraintTimeline","_PathConstraintPositionTimeline","value","PathConstraintPositionTimeline","PathConstraintSpacingTimeline","spacing","_PathConstraintMixTimeline","PathConstraintMixTimeline","_AnimationState","EventQueue","IntSet","Pool","TrackEntry","delta","tracks","currentDelta","next","nextTime","from","to","finished","applied","animationLast","animationTime","timelineCount","ii","timeline","timelineMode","firstFrame","timelinesRotation","timelineBlend","setupState","attachments","alphaHold","alphaMix","timelineHoldMix","holdMix","rotateTimeline","r1","total","diff","lastTotal","lastDiff","dir","entry","animationStart","animationEnd","trackLastWrapped","complete","oldDrainDisabled","trackIndex","interrupt","animationName","animation","delay","mixDuration","timelinesCount","timelineDipMix","propertyIDs","outer","listener","AnimationState","_TrackEntry","_EventQueue","animState","EventType","objects","listeners","o","AnimationStateAdapter","_AnimationStateData","skeletonData","fromName","toName","key","AnimationStateData","AtlasAttachmentLoader","atlas","path","Bone","parent","Matrix","rotation","scaleX","scaleY","shearX","shearY","m","sx","sy","settings","rotationY","pa","pb","pc","pd","TransformMode","la","lb","lc","ld","prx","rx","ry","za","zc","zb","zd","pm","pid","dx","dy","ia","ib","ic","ra","rb","rc","rd","det","world","invDet","local","worldRotation","localRotation","BoneData","ConstraintData","order","skinRequired","Event","EventData","IkConstraint","targetX","targetY","compress","stretch","uniform","p","rotationIK","tx","ty","sa","sc","dd","child","bendDir","softness","px","py","psx","psy","csx","pmat","os1","os2","s2","cx","cy","cwx","cwy","u","pp","l1","l2","a1","a2","td","sd","aa","bb","ta","c1","c2","q","r0","minAngle","minX","minDist","minY","maxAngle","maxX","maxDist","maxY","os","IkConstraintData","PathConstraintData","SpacingMode","_PathConstraint","spacingMode","lengthSpacing","rotateMode","tangents","RotateMode","boneCount","spacesCount","spaces","lengths","setupLength","length","positions","PositionMode","boneX","boneY","offsetRotation","tip","percentPosition","percentSpacing","out","closed","verticesLength","curveCount","prevCurve","pathLength","curve","space","x1","y1","x2","y2","segments","curveLength","segment","temp","tt","ttt","uu","uuu","ut","ut3","uut3","utt3","PathConstraint","TransformConstraint","Vector2","targetMat","tb","tc","degRadReflect","offsetShearY","modified","ts","_Skeleton","boneData","slotData","ikConstraintData","transformConstraintData","pathConstraintData","updateCache","skinBones","ikConstraints","transformConstraints","pathConstraints","ikCount","transformCount","pathCount","constraintCount","constrained","slotIndex","slotBone","pathBones","boneIndex","updateCacheReset","boneName","slotName","skinName","newSkin","constraintName","ikConstraint","size","mesh","nn","Skeleton","SkeletonData","skins","eventDataName","animations","pathConstraintName","SlotData","TransformConstraintData","SkinEntry","Skin","contained","j","dictionary","entries","slotAttachments","oldSkin","skinAttachment","_SkeletonBinary","attachmentLoader","binary","input","BinaryInput","nonessential","transform","defaultSkin","linkedMesh","slotCount","typeIndex","width","height","box","triangles","hullLength","edges","inheritDeform","LinkedMesh","constantSpeed","endSlotIndex","clip","Vertices","myVertices","weights","bonesArray","bone2","weight1","weight2","weight3","array","tempColor1","timelineType","timelineScale","iii","nnn","weighted","deformLength","end","vn","drawOrderCount","offsetCount","unchanged","originalIndex","unchangedIndex","eventCount","eventData","SkeletonBinary","BLEND_MODES","cVertices","SkeletonBounds","SkeletonBoundsBase","SkeletonJson","json","root","skeletonMap","error","boneMap","parentName","slotMap","constraintMap","targetName","skinMap","entryName","eventName","eventMap","animationMap","map","scaledVertices","timelineName","timelineMap","valueMap","defaultValue","deformName","deformMap","verticesValue","drawOrderNode","drawOrderMap","offsets","offsetMap","prop","str","Spine","SpineBase","spineData"],"mappings":"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"}