{"version":3,"file":"Animation.js","sources":["../../src/core/Animation.ts"],"sourcesContent":["import type { Event } from './Event';\r\nimport type { Skeleton } from './Skeleton';\r\nimport { Attachment, VertexAttachment } from './attachments';\r\nimport { ArrayLike, MathUtils, Utils, MixBlend, MixDirection } from '@pixi-spine/base';\r\nimport type { Slot } from './Slot';\r\nimport type { IkConstraint } from './IkConstraint';\r\nimport type { TransformConstraint } from './TransformConstraint';\r\nimport type { PathConstraint } from './PathConstraint';\r\n/** A simple container for a list of timelines and a name. */\r\n/**\r\n * @public\r\n */\r\nexport class Animation {\r\n    /** The animation's name, which is unique across all animations in the skeleton. */\r\n    name: string;\r\n    timelines: Array<Timeline>;\r\n    timelineIds: Array<boolean>;\r\n\r\n    /** The duration of the animation in seconds, which is the highest time of all keys in the timeline. */\r\n    duration: number;\r\n\r\n    constructor(name: string, timelines: Array<Timeline>, duration: number) {\r\n        if (name == null) throw new Error('name cannot be null.');\r\n        if (timelines == null) throw new Error('timelines cannot be null.');\r\n        this.name = name;\r\n        this.timelines = timelines;\r\n        this.timelineIds = [];\r\n        for (let i = 0; i < timelines.length; i++) this.timelineIds[timelines[i].getPropertyId()] = true;\r\n        this.duration = duration;\r\n    }\r\n\r\n    hasTimeline(id: number) {\r\n        return this.timelineIds[id] == true;\r\n    }\r\n\r\n    /** Applies all the animation's timelines to the specified skeleton.\r\n     *\r\n     * See Timeline {@link Timeline#apply(Skeleton, float, float, Array, float, MixBlend, MixDirection)}.\r\n     * @param loop If true, the animation repeats after {@link #getDuration()}.\r\n     * @param events May be null to ignore fired events. */\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, loop: boolean, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        if (skeleton == null) throw new Error('skeleton cannot be null.');\r\n\r\n        if (loop && this.duration != 0) {\r\n            time %= this.duration;\r\n            if (lastTime > 0) lastTime %= this.duration;\r\n        }\r\n\r\n        const timelines = this.timelines;\r\n\r\n        for (let i = 0, n = timelines.length; i < n; i++) timelines[i].apply(skeleton, lastTime, time, events, alpha, blend, direction);\r\n    }\r\n\r\n    /** @param target After the first and before the last value.\r\n     * @returns index of first value greater than the target. */\r\n    static binarySearch(values: ArrayLike<number>, target: number, step = 1) {\r\n        let low = 0;\r\n        let high = values.length / step - 2;\r\n\r\n        if (high == 0) return step;\r\n        let current = high >>> 1;\r\n\r\n        while (true) {\r\n            if (values[(current + 1) * step] <= target) low = current + 1;\r\n            else high = current;\r\n            if (low == high) return (low + 1) * step;\r\n            current = (low + high) >>> 1;\r\n        }\r\n    }\r\n\r\n    static linearSearch(values: ArrayLike<number>, target: number, step: number) {\r\n        for (let i = 0, last = values.length - step; i <= last; i += step) if (values[i] > target) return i;\r\n\r\n        return -1;\r\n    }\r\n}\r\n\r\n/** The interface for all timelines. */\r\n/**\r\n * @public\r\n */\r\nexport interface Timeline {\r\n    /** Applies this timeline to the skeleton.\r\n     * @param skeleton The skeleton the timeline is being applied to. This provides access to the bones, slots, and other\r\n     *           skeleton components the timeline may change.\r\n     * @param lastTime The time this timeline was last applied. Timelines such as {@link EventTimeline}} trigger only at specific\r\n     *           times rather than every frame. In that case, the timeline triggers everything between `lastTime`\r\n     *           (exclusive) and `time` (inclusive).\r\n     * @param time The time within the animation. Most timelines find the key before and the key after this time so they can\r\n     *           interpolate between the keys.\r\n     * @param events If any events are fired, they are added to this list. Can be null to ignore fired events or if the timeline\r\n     *           does not fire events.\r\n     * @param alpha 0 applies the current or setup value (depending on `blend`). 1 applies the timeline value.\r\n     *           Between 0 and 1 applies a value between the current or setup value and the timeline value. By adjusting\r\n     *           `alpha` over time, an animation can be mixed in or out. `alpha` can also be useful to\r\n     *           apply animations on top of each other (layering).\r\n     * @param blend Controls how mixing is applied when `alpha` < 1.\r\n     * @param direction Indicates whether the timeline is mixing in or out. Used by timelines which perform instant transitions,\r\n     *           such as {@link DrawOrderTimeline} or {@link AttachmentTimeline}. */\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection): void;\r\n\r\n    /** Uniquely encodes both the type of this timeline and the skeleton property that it affects. */\r\n    getPropertyId(): number;\r\n}\r\n\r\n/** Controls how a timeline value is mixed with the setup pose value or current pose value when a timeline's `alpha`\r\n * < 1.\r\n *\r\n * See Timeline {@link Timeline#apply(Skeleton, float, float, Array, float, MixBlend, MixDirection)}. */\r\n\r\n/**\r\n * @public\r\n */\r\nexport enum TimelineType {\r\n    rotate,\r\n    translate,\r\n    scale,\r\n    shear,\r\n    attachment,\r\n    color,\r\n    deform,\r\n    event,\r\n    drawOrder,\r\n    ikConstraint,\r\n    transformConstraint,\r\n    pathConstraintPosition,\r\n    pathConstraintSpacing,\r\n    pathConstraintMix,\r\n    twoColor,\r\n}\r\n\r\n/** The base class for timelines that use interpolation between key frame values. */\r\n/**\r\n * @public\r\n */\r\nexport abstract class CurveTimeline implements Timeline {\r\n    static LINEAR = 0;\r\n    static STEPPED = 1;\r\n    static BEZIER = 2;\r\n    static BEZIER_SIZE = 10 * 2 - 1;\r\n    curveData: { frameIndex: number; cx1: number; cy1: number; cx2: number; cy2: number }[] = [];\r\n\r\n    private curves: ArrayLike<number>; // type, x, y, ...\r\n\r\n    abstract getPropertyId(): number;\r\n\r\n    constructor(frameCount: number) {\r\n        if (frameCount <= 0) throw new Error(`frameCount must be > 0: ${frameCount}`);\r\n        this.curves = Utils.newFloatArray((frameCount - 1) * CurveTimeline.BEZIER_SIZE);\r\n    }\r\n\r\n    /** The number of key frames for this timeline. */\r\n    getFrameCount() {\r\n        return this.curves.length / CurveTimeline.BEZIER_SIZE + 1;\r\n    }\r\n\r\n    /** Sets the specified key frame to linear interpolation. */\r\n    setLinear(frameIndex: number) {\r\n        this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.LINEAR;\r\n    }\r\n\r\n    /** Sets the specified key frame to stepped interpolation. */\r\n    setStepped(frameIndex: number) {\r\n        this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.STEPPED;\r\n    }\r\n\r\n    /** Returns the interpolation type for the specified key frame.\r\n     * @returns Linear is 0, stepped is 1, Bezier is 2. */\r\n    getCurveType(frameIndex: number): number {\r\n        const index = frameIndex * CurveTimeline.BEZIER_SIZE;\r\n\r\n        if (index == this.curves.length) return CurveTimeline.LINEAR;\r\n        const type = this.curves[index];\r\n\r\n        if (type == CurveTimeline.LINEAR) return CurveTimeline.LINEAR;\r\n        if (type == CurveTimeline.STEPPED) return CurveTimeline.STEPPED;\r\n\r\n        return CurveTimeline.BEZIER;\r\n    }\r\n\r\n    /** Sets the specified key frame to Bezier interpolation. `cx1` and `cx2` are from 0 to 1,\r\n     * representing the percent of time between the two key frames. `cy1` and `cy2` are the percent of the\r\n     * difference between the key frame's values. */\r\n    setCurve(frameIndex: number, cx1: number, cy1: number, cx2: number, cy2: number) {\r\n        this.curveData.push({ frameIndex, cx1, cy1, cx2, cy2 });\r\n        const tmpx = (-cx1 * 2 + cx2) * 0.03;\r\n        const tmpy = (-cy1 * 2 + cy2) * 0.03;\r\n        const dddfx = ((cx1 - cx2) * 3 + 1) * 0.006;\r\n        const dddfy = ((cy1 - cy2) * 3 + 1) * 0.006;\r\n        let ddfx = tmpx * 2 + dddfx;\r\n        let ddfy = tmpy * 2 + dddfy;\r\n        let dfx = cx1 * 0.3 + tmpx + dddfx * 0.16666667;\r\n        let dfy = cy1 * 0.3 + tmpy + dddfy * 0.16666667;\r\n\r\n        let i = frameIndex * CurveTimeline.BEZIER_SIZE;\r\n        const curves = this.curves;\r\n\r\n        curves[i++] = CurveTimeline.BEZIER;\r\n\r\n        let x = dfx;\r\n        let y = dfy;\r\n\r\n        for (let n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\r\n            curves[i] = x;\r\n            curves[i + 1] = y;\r\n            dfx += ddfx;\r\n            dfy += ddfy;\r\n            ddfx += dddfx;\r\n            ddfy += dddfy;\r\n            x += dfx;\r\n            y += dfy;\r\n        }\r\n    }\r\n\r\n    /** Returns the interpolated percentage for the specified key frame and linear percentage. */\r\n    getCurvePercent(frameIndex: number, percent: number) {\r\n        percent = MathUtils.clamp(percent, 0, 1);\r\n        const curves = this.curves;\r\n        let i = frameIndex * CurveTimeline.BEZIER_SIZE;\r\n        const type = curves[i];\r\n\r\n        if (type == CurveTimeline.LINEAR) return percent;\r\n        if (type == CurveTimeline.STEPPED) return 0;\r\n        i++;\r\n        let x = 0;\r\n\r\n        for (let start = i, n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\r\n            x = curves[i];\r\n            if (x >= percent) {\r\n                let prevX: number;\r\n                let prevY: number;\r\n\r\n                if (i == start) {\r\n                    prevX = 0;\r\n                    prevY = 0;\r\n                } else {\r\n                    prevX = curves[i - 2];\r\n                    prevY = curves[i - 1];\r\n                }\r\n\r\n                return prevY + ((curves[i + 1] - prevY) * (percent - prevX)) / (x - prevX);\r\n            }\r\n        }\r\n        const y = curves[i - 1];\r\n\r\n        return y + ((1 - y) * (percent - x)) / (1 - x); // Last point is 1,1.\r\n    }\r\n\r\n    abstract apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection): void;\r\n}\r\n\r\n/** Changes a bone's local {@link Bone#rotation}. */\r\n/**\r\n * @public\r\n */\r\nexport class RotateTimeline extends CurveTimeline {\r\n    static ENTRIES = 2;\r\n    static PREV_TIME = -2;\r\n    static PREV_ROTATION = -1;\r\n    static ROTATION = 1;\r\n\r\n    data: { frameIndex: number; time: number; degrees: number }[] = [];\r\n\r\n    /** The index of the bone in {@link Skeleton#bones} that will be changed. */\r\n    boneIndex: number;\r\n\r\n    /** The time in seconds and rotation in degrees for each key frame. */\r\n    frames: ArrayLike<number>; // time, degrees, ...\r\n\r\n    constructor(frameCount: number) {\r\n        super(frameCount);\r\n        this.frames = Utils.newFloatArray(frameCount << 1);\r\n    }\r\n\r\n    getPropertyId() {\r\n        return (TimelineType.rotate << 24) + this.boneIndex;\r\n    }\r\n\r\n    /** Sets the time and angle of the specified keyframe. */\r\n    setFrame(frameIndex: number, time: number, degrees: number) {\r\n        this.data.push({ frameIndex, time, degrees });\r\n        frameIndex <<= 1;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + RotateTimeline.ROTATION] = degrees;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const frames = this.frames;\r\n\r\n        const bone = skeleton.bones[this.boneIndex];\r\n\r\n        if (!bone.active) return;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.rotation = bone.data.rotation;\r\n\r\n                    return;\r\n                case MixBlend.first:\r\n                    const r = bone.data.rotation - bone.rotation;\r\n\r\n                    bone.rotation += (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * alpha;\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        if (time >= frames[frames.length - RotateTimeline.ENTRIES]) {\r\n            // Time is after last frame.\r\n            let r = frames[frames.length + RotateTimeline.PREV_ROTATION];\r\n\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.rotation = bone.data.rotation + r * alpha;\r\n                    break;\r\n                case MixBlend.first:\r\n                case MixBlend.replace:\r\n                    r += bone.data.rotation - bone.rotation;\r\n                    r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360; // Wrap within -180 and 180.\r\n                case MixBlend.add:\r\n                    bone.rotation += r * alpha;\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        const frame = Animation.binarySearch(frames, time, RotateTimeline.ENTRIES);\r\n        const prevRotation = frames[frame + RotateTimeline.PREV_ROTATION];\r\n        const frameTime = frames[frame];\r\n        const percent = this.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + RotateTimeline.PREV_TIME] - frameTime));\r\n\r\n        let r = frames[frame + RotateTimeline.ROTATION] - prevRotation;\r\n\r\n        r = prevRotation + (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * percent;\r\n        switch (blend) {\r\n            case MixBlend.setup:\r\n                bone.rotation = bone.data.rotation + (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * alpha;\r\n                break;\r\n            case MixBlend.first:\r\n            case MixBlend.replace:\r\n                r += bone.data.rotation - bone.rotation;\r\n            case MixBlend.add:\r\n                bone.rotation += (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a bone's local {@link Bone#x} and {@link Bone#y}. */\r\n/**\r\n * @public\r\n */\r\nexport class TranslateTimeline extends CurveTimeline {\r\n    static ENTRIES = 3;\r\n    static PREV_TIME = -3;\r\n    static PREV_X = -2;\r\n    static PREV_Y = -1;\r\n    static X = 1;\r\n    static Y = 2;\r\n\r\n    data: { frameIndex: number; time: number; x: number; y: number }[] = [];\r\n\r\n    /** The index of the bone in {@link Skeleton#bones} that will be changed. */\r\n    boneIndex: number;\r\n\r\n    /** The time in seconds, x, and y values for each key frame. */\r\n    frames: ArrayLike<number>; // time, x, y, ...\r\n\r\n    constructor(frameCount: number) {\r\n        super(frameCount);\r\n        this.frames = Utils.newFloatArray(frameCount * TranslateTimeline.ENTRIES);\r\n    }\r\n\r\n    getPropertyId() {\r\n        return (TimelineType.translate << 24) + this.boneIndex;\r\n    }\r\n\r\n    /** Sets the time in seconds, x, and y values for the specified key frame. */\r\n    setFrame(frameIndex: number, time: number, x: number, y: number) {\r\n        this.data.push({ frameIndex, time, x, y });\r\n        frameIndex *= TranslateTimeline.ENTRIES;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + TranslateTimeline.X] = x;\r\n        this.frames[frameIndex + TranslateTimeline.Y] = y;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const frames = this.frames;\r\n\r\n        const bone = skeleton.bones[this.boneIndex];\r\n\r\n        if (!bone.active) return;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.x = bone.data.x;\r\n                    bone.y = bone.data.y;\r\n\r\n                    return;\r\n                case MixBlend.first:\r\n                    bone.x += (bone.data.x - bone.x) * alpha;\r\n                    bone.y += (bone.data.y - bone.y) * alpha;\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        let x = 0;\r\n        let y = 0;\r\n\r\n        if (time >= frames[frames.length - TranslateTimeline.ENTRIES]) {\r\n            // Time is after last frame.\r\n            x = frames[frames.length + TranslateTimeline.PREV_X];\r\n            y = frames[frames.length + TranslateTimeline.PREV_Y];\r\n        } else {\r\n            // Interpolate between the previous frame and the current frame.\r\n            const frame = Animation.binarySearch(frames, time, TranslateTimeline.ENTRIES);\r\n\r\n            x = frames[frame + TranslateTimeline.PREV_X];\r\n            y = frames[frame + TranslateTimeline.PREV_Y];\r\n            const frameTime = frames[frame];\r\n            const percent = this.getCurvePercent(frame / TranslateTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TranslateTimeline.PREV_TIME] - frameTime));\r\n\r\n            x += (frames[frame + TranslateTimeline.X] - x) * percent;\r\n            y += (frames[frame + TranslateTimeline.Y] - y) * percent;\r\n        }\r\n        switch (blend) {\r\n            case MixBlend.setup:\r\n                bone.x = bone.data.x + x * alpha;\r\n                bone.y = bone.data.y + y * alpha;\r\n                break;\r\n            case MixBlend.first:\r\n            case MixBlend.replace:\r\n                bone.x += (bone.data.x + x - bone.x) * alpha;\r\n                bone.y += (bone.data.y + y - bone.y) * alpha;\r\n                break;\r\n            case MixBlend.add:\r\n                bone.x += x * alpha;\r\n                bone.y += y * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a bone's local {@link Bone#scaleX)} and {@link Bone#scaleY}. */\r\n/**\r\n * @public\r\n */\r\nexport class ScaleTimeline extends TranslateTimeline {\r\n    constructor(frameCount: number) {\r\n        super(frameCount);\r\n    }\r\n\r\n    getPropertyId() {\r\n        return (TimelineType.scale << 24) + this.boneIndex;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const frames = this.frames;\r\n\r\n        const bone = skeleton.bones[this.boneIndex];\r\n\r\n        if (!bone.active) return;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.scaleX = bone.data.scaleX;\r\n                    bone.scaleY = bone.data.scaleY;\r\n\r\n                    return;\r\n                case MixBlend.first:\r\n                    bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;\r\n                    bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        let x = 0;\r\n        let y = 0;\r\n\r\n        if (time >= frames[frames.length - ScaleTimeline.ENTRIES]) {\r\n            // Time is after last frame.\r\n            x = frames[frames.length + ScaleTimeline.PREV_X] * bone.data.scaleX;\r\n            y = frames[frames.length + ScaleTimeline.PREV_Y] * bone.data.scaleY;\r\n        } else {\r\n            // Interpolate between the previous frame and the current frame.\r\n            const frame = Animation.binarySearch(frames, time, ScaleTimeline.ENTRIES);\r\n\r\n            x = frames[frame + ScaleTimeline.PREV_X];\r\n            y = frames[frame + ScaleTimeline.PREV_Y];\r\n            const frameTime = frames[frame];\r\n            const percent = this.getCurvePercent(frame / ScaleTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ScaleTimeline.PREV_TIME] - frameTime));\r\n\r\n            x = (x + (frames[frame + ScaleTimeline.X] - x) * percent) * bone.data.scaleX;\r\n            y = (y + (frames[frame + ScaleTimeline.Y] - y) * percent) * bone.data.scaleY;\r\n        }\r\n        if (alpha == 1) {\r\n            if (blend == MixBlend.add) {\r\n                bone.scaleX += x - bone.data.scaleX;\r\n                bone.scaleY += y - bone.data.scaleY;\r\n            } else {\r\n                bone.scaleX = x;\r\n                bone.scaleY = y;\r\n            }\r\n        } else {\r\n            let bx = 0;\r\n            let by = 0;\r\n\r\n            if (direction == MixDirection.mixOut) {\r\n                switch (blend) {\r\n                    case MixBlend.setup:\r\n                        bx = bone.data.scaleX;\r\n                        by = bone.data.scaleY;\r\n                        bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\r\n                        bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\r\n                        break;\r\n                    case MixBlend.first:\r\n                    case MixBlend.replace:\r\n                        bx = bone.scaleX;\r\n                        by = bone.scaleY;\r\n                        bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\r\n                        bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\r\n                        break;\r\n                    case MixBlend.add:\r\n                        bx = bone.scaleX;\r\n                        by = bone.scaleY;\r\n                        bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bone.data.scaleX) * alpha;\r\n                        bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - bone.data.scaleY) * alpha;\r\n                }\r\n            } else {\r\n                switch (blend) {\r\n                    case MixBlend.setup:\r\n                        bx = Math.abs(bone.data.scaleX) * MathUtils.signum(x);\r\n                        by = Math.abs(bone.data.scaleY) * MathUtils.signum(y);\r\n                        bone.scaleX = bx + (x - bx) * alpha;\r\n                        bone.scaleY = by + (y - by) * alpha;\r\n                        break;\r\n                    case MixBlend.first:\r\n                    case MixBlend.replace:\r\n                        bx = Math.abs(bone.scaleX) * MathUtils.signum(x);\r\n                        by = Math.abs(bone.scaleY) * MathUtils.signum(y);\r\n                        bone.scaleX = bx + (x - bx) * alpha;\r\n                        bone.scaleY = by + (y - by) * alpha;\r\n                        break;\r\n                    case MixBlend.add:\r\n                        bx = MathUtils.signum(x);\r\n                        by = MathUtils.signum(y);\r\n                        bone.scaleX = Math.abs(bone.scaleX) * bx + (x - Math.abs(bone.data.scaleX) * bx) * alpha;\r\n                        bone.scaleY = Math.abs(bone.scaleY) * by + (y - Math.abs(bone.data.scaleY) * by) * alpha;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a bone's local {@link Bone#shearX} and {@link Bone#shearY}. */\r\n/**\r\n * @public\r\n */\r\nexport class ShearTimeline extends TranslateTimeline {\r\n    constructor(frameCount: number) {\r\n        super(frameCount);\r\n    }\r\n\r\n    getPropertyId() {\r\n        return (TimelineType.shear << 24) + this.boneIndex;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const frames = this.frames;\r\n\r\n        const bone = skeleton.bones[this.boneIndex];\r\n\r\n        if (!bone.active) return;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.shearX = bone.data.shearX;\r\n                    bone.shearY = bone.data.shearY;\r\n\r\n                    return;\r\n                case MixBlend.first:\r\n                    bone.shearX += (bone.data.shearX - bone.shearX) * alpha;\r\n                    bone.shearY += (bone.data.shearY - bone.shearY) * alpha;\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        let x = 0;\r\n        let y = 0;\r\n\r\n        if (time >= frames[frames.length - ShearTimeline.ENTRIES]) {\r\n            // Time is after last frame.\r\n            x = frames[frames.length + ShearTimeline.PREV_X];\r\n            y = frames[frames.length + ShearTimeline.PREV_Y];\r\n        } else {\r\n            // Interpolate between the previous frame and the current frame.\r\n            const frame = Animation.binarySearch(frames, time, ShearTimeline.ENTRIES);\r\n\r\n            x = frames[frame + ShearTimeline.PREV_X];\r\n            y = frames[frame + ShearTimeline.PREV_Y];\r\n            const frameTime = frames[frame];\r\n            const percent = this.getCurvePercent(frame / ShearTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ShearTimeline.PREV_TIME] - frameTime));\r\n\r\n            x = x + (frames[frame + ShearTimeline.X] - x) * percent;\r\n            y = y + (frames[frame + ShearTimeline.Y] - y) * percent;\r\n        }\r\n        switch (blend) {\r\n            case MixBlend.setup:\r\n                bone.shearX = bone.data.shearX + x * alpha;\r\n                bone.shearY = bone.data.shearY + y * alpha;\r\n                break;\r\n            case MixBlend.first:\r\n            case MixBlend.replace:\r\n                bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;\r\n                bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;\r\n                break;\r\n            case MixBlend.add:\r\n                bone.shearX += x * alpha;\r\n                bone.shearY += y * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a slot's {@link Slot#color}. */\r\n/**\r\n * @public\r\n */\r\nexport class ColorTimeline extends CurveTimeline {\r\n    static ENTRIES = 5;\r\n    static PREV_TIME = -5;\r\n    static PREV_R = -4;\r\n    static PREV_G = -3;\r\n    static PREV_B = -2;\r\n    static PREV_A = -1;\r\n    static R = 1;\r\n    static G = 2;\r\n    static B = 3;\r\n    static A = 4;\r\n\r\n    /** The index of the slot in {@link Skeleton#slots} that will be changed. */\r\n    slotIndex: number;\r\n\r\n    /** The time in seconds, red, green, blue, and alpha values for each key frame. */\r\n    frames: ArrayLike<number>; // time, r, g, b, a, ...\r\n\r\n    data: { frameIndex: number; time: number; r: number; g: number; b: number; a: number }[] = [];\r\n\r\n    constructor(frameCount: number) {\r\n        super(frameCount);\r\n        this.frames = Utils.newFloatArray(frameCount * ColorTimeline.ENTRIES);\r\n    }\r\n\r\n    getPropertyId() {\r\n        return (TimelineType.color << 24) + this.slotIndex;\r\n    }\r\n\r\n    /** Sets the time in seconds, red, green, blue, and alpha for the specified key frame. */\r\n    setFrame(frameIndex: number, time: number, r: number, g: number, b: number, a: number) {\r\n        this.data.push({ frameIndex, time, r, g, b, a });\r\n        frameIndex *= ColorTimeline.ENTRIES;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + ColorTimeline.R] = r;\r\n        this.frames[frameIndex + ColorTimeline.G] = g;\r\n        this.frames[frameIndex + ColorTimeline.B] = b;\r\n        this.frames[frameIndex + ColorTimeline.A] = a;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const slot = skeleton.slots[this.slotIndex];\r\n\r\n        if (!slot.bone.active) return;\r\n        const frames = this.frames;\r\n\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    slot.color.setFromColor(slot.data.color);\r\n\r\n                    return;\r\n                case MixBlend.first:\r\n                    const color = slot.color;\r\n                    const setup = slot.data.color;\r\n\r\n                    color.add((setup.r - color.r) * alpha, (setup.g - color.g) * alpha, (setup.b - color.b) * alpha, (setup.a - color.a) * alpha);\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        let r = 0;\r\n        let g = 0;\r\n        let b = 0;\r\n        let a = 0;\r\n\r\n        if (time >= frames[frames.length - ColorTimeline.ENTRIES]) {\r\n            // Time is after last frame.\r\n            const i = frames.length;\r\n\r\n            r = frames[i + ColorTimeline.PREV_R];\r\n            g = frames[i + ColorTimeline.PREV_G];\r\n            b = frames[i + ColorTimeline.PREV_B];\r\n            a = frames[i + ColorTimeline.PREV_A];\r\n        } else {\r\n            // Interpolate between the previous frame and the current frame.\r\n            const frame = Animation.binarySearch(frames, time, ColorTimeline.ENTRIES);\r\n\r\n            r = frames[frame + ColorTimeline.PREV_R];\r\n            g = frames[frame + ColorTimeline.PREV_G];\r\n            b = frames[frame + ColorTimeline.PREV_B];\r\n            a = frames[frame + ColorTimeline.PREV_A];\r\n            const frameTime = frames[frame];\r\n            const percent = this.getCurvePercent(frame / ColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ColorTimeline.PREV_TIME] - frameTime));\r\n\r\n            r += (frames[frame + ColorTimeline.R] - r) * percent;\r\n            g += (frames[frame + ColorTimeline.G] - g) * percent;\r\n            b += (frames[frame + ColorTimeline.B] - b) * percent;\r\n            a += (frames[frame + ColorTimeline.A] - a) * percent;\r\n        }\r\n        if (alpha == 1) slot.color.set(r, g, b, a);\r\n        else {\r\n            const color = slot.color;\r\n\r\n            if (blend == MixBlend.setup) color.setFromColor(slot.data.color);\r\n            color.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a slot's {@link Slot#color} and {@link Slot#darkColor} for two color tinting. */\r\n/**\r\n * @public\r\n */\r\nexport class TwoColorTimeline extends CurveTimeline {\r\n    static ENTRIES = 8;\r\n    static PREV_TIME = -8;\r\n    static PREV_R = -7;\r\n    static PREV_G = -6;\r\n    static PREV_B = -5;\r\n    static PREV_A = -4;\r\n    static PREV_R2 = -3;\r\n    static PREV_G2 = -2;\r\n    static PREV_B2 = -1;\r\n    static R = 1;\r\n    static G = 2;\r\n    static B = 3;\r\n    static A = 4;\r\n    static R2 = 5;\r\n    static G2 = 6;\r\n    static B2 = 7;\r\n\r\n    /** The index of the slot in {@link Skeleton#slots()} that will be changed. The {@link Slot#darkColor()} must not be\r\n     * null. */\r\n    slotIndex: number;\r\n\r\n    /** The time in seconds, red, green, blue, and alpha values of the color, red, green, blue of the dark color, for each key frame. */\r\n    frames: ArrayLike<number>; // time, r, g, b, a, r2, g2, b2, ...\r\n\r\n    data: { frameIndex: number; time: number; r: number; g: number; b: number; a: number; r2: number; g2: number; b2: number }[] = [];\r\n    constructor(frameCount: number) {\r\n        super(frameCount);\r\n        this.frames = Utils.newFloatArray(frameCount * TwoColorTimeline.ENTRIES);\r\n    }\r\n\r\n    getPropertyId() {\r\n        return (TimelineType.twoColor << 24) + this.slotIndex;\r\n    }\r\n\r\n    /** Sets the time in seconds, light, and dark colors for the specified key frame. */\r\n    setFrame(frameIndex: number, time: number, r: number, g: number, b: number, a: number, r2: number, g2: number, b2: number) {\r\n        this.data.push({ frameIndex, time, r, g, b, a, r2, g2, b2 });\r\n        frameIndex *= TwoColorTimeline.ENTRIES;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + TwoColorTimeline.R] = r;\r\n        this.frames[frameIndex + TwoColorTimeline.G] = g;\r\n        this.frames[frameIndex + TwoColorTimeline.B] = b;\r\n        this.frames[frameIndex + TwoColorTimeline.A] = a;\r\n        this.frames[frameIndex + TwoColorTimeline.R2] = r2;\r\n        this.frames[frameIndex + TwoColorTimeline.G2] = g2;\r\n        this.frames[frameIndex + TwoColorTimeline.B2] = b2;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const slot = skeleton.slots[this.slotIndex];\r\n\r\n        if (!slot.bone.active) return;\r\n        const frames = this.frames;\r\n\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    slot.color.setFromColor(slot.data.color);\r\n                    slot.darkColor.setFromColor(slot.data.darkColor);\r\n\r\n                    return;\r\n                case MixBlend.first:\r\n                    const light = slot.color;\r\n                    const dark = slot.darkColor;\r\n                    const setupLight = slot.data.color;\r\n                    const setupDark = slot.data.darkColor;\r\n\r\n                    light.add((setupLight.r - light.r) * alpha, (setupLight.g - light.g) * alpha, (setupLight.b - light.b) * alpha, (setupLight.a - light.a) * alpha);\r\n                    dark.add((setupDark.r - dark.r) * alpha, (setupDark.g - dark.g) * alpha, (setupDark.b - dark.b) * alpha, 0);\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        let r = 0;\r\n        let g = 0;\r\n        let b = 0;\r\n        let a = 0;\r\n        let r2 = 0;\r\n        let g2 = 0;\r\n        let b2 = 0;\r\n\r\n        if (time >= frames[frames.length - TwoColorTimeline.ENTRIES]) {\r\n            // Time is after last frame.\r\n            const i = frames.length;\r\n\r\n            r = frames[i + TwoColorTimeline.PREV_R];\r\n            g = frames[i + TwoColorTimeline.PREV_G];\r\n            b = frames[i + TwoColorTimeline.PREV_B];\r\n            a = frames[i + TwoColorTimeline.PREV_A];\r\n            r2 = frames[i + TwoColorTimeline.PREV_R2];\r\n            g2 = frames[i + TwoColorTimeline.PREV_G2];\r\n            b2 = frames[i + TwoColorTimeline.PREV_B2];\r\n        } else {\r\n            // Interpolate between the previous frame and the current frame.\r\n            const frame = Animation.binarySearch(frames, time, TwoColorTimeline.ENTRIES);\r\n\r\n            r = frames[frame + TwoColorTimeline.PREV_R];\r\n            g = frames[frame + TwoColorTimeline.PREV_G];\r\n            b = frames[frame + TwoColorTimeline.PREV_B];\r\n            a = frames[frame + TwoColorTimeline.PREV_A];\r\n            r2 = frames[frame + TwoColorTimeline.PREV_R2];\r\n            g2 = frames[frame + TwoColorTimeline.PREV_G2];\r\n            b2 = frames[frame + TwoColorTimeline.PREV_B2];\r\n            const frameTime = frames[frame];\r\n            const percent = this.getCurvePercent(frame / TwoColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TwoColorTimeline.PREV_TIME] - frameTime));\r\n\r\n            r += (frames[frame + TwoColorTimeline.R] - r) * percent;\r\n            g += (frames[frame + TwoColorTimeline.G] - g) * percent;\r\n            b += (frames[frame + TwoColorTimeline.B] - b) * percent;\r\n            a += (frames[frame + TwoColorTimeline.A] - a) * percent;\r\n            r2 += (frames[frame + TwoColorTimeline.R2] - r2) * percent;\r\n            g2 += (frames[frame + TwoColorTimeline.G2] - g2) * percent;\r\n            b2 += (frames[frame + TwoColorTimeline.B2] - b2) * percent;\r\n        }\r\n        if (alpha == 1) {\r\n            slot.color.set(r, g, b, a);\r\n            slot.darkColor.set(r2, g2, b2, 1);\r\n        } else {\r\n            const light = slot.color;\r\n            const dark = slot.darkColor;\r\n\r\n            if (blend == MixBlend.setup) {\r\n                light.setFromColor(slot.data.color);\r\n                dark.setFromColor(slot.data.darkColor);\r\n            }\r\n            light.add((r - light.r) * alpha, (g - light.g) * alpha, (b - light.b) * alpha, (a - light.a) * alpha);\r\n            dark.add((r2 - dark.r) * alpha, (g2 - dark.g) * alpha, (b2 - dark.b) * alpha, 0);\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a slot's {@link Slot#attachment}. */\r\n/**\r\n * @public\r\n */\r\nexport class AttachmentTimeline implements Timeline {\r\n    /** The index of the slot in {@link Skeleton#slots} that will be changed. */\r\n    slotIndex: number;\r\n\r\n    /** The time in seconds for each key frame. */\r\n    frames: ArrayLike<number>; // time, ...\r\n\r\n    /** The attachment name for each key frame. May contain null values to clear the attachment. */\r\n    attachmentNames: Array<string>;\r\n\r\n    data: { frameIndex: number; time: number; attachmentName: string }[] = [];\r\n    constructor(frameCount: number) {\r\n        this.frames = Utils.newFloatArray(frameCount);\r\n        this.attachmentNames = new Array<string>(frameCount);\r\n    }\r\n\r\n    getPropertyId() {\r\n        return (TimelineType.attachment << 24) + this.slotIndex;\r\n    }\r\n\r\n    /** The number of key frames for this timeline. */\r\n    getFrameCount() {\r\n        return this.frames.length;\r\n    }\r\n\r\n    /** Sets the time in seconds and the attachment name for the specified key frame. */\r\n    setFrame(frameIndex: number, time: number, attachmentName: string) {\r\n        this.data.push({ frameIndex, time, attachmentName });\r\n        this.frames[frameIndex] = time;\r\n        this.attachmentNames[frameIndex] = attachmentName;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const slot = skeleton.slots[this.slotIndex];\r\n\r\n        if (!slot.bone.active) return;\r\n        if (direction == MixDirection.mixOut) {\r\n            if (blend == MixBlend.setup) this.setAttachment(skeleton, slot, slot.data.attachmentName);\r\n\r\n            return;\r\n        }\r\n\r\n        const frames = this.frames;\r\n\r\n        if (time < frames[0]) {\r\n            if (blend == MixBlend.setup || blend == MixBlend.first) this.setAttachment(skeleton, slot, slot.data.attachmentName);\r\n\r\n            return;\r\n        }\r\n\r\n        let frameIndex = 0;\r\n\r\n        if (time >= frames[frames.length - 1])\r\n            // Time is after last frame.\r\n            frameIndex = frames.length - 1;\r\n        else frameIndex = Animation.binarySearch(frames, time, 1) - 1;\r\n\r\n        const attachmentName = this.attachmentNames[frameIndex];\r\n\r\n        skeleton.slots[this.slotIndex].setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\r\n    }\r\n\r\n    setAttachment(skeleton: Skeleton, slot: Slot, attachmentName: string) {\r\n        slot.setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\r\n    }\r\n}\r\n\r\nlet zeros: ArrayLike<number> = null;\r\n\r\n/** Changes a slot's {@link Slot#deform} to deform a {@link VertexAttachment}. */\r\n/**\r\n * @public\r\n */\r\nexport class DeformTimeline extends CurveTimeline {\r\n    /** The index of the slot in {@link Skeleton#getSlots()} that will be changed. */\r\n    slotIndex: number;\r\n\r\n    /** The attachment that will be deformed. */\r\n    attachment: VertexAttachment;\r\n\r\n    /** The time in seconds for each key frame. */\r\n    frames: ArrayLike<number>; // time, ...\r\n\r\n    /** The vertices for each key frame. */\r\n    frameVertices: Array<ArrayLike<number>>;\r\n\r\n    data: { frameIndex: number; time: number; vertices: ArrayLike<number>; skin: string }[] = [];\r\n    constructor(frameCount: number) {\r\n        super(frameCount);\r\n        this.frames = Utils.newFloatArray(frameCount);\r\n        this.frameVertices = new Array<ArrayLike<number>>(frameCount);\r\n        if (zeros == null) zeros = Utils.newFloatArray(64);\r\n    }\r\n\r\n    getPropertyId() {\r\n        return (TimelineType.deform << 27) + Number(this.attachment.id) + this.slotIndex;\r\n    }\r\n\r\n    /** Sets the time in seconds and the vertices for the specified key frame.\r\n     * @param vertices Vertex positions for an unweighted VertexAttachment, or deform offsets if it has weights. */\r\n    setFrame(frameIndex: number, time: number, vertices: ArrayLike<number>, skin: string) {\r\n        this.data.push({ frameIndex, time, vertices, skin });\r\n        this.frames[frameIndex] = time;\r\n        this.frameVertices[frameIndex] = vertices;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const slot: Slot = skeleton.slots[this.slotIndex];\r\n\r\n        if (!slot.bone.active) return;\r\n        const slotAttachment: Attachment = slot.getAttachment();\r\n\r\n        if (!(slotAttachment instanceof VertexAttachment) || !((<VertexAttachment>slotAttachment).deformAttachment == this.attachment)) return;\r\n\r\n        const deformArray: Array<number> = slot.deform || [];\r\n\r\n        if (deformArray.length == 0) blend = MixBlend.setup;\r\n\r\n        const frameVertices = this.frameVertices;\r\n        const vertexCount = frameVertices[0].length;\r\n\r\n        const frames = this.frames;\r\n\r\n        if (time < frames[0]) {\r\n            const vertexAttachment = <VertexAttachment>slotAttachment;\r\n\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    deformArray.length = 0;\r\n\r\n                    return;\r\n                case MixBlend.first:\r\n                    if (alpha == 1) {\r\n                        deformArray.length = 0;\r\n                        break;\r\n                    }\r\n                    const deform: Array<number> = Utils.setArraySize(deformArray, vertexCount);\r\n\r\n                    if (vertexAttachment.bones == null) {\r\n                        // Unweighted vertex positions.\r\n                        const setupVertices = vertexAttachment.vertices;\r\n\r\n                        for (let i = 0; i < vertexCount; i++) deform[i] += (setupVertices[i] - deform[i]) * alpha;\r\n                    } else {\r\n                        // Weighted deform offsets.\r\n                        alpha = 1 - alpha;\r\n                        for (let i = 0; i < vertexCount; i++) deform[i] *= alpha;\r\n                    }\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        const deform: Array<number> = Utils.setArraySize(deformArray, vertexCount);\r\n\r\n        if (time >= frames[frames.length - 1]) {\r\n            // Time is after last frame.\r\n            const lastVertices = frameVertices[frames.length - 1];\r\n\r\n            if (alpha == 1) {\r\n                if (blend == MixBlend.add) {\r\n                    const vertexAttachment = slotAttachment as VertexAttachment;\r\n\r\n                    if (vertexAttachment.bones == null) {\r\n                        // Unweighted vertex positions, with alpha.\r\n                        const setupVertices = vertexAttachment.vertices;\r\n\r\n                        for (let i = 0; i < vertexCount; i++) {\r\n                            deform[i] += lastVertices[i] - setupVertices[i];\r\n                        }\r\n                    } else {\r\n                        // Weighted deform offsets, with alpha.\r\n                        for (let i = 0; i < vertexCount; i++) deform[i] += lastVertices[i];\r\n                    }\r\n                } else {\r\n                    Utils.arrayCopy(lastVertices, 0, deform, 0, vertexCount);\r\n                }\r\n            } else {\r\n                switch (blend) {\r\n                    case MixBlend.setup: {\r\n                        const vertexAttachment = slotAttachment as VertexAttachment;\r\n\r\n                        if (vertexAttachment.bones == null) {\r\n                            // Unweighted vertex positions, with alpha.\r\n                            const setupVertices = vertexAttachment.vertices;\r\n\r\n                            for (let i = 0; i < vertexCount; i++) {\r\n                                const setup = setupVertices[i];\r\n\r\n                                deform[i] = setup + (lastVertices[i] - setup) * alpha;\r\n                            }\r\n                        } else {\r\n                            // Weighted deform offsets, with alpha.\r\n                            for (let i = 0; i < vertexCount; i++) deform[i] = lastVertices[i] * alpha;\r\n                        }\r\n                        break;\r\n                    }\r\n                    case MixBlend.first:\r\n                    case MixBlend.replace:\r\n                        for (let i = 0; i < vertexCount; i++) deform[i] += (lastVertices[i] - deform[i]) * alpha;\r\n                        break;\r\n                    case MixBlend.add:\r\n                        const vertexAttachment = slotAttachment as VertexAttachment;\r\n\r\n                        if (vertexAttachment.bones == null) {\r\n                            // Unweighted vertex positions, with alpha.\r\n                            const setupVertices = vertexAttachment.vertices;\r\n\r\n                            for (let i = 0; i < vertexCount; i++) {\r\n                                deform[i] += (lastVertices[i] - setupVertices[i]) * alpha;\r\n                            }\r\n                        } else {\r\n                            // Weighted deform offsets, with alpha.\r\n                            for (let i = 0; i < vertexCount; i++) deform[i] += lastVertices[i] * alpha;\r\n                        }\r\n                }\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        const frame = Animation.binarySearch(frames, time);\r\n        const prevVertices = frameVertices[frame - 1];\r\n        const nextVertices = frameVertices[frame];\r\n        const frameTime = frames[frame];\r\n        const percent = this.getCurvePercent(frame - 1, 1 - (time - frameTime) / (frames[frame - 1] - frameTime));\r\n\r\n        if (alpha == 1) {\r\n            if (blend == MixBlend.add) {\r\n                const vertexAttachment = slotAttachment as VertexAttachment;\r\n\r\n                if (vertexAttachment.bones == null) {\r\n                    // Unweighted vertex positions, with alpha.\r\n                    const setupVertices = vertexAttachment.vertices;\r\n\r\n                    for (let i = 0; i < vertexCount; i++) {\r\n                        const prev = prevVertices[i];\r\n\r\n                        deform[i] += prev + (nextVertices[i] - prev) * percent - setupVertices[i];\r\n                    }\r\n                } else {\r\n                    // Weighted deform offsets, with alpha.\r\n                    for (let i = 0; i < vertexCount; i++) {\r\n                        const prev = prevVertices[i];\r\n\r\n                        deform[i] += prev + (nextVertices[i] - prev) * percent;\r\n                    }\r\n                }\r\n            } else {\r\n                for (let i = 0; i < vertexCount; i++) {\r\n                    const prev = prevVertices[i];\r\n\r\n                    deform[i] = prev + (nextVertices[i] - prev) * percent;\r\n                }\r\n            }\r\n        } else {\r\n            switch (blend) {\r\n                case MixBlend.setup: {\r\n                    const vertexAttachment = slotAttachment as VertexAttachment;\r\n\r\n                    if (vertexAttachment.bones == null) {\r\n                        // Unweighted vertex positions, with alpha.\r\n                        const setupVertices = vertexAttachment.vertices;\r\n\r\n                        for (let i = 0; i < vertexCount; i++) {\r\n                            const prev = prevVertices[i];\r\n                            const setup = setupVertices[i];\r\n\r\n                            deform[i] = setup + (prev + (nextVertices[i] - prev) * percent - setup) * alpha;\r\n                        }\r\n                    } else {\r\n                        // Weighted deform offsets, with alpha.\r\n                        for (let i = 0; i < vertexCount; i++) {\r\n                            const prev = prevVertices[i];\r\n\r\n                            deform[i] = (prev + (nextVertices[i] - prev) * percent) * alpha;\r\n                        }\r\n                    }\r\n                    break;\r\n                }\r\n                case MixBlend.first:\r\n                case MixBlend.replace:\r\n                    for (let i = 0; i < vertexCount; i++) {\r\n                        const prev = prevVertices[i];\r\n\r\n                        deform[i] += (prev + (nextVertices[i] - prev) * percent - deform[i]) * alpha;\r\n                    }\r\n                    break;\r\n                case MixBlend.add:\r\n                    const vertexAttachment = slotAttachment as VertexAttachment;\r\n\r\n                    if (vertexAttachment.bones == null) {\r\n                        // Unweighted vertex positions, with alpha.\r\n                        const setupVertices = vertexAttachment.vertices;\r\n\r\n                        for (let i = 0; i < vertexCount; i++) {\r\n                            const prev = prevVertices[i];\r\n\r\n                            deform[i] += (prev + (nextVertices[i] - prev) * percent - setupVertices[i]) * alpha;\r\n                        }\r\n                    } else {\r\n                        // Weighted deform offsets, with alpha.\r\n                        for (let i = 0; i < vertexCount; i++) {\r\n                            const prev = prevVertices[i];\r\n\r\n                            deform[i] += (prev + (nextVertices[i] - prev) * percent) * alpha;\r\n                        }\r\n                    }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/** Fires an {@link Event} when specific animation times are reached. */\r\n/**\r\n * @public\r\n */\r\nexport class EventTimeline implements Timeline {\r\n    /** The time in seconds for each key frame. */\r\n    frames: ArrayLike<number>; // time, ...\r\n\r\n    /** The event for each key frame. */\r\n    events: Array<Event>;\r\n\r\n    data: { frameIndex: number; event: Event }[] = [];\r\n    constructor(frameCount: number) {\r\n        this.frames = Utils.newFloatArray(frameCount);\r\n        this.events = new Array<Event>(frameCount);\r\n    }\r\n\r\n    getPropertyId() {\r\n        return TimelineType.event << 24;\r\n    }\r\n\r\n    /** The number of key frames for this timeline. */\r\n    getFrameCount() {\r\n        return this.frames.length;\r\n    }\r\n\r\n    /** Sets the time in seconds and the event for the specified key frame. */\r\n    setFrame(frameIndex: number, event: Event) {\r\n        this.data.push({ frameIndex, event });\r\n        this.frames[frameIndex] = event.time;\r\n        this.events[frameIndex] = event;\r\n    }\r\n\r\n    /** Fires events for frames > `lastTime` and <= `time`. */\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        if (firedEvents == null) return;\r\n        const frames = this.frames;\r\n        const frameCount = this.frames.length;\r\n\r\n        if (lastTime > time) {\r\n            // Fire events after last time for looped animations.\r\n            this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, blend, direction);\r\n            lastTime = -1;\r\n        } else if (lastTime >= frames[frameCount - 1])\r\n            // Last time is after last frame.\r\n            return;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        let frame = 0;\r\n\r\n        if (lastTime < frames[0]) frame = 0;\r\n        else {\r\n            frame = Animation.binarySearch(frames, lastTime);\r\n            const frameTime = frames[frame];\r\n\r\n            while (frame > 0) {\r\n                // Fire multiple events with the same frame.\r\n                if (frames[frame - 1] != frameTime) break;\r\n                frame--;\r\n            }\r\n        }\r\n        for (; frame < frameCount && time >= frames[frame]; frame++) firedEvents.push(this.events[frame]);\r\n    }\r\n}\r\n\r\n/** Changes a skeleton's {@link Skeleton#drawOrder}. */\r\n/**\r\n * @public\r\n */\r\nexport class DrawOrderTimeline implements Timeline {\r\n    /** The time in seconds for each key frame. */\r\n    frames: ArrayLike<number>; // time, ...\r\n\r\n    /** The draw order for each key frame. See {@link #setFrame(int, float, int[])}. */\r\n    drawOrders: Array<Array<number>>;\r\n\r\n    data: { frameIndex: number; time: number; drawOrder: Array<number> }[] = [];\r\n    constructor(frameCount: number) {\r\n        this.frames = Utils.newFloatArray(frameCount);\r\n        this.drawOrders = new Array<Array<number>>(frameCount);\r\n    }\r\n\r\n    getPropertyId() {\r\n        return TimelineType.drawOrder << 24;\r\n    }\r\n\r\n    /** The number of key frames for this timeline. */\r\n    getFrameCount() {\r\n        return this.frames.length;\r\n    }\r\n\r\n    /** Sets the time in seconds and the draw order for the specified key frame.\r\n     * @param drawOrder For each slot in {@link Skeleton#slots}, the index of the new draw order. May be null to use setup pose\r\n     *           draw order. */\r\n    setFrame(frameIndex: number, time: number, drawOrder: Array<number>) {\r\n        this.data.push({ frameIndex, time, drawOrder });\r\n        this.frames[frameIndex] = time;\r\n        this.drawOrders[frameIndex] = drawOrder;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const drawOrder: Array<Slot> = skeleton.drawOrder;\r\n        const slots: Array<Slot> = skeleton.slots;\r\n\r\n        if (direction == MixDirection.mixOut && blend == MixBlend.setup) {\r\n            Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\r\n\r\n            return;\r\n        }\r\n\r\n        const frames = this.frames;\r\n\r\n        if (time < frames[0]) {\r\n            if (blend == MixBlend.setup || blend == MixBlend.first) Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\r\n\r\n            return;\r\n        }\r\n\r\n        let frame = 0;\r\n\r\n        if (time >= frames[frames.length - 1])\r\n            // Time is after last frame.\r\n            frame = frames.length - 1;\r\n        else frame = Animation.binarySearch(frames, time) - 1;\r\n\r\n        const drawOrderToSetupIndex = this.drawOrders[frame];\r\n\r\n        if (drawOrderToSetupIndex == null) Utils.arrayCopy(slots, 0, drawOrder, 0, slots.length);\r\n        else {\r\n            for (let i = 0, n = drawOrderToSetupIndex.length; i < n; i++) drawOrder[i] = slots[drawOrderToSetupIndex[i]];\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes an IK constraint's {@link IkConstraint#mix}, {@link IkConstraint#softness},\r\n * {@link IkConstraint#bendDirection}, {@link IkConstraint#stretch}, and {@link IkConstraint#compress}. */\r\n/**\r\n * @public\r\n */\r\nexport class IkConstraintTimeline extends CurveTimeline {\r\n    static ENTRIES = 6;\r\n    static PREV_TIME = -6;\r\n    static PREV_MIX = -5;\r\n    static PREV_SOFTNESS = -4;\r\n    static PREV_BEND_DIRECTION = -3;\r\n    static PREV_COMPRESS = -2;\r\n    static PREV_STRETCH = -1;\r\n    static MIX = 1;\r\n    static SOFTNESS = 2;\r\n    static BEND_DIRECTION = 3;\r\n    static COMPRESS = 4;\r\n    static STRETCH = 5;\r\n\r\n    /** The index of the IK constraint slot in {@link Skeleton#ikConstraints} that will be changed. */\r\n    ikConstraintIndex: number;\r\n\r\n    /** The time in seconds, mix, softness, bend direction, compress, and stretch for each key frame. */\r\n    frames: ArrayLike<number>; // time, mix, softness, bendDirection, compress, stretch, ...\r\n\r\n    data: { frameIndex: number; time: number; mix: number; bendDirection: number }[] = [];\r\n    constructor(frameCount: number) {\r\n        super(frameCount);\r\n        this.frames = Utils.newFloatArray(frameCount * IkConstraintTimeline.ENTRIES);\r\n    }\r\n\r\n    getPropertyId() {\r\n        return (TimelineType.ikConstraint << 24) + this.ikConstraintIndex;\r\n    }\r\n\r\n    /** Sets the time, mix and bend direction of the specified keyframe. */\r\n    setFrame(frameIndex: number, time: number, mix: number, bendDirection: number) {\r\n        this.data.push({ frameIndex, time, mix, bendDirection });\r\n        frameIndex *= IkConstraintTimeline.ENTRIES;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + IkConstraintTimeline.MIX] = mix;\r\n        this.frames[frameIndex + IkConstraintTimeline.BEND_DIRECTION] = bendDirection;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const frames = this.frames;\r\n        const constraint: IkConstraint = skeleton.ikConstraints[this.ikConstraintIndex];\r\n\r\n        if (!constraint.active) return;\r\n\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    constraint.mix = constraint.data.mix;\r\n                    constraint.softness = constraint.data.softness;\r\n                    constraint.bendDirection = constraint.data.bendDirection;\r\n                    constraint.compress = constraint.data.compress;\r\n                    constraint.stretch = constraint.data.stretch;\r\n\r\n                    return;\r\n                case MixBlend.first:\r\n                    constraint.mix += (constraint.data.mix - constraint.mix) * alpha;\r\n                    constraint.softness += (constraint.data.softness - constraint.softness) * alpha;\r\n                    constraint.bendDirection = constraint.data.bendDirection;\r\n                    constraint.compress = constraint.data.compress;\r\n                    constraint.stretch = constraint.data.stretch;\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        if (time >= frames[frames.length - IkConstraintTimeline.ENTRIES]) {\r\n            // Time is after last frame.\r\n            if (blend === MixBlend.setup) {\r\n                constraint.mix = constraint.data.mix + (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.data.mix) * alpha;\r\n                constraint.softness = constraint.data.softness + (frames[frames.length + IkConstraintTimeline.PREV_SOFTNESS] - constraint.data.softness) * alpha;\r\n                if (direction === MixDirection.mixOut) {\r\n                    constraint.bendDirection = constraint.data.bendDirection;\r\n                    constraint.compress = constraint.data.compress;\r\n                    constraint.stretch = constraint.data.stretch;\r\n                } else {\r\n                    constraint.bendDirection = frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION];\r\n                    constraint.compress = frames[frames.length + IkConstraintTimeline.PREV_COMPRESS] !== 0;\r\n                    constraint.stretch = frames[frames.length + IkConstraintTimeline.PREV_STRETCH] !== 0;\r\n                }\r\n            } else {\r\n                constraint.mix += (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.mix) * alpha;\r\n                constraint.softness += (frames[frames.length + IkConstraintTimeline.PREV_SOFTNESS] - constraint.softness) * alpha;\r\n                if (direction === MixDirection.mixIn) {\r\n                    constraint.bendDirection = frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION];\r\n                    constraint.compress = frames[frames.length + IkConstraintTimeline.PREV_COMPRESS] !== 0;\r\n                    constraint.stretch = frames[frames.length + IkConstraintTimeline.PREV_STRETCH] !== 0;\r\n                }\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        const frame = Animation.binarySearch(frames, time, IkConstraintTimeline.ENTRIES);\r\n        const mix = frames[frame + IkConstraintTimeline.PREV_MIX];\r\n        const frameTime = frames[frame];\r\n        const percent = this.getCurvePercent(frame / IkConstraintTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + IkConstraintTimeline.PREV_TIME] - frameTime));\r\n\r\n        constraint.mix += (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.mix) * alpha;\r\n        constraint.bendDirection = Math.floor(frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION]);\r\n    }\r\n}\r\n\r\n/** Changes a transform constraint's {@link TransformConstraint#rotateMix}, {@link TransformConstraint#translateMix},\r\n * {@link TransformConstraint#scaleMix}, and {@link TransformConstraint#shearMix}. */\r\n/**\r\n * @public\r\n */\r\nexport class TransformConstraintTimeline extends CurveTimeline {\r\n    static ENTRIES = 5;\r\n    static PREV_TIME = -5;\r\n    static PREV_ROTATE = -4;\r\n    static PREV_TRANSLATE = -3;\r\n    static PREV_SCALE = -2;\r\n    static PREV_SHEAR = -1;\r\n    static ROTATE = 1;\r\n    static TRANSLATE = 2;\r\n    static SCALE = 3;\r\n    static SHEAR = 4;\r\n\r\n    /** The index of the transform constraint slot in {@link Skeleton#transformConstraints} that will be changed. */\r\n    transformConstraintIndex: number;\r\n\r\n    /** The time in seconds, rotate mix, translate mix, scale mix, and shear mix for each key frame. */\r\n    frames: ArrayLike<number>; // time, rotate mix, translate mix, scale mix, shear mix, ...\r\n\r\n    data: { frameIndex: number; time: number; rotateMix: number; translateMix: number; scaleMix: number; shearMix: number }[] = [];\r\n    constructor(frameCount: number) {\r\n        super(frameCount);\r\n        this.frames = Utils.newFloatArray(frameCount * TransformConstraintTimeline.ENTRIES);\r\n    }\r\n\r\n    getPropertyId() {\r\n        return (TimelineType.transformConstraint << 24) + this.transformConstraintIndex;\r\n    }\r\n\r\n    /** The time in seconds, rotate mix, translate mix, scale mix, and shear mix for the specified key frame. */\r\n    setFrame(frameIndex: number, time: number, rotateMix: number, translateMix: number, scaleMix: number, shearMix: number) {\r\n        this.data.push({ frameIndex, time, rotateMix, translateMix, scaleMix, shearMix });\r\n        frameIndex *= TransformConstraintTimeline.ENTRIES;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + TransformConstraintTimeline.ROTATE] = rotateMix;\r\n        this.frames[frameIndex + TransformConstraintTimeline.TRANSLATE] = translateMix;\r\n        this.frames[frameIndex + TransformConstraintTimeline.SCALE] = scaleMix;\r\n        this.frames[frameIndex + TransformConstraintTimeline.SHEAR] = shearMix;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const frames = this.frames;\r\n\r\n        const constraint: TransformConstraint = skeleton.transformConstraints[this.transformConstraintIndex];\r\n\r\n        if (!constraint.active) return;\r\n        if (time < frames[0]) {\r\n            const data = constraint.data;\r\n\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    constraint.rotateMix = data.rotateMix;\r\n                    constraint.translateMix = data.translateMix;\r\n                    constraint.scaleMix = data.scaleMix;\r\n                    constraint.shearMix = data.shearMix;\r\n\r\n                    return;\r\n                case MixBlend.first:\r\n                    constraint.rotateMix += (data.rotateMix - constraint.rotateMix) * alpha;\r\n                    constraint.translateMix += (data.translateMix - constraint.translateMix) * alpha;\r\n                    constraint.scaleMix += (data.scaleMix - constraint.scaleMix) * alpha;\r\n                    constraint.shearMix += (data.shearMix - constraint.shearMix) * alpha;\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        let rotate = 0;\r\n        let translate = 0;\r\n        let scale = 0;\r\n        let shear = 0;\r\n\r\n        if (time >= frames[frames.length - TransformConstraintTimeline.ENTRIES]) {\r\n            // Time is after last frame.\r\n            const i = frames.length;\r\n\r\n            rotate = frames[i + TransformConstraintTimeline.PREV_ROTATE];\r\n            translate = frames[i + TransformConstraintTimeline.PREV_TRANSLATE];\r\n            scale = frames[i + TransformConstraintTimeline.PREV_SCALE];\r\n            shear = frames[i + TransformConstraintTimeline.PREV_SHEAR];\r\n        } else {\r\n            // Interpolate between the previous frame and the current frame.\r\n            const frame = Animation.binarySearch(frames, time, TransformConstraintTimeline.ENTRIES);\r\n\r\n            rotate = frames[frame + TransformConstraintTimeline.PREV_ROTATE];\r\n            translate = frames[frame + TransformConstraintTimeline.PREV_TRANSLATE];\r\n            scale = frames[frame + TransformConstraintTimeline.PREV_SCALE];\r\n            shear = frames[frame + TransformConstraintTimeline.PREV_SHEAR];\r\n            const frameTime = frames[frame];\r\n            const percent = this.getCurvePercent(\r\n                frame / TransformConstraintTimeline.ENTRIES - 1,\r\n                1 - (time - frameTime) / (frames[frame + TransformConstraintTimeline.PREV_TIME] - frameTime)\r\n            );\r\n\r\n            rotate += (frames[frame + TransformConstraintTimeline.ROTATE] - rotate) * percent;\r\n            translate += (frames[frame + TransformConstraintTimeline.TRANSLATE] - translate) * percent;\r\n            scale += (frames[frame + TransformConstraintTimeline.SCALE] - scale) * percent;\r\n            shear += (frames[frame + TransformConstraintTimeline.SHEAR] - shear) * percent;\r\n        }\r\n        if (blend == MixBlend.setup) {\r\n            const data = constraint.data;\r\n\r\n            constraint.rotateMix = data.rotateMix + (rotate - data.rotateMix) * alpha;\r\n            constraint.translateMix = data.translateMix + (translate - data.translateMix) * alpha;\r\n            constraint.scaleMix = data.scaleMix + (scale - data.scaleMix) * alpha;\r\n            constraint.shearMix = data.shearMix + (shear - data.shearMix) * alpha;\r\n        } else {\r\n            constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;\r\n            constraint.translateMix += (translate - constraint.translateMix) * alpha;\r\n            constraint.scaleMix += (scale - constraint.scaleMix) * alpha;\r\n            constraint.shearMix += (shear - constraint.shearMix) * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a path constraint's {@link PathConstraint#position}. */\r\n/**\r\n * @public\r\n */\r\nexport class PathConstraintPositionTimeline extends CurveTimeline {\r\n    static ENTRIES = 2;\r\n    static PREV_TIME = -2;\r\n    static PREV_VALUE = -1;\r\n    static VALUE = 1;\r\n\r\n    /** The index of the path constraint slot in {@link Skeleton#pathConstraints} that will be changed. */\r\n    pathConstraintIndex: number;\r\n\r\n    /** The time in seconds and path constraint position for each key frame. */\r\n    frames: ArrayLike<number>; // time, position, ...\r\n\r\n    data: { frameIndex: number; time: number; value: number }[] = [];\r\n    constructor(frameCount: number) {\r\n        super(frameCount);\r\n        this.frames = Utils.newFloatArray(frameCount * PathConstraintPositionTimeline.ENTRIES);\r\n    }\r\n\r\n    getPropertyId() {\r\n        return (TimelineType.pathConstraintPosition << 24) + this.pathConstraintIndex;\r\n    }\r\n\r\n    /** Sets the time in seconds and path constraint position for the specified key frame. */\r\n    setFrame(frameIndex: number, time: number, value: number) {\r\n        this.data.push({ frameIndex, time, value });\r\n        frameIndex *= PathConstraintPositionTimeline.ENTRIES;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + PathConstraintPositionTimeline.VALUE] = value;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const frames = this.frames;\r\n        const constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\r\n\r\n        if (!constraint.active) return;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    constraint.position = constraint.data.position;\r\n\r\n                    return;\r\n                case MixBlend.first:\r\n                    constraint.position += (constraint.data.position - constraint.position) * alpha;\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        let position = 0;\r\n\r\n        if (time >= frames[frames.length - PathConstraintPositionTimeline.ENTRIES])\r\n            // Time is after last frame.\r\n            position = frames[frames.length + PathConstraintPositionTimeline.PREV_VALUE];\r\n        else {\r\n            // Interpolate between the previous frame and the current frame.\r\n            const frame = Animation.binarySearch(frames, time, PathConstraintPositionTimeline.ENTRIES);\r\n\r\n            position = frames[frame + PathConstraintPositionTimeline.PREV_VALUE];\r\n            const frameTime = frames[frame];\r\n            const percent = this.getCurvePercent(\r\n                frame / PathConstraintPositionTimeline.ENTRIES - 1,\r\n                1 - (time - frameTime) / (frames[frame + PathConstraintPositionTimeline.PREV_TIME] - frameTime)\r\n            );\r\n\r\n            position += (frames[frame + PathConstraintPositionTimeline.VALUE] - position) * percent;\r\n        }\r\n        if (blend == MixBlend.setup) constraint.position = constraint.data.position + (position - constraint.data.position) * alpha;\r\n        else constraint.position += (position - constraint.position) * alpha;\r\n    }\r\n}\r\n\r\n/** Changes a path constraint's {@link PathConstraint#spacing}. */\r\n/**\r\n * @public\r\n */\r\nexport class PathConstraintSpacingTimeline extends PathConstraintPositionTimeline {\r\n    constructor(frameCount: number) {\r\n        super(frameCount);\r\n    }\r\n\r\n    getPropertyId() {\r\n        return (TimelineType.pathConstraintSpacing << 24) + this.pathConstraintIndex;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const frames = this.frames;\r\n        const constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\r\n\r\n        if (!constraint.active) return;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    constraint.spacing = constraint.data.spacing;\r\n\r\n                    return;\r\n                case MixBlend.first:\r\n                    constraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha;\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        let spacing = 0;\r\n\r\n        if (time >= frames[frames.length - PathConstraintSpacingTimeline.ENTRIES])\r\n            // Time is after last frame.\r\n            spacing = frames[frames.length + PathConstraintSpacingTimeline.PREV_VALUE];\r\n        else {\r\n            // Interpolate between the previous frame and the current frame.\r\n            const frame = Animation.binarySearch(frames, time, PathConstraintSpacingTimeline.ENTRIES);\r\n\r\n            spacing = frames[frame + PathConstraintSpacingTimeline.PREV_VALUE];\r\n            const frameTime = frames[frame];\r\n            const percent = this.getCurvePercent(\r\n                frame / PathConstraintSpacingTimeline.ENTRIES - 1,\r\n                1 - (time - frameTime) / (frames[frame + PathConstraintSpacingTimeline.PREV_TIME] - frameTime)\r\n            );\r\n\r\n            spacing += (frames[frame + PathConstraintSpacingTimeline.VALUE] - spacing) * percent;\r\n        }\r\n\r\n        if (blend == MixBlend.setup) constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha;\r\n        else constraint.spacing += (spacing - constraint.spacing) * alpha;\r\n    }\r\n}\r\n\r\n/** Changes a transform constraint's {@link PathConstraint#rotateMix} and\r\n * {@link TransformConstraint#translateMix}. */\r\n/**\r\n * @public\r\n */\r\nexport class PathConstraintMixTimeline extends CurveTimeline {\r\n    static ENTRIES = 3;\r\n    static PREV_TIME = -3;\r\n    static PREV_ROTATE = -2;\r\n    static PREV_TRANSLATE = -1;\r\n    static ROTATE = 1;\r\n    static TRANSLATE = 2;\r\n\r\n    /** The index of the path constraint slot in {@link Skeleton#getPathConstraints()} that will be changed. */\r\n    pathConstraintIndex: number;\r\n\r\n    /** The time in seconds, rotate mix, and translate mix for each key frame. */\r\n    frames: ArrayLike<number>; // time, rotate mix, translate mix, ...\r\n\r\n    data: { frameIndex: number; time: number; rotateMix: number; translateMix: number }[] = [];\r\n    constructor(frameCount: number) {\r\n        super(frameCount);\r\n        this.frames = Utils.newFloatArray(frameCount * PathConstraintMixTimeline.ENTRIES);\r\n    }\r\n\r\n    getPropertyId() {\r\n        return (TimelineType.pathConstraintMix << 24) + this.pathConstraintIndex;\r\n    }\r\n\r\n    /** The time in seconds, rotate mix, and translate mix for the specified key frame. */\r\n    setFrame(frameIndex: number, time: number, rotateMix: number, translateMix: number) {\r\n        this.data.push({ frameIndex, time, rotateMix, translateMix });\r\n        frameIndex *= PathConstraintMixTimeline.ENTRIES;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + PathConstraintMixTimeline.ROTATE] = rotateMix;\r\n        this.frames[frameIndex + PathConstraintMixTimeline.TRANSLATE] = translateMix;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const frames = this.frames;\r\n        const constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\r\n\r\n        if (!constraint.active) return;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    constraint.rotateMix = constraint.data.rotateMix;\r\n                    constraint.translateMix = constraint.data.translateMix;\r\n\r\n                    return;\r\n                case MixBlend.first:\r\n                    constraint.rotateMix += (constraint.data.rotateMix - constraint.rotateMix) * alpha;\r\n                    constraint.translateMix += (constraint.data.translateMix - constraint.translateMix) * alpha;\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        let rotate = 0;\r\n        let translate = 0;\r\n\r\n        if (time >= frames[frames.length - PathConstraintMixTimeline.ENTRIES]) {\r\n            // Time is after last frame.\r\n            rotate = frames[frames.length + PathConstraintMixTimeline.PREV_ROTATE];\r\n            translate = frames[frames.length + PathConstraintMixTimeline.PREV_TRANSLATE];\r\n        } else {\r\n            // Interpolate between the previous frame and the current frame.\r\n            const frame = Animation.binarySearch(frames, time, PathConstraintMixTimeline.ENTRIES);\r\n\r\n            rotate = frames[frame + PathConstraintMixTimeline.PREV_ROTATE];\r\n            translate = frames[frame + PathConstraintMixTimeline.PREV_TRANSLATE];\r\n            const frameTime = frames[frame];\r\n            const percent = this.getCurvePercent(\r\n                frame / PathConstraintMixTimeline.ENTRIES - 1,\r\n                1 - (time - frameTime) / (frames[frame + PathConstraintMixTimeline.PREV_TIME] - frameTime)\r\n            );\r\n\r\n            rotate += (frames[frame + PathConstraintMixTimeline.ROTATE] - rotate) * percent;\r\n            translate += (frames[frame + PathConstraintMixTimeline.TRANSLATE] - translate) * percent;\r\n        }\r\n\r\n        if (blend == MixBlend.setup) {\r\n            constraint.rotateMix = constraint.data.rotateMix + (rotate - constraint.data.rotateMix) * alpha;\r\n            constraint.translateMix = constraint.data.translateMix + (translate - constraint.data.translateMix) * alpha;\r\n        } else {\r\n            constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;\r\n            constraint.translateMix += (translate - constraint.translateMix) * alpha;\r\n        }\r\n    }\r\n}\r\n"],"names":["TimelineType","Utils","MathUtils","MixBlend","r","MixDirection","VertexAttachment","deform","vertexAttachment"],"mappings":";;;;;;AAYO,MAAM,SAAU,CAAA;AAAA,EASnB,WAAA,CAAY,IAAc,EAAA,SAAA,EAA4B,QAAkB,EAAA;AACpE,IAAA,IAAI,IAAQ,IAAA,IAAA;AAAM,MAAM,MAAA,IAAI,MAAM,sBAAsB,CAAA,CAAA;AACxD,IAAA,IAAI,SAAa,IAAA,IAAA;AAAM,MAAM,MAAA,IAAI,MAAM,2BAA2B,CAAA,CAAA;AAClE,IAAA,IAAA,CAAK,IAAO,GAAA,IAAA,CAAA;AACZ,IAAA,IAAA,CAAK,SAAY,GAAA,SAAA,CAAA;AACjB,IAAA,IAAA,CAAK,cAAc,EAAC,CAAA;AACpB,IAAA,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,SAAA,CAAU,MAAQ,EAAA,CAAA,EAAA;AAAK,MAAA,IAAA,CAAK,YAAY,SAAU,CAAA,CAAC,CAAE,CAAA,aAAA,EAAe,CAAI,GAAA,IAAA,CAAA;AAC5F,IAAA,IAAA,CAAK,QAAW,GAAA,QAAA,CAAA;AAAA,GACpB;AAAA,EAEA,YAAY,EAAY,EAAA;AACpB,IAAO,OAAA,IAAA,CAAK,WAAY,CAAA,EAAE,CAAK,IAAA,IAAA,CAAA;AAAA,GACnC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,KAAA,CAAM,UAAoB,QAAkB,EAAA,IAAA,EAAc,MAAe,MAAsB,EAAA,KAAA,EAAe,OAAiB,SAAyB,EAAA;AACpJ,IAAA,IAAI,QAAY,IAAA,IAAA;AAAM,MAAM,MAAA,IAAI,MAAM,0BAA0B,CAAA,CAAA;AAEhE,IAAI,IAAA,IAAA,IAAQ,IAAK,CAAA,QAAA,IAAY,CAAG,EAAA;AAC5B,MAAA,IAAA,IAAQ,IAAK,CAAA,QAAA,CAAA;AACb,MAAA,IAAI,QAAW,GAAA,CAAA;AAAG,QAAA,QAAA,IAAY,IAAK,CAAA,QAAA,CAAA;AAAA,KACvC;AAEA,IAAA,MAAM,YAAY,IAAK,CAAA,SAAA,CAAA;AAEvB,IAAA,KAAA,IAAS,IAAI,CAAG,EAAA,CAAA,GAAI,SAAU,CAAA,MAAA,EAAQ,IAAI,CAAG,EAAA,CAAA,EAAA;AAAK,MAAU,SAAA,CAAA,CAAC,EAAE,KAAM,CAAA,QAAA,EAAU,UAAU,IAAM,EAAA,MAAA,EAAQ,KAAO,EAAA,KAAA,EAAO,SAAS,CAAA,CAAA;AAAA,GAClI;AAAA;AAAA;AAAA,EAIA,OAAO,YAAA,CAAa,MAA2B,EAAA,MAAA,EAAgB,OAAO,CAAG,EAAA;AACrE,IAAA,IAAI,GAAM,GAAA,CAAA,CAAA;AACV,IAAI,IAAA,IAAA,GAAO,MAAO,CAAA,MAAA,GAAS,IAAO,GAAA,CAAA,CAAA;AAElC,IAAA,IAAI,IAAQ,IAAA,CAAA;AAAG,MAAO,OAAA,IAAA,CAAA;AACtB,IAAA,IAAI,UAAU,IAAS,KAAA,CAAA,CAAA;AAEvB,IAAA,OAAO,IAAM,EAAA;AACT,MAAA,IAAI,MAAQ,CAAA,CAAA,OAAA,GAAU,CAAK,IAAA,IAAI,CAAK,IAAA,MAAA;AAAQ,QAAA,GAAA,GAAM,OAAU,GAAA,CAAA,CAAA;AAAA;AACvD,QAAO,IAAA,GAAA,OAAA,CAAA;AACZ,MAAA,IAAI,GAAO,IAAA,IAAA;AAAM,QAAA,OAAA,CAAQ,MAAM,CAAK,IAAA,IAAA,CAAA;AACpC,MAAA,OAAA,GAAW,MAAM,IAAU,KAAA,CAAA,CAAA;AAAA,KAC/B;AAAA,GACJ;AAAA,EAEA,OAAO,YAAA,CAAa,MAA2B,EAAA,MAAA,EAAgB,IAAc,EAAA;AACzE,IAAS,KAAA,IAAA,CAAA,GAAI,GAAG,IAAO,GAAA,MAAA,CAAO,SAAS,IAAM,EAAA,CAAA,IAAK,MAAM,CAAK,IAAA,IAAA;AAAM,MAAI,IAAA,MAAA,CAAO,CAAC,CAAI,GAAA,MAAA;AAAQ,QAAO,OAAA,CAAA,CAAA;AAElG,IAAO,OAAA,CAAA,CAAA,CAAA;AAAA,GACX;AACJ,CAAA;AAsCY,IAAA,YAAA,qBAAAA,aAAL,KAAA;AACH,EAAAA,aAAA,CAAA,aAAA,CAAA,QAAA,CAAA,GAAA,CAAA,CAAA,GAAA,QAAA,CAAA;AACA,EAAAA,aAAA,CAAA,aAAA,CAAA,WAAA,CAAA,GAAA,CAAA,CAAA,GAAA,WAAA,CAAA;AACA,EAAAA,aAAA,CAAA,aAAA,CAAA,OAAA,CAAA,GAAA,CAAA,CAAA,GAAA,OAAA,CAAA;AACA,EAAAA,aAAA,CAAA,aAAA,CAAA,OAAA,CAAA,GAAA,CAAA,CAAA,GAAA,OAAA,CAAA;AACA,EAAAA,aAAA,CAAA,aAAA,CAAA,YAAA,CAAA,GAAA,CAAA,CAAA,GAAA,YAAA,CAAA;AACA,EAAAA,aAAA,CAAA,aAAA,CAAA,OAAA,CAAA,GAAA,CAAA,CAAA,GAAA,OAAA,CAAA;AACA,EAAAA,aAAA,CAAA,aAAA,CAAA,QAAA,CAAA,GAAA,CAAA,CAAA,GAAA,QAAA,CAAA;AACA,EAAAA,aAAA,CAAA,aAAA,CAAA,OAAA,CAAA,GAAA,CAAA,CAAA,GAAA,OAAA,CAAA;AACA,EAAAA,aAAA,CAAA,aAAA,CAAA,WAAA,CAAA,GAAA,CAAA,CAAA,GAAA,WAAA,CAAA;AACA,EAAAA,aAAA,CAAA,aAAA,CAAA,cAAA,CAAA,GAAA,CAAA,CAAA,GAAA,cAAA,CAAA;AACA,EAAAA,aAAA,CAAA,aAAA,CAAA,qBAAA,CAAA,GAAA,EAAA,CAAA,GAAA,qBAAA,CAAA;AACA,EAAAA,aAAA,CAAA,aAAA,CAAA,wBAAA,CAAA,GAAA,EAAA,CAAA,GAAA,wBAAA,CAAA;AACA,EAAAA,aAAA,CAAA,aAAA,CAAA,uBAAA,CAAA,GAAA,EAAA,CAAA,GAAA,uBAAA,CAAA;AACA,EAAAA,aAAA,CAAA,aAAA,CAAA,mBAAA,CAAA,GAAA,EAAA,CAAA,GAAA,mBAAA,CAAA;AACA,EAAAA,aAAA,CAAA,aAAA,CAAA,UAAA,CAAA,GAAA,EAAA,CAAA,GAAA,UAAA,CAAA;AAfQ,EAAAA,OAAAA,aAAAA,CAAAA;AAAA,CAAA,EAAA,YAAA,IAAA,EAAA,EAAA;AAsBL,MAAe,iBAAf,MAAiD;AAAA,EAWpD,YAAY,UAAoB,EAAA;AANhC,IAAA,IAAA,CAAA,SAAA,GAA0F,EAAC,CAAA;AAOvF,IAAA,IAAI,UAAc,IAAA,CAAA;AAAG,MAAM,MAAA,IAAI,KAAM,CAAA,CAAA,wBAAA,EAA2B,UAAY,CAAA,CAAA,CAAA,CAAA;AAC5E,IAAA,IAAA,CAAK,SAASC,UAAM,CAAA,aAAA,CAAA,CAAe,UAAa,GAAA,CAAA,IAAK,eAAc,WAAW,CAAA,CAAA;AAAA,GAClF;AAAA;AAAA,EAGA,aAAgB,GAAA;AACZ,IAAA,OAAO,IAAK,CAAA,MAAA,CAAO,MAAS,GAAA,cAAA,CAAc,WAAc,GAAA,CAAA,CAAA;AAAA,GAC5D;AAAA;AAAA,EAGA,UAAU,UAAoB,EAAA;AAC1B,IAAA,IAAA,CAAK,MAAO,CAAA,UAAA,GAAa,cAAc,CAAA,WAAW,IAAI,cAAc,CAAA,MAAA,CAAA;AAAA,GACxE;AAAA;AAAA,EAGA,WAAW,UAAoB,EAAA;AAC3B,IAAA,IAAA,CAAK,MAAO,CAAA,UAAA,GAAa,cAAc,CAAA,WAAW,IAAI,cAAc,CAAA,OAAA,CAAA;AAAA,GACxE;AAAA;AAAA;AAAA,EAIA,aAAa,UAA4B,EAAA;AACrC,IAAM,MAAA,KAAA,GAAQ,aAAa,cAAc,CAAA,WAAA,CAAA;AAEzC,IAAI,IAAA,KAAA,IAAS,KAAK,MAAO,CAAA,MAAA;AAAQ,MAAA,OAAO,cAAc,CAAA,MAAA,CAAA;AACtD,IAAM,MAAA,IAAA,GAAO,IAAK,CAAA,MAAA,CAAO,KAAK,CAAA,CAAA;AAE9B,IAAA,IAAI,QAAQ,cAAc,CAAA,MAAA;AAAQ,MAAA,OAAO,cAAc,CAAA,MAAA,CAAA;AACvD,IAAA,IAAI,QAAQ,cAAc,CAAA,OAAA;AAAS,MAAA,OAAO,cAAc,CAAA,OAAA,CAAA;AAExD,IAAA,OAAO,cAAc,CAAA,MAAA,CAAA;AAAA,GACzB;AAAA;AAAA;AAAA;AAAA,EAKA,QAAS,CAAA,UAAA,EAAoB,GAAa,EAAA,GAAA,EAAa,KAAa,GAAa,EAAA;AAC7E,IAAK,IAAA,CAAA,SAAA,CAAU,KAAK,EAAE,UAAA,EAAY,KAAK,GAAK,EAAA,GAAA,EAAK,KAAK,CAAA,CAAA;AACtD,IAAA,MAAM,IAAQ,GAAA,CAAA,CAAC,GAAM,GAAA,CAAA,GAAI,GAAO,IAAA,IAAA,CAAA;AAChC,IAAA,MAAM,IAAQ,GAAA,CAAA,CAAC,GAAM,GAAA,CAAA,GAAI,GAAO,IAAA,IAAA,CAAA;AAChC,IAAA,MAAM,KAAU,GAAA,CAAA,CAAA,GAAA,GAAM,GAAO,IAAA,CAAA,GAAI,CAAK,IAAA,IAAA,CAAA;AACtC,IAAA,MAAM,KAAU,GAAA,CAAA,CAAA,GAAA,GAAM,GAAO,IAAA,CAAA,GAAI,CAAK,IAAA,IAAA,CAAA;AACtC,IAAI,IAAA,IAAA,GAAO,OAAO,CAAI,GAAA,KAAA,CAAA;AACtB,IAAI,IAAA,IAAA,GAAO,OAAO,CAAI,GAAA,KAAA,CAAA;AACtB,IAAA,IAAI,GAAM,GAAA,GAAA,GAAM,GAAM,GAAA,IAAA,GAAO,KAAQ,GAAA,UAAA,CAAA;AACrC,IAAA,IAAI,GAAM,GAAA,GAAA,GAAM,GAAM,GAAA,IAAA,GAAO,KAAQ,GAAA,UAAA,CAAA;AAErC,IAAI,IAAA,CAAA,GAAI,aAAa,cAAc,CAAA,WAAA,CAAA;AACnC,IAAA,MAAM,SAAS,IAAK,CAAA,MAAA,CAAA;AAEpB,IAAO,MAAA,CAAA,CAAA,EAAG,IAAI,cAAc,CAAA,MAAA,CAAA;AAE5B,IAAA,IAAI,CAAI,GAAA,GAAA,CAAA;AACR,IAAA,IAAI,CAAI,GAAA,GAAA,CAAA;AAER,IAAS,KAAA,IAAA,CAAA,GAAI,IAAI,cAAc,CAAA,WAAA,GAAc,GAAG,CAAI,GAAA,CAAA,EAAG,KAAK,CAAG,EAAA;AAC3D,MAAA,MAAA,CAAO,CAAC,CAAI,GAAA,CAAA,CAAA;AACZ,MAAO,MAAA,CAAA,CAAA,GAAI,CAAC,CAAI,GAAA,CAAA,CAAA;AAChB,MAAO,GAAA,IAAA,IAAA,CAAA;AACP,MAAO,GAAA,IAAA,IAAA,CAAA;AACP,MAAQ,IAAA,IAAA,KAAA,CAAA;AACR,MAAQ,IAAA,IAAA,KAAA,CAAA;AACR,MAAK,CAAA,IAAA,GAAA,CAAA;AACL,MAAK,CAAA,IAAA,GAAA,CAAA;AAAA,KACT;AAAA,GACJ;AAAA;AAAA,EAGA,eAAA,CAAgB,YAAoB,OAAiB,EAAA;AACjD,IAAA,OAAA,GAAUC,cAAU,CAAA,KAAA,CAAM,OAAS,EAAA,CAAA,EAAG,CAAC,CAAA,CAAA;AACvC,IAAA,MAAM,SAAS,IAAK,CAAA,MAAA,CAAA;AACpB,IAAI,IAAA,CAAA,GAAI,aAAa,cAAc,CAAA,WAAA,CAAA;AACnC,IAAM,MAAA,IAAA,GAAO,OAAO,CAAC,CAAA,CAAA;AAErB,IAAA,IAAI,QAAQ,cAAc,CAAA,MAAA;AAAQ,MAAO,OAAA,OAAA,CAAA;AACzC,IAAA,IAAI,QAAQ,cAAc,CAAA,OAAA;AAAS,MAAO,OAAA,CAAA,CAAA;AAC1C,IAAA,CAAA,EAAA,CAAA;AACA,IAAA,IAAI,CAAI,GAAA,CAAA,CAAA;AAER,IAAS,KAAA,IAAA,KAAA,GAAQ,CAAG,EAAA,CAAA,GAAI,CAAI,GAAA,cAAA,CAAc,cAAc,CAAG,EAAA,CAAA,GAAI,CAAG,EAAA,CAAA,IAAK,CAAG,EAAA;AACtE,MAAA,CAAA,GAAI,OAAO,CAAC,CAAA,CAAA;AACZ,MAAA,IAAI,KAAK,OAAS,EAAA;AACd,QAAI,IAAA,KAAA,CAAA;AACJ,QAAI,IAAA,KAAA,CAAA;AAEJ,QAAA,IAAI,KAAK,KAAO,EAAA;AACZ,UAAQ,KAAA,GAAA,CAAA,CAAA;AACR,UAAQ,KAAA,GAAA,CAAA,CAAA;AAAA,SACL,MAAA;AACH,UAAQ,KAAA,GAAA,MAAA,CAAO,IAAI,CAAC,CAAA,CAAA;AACpB,UAAQ,KAAA,GAAA,MAAA,CAAO,IAAI,CAAC,CAAA,CAAA;AAAA,SACxB;AAEA,QAAO,OAAA,KAAA,GAAA,CAAU,OAAO,CAAI,GAAA,CAAC,IAAI,KAAU,KAAA,OAAA,GAAU,UAAW,CAAI,GAAA,KAAA,CAAA,CAAA;AAAA,OACxE;AAAA,KACJ;AACA,IAAM,MAAA,CAAA,GAAI,MAAO,CAAA,CAAA,GAAI,CAAC,CAAA,CAAA;AAEtB,IAAA,OAAO,CAAM,GAAA,CAAA,CAAA,GAAI,CAAM,KAAA,OAAA,GAAU,MAAO,CAAI,GAAA,CAAA,CAAA,CAAA;AAAA,GAChD;AAGJ,CAAA,CAAA;AAlHO,IAAe,aAAf,GAAA,eAAA;AAAe,aAAA,CACX,MAAS,GAAA,CAAA,CAAA;AADE,aAAA,CAEX,OAAU,GAAA,CAAA,CAAA;AAFC,aAAA,CAGX,MAAS,GAAA,CAAA,CAAA;AAHE,aAIX,CAAA,WAAA,GAAc,KAAK,CAAI,GAAA,CAAA,CAAA;AAoH3B,MAAM,eAAA,GAAN,cAA6B,aAAc,CAAA;AAAA;AAAA,EAc9C,YAAY,UAAoB,EAAA;AAC5B,IAAA,KAAA,CAAM,UAAU,CAAA,CAAA;AATpB,IAAA,IAAA,CAAA,IAAA,GAAgE,EAAC,CAAA;AAU7D,IAAA,IAAA,CAAK,MAAS,GAAAD,UAAA,CAAM,aAAc,CAAA,UAAA,IAAc,CAAC,CAAA,CAAA;AAAA,GACrD;AAAA,EAEA,aAAgB,GAAA;AACZ,IAAQ,OAAA,CAAA,CAAA,iBAAuB,MAAM,IAAK,CAAA,SAAA,CAAA;AAAA,GAC9C;AAAA;AAAA,EAGA,QAAA,CAAS,UAAoB,EAAA,IAAA,EAAc,OAAiB,EAAA;AACxD,IAAA,IAAA,CAAK,KAAK,IAAK,CAAA,EAAE,UAAY,EAAA,IAAA,EAAM,SAAS,CAAA,CAAA;AAC5C,IAAe,UAAA,KAAA,CAAA,CAAA;AACf,IAAK,IAAA,CAAA,MAAA,CAAO,UAAU,CAAI,GAAA,IAAA,CAAA;AAC1B,IAAA,IAAA,CAAK,MAAO,CAAA,UAAA,GAAa,eAAe,CAAA,QAAQ,CAAI,GAAA,OAAA,CAAA;AAAA,GACxD;AAAA,EAEA,MAAM,QAAoB,EAAA,QAAA,EAAkB,MAAc,MAAsB,EAAA,KAAA,EAAe,OAAiB,SAAyB,EAAA;AACrI,IAAA,MAAM,SAAS,IAAK,CAAA,MAAA,CAAA;AAEpB,IAAA,MAAM,IAAO,GAAA,QAAA,CAAS,KAAM,CAAA,IAAA,CAAK,SAAS,CAAA,CAAA;AAE1C,IAAA,IAAI,CAAC,IAAK,CAAA,MAAA;AAAQ,MAAA,OAAA;AAClB,IAAI,IAAA,IAAA,GAAO,MAAO,CAAA,CAAC,CAAG,EAAA;AAClB,MAAA,QAAQ,KAAO;AAAA,QACX,KAAKE,aAAS,CAAA,KAAA;AACV,UAAK,IAAA,CAAA,QAAA,GAAW,KAAK,IAAK,CAAA,QAAA,CAAA;AAE1B,UAAA,OAAA;AAAA,QACJ,KAAKA,aAAS,CAAA,KAAA;AACV,UAAA,MAAMC,EAAI,GAAA,IAAA,CAAK,IAAK,CAAA,QAAA,GAAW,IAAK,CAAA,QAAA,CAAA;AAEpC,UAAA,IAAA,CAAK,aAAaA,EAAK,GAAA,CAAA,KAAA,IAAU,qBAAqBA,EAAI,GAAA,GAAA,GAAO,MAAM,GAAO,IAAA,KAAA,CAAA;AAAA,OACtF;AAEA,MAAA,OAAA;AAAA,KACJ;AAEA,IAAA,IAAI,QAAQ,MAAO,CAAA,MAAA,CAAO,MAAS,GAAA,eAAA,CAAe,OAAO,CAAG,EAAA;AAExD,MAAA,IAAIA,EAAI,GAAA,MAAA,CAAO,MAAO,CAAA,MAAA,GAAS,gBAAe,aAAa,CAAA,CAAA;AAE3D,MAAA,QAAQ,KAAO;AAAA,QACX,KAAKD,aAAS,CAAA,KAAA;AACV,UAAA,IAAA,CAAK,QAAW,GAAA,IAAA,CAAK,IAAK,CAAA,QAAA,GAAWC,EAAI,GAAA,KAAA,CAAA;AACzC,UAAA,MAAA;AAAA,QACJ,KAAKD,aAAS,CAAA,KAAA,CAAA;AAAA,QACd,KAAKA,aAAS,CAAA,OAAA;AACV,UAAAC,EAAK,IAAA,IAAA,CAAK,IAAK,CAAA,QAAA,GAAW,IAAK,CAAA,QAAA,CAAA;AAC/B,UAAAA,EAAM,IAAA,CAAA,KAAA,IAAU,kBAAqBA,GAAAA,EAAAA,GAAI,MAAO,CAAM,CAAA,IAAA,GAAA,CAAA;AAAA,QAC1D,KAAKD,aAAS,CAAA,GAAA;AACV,UAAA,IAAA,CAAK,YAAYC,EAAI,GAAA,KAAA,CAAA;AAAA,OAC7B;AAEA,MAAA,OAAA;AAAA,KACJ;AAGA,IAAA,MAAM,QAAQ,SAAU,CAAA,YAAA,CAAa,MAAQ,EAAA,IAAA,EAAM,gBAAe,OAAO,CAAA,CAAA;AACzE,IAAA,MAAM,YAAe,GAAA,MAAA,CAAO,KAAQ,GAAA,eAAA,CAAe,aAAa,CAAA,CAAA;AAChE,IAAM,MAAA,SAAA,GAAY,OAAO,KAAK,CAAA,CAAA;AAC9B,IAAA,MAAM,OAAU,GAAA,IAAA,CAAK,eAAiB,CAAA,CAAA,KAAA,IAAS,KAAK,CAAG,EAAA,CAAA,GAAA,CAAK,IAAO,GAAA,SAAA,KAAc,MAAO,CAAA,KAAA,GAAQ,eAAe,CAAA,SAAS,IAAI,SAAU,CAAA,CAAA,CAAA;AAEtI,IAAA,IAAI,CAAI,GAAA,MAAA,CAAO,KAAQ,GAAA,eAAA,CAAe,QAAQ,CAAI,GAAA,YAAA,CAAA;AAElD,IAAA,CAAA,GAAI,gBAAgB,CAAK,GAAA,CAAA,KAAA,IAAU,qBAAqB,CAAI,GAAA,GAAA,GAAO,MAAM,GAAO,IAAA,OAAA,CAAA;AAChF,IAAA,QAAQ,KAAO;AAAA,MACX,KAAKD,aAAS,CAAA,KAAA;AACV,QAAK,IAAA,CAAA,QAAA,GAAW,IAAK,CAAA,IAAA,CAAK,QAAY,GAAA,CAAA,CAAA,GAAA,CAAK,SAAU,kBAAqB,GAAA,CAAA,GAAI,GAAO,GAAA,CAAA,CAAA,IAAM,GAAO,IAAA,KAAA,CAAA;AAClG,QAAA,MAAA;AAAA,MACJ,KAAKA,aAAS,CAAA,KAAA,CAAA;AAAA,MACd,KAAKA,aAAS,CAAA,OAAA;AACV,QAAK,CAAA,IAAA,IAAA,CAAK,IAAK,CAAA,QAAA,GAAW,IAAK,CAAA,QAAA,CAAA;AAAA,MACnC,KAAKA,aAAS,CAAA,GAAA;AACV,QAAA,IAAA,CAAK,aAAa,CAAK,GAAA,CAAA,KAAA,IAAU,qBAAqB,CAAI,GAAA,GAAA,GAAO,MAAM,GAAO,IAAA,KAAA,CAAA;AAAA,KACtF;AAAA,GACJ;AACJ,CAAA,CAAA;AA3FO,IAAM,cAAN,GAAA,gBAAA;AAAM,cAAA,CACF,OAAU,GAAA,CAAA,CAAA;AADR,cAAA,CAEF,SAAY,GAAA,CAAA,CAAA,CAAA;AAFV,cAAA,CAGF,aAAgB,GAAA,CAAA,CAAA,CAAA;AAHd,cAAA,CAIF,QAAW,GAAA,CAAA,CAAA;AA6Ff,MAAM,kBAAA,GAAN,cAAgC,aAAc,CAAA;AAAA;AAAA,EAgBjD,YAAY,UAAoB,EAAA;AAC5B,IAAA,KAAA,CAAM,UAAU,CAAA,CAAA;AATpB,IAAA,IAAA,CAAA,IAAA,GAAqE,EAAC,CAAA;AAUlE,IAAA,IAAA,CAAK,MAAS,GAAAF,UAAA,CAAM,aAAc,CAAA,UAAA,GAAa,mBAAkB,OAAO,CAAA,CAAA;AAAA,GAC5E;AAAA,EAEA,aAAgB,GAAA;AACZ,IAAQ,OAAA,CAAA,CAAA,oBAA0B,MAAM,IAAK,CAAA,SAAA,CAAA;AAAA,GACjD;AAAA;AAAA,EAGA,QAAS,CAAA,UAAA,EAAoB,IAAc,EAAA,CAAA,EAAW,CAAW,EAAA;AAC7D,IAAA,IAAA,CAAK,KAAK,IAAK,CAAA,EAAE,YAAY,IAAM,EAAA,CAAA,EAAG,GAAG,CAAA,CAAA;AACzC,IAAA,UAAA,IAAc,kBAAkB,CAAA,OAAA,CAAA;AAChC,IAAK,IAAA,CAAA,MAAA,CAAO,UAAU,CAAI,GAAA,IAAA,CAAA;AAC1B,IAAA,IAAA,CAAK,MAAO,CAAA,UAAA,GAAa,kBAAkB,CAAA,CAAC,CAAI,GAAA,CAAA,CAAA;AAChD,IAAA,IAAA,CAAK,MAAO,CAAA,UAAA,GAAa,kBAAkB,CAAA,CAAC,CAAI,GAAA,CAAA,CAAA;AAAA,GACpD;AAAA,EAEA,MAAM,QAAoB,EAAA,QAAA,EAAkB,MAAc,MAAsB,EAAA,KAAA,EAAe,OAAiB,SAAyB,EAAA;AACrI,IAAA,MAAM,SAAS,IAAK,CAAA,MAAA,CAAA;AAEpB,IAAA,MAAM,IAAO,GAAA,QAAA,CAAS,KAAM,CAAA,IAAA,CAAK,SAAS,CAAA,CAAA;AAE1C,IAAA,IAAI,CAAC,IAAK,CAAA,MAAA;AAAQ,MAAA,OAAA;AAClB,IAAI,IAAA,IAAA,GAAO,MAAO,CAAA,CAAC,CAAG,EAAA;AAClB,MAAA,QAAQ,KAAO;AAAA,QACX,KAAKE,aAAS,CAAA,KAAA;AACV,UAAK,IAAA,CAAA,CAAA,GAAI,KAAK,IAAK,CAAA,CAAA,CAAA;AACnB,UAAK,IAAA,CAAA,CAAA,GAAI,KAAK,IAAK,CAAA,CAAA,CAAA;AAEnB,UAAA,OAAA;AAAA,QACJ,KAAKA,aAAS,CAAA,KAAA;AACV,UAAA,IAAA,CAAK,CAAM,IAAA,CAAA,IAAA,CAAK,IAAK,CAAA,CAAA,GAAI,KAAK,CAAK,IAAA,KAAA,CAAA;AACnC,UAAA,IAAA,CAAK,CAAM,IAAA,CAAA,IAAA,CAAK,IAAK,CAAA,CAAA,GAAI,KAAK,CAAK,IAAA,KAAA,CAAA;AAAA,OAC3C;AAEA,MAAA,OAAA;AAAA,KACJ;AAEA,IAAA,IAAI,CAAI,GAAA,CAAA,CAAA;AACR,IAAA,IAAI,CAAI,GAAA,CAAA,CAAA;AAER,IAAA,IAAI,QAAQ,MAAO,CAAA,MAAA,CAAO,MAAS,GAAA,kBAAA,CAAkB,OAAO,CAAG,EAAA;AAE3D,MAAA,CAAA,GAAI,MAAO,CAAA,MAAA,CAAO,MAAS,GAAA,kBAAA,CAAkB,MAAM,CAAA,CAAA;AACnD,MAAA,CAAA,GAAI,MAAO,CAAA,MAAA,CAAO,MAAS,GAAA,kBAAA,CAAkB,MAAM,CAAA,CAAA;AAAA,KAChD,MAAA;AAEH,MAAA,MAAM,QAAQ,SAAU,CAAA,YAAA,CAAa,MAAQ,EAAA,IAAA,EAAM,mBAAkB,OAAO,CAAA,CAAA;AAE5E,MAAI,CAAA,GAAA,MAAA,CAAO,KAAQ,GAAA,kBAAA,CAAkB,MAAM,CAAA,CAAA;AAC3C,MAAI,CAAA,GAAA,MAAA,CAAO,KAAQ,GAAA,kBAAA,CAAkB,MAAM,CAAA,CAAA;AAC3C,MAAM,MAAA,SAAA,GAAY,OAAO,KAAK,CAAA,CAAA;AAC9B,MAAA,MAAM,OAAU,GAAA,IAAA,CAAK,eAAgB,CAAA,KAAA,GAAQ,mBAAkB,OAAU,GAAA,CAAA,EAAG,CAAK,GAAA,CAAA,IAAA,GAAO,cAAc,MAAO,CAAA,KAAA,GAAQ,kBAAkB,CAAA,SAAS,IAAI,SAAU,CAAA,CAAA,CAAA;AAE9J,MAAA,CAAA,IAAA,CAAM,MAAO,CAAA,KAAA,GAAQ,kBAAkB,CAAA,CAAC,IAAI,CAAK,IAAA,OAAA,CAAA;AACjD,MAAA,CAAA,IAAA,CAAM,MAAO,CAAA,KAAA,GAAQ,kBAAkB,CAAA,CAAC,IAAI,CAAK,IAAA,OAAA,CAAA;AAAA,KACrD;AACA,IAAA,QAAQ,KAAO;AAAA,MACX,KAAKA,aAAS,CAAA,KAAA;AACV,QAAA,IAAA,CAAK,CAAI,GAAA,IAAA,CAAK,IAAK,CAAA,CAAA,GAAI,CAAI,GAAA,KAAA,CAAA;AAC3B,QAAA,IAAA,CAAK,CAAI,GAAA,IAAA,CAAK,IAAK,CAAA,CAAA,GAAI,CAAI,GAAA,KAAA,CAAA;AAC3B,QAAA,MAAA;AAAA,MACJ,KAAKA,aAAS,CAAA,KAAA,CAAA;AAAA,MACd,KAAKA,aAAS,CAAA,OAAA;AACV,QAAA,IAAA,CAAK,MAAM,IAAK,CAAA,IAAA,CAAK,CAAI,GAAA,CAAA,GAAI,KAAK,CAAK,IAAA,KAAA,CAAA;AACvC,QAAA,IAAA,CAAK,MAAM,IAAK,CAAA,IAAA,CAAK,CAAI,GAAA,CAAA,GAAI,KAAK,CAAK,IAAA,KAAA,CAAA;AACvC,QAAA,MAAA;AAAA,MACJ,KAAKA,aAAS,CAAA,GAAA;AACV,QAAA,IAAA,CAAK,KAAK,CAAI,GAAA,KAAA,CAAA;AACd,QAAA,IAAA,CAAK,KAAK,CAAI,GAAA,KAAA,CAAA;AAAA,KACtB;AAAA,GACJ;AACJ,CAAA,CAAA;AAzFO,IAAM,iBAAN,GAAA,mBAAA;AAAM,iBAAA,CACF,OAAU,GAAA,CAAA,CAAA;AADR,iBAAA,CAEF,SAAY,GAAA,CAAA,CAAA,CAAA;AAFV,iBAAA,CAGF,MAAS,GAAA,CAAA,CAAA,CAAA;AAHP,iBAAA,CAIF,MAAS,GAAA,CAAA,CAAA,CAAA;AAJP,iBAAA,CAKF,CAAI,GAAA,CAAA,CAAA;AALF,iBAAA,CAMF,CAAI,GAAA,CAAA,CAAA;AAyFR,MAAM,sBAAsB,iBAAkB,CAAA;AAAA,EACjD,YAAY,UAAoB,EAAA;AAC5B,IAAA,KAAA,CAAM,UAAU,CAAA,CAAA;AAAA,GACpB;AAAA,EAEA,aAAgB,GAAA;AACZ,IAAQ,OAAA,CAAA,CAAA,gBAAsB,MAAM,IAAK,CAAA,SAAA,CAAA;AAAA,GAC7C;AAAA,EAEA,MAAM,QAAoB,EAAA,QAAA,EAAkB,MAAc,MAAsB,EAAA,KAAA,EAAe,OAAiB,SAAyB,EAAA;AACrI,IAAA,MAAM,SAAS,IAAK,CAAA,MAAA,CAAA;AAEpB,IAAA,MAAM,IAAO,GAAA,QAAA,CAAS,KAAM,CAAA,IAAA,CAAK,SAAS,CAAA,CAAA;AAE1C,IAAA,IAAI,CAAC,IAAK,CAAA,MAAA;AAAQ,MAAA,OAAA;AAClB,IAAI,IAAA,IAAA,GAAO,MAAO,CAAA,CAAC,CAAG,EAAA;AAClB,MAAA,QAAQ,KAAO;AAAA,QACX,KAAKA,aAAS,CAAA,KAAA;AACV,UAAK,IAAA,CAAA,MAAA,GAAS,KAAK,IAAK,CAAA,MAAA,CAAA;AACxB,UAAK,IAAA,CAAA,MAAA,GAAS,KAAK,IAAK,CAAA,MAAA,CAAA;AAExB,UAAA,OAAA;AAAA,QACJ,KAAKA,aAAS,CAAA,KAAA;AACV,UAAA,IAAA,CAAK,MAAW,IAAA,CAAA,IAAA,CAAK,IAAK,CAAA,MAAA,GAAS,KAAK,MAAU,IAAA,KAAA,CAAA;AAClD,UAAA,IAAA,CAAK,MAAW,IAAA,CAAA,IAAA,CAAK,IAAK,CAAA,MAAA,GAAS,KAAK,MAAU,IAAA,KAAA,CAAA;AAAA,OAC1D;AAEA,MAAA,OAAA;AAAA,KACJ;AAEA,IAAA,IAAI,CAAI,GAAA,CAAA,CAAA;AACR,IAAA,IAAI,CAAI,GAAA,CAAA,CAAA;AAER,IAAA,IAAI,QAAQ,MAAO,CAAA,MAAA,CAAO,MAAS,GAAA,aAAA,CAAc,OAAO,CAAG,EAAA;AAEvD,MAAA,CAAA,GAAI,OAAO,MAAO,CAAA,MAAA,GAAS,cAAc,MAAM,CAAA,GAAI,KAAK,IAAK,CAAA,MAAA,CAAA;AAC7D,MAAA,CAAA,GAAI,OAAO,MAAO,CAAA,MAAA,GAAS,cAAc,MAAM,CAAA,GAAI,KAAK,IAAK,CAAA,MAAA,CAAA;AAAA,KAC1D,MAAA;AAEH,MAAA,MAAM,QAAQ,SAAU,CAAA,YAAA,CAAa,MAAQ,EAAA,IAAA,EAAM,cAAc,OAAO,CAAA,CAAA;AAExE,MAAI,CAAA,GAAA,MAAA,CAAO,KAAQ,GAAA,aAAA,CAAc,MAAM,CAAA,CAAA;AACvC,MAAI,CAAA,GAAA,MAAA,CAAO,KAAQ,GAAA,aAAA,CAAc,MAAM,CAAA,CAAA;AACvC,MAAM,MAAA,SAAA,GAAY,OAAO,KAAK,CAAA,CAAA;AAC9B,MAAA,MAAM,OAAU,GAAA,IAAA,CAAK,eAAgB,CAAA,KAAA,GAAQ,cAAc,OAAU,GAAA,CAAA,EAAG,CAAK,GAAA,CAAA,IAAA,GAAO,cAAc,MAAO,CAAA,KAAA,GAAQ,aAAc,CAAA,SAAS,IAAI,SAAU,CAAA,CAAA,CAAA;AAEtJ,MAAK,CAAA,GAAA,CAAA,CAAA,GAAA,CAAK,OAAO,KAAQ,GAAA,aAAA,CAAc,CAAC,CAAI,GAAA,CAAA,IAAK,OAAW,IAAA,IAAA,CAAK,IAAK,CAAA,MAAA,CAAA;AACtE,MAAK,CAAA,GAAA,CAAA,CAAA,GAAA,CAAK,OAAO,KAAQ,GAAA,aAAA,CAAc,CAAC,CAAI,GAAA,CAAA,IAAK,OAAW,IAAA,IAAA,CAAK,IAAK,CAAA,MAAA,CAAA;AAAA,KAC1E;AACA,IAAA,IAAI,SAAS,CAAG,EAAA;AACZ,MAAI,IAAA,KAAA,IAASA,cAAS,GAAK,EAAA;AACvB,QAAK,IAAA,CAAA,MAAA,IAAU,CAAI,GAAA,IAAA,CAAK,IAAK,CAAA,MAAA,CAAA;AAC7B,QAAK,IAAA,CAAA,MAAA,IAAU,CAAI,GAAA,IAAA,CAAK,IAAK,CAAA,MAAA,CAAA;AAAA,OAC1B,MAAA;AACH,QAAA,IAAA,CAAK,MAAS,GAAA,CAAA,CAAA;AACd,QAAA,IAAA,CAAK,MAAS,GAAA,CAAA,CAAA;AAAA,OAClB;AAAA,KACG,MAAA;AACH,MAAA,IAAI,EAAK,GAAA,CAAA,CAAA;AACT,MAAA,IAAI,EAAK,GAAA,CAAA,CAAA;AAET,MAAI,IAAA,SAAA,IAAaE,kBAAa,MAAQ,EAAA;AAClC,QAAA,QAAQ,KAAO;AAAA,UACX,KAAKF,aAAS,CAAA,KAAA;AACV,YAAA,EAAA,GAAK,KAAK,IAAK,CAAA,MAAA,CAAA;AACf,YAAA,EAAA,GAAK,KAAK,IAAK,CAAA,MAAA,CAAA;AACf,YAAK,IAAA,CAAA,MAAA,GAAS,EAAM,GAAA,CAAA,IAAA,CAAK,GAAI,CAAA,CAAC,IAAID,cAAU,CAAA,MAAA,CAAO,EAAE,CAAA,GAAI,EAAM,IAAA,KAAA,CAAA;AAC/D,YAAK,IAAA,CAAA,MAAA,GAAS,EAAM,GAAA,CAAA,IAAA,CAAK,GAAI,CAAA,CAAC,IAAIA,cAAU,CAAA,MAAA,CAAO,EAAE,CAAA,GAAI,EAAM,IAAA,KAAA,CAAA;AAC/D,YAAA,MAAA;AAAA,UACJ,KAAKC,aAAS,CAAA,KAAA,CAAA;AAAA,UACd,KAAKA,aAAS,CAAA,OAAA;AACV,YAAA,EAAA,GAAK,IAAK,CAAA,MAAA,CAAA;AACV,YAAA,EAAA,GAAK,IAAK,CAAA,MAAA,CAAA;AACV,YAAK,IAAA,CAAA,MAAA,GAAS,EAAM,GAAA,CAAA,IAAA,CAAK,GAAI,CAAA,CAAC,IAAID,cAAU,CAAA,MAAA,CAAO,EAAE,CAAA,GAAI,EAAM,IAAA,KAAA,CAAA;AAC/D,YAAK,IAAA,CAAA,MAAA,GAAS,EAAM,GAAA,CAAA,IAAA,CAAK,GAAI,CAAA,CAAC,IAAIA,cAAU,CAAA,MAAA,CAAO,EAAE,CAAA,GAAI,EAAM,IAAA,KAAA,CAAA;AAC/D,YAAA,MAAA;AAAA,UACJ,KAAKC,aAAS,CAAA,GAAA;AACV,YAAA,EAAA,GAAK,IAAK,CAAA,MAAA,CAAA;AACV,YAAA,EAAA,GAAK,IAAK,CAAA,MAAA,CAAA;AACV,YAAA,IAAA,CAAK,MAAS,GAAA,EAAA,GAAA,CAAM,IAAK,CAAA,GAAA,CAAI,CAAC,CAAA,GAAID,cAAU,CAAA,MAAA,CAAO,EAAE,CAAA,GAAI,IAAK,CAAA,IAAA,CAAK,MAAU,IAAA,KAAA,CAAA;AAC7E,YAAA,IAAA,CAAK,MAAS,GAAA,EAAA,GAAA,CAAM,IAAK,CAAA,GAAA,CAAI,CAAC,CAAA,GAAIA,cAAU,CAAA,MAAA,CAAO,EAAE,CAAA,GAAI,IAAK,CAAA,IAAA,CAAK,MAAU,IAAA,KAAA,CAAA;AAAA,SACrF;AAAA,OACG,MAAA;AACH,QAAA,QAAQ,KAAO;AAAA,UACX,KAAKC,aAAS,CAAA,KAAA;AACV,YAAK,EAAA,GAAA,IAAA,CAAK,IAAI,IAAK,CAAA,IAAA,CAAK,MAAM,CAAI,GAAAD,cAAA,CAAU,OAAO,CAAC,CAAA,CAAA;AACpD,YAAK,EAAA,GAAA,IAAA,CAAK,IAAI,IAAK,CAAA,IAAA,CAAK,MAAM,CAAI,GAAAA,cAAA,CAAU,OAAO,CAAC,CAAA,CAAA;AACpD,YAAK,IAAA,CAAA,MAAA,GAAS,EAAM,GAAA,CAAA,CAAA,GAAI,EAAM,IAAA,KAAA,CAAA;AAC9B,YAAK,IAAA,CAAA,MAAA,GAAS,EAAM,GAAA,CAAA,CAAA,GAAI,EAAM,IAAA,KAAA,CAAA;AAC9B,YAAA,MAAA;AAAA,UACJ,KAAKC,aAAS,CAAA,KAAA,CAAA;AAAA,UACd,KAAKA,aAAS,CAAA,OAAA;AACV,YAAA,EAAA,GAAK,KAAK,GAAI,CAAA,IAAA,CAAK,MAAM,CAAI,GAAAD,cAAA,CAAU,OAAO,CAAC,CAAA,CAAA;AAC/C,YAAA,EAAA,GAAK,KAAK,GAAI,CAAA,IAAA,CAAK,MAAM,CAAI,GAAAA,cAAA,CAAU,OAAO,CAAC,CAAA,CAAA;AAC/C,YAAK,IAAA,CAAA,MAAA,GAAS,EAAM,GAAA,CAAA,CAAA,GAAI,EAAM,IAAA,KAAA,CAAA;AAC9B,YAAK,IAAA,CAAA,MAAA,GAAS,EAAM,GAAA,CAAA,CAAA,GAAI,EAAM,IAAA,KAAA,CAAA;AAC9B,YAAA,MAAA;AAAA,UACJ,KAAKC,aAAS,CAAA,GAAA;AACV,YAAK,EAAA,GAAAD,cAAA,CAAU,OAAO,CAAC,CAAA,CAAA;AACvB,YAAK,EAAA,GAAAA,cAAA,CAAU,OAAO,CAAC,CAAA,CAAA;AACvB,YAAA,IAAA,CAAK,MAAS,GAAA,IAAA,CAAK,GAAI,CAAA,IAAA,CAAK,MAAM,CAAI,GAAA,EAAA,GAAA,CAAM,CAAI,GAAA,IAAA,CAAK,GAAI,CAAA,IAAA,CAAK,IAAK,CAAA,MAAM,IAAI,EAAM,IAAA,KAAA,CAAA;AACnF,YAAA,IAAA,CAAK,MAAS,GAAA,IAAA,CAAK,GAAI,CAAA,IAAA,CAAK,MAAM,CAAI,GAAA,EAAA,GAAA,CAAM,CAAI,GAAA,IAAA,CAAK,GAAI,CAAA,IAAA,CAAK,IAAK,CAAA,MAAM,IAAI,EAAM,IAAA,KAAA,CAAA;AAAA,SAC3F;AAAA,OACJ;AAAA,KACJ;AAAA,GACJ;AACJ,CAAA;AAMO,MAAM,sBAAsB,iBAAkB,CAAA;AAAA,EACjD,YAAY,UAAoB,EAAA;AAC5B,IAAA,KAAA,CAAM,UAAU,CAAA,CAAA;AAAA,GACpB;AAAA,EAEA,aAAgB,GAAA;AACZ,IAAQ,OAAA,CAAA,CAAA,gBAAsB,MAAM,IAAK,CAAA,SAAA,CAAA;AAAA,GAC7C;AAAA,EAEA,MAAM,QAAoB,EAAA,QAAA,EAAkB,MAAc,MAAsB,EAAA,KAAA,EAAe,OAAiB,SAAyB,EAAA;AACrI,IAAA,MAAM,SAAS,IAAK,CAAA,MAAA,CAAA;AAEpB,IAAA,MAAM,IAAO,GAAA,QAAA,CAAS,KAAM,CAAA,IAAA,CAAK,SAAS,CAAA,CAAA;AAE1C,IAAA,IAAI,CAAC,IAAK,CAAA,MAAA;AAAQ,MAAA,OAAA;AAClB,IAAI,IAAA,IAAA,GAAO,MAAO,CAAA,CAAC,CAAG,EAAA;AAClB,MAAA,QAAQ,KAAO;AAAA,QACX,KAAKC,aAAS,CAAA,KAAA;AACV,UAAK,IAAA,CAAA,MAAA,GAAS,KAAK,IAAK,CAAA,MAAA,CAAA;AACxB,UAAK,IAAA,CAAA,MAAA,GAAS,KAAK,IAAK,CAAA,MAAA,CAAA;AAExB,UAAA,OAAA;AAAA,QACJ,KAAKA,aAAS,CAAA,KAAA;AACV,UAAA,IAAA,CAAK,MAAW,IAAA,CAAA,IAAA,CAAK,IAAK,CAAA,MAAA,GAAS,KAAK,MAAU,IAAA,KAAA,CAAA;AAClD,UAAA,IAAA,CAAK,MAAW,IAAA,CAAA,IAAA,CAAK,IAAK,CAAA,MAAA,GAAS,KAAK,MAAU,IAAA,KAAA,CAAA;AAAA,OAC1D;AAEA,MAAA,OAAA;AAAA,KACJ;AAEA,IAAA,IAAI,CAAI,GAAA,CAAA,CAAA;AACR,IAAA,IAAI,CAAI,GAAA,CAAA,CAAA;AAER,IAAA,IAAI,QAAQ,MAAO,CAAA,MAAA,CAAO,MAAS,GAAA,aAAA,CAAc,OAAO,CAAG,EAAA;AAEvD,MAAA,CAAA,GAAI,MAAO,CAAA,MAAA,CAAO,MAAS,GAAA,aAAA,CAAc,MAAM,CAAA,CAAA;AAC/C,MAAA,CAAA,GAAI,MAAO,CAAA,MAAA,CAAO,MAAS,GAAA,aAAA,CAAc,MAAM,CAAA,CAAA;AAAA,KAC5C,MAAA;AAEH,MAAA,MAAM,QAAQ,SAAU,CAAA,YAAA,CAAa,MAAQ,EAAA,IAAA,EAAM,cAAc,OAAO,CAAA,CAAA;AAExE,MAAI,CAAA,GAAA,MAAA,CAAO,KAAQ,GAAA,aAAA,CAAc,MAAM,CAAA,CAAA;AACvC,MAAI,CAAA,GAAA,MAAA,CAAO,KAAQ,GAAA,aAAA,CAAc,MAAM,CAAA,CAAA;AACvC,MAAM,MAAA,SAAA,GAAY,OAAO,KAAK,CAAA,CAAA;AAC9B,MAAA,MAAM,OAAU,GAAA,IAAA,CAAK,eAAgB,CAAA,KAAA,GAAQ,cAAc,OAAU,GAAA,CAAA,EAAG,CAAK,GAAA,CAAA,IAAA,GAAO,cAAc,MAAO,CAAA,KAAA,GAAQ,aAAc,CAAA,SAAS,IAAI,SAAU,CAAA,CAAA,CAAA;AAEtJ,MAAA,CAAA,GAAI,KAAK,MAAO,CAAA,KAAA,GAAQ,aAAc,CAAA,CAAC,IAAI,CAAK,IAAA,OAAA,CAAA;AAChD,MAAA,CAAA,GAAI,KAAK,MAAO,CAAA,KAAA,GAAQ,aAAc,CAAA,CAAC,IAAI,CAAK,IAAA,OAAA,CAAA;AAAA,KACpD;AACA,IAAA,QAAQ,KAAO;AAAA,MACX,KAAKA,aAAS,CAAA,KAAA;AACV,QAAA,IAAA,CAAK,MAAS,GAAA,IAAA,CAAK,IAAK,CAAA,MAAA,GAAS,CAAI,GAAA,KAAA,CAAA;AACrC,QAAA,IAAA,CAAK,MAAS,GAAA,IAAA,CAAK,IAAK,CAAA,MAAA,GAAS,CAAI,GAAA,KAAA,CAAA;AACrC,QAAA,MAAA;AAAA,MACJ,KAAKA,aAAS,CAAA,KAAA,CAAA;AAAA,MACd,KAAKA,aAAS,CAAA,OAAA;AACV,QAAA,IAAA,CAAK,WAAW,IAAK,CAAA,IAAA,CAAK,MAAS,GAAA,CAAA,GAAI,KAAK,MAAU,IAAA,KAAA,CAAA;AACtD,QAAA,IAAA,CAAK,WAAW,IAAK,CAAA,IAAA,CAAK,MAAS,GAAA,CAAA,GAAI,KAAK,MAAU,IAAA,KAAA,CAAA;AACtD,QAAA,MAAA;AAAA,MACJ,KAAKA,aAAS,CAAA,GAAA;AACV,QAAA,IAAA,CAAK,UAAU,CAAI,GAAA,KAAA,CAAA;AACnB,QAAA,IAAA,CAAK,UAAU,CAAI,GAAA,KAAA,CAAA;AAAA,KAC3B;AAAA,GACJ;AACJ,CAAA;AAMO,MAAM,cAAA,GAAN,cAA4B,aAAc,CAAA;AAAA,EAoB7C,YAAY,UAAoB,EAAA;AAC5B,IAAA,KAAA,CAAM,UAAU,CAAA,CAAA;AAHpB;AAAA,IAAA,IAAA,CAAA,IAAA,GAA2F,EAAC,CAAA;AAIxF,IAAA,IAAA,CAAK,MAAS,GAAAF,UAAA,CAAM,aAAc,CAAA,UAAA,GAAa,eAAc,OAAO,CAAA,CAAA;AAAA,GACxE;AAAA,EAEA,aAAgB,GAAA;AACZ,IAAQ,OAAA,CAAA,CAAA,gBAAsB,MAAM,IAAK,CAAA,SAAA,CAAA;AAAA,GAC7C;AAAA;AAAA,EAGA,SAAS,UAAoB,EAAA,IAAA,EAAc,CAAW,EAAA,CAAA,EAAW,GAAW,CAAW,EAAA;AACnF,IAAK,IAAA,CAAA,IAAA,CAAK,KAAK,EAAE,UAAA,EAAY,MAAM,CAAG,EAAA,CAAA,EAAG,CAAG,EAAA,CAAA,EAAG,CAAA,CAAA;AAC/C,IAAA,UAAA,IAAc,cAAc,CAAA,OAAA,CAAA;AAC5B,IAAK,IAAA,CAAA,MAAA,CAAO,UAAU,CAAI,GAAA,IAAA,CAAA;AAC1B,IAAA,IAAA,CAAK,MAAO,CAAA,UAAA,GAAa,cAAc,CAAA,CAAC,CAAI,GAAA,CAAA,CAAA;AAC5C,IAAA,IAAA,CAAK,MAAO,CAAA,UAAA,GAAa,cAAc,CAAA,CAAC,CAAI,GAAA,CAAA,CAAA;AAC5C,IAAA,IAAA,CAAK,MAAO,CAAA,UAAA,GAAa,cAAc,CAAA,CAAC,CAAI,GAAA,CAAA,CAAA;AAC5C,IAAA,IAAA,CAAK,MAAO,CAAA,UAAA,GAAa,cAAc,CAAA,CAAC,CAAI,GAAA,CAAA,CAAA;AAAA,GAChD;AAAA,EAEA,MAAM,QAAoB,EAAA,QAAA,EAAkB,MAAc,MAAsB,EAAA,KAAA,EAAe,OAAiB,SAAyB,EAAA;AACrI,IAAA,MAAM,IAAO,GAAA,QAAA,CAAS,KAAM,CAAA,IAAA,CAAK,SAAS,CAAA,CAAA;AAE1C,IAAI,IAAA,CAAC,KAAK,IAAK,CAAA,MAAA;AAAQ,MAAA,OAAA;AACvB,IAAA,MAAM,SAAS,IAAK,CAAA,MAAA,CAAA;AAEpB,IAAI,IAAA,IAAA,GAAO,MAAO,CAAA,CAAC,CAAG,EAAA;AAClB,MAAA,QAAQ,KAAO;AAAA,QACX,KAAKE,aAAS,CAAA,KAAA;AACV,UAAA,IAAA,CAAK,KAAM,CAAA,YAAA,CAAa,IAAK,CAAA,IAAA,CAAK,KAAK,CAAA,CAAA;AAEvC,UAAA,OAAA;AAAA,QACJ,KAAKA,aAAS,CAAA,KAAA;AACV,UAAA,MAAM,QAAQ,IAAK,CAAA,KAAA,CAAA;AACnB,UAAM,MAAA,KAAA,GAAQ,KAAK,IAAK,CAAA,KAAA,CAAA;AAExB,UAAM,KAAA,CAAA,GAAA,CAAA,CAAK,MAAM,CAAI,GAAA,KAAA,CAAM,KAAK,KAAQ,EAAA,CAAA,KAAA,CAAM,IAAI,KAAM,CAAA,CAAA,IAAK,QAAQ,KAAM,CAAA,CAAA,GAAI,MAAM,CAAK,IAAA,KAAA,EAAA,CAAQ,MAAM,CAAI,GAAA,KAAA,CAAM,KAAK,KAAK,CAAA,CAAA;AAAA,OACpI;AAEA,MAAA,OAAA;AAAA,KACJ;AAEA,IAAA,IAAI,CAAI,GAAA,CAAA,CAAA;AACR,IAAA,IAAI,CAAI,GAAA,CAAA,CAAA;AACR,IAAA,IAAI,CAAI,GAAA,CAAA,CAAA;AACR,IAAA,IAAI,CAAI,GAAA,CAAA,CAAA;AAER,IAAA,IAAI,QAAQ,MAAO,CAAA,MAAA,CAAO,MAAS,GAAA,cAAA,CAAc,OAAO,CAAG,EAAA;AAEvD,MAAA,MAAM,IAAI,MAAO,CAAA,MAAA,CAAA;AAEjB,MAAI,CAAA,GAAA,MAAA,CAAO,CAAI,GAAA,cAAA,CAAc,MAAM,CAAA,CAAA;AACnC,MAAI,CAAA,GAAA,MAAA,CAAO,CAAI,GAAA,cAAA,CAAc,MAAM,CAAA,CAAA;AACnC,MAAI,CAAA,GAAA,MAAA,CAAO,CAAI,GAAA,cAAA,CAAc,MAAM,CAAA,CAAA;AACnC,MAAI,CAAA,GAAA,MAAA,CAAO,CAAI,GAAA,cAAA,CAAc,MAAM,CAAA,CAAA;AAAA,KAChC,MAAA;AAEH,MAAA,MAAM,QAAQ,SAAU,CAAA,YAAA,CAAa,MAAQ,EAAA,IAAA,EAAM,eAAc,OAAO,CAAA,CAAA;AAExE,MAAI,CAAA,GAAA,MAAA,CAAO,KAAQ,GAAA,cAAA,CAAc,MAAM,CAAA,CAAA;AACvC,MAAI,CAAA,GAAA,MAAA,CAAO,KAAQ,GAAA,cAAA,CAAc,MAAM,CAAA,CAAA;AACvC,MAAI,CAAA,GAAA,MAAA,CAAO,KAAQ,GAAA,cAAA,CAAc,MAAM,CAAA,CAAA;AACvC,MAAI,CAAA,GAAA,MAAA,CAAO,KAAQ,GAAA,cAAA,CAAc,MAAM,CAAA,CAAA;AACvC,MAAM,MAAA,SAAA,GAAY,OAAO,KAAK,CAAA,CAAA;AAC9B,MAAA,MAAM,OAAU,GAAA,IAAA,CAAK,eAAgB,CAAA,KAAA,GAAQ,eAAc,OAAU,GAAA,CAAA,EAAG,CAAK,GAAA,CAAA,IAAA,GAAO,cAAc,MAAO,CAAA,KAAA,GAAQ,cAAc,CAAA,SAAS,IAAI,SAAU,CAAA,CAAA,CAAA;AAEtJ,MAAA,CAAA,IAAA,CAAM,MAAO,CAAA,KAAA,GAAQ,cAAc,CAAA,CAAC,IAAI,CAAK,IAAA,OAAA,CAAA;AAC7C,MAAA,CAAA,IAAA,CAAM,MAAO,CAAA,KAAA,GAAQ,cAAc,CAAA,CAAC,IAAI,CAAK,IAAA,OAAA,CAAA;AAC7C,MAAA,CAAA,IAAA,CAAM,MAAO,CAAA,KAAA,GAAQ,cAAc,CAAA,CAAC,IAAI,CAAK,IAAA,OAAA,CAAA;AAC7C,MAAA,CAAA,IAAA,CAAM,MAAO,CAAA,KAAA,GAAQ,cAAc,CAAA,CAAC,IAAI,CAAK,IAAA,OAAA,CAAA;AAAA,KACjD;AACA,IAAA,IAAI,KAAS,IAAA,CAAA;AAAG,MAAA,IAAA,CAAK,KAAM,CAAA,GAAA,CAAI,CAAG,EAAA,CAAA,EAAG,GAAG,CAAC,CAAA,CAAA;AAAA,SACpC;AACD,MAAA,MAAM,QAAQ,IAAK,CAAA,KAAA,CAAA;AAEnB,MAAA,IAAI,SAASA,aAAS,CAAA,KAAA;AAAO,QAAM,KAAA,CAAA,YAAA,CAAa,IAAK,CAAA,IAAA,CAAK,KAAK,CAAA,CAAA;AAC/D,MAAA,KAAA,CAAM,KAAK,CAAI,GAAA,KAAA,CAAM,CAAK,IAAA,KAAA,EAAA,CAAQ,IAAI,KAAM,CAAA,CAAA,IAAK,KAAQ,EAAA,CAAA,CAAA,GAAI,MAAM,CAAK,IAAA,KAAA,EAAA,CAAQ,CAAI,GAAA,KAAA,CAAM,KAAK,KAAK,CAAA,CAAA;AAAA,KACxG;AAAA,GACJ;AACJ,CAAA,CAAA;AAnGO,IAAM,aAAN,GAAA,eAAA;AAAM,aAAA,CACF,OAAU,GAAA,CAAA,CAAA;AADR,aAAA,CAEF,SAAY,GAAA,CAAA,CAAA,CAAA;AAFV,aAAA,CAGF,MAAS,GAAA,CAAA,CAAA,CAAA;AAHP,aAAA,CAIF,MAAS,GAAA,CAAA,CAAA,CAAA;AAJP,aAAA,CAKF,MAAS,GAAA,CAAA,CAAA,CAAA;AALP,aAAA,CAMF,MAAS,GAAA,CAAA,CAAA,CAAA;AANP,aAAA,CAOF,CAAI,GAAA,CAAA,CAAA;AAPF,aAAA,CAQF,CAAI,GAAA,CAAA,CAAA;AARF,aAAA,CASF,CAAI,GAAA,CAAA,CAAA;AATF,aAAA,CAUF,CAAI,GAAA,CAAA,CAAA;AA+FR,MAAM,iBAAA,GAAN,cAA+B,aAAc,CAAA;AAAA,EA0BhD,YAAY,UAAoB,EAAA;AAC5B,IAAA,KAAA,CAAM,UAAU,CAAA,CAAA;AAFpB;AAAA,IAAA,IAAA,CAAA,IAAA,GAA+H,EAAC,CAAA;AAG5H,IAAA,IAAA,CAAK,MAAS,GAAAF,UAAA,CAAM,aAAc,CAAA,UAAA,GAAa,kBAAiB,OAAO,CAAA,CAAA;AAAA,GAC3E;AAAA,EAEA,aAAgB,GAAA;AACZ,IAAQ,OAAA,CAAA,EAAA,mBAAyB,MAAM,IAAK,CAAA,SAAA,CAAA;AAAA,GAChD;AAAA;AAAA,EAGA,QAAA,CAAS,YAAoB,IAAc,EAAA,CAAA,EAAW,GAAW,CAAW,EAAA,CAAA,EAAW,EAAY,EAAA,EAAA,EAAY,EAAY,EAAA;AACvH,IAAA,IAAA,CAAK,IAAK,CAAA,IAAA,CAAK,EAAE,UAAA,EAAY,IAAM,EAAA,CAAA,EAAG,CAAG,EAAA,CAAA,EAAG,CAAG,EAAA,EAAA,EAAI,EAAI,EAAA,EAAA,EAAI,CAAA,CAAA;AAC3D,IAAA,UAAA,IAAc,iBAAiB,CAAA,OAAA,CAAA;AAC/B,IAAK,IAAA,CAAA,MAAA,CAAO,UAAU,CAAI,GAAA,IAAA,CAAA;AAC1B,IAAA,IAAA,CAAK,MAAO,CAAA,UAAA,GAAa,iBAAiB,CAAA,CAAC,CAAI,GAAA,CAAA,CAAA;AAC/C,IAAA,IAAA,CAAK,MAAO,CAAA,UAAA,GAAa,iBAAiB,CAAA,CAAC,CAAI,GAAA,CAAA,CAAA;AAC/C,IAAA,IAAA,CAAK,MAAO,CAAA,UAAA,GAAa,iBAAiB,CAAA,CAAC,CAAI,GAAA,CAAA,CAAA;AAC/C,IAAA,IAAA,CAAK,MAAO,CAAA,UAAA,GAAa,iBAAiB,CAAA,CAAC,CAAI,GAAA,CAAA,CAAA;AAC/C,IAAA,IAAA,CAAK,MAAO,CAAA,UAAA,GAAa,iBAAiB,CAAA,EAAE,CAAI,GAAA,EAAA,CAAA;AAChD,IAAA,IAAA,CAAK,MAAO,CAAA,UAAA,GAAa,iBAAiB,CAAA,EAAE,CAAI,GAAA,EAAA,CAAA;AAChD,IAAA,IAAA,CAAK,MAAO,CAAA,UAAA,GAAa,iBAAiB,CAAA,EAAE,CAAI,GAAA,EAAA,CAAA;AAAA,GACpD;AAAA,EAEA,MAAM,QAAoB,EAAA,QAAA,EAAkB,MAAc,MAAsB,EAAA,KAAA,EAAe,OAAiB,SAAyB,EAAA;AACrI,IAAA,MAAM,IAAO,GAAA,QAAA,CAAS,KAAM,CAAA,IAAA,CAAK,SAAS,CAAA,CAAA;AAE1C,IAAI,IAAA,CAAC,KAAK,IAAK,CAAA,MAAA;AAAQ,MAAA,OAAA;AACvB,IAAA,MAAM,SAAS,IAAK,CAAA,MAAA,CAAA;AAEpB,IAAI,IAAA,IAAA,GAAO,MAAO,CAAA,CAAC,CAAG,EAAA;AAClB,MAAA,QAAQ,KAAO;AAAA,QACX,KAAKE,aAAS,CAAA,KAAA;AACV,UAAA,IAAA,CAAK,KAAM,CAAA,YAAA,CAAa,IAAK,CAAA,IAAA,CAAK,KAAK,CAAA,CAAA;AACvC,UAAA,IAAA,CAAK,SAAU,CAAA,YAAA,CAAa,IAAK,CAAA,IAAA,CAAK,SAAS,CAAA,CAAA;AAE/C,UAAA,OAAA;AAAA,QACJ,KAAKA,aAAS,CAAA,KAAA;AACV,UAAA,MAAM,QAAQ,IAAK,CAAA,KAAA,CAAA;AACnB,UAAA,MAAM,OAAO,IAAK,CAAA,SAAA,CAAA;AAClB,UAAM,MAAA,UAAA,GAAa,KAAK,IAAK,CAAA,KAAA,CAAA;AAC7B,UAAM,MAAA,SAAA,GAAY,KAAK,IAAK,CAAA,SAAA,CAAA;AAE5B,UAAM,KAAA,CAAA,GAAA,CAAA,CAAK,WAAW,CAAI,GAAA,KAAA,CAAM,KAAK,KAAQ,EAAA,CAAA,UAAA,CAAW,IAAI,KAAM,CAAA,CAAA,IAAK,QAAQ,UAAW,CAAA,CAAA,GAAI,MAAM,CAAK,IAAA,KAAA,EAAA,CAAQ,WAAW,CAAI,GAAA,KAAA,CAAM,KAAK,KAAK,CAAA,CAAA;AAChJ,UAAA,IAAA,CAAK,KAAK,SAAU,CAAA,CAAA,GAAI,IAAK,CAAA,CAAA,IAAK,QAAQ,SAAU,CAAA,CAAA,GAAI,IAAK,CAAA,CAAA,IAAK,QAAQ,SAAU,CAAA,CAAA,GAAI,IAAK,CAAA,CAAA,IAAK,OAAO,CAAC,CAAA,CAAA;AAAA,OAClH;AAEA,MAAA,OAAA;AAAA,KACJ;AAEA,IAAA,IAAI,CAAI,GAAA,CAAA,CAAA;AACR,IAAA,IAAI,CAAI,GAAA,CAAA,CAAA;AACR,IAAA,IAAI,CAAI,GAAA,CAAA,CAAA;AACR,IAAA,IAAI,CAAI,GAAA,CAAA,CAAA;AACR,IAAA,IAAI,EAAK,GAAA,CAAA,CAAA;AACT,IAAA,IAAI,EAAK,GAAA,CAAA,CAAA;AACT,IAAA,IAAI,EAAK,GAAA,CAAA,CAAA;AAET,IAAA,IAAI,QAAQ,MAAO,CAAA,MAAA,CAAO,MAAS,GAAA,iBAAA,CAAiB,OAAO,CAAG,EAAA;AAE1D,MAAA,MAAM,IAAI,MAAO,CAAA,MAAA,CAAA;AAEjB,MAAI,CAAA,GAAA,MAAA,CAAO,CAAI,GAAA,iBAAA,CAAiB,MAAM,CAAA,CAAA;AACtC,MAAI,CAAA,GAAA,MAAA,CAAO,CAAI,GAAA,iBAAA,CAAiB,MAAM,CAAA,CAAA;AACtC,MAAI,CAAA,GAAA,MAAA,CAAO,CAAI,GAAA,iBAAA,CAAiB,MAAM,CAAA,CAAA;AACtC,MAAI,CAAA,GAAA,MAAA,CAAO,CAAI,GAAA,iBAAA,CAAiB,MAAM,CAAA,CAAA;AACtC,MAAK,EAAA,GAAA,MAAA,CAAO,CAAI,GAAA,iBAAA,CAAiB,OAAO,CAAA,CAAA;AACxC,MAAK,EAAA,GAAA,MAAA,CAAO,CAAI,GAAA,iBAAA,CAAiB,OAAO,CAAA,CAAA;AACxC,MAAK,EAAA,GAAA,MAAA,CAAO,CAAI,GAAA,iBAAA,CAAiB,OAAO,CAAA,CAAA;AAAA,KACrC,MAAA;AAEH,MAAA,MAAM,QAAQ,SAAU,CAAA,YAAA,CAAa,MAAQ,EAAA,IAAA,EAAM,kBAAiB,OAAO,CAAA,CAAA;AAE3E,MAAI,CAAA,GAAA,MAAA,CAAO,KAAQ,GAAA,iBAAA,CAAiB,MAAM,CAAA,CAAA;AAC1C,MAAI,CAAA,GAAA,MAAA,CAAO,KAAQ,GAAA,iBAAA,CAAiB,MAAM,CAAA,CAAA;AAC1C,MAAI,CAAA,GAAA,MAAA,CAAO,KAAQ,GAAA,iBAAA,CAAiB,MAAM,CAAA,CAAA;AAC1C,MAAI,CAAA,GAAA,MAAA,CAAO,KAAQ,GAAA,iBAAA,CAAiB,MAAM,CAAA,CAAA;AAC1C,MAAK,EAAA,GAAA,MAAA,CAAO,KAAQ,GAAA,iBAAA,CAAiB,OAAO,CAAA,CAAA;AAC5C,MAAK,EAAA,GAAA,MAAA,CAAO,KAAQ,GAAA,iBAAA,CAAiB,OAAO,CAAA,CAAA;AAC5C,MAAK,EAAA,GAAA,MAAA,CAAO,KAAQ,GAAA,iBAAA,CAAiB,OAAO,CAAA,CAAA;AAC5C,MAAM,MAAA,SAAA,GAAY,OAAO,KAAK,CAAA,CAAA;AAC9B,MAAA,MAAM,OAAU,GAAA,IAAA,CAAK,eAAgB,CAAA,KAAA,GAAQ,kBAAiB,OAAU,GAAA,CAAA,EAAG,CAAK,GAAA,CAAA,IAAA,GAAO,cAAc,MAAO,CAAA,KAAA,GAAQ,iBAAiB,CAAA,SAAS,IAAI,SAAU,CAAA,CAAA,CAAA;AAE5J,MAAA,CAAA,IAAA,CAAM,MAAO,CAAA,KAAA,GAAQ,iBAAiB,CAAA,CAAC,IAAI,CAAK,IAAA,OAAA,CAAA;AAChD,MAAA,CAAA,IAAA,CAAM,MAAO,CAAA,KAAA,GAAQ,iBAAiB,CAAA,CAAC,IAAI,CAAK,IAAA,OAAA,CAAA;AAChD,MAAA,CAAA,IAAA,CAAM,MAAO,CAAA,KAAA,GAAQ,iBAAiB,CAAA,CAAC,IAAI,CAAK,IAAA,OAAA,CAAA;AAChD,MAAA,CAAA,IAAA,CAAM,MAAO,CAAA,KAAA,GAAQ,iBAAiB,CAAA,CAAC,IAAI,CAAK,IAAA,OAAA,CAAA;AAChD,MAAA,EAAA,IAAA,CAAO,MAAO,CAAA,KAAA,GAAQ,iBAAiB,CAAA,EAAE,IAAI,EAAM,IAAA,OAAA,CAAA;AACnD,MAAA,EAAA,IAAA,CAAO,MAAO,CAAA,KAAA,GAAQ,iBAAiB,CAAA,EAAE,IAAI,EAAM,IAAA,OAAA,CAAA;AACnD,MAAA,EAAA,IAAA,CAAO,MAAO,CAAA,KAAA,GAAQ,iBAAiB,CAAA,EAAE,IAAI,EAAM,IAAA,OAAA,CAAA;AAAA,KACvD;AACA,IAAA,IAAI,SAAS,CAAG,EAAA;AACZ,MAAA,IAAA,CAAK,KAAM,CAAA,GAAA,CAAI,CAAG,EAAA,CAAA,EAAG,GAAG,CAAC,CAAA,CAAA;AACzB,MAAA,IAAA,CAAK,SAAU,CAAA,GAAA,CAAI,EAAI,EAAA,EAAA,EAAI,IAAI,CAAC,CAAA,CAAA;AAAA,KAC7B,MAAA;AACH,MAAA,MAAM,QAAQ,IAAK,CAAA,KAAA,CAAA;AACnB,MAAA,MAAM,OAAO,IAAK,CAAA,SAAA,CAAA;AAElB,MAAI,IAAA,KAAA,IAASA,cAAS,KAAO,EAAA;AACzB,QAAM,KAAA,CAAA,YAAA,CAAa,IAAK,CAAA,IAAA,CAAK,KAAK,CAAA,CAAA;AAClC,QAAK,IAAA,CAAA,YAAA,CAAa,IAAK,CAAA,IAAA,CAAK,SAAS,CAAA,CAAA;AAAA,OACzC;AACA,MAAA,KAAA,CAAM,KAAK,CAAI,GAAA,KAAA,CAAM,CAAK,IAAA,KAAA,EAAA,CAAQ,IAAI,KAAM,CAAA,CAAA,IAAK,KAAQ,EAAA,CAAA,CAAA,GAAI,MAAM,CAAK,IAAA,KAAA,EAAA,CAAQ,CAAI,GAAA,KAAA,CAAM,KAAK,KAAK,CAAA,CAAA;AACpG,MAAA,IAAA,CAAK,GAAK,CAAA,CAAA,EAAA,GAAK,IAAK,CAAA,CAAA,IAAK,KAAQ,EAAA,CAAA,EAAA,GAAK,IAAK,CAAA,CAAA,IAAK,KAAQ,EAAA,CAAA,EAAA,GAAK,IAAK,CAAA,CAAA,IAAK,OAAO,CAAC,CAAA,CAAA;AAAA,KACnF;AAAA,GACJ;AACJ,CAAA,CAAA;AAnIO,IAAM,gBAAN,GAAA,kBAAA;AAAM,gBAAA,CACF,OAAU,GAAA,CAAA,CAAA;AADR,gBAAA,CAEF,SAAY,GAAA,CAAA,CAAA,CAAA;AAFV,gBAAA,CAGF,MAAS,GAAA,CAAA,CAAA,CAAA;AAHP,gBAAA,CAIF,MAAS,GAAA,CAAA,CAAA,CAAA;AAJP,gBAAA,CAKF,MAAS,GAAA,CAAA,CAAA,CAAA;AALP,gBAAA,CAMF,MAAS,GAAA,CAAA,CAAA,CAAA;AANP,gBAAA,CAOF,OAAU,GAAA,CAAA,CAAA,CAAA;AAPR,gBAAA,CAQF,OAAU,GAAA,CAAA,CAAA,CAAA;AARR,gBAAA,CASF,OAAU,GAAA,CAAA,CAAA,CAAA;AATR,gBAAA,CAUF,CAAI,GAAA,CAAA,CAAA;AAVF,gBAAA,CAWF,CAAI,GAAA,CAAA,CAAA;AAXF,gBAAA,CAYF,CAAI,GAAA,CAAA,CAAA;AAZF,gBAAA,CAaF,CAAI,GAAA,CAAA,CAAA;AAbF,gBAAA,CAcF,EAAK,GAAA,CAAA,CAAA;AAdH,gBAAA,CAeF,EAAK,GAAA,CAAA,CAAA;AAfH,gBAAA,CAgBF,EAAK,GAAA,CAAA,CAAA;AAyHT,MAAM,kBAAuC,CAAA;AAAA,EAWhD,YAAY,UAAoB,EAAA;AADhC,IAAA,IAAA,CAAA,IAAA,GAAuE,EAAC,CAAA;AAEpE,IAAK,IAAA,CAAA,MAAA,GAASF,UAAM,CAAA,aAAA,CAAc,UAAU,CAAA,CAAA;AAC5C,IAAK,IAAA,CAAA,eAAA,GAAkB,IAAI,KAAA,CAAc,UAAU,CAAA,CAAA;AAAA,GACvD;AAAA,EAEA,aAAgB,GAAA;AACZ,IAAQ,OAAA,CAAA,CAAA,qBAA2B,MAAM,IAAK,CAAA,SAAA,CAAA;AAAA,GAClD;AAAA;AAAA,EAGA,aAAgB,GAAA;AACZ,IAAA,OAAO,KAAK,MAAO,CAAA,MAAA,CAAA;AAAA,GACvB;AAAA;AAAA,EAGA,QAAA,CAAS,UAAoB,EAAA,IAAA,EAAc,cAAwB,EAAA;AAC/D,IAAA,IAAA,CAAK,KAAK,IAAK,CAAA,EAAE,UAAY,EAAA,IAAA,EAAM,gBAAgB,CAAA,CAAA;AACnD,IAAK,IAAA,CAAA,MAAA,CAAO,UAAU,CAAI,GAAA,IAAA,CAAA;AAC1B,IAAK,IAAA,CAAA,eAAA,CAAgB,UAAU,CAAI,GAAA,cAAA,CAAA;AAAA,GACvC;AAAA,EAEA,MAAM,QAAoB,EAAA,QAAA,EAAkB,MAAc,MAAsB,EAAA,KAAA,EAAe,OAAiB,SAAyB,EAAA;AACrI,IAAA,MAAM,IAAO,GAAA,QAAA,CAAS,KAAM,CAAA,IAAA,CAAK,SAAS,CAAA,CAAA;AAE1C,IAAI,IAAA,CAAC,KAAK,IAAK,CAAA,MAAA;AAAQ,MAAA,OAAA;AACvB,IAAI,IAAA,SAAA,IAAaI,kBAAa,MAAQ,EAAA;AAClC,MAAA,IAAI,SAASF,aAAS,CAAA,KAAA;AAAO,QAAA,IAAA,CAAK,aAAc,CAAA,QAAA,EAAU,IAAM,EAAA,IAAA,CAAK,KAAK,cAAc,CAAA,CAAA;AAExF,MAAA,OAAA;AAAA,KACJ;AAEA,IAAA,MAAM,SAAS,IAAK,CAAA,MAAA,CAAA;AAEpB,IAAI,IAAA,IAAA,GAAO,MAAO,CAAA,CAAC,CAAG,EAAA;AAClB,MAAA,IAAI,KAAS,IAAAA,aAAA,CAAS,KAAS,IAAA,KAAA,IAASA,aAAS,CAAA,KAAA;AAAO,QAAA,IAAA,CAAK,aAAc,CAAA,QAAA,EAAU,IAAM,EAAA,IAAA,CAAK,KAAK,cAAc,CAAA,CAAA;AAEnH,MAAA,OAAA;AAAA,KACJ;AAEA,IAAA,IAAI,UAAa,GAAA,CAAA,CAAA;AAEjB,IAAA,IAAI,IAAQ,IAAA,MAAA,CAAO,MAAO,CAAA,MAAA,GAAS,CAAC,CAAA;AAEhC,MAAA,UAAA,GAAa,OAAO,MAAS,GAAA,CAAA,CAAA;AAAA;AAC5B,MAAA,UAAA,GAAa,SAAU,CAAA,YAAA,CAAa,MAAQ,EAAA,IAAA,EAAM,CAAC,CAAI,GAAA,CAAA,CAAA;AAE5D,IAAM,MAAA,cAAA,GAAiB,IAAK,CAAA,eAAA,CAAgB,UAAU,CAAA,CAAA;AAEtD,IAAA,QAAA,CAAS,KAAM,CAAA,IAAA,CAAK,SAAS,CAAA,CAAE,aAAc,CAAA,cAAA,IAAkB,IAAO,GAAA,IAAA,GAAO,QAAS,CAAA,aAAA,CAAc,IAAK,CAAA,SAAA,EAAW,cAAc,CAAC,CAAA,CAAA;AAAA,GACvI;AAAA,EAEA,aAAA,CAAc,QAAoB,EAAA,IAAA,EAAY,cAAwB,EAAA;AAClE,IAAK,IAAA,CAAA,aAAA,CAAc,kBAAkB,IAAO,GAAA,IAAA,GAAO,SAAS,aAAc,CAAA,IAAA,CAAK,SAAW,EAAA,cAAc,CAAC,CAAA,CAAA;AAAA,GAC7G;AACJ,CAAA;AAEA,IAAI,KAA2B,GAAA,IAAA,CAAA;AAMxB,MAAM,uBAAuB,aAAc,CAAA;AAAA,EAc9C,YAAY,UAAoB,EAAA;AAC5B,IAAA,KAAA,CAAM,UAAU,CAAA,CAAA;AAFpB,IAAA,IAAA,CAAA,IAAA,GAA0F,EAAC,CAAA;AAGvF,IAAK,IAAA,CAAA,MAAA,GAASF,UAAM,CAAA,aAAA,CAAc,UAAU,CAAA,CAAA;AAC5C,IAAK,IAAA,CAAA,aAAA,GAAgB,IAAI,KAAA,CAAyB,UAAU,CAAA,CAAA;AAC5D,IAAA,IAAI,KAAS,IAAA,IAAA;AAAM,MAAQ,KAAA,GAAAA,UAAA,CAAM,cAAc,EAAE,CAAA,CAAA;AAAA,GACrD;AAAA,EAEA,aAAgB,GAAA;AACZ,IAAA,OAAA,CAAQ,kBAAuB,EAAM,IAAA,MAAA,CAAO,KAAK,UAAW,CAAA,EAAE,IAAI,IAAK,CAAA,SAAA,CAAA;AAAA,GAC3E;AAAA;AAAA;AAAA,EAIA,QAAS,CAAA,UAAA,EAAoB,IAAc,EAAA,QAAA,EAA6B,IAAc,EAAA;AAClF,IAAA,IAAA,CAAK,KAAK,IAAK,CAAA,EAAE,YAAY,IAAM,EAAA,QAAA,EAAU,MAAM,CAAA,CAAA;AACnD,IAAK,IAAA,CAAA,MAAA,CAAO,UAAU,CAAI,GAAA,IAAA,CAAA;AAC1B,IAAK,IAAA,CAAA,aAAA,CAAc,UAAU,CAAI,GAAA,QAAA,CAAA;AAAA,GACrC;AAAA,EAEA,MAAM,QAAoB,EAAA,QAAA,EAAkB,MAAc,WAA2B,EAAA,KAAA,EAAe,OAAiB,SAAyB,EAAA;AAC1I,IAAA,MAAM,IAAa,GAAA,QAAA,CAAS,KAAM,CAAA,IAAA,CAAK,SAAS,CAAA,CAAA;AAEhD,IAAI,IAAA,CAAC,KAAK,IAAK,CAAA,MAAA;AAAQ,MAAA,OAAA;AACvB,IAAM,MAAA,cAAA,GAA6B,KAAK,aAAc,EAAA,CAAA;AAEtD,IAAA,IAAI,EAAE,cAA0B,YAAAK,2BAAA,CAAA,IAAqB,EAAqB,cAAA,CAAgB,oBAAoB,IAAK,CAAA,UAAA,CAAA;AAAa,MAAA,OAAA;AAEhI,IAAM,MAAA,WAAA,GAA6B,IAAK,CAAA,MAAA,IAAU,EAAC,CAAA;AAEnD,IAAA,IAAI,YAAY,MAAU,IAAA,CAAA;AAAG,MAAA,KAAA,GAAQH,aAAS,CAAA,KAAA,CAAA;AAE9C,IAAA,MAAM,gBAAgB,IAAK,CAAA,aAAA,CAAA;AAC3B,IAAM,MAAA,WAAA,GAAc,aAAc,CAAA,CAAC,CAAE,CAAA,MAAA,CAAA;AAErC,IAAA,MAAM,SAAS,IAAK,CAAA,MAAA,CAAA;AAEpB,IAAI,IAAA,IAAA,GAAO,MAAO,CAAA,CAAC,CAAG,EAAA;AAClB,MAAA,MAAM,gBAAqC,GAAA,cAAA,CAAA;AAE3C,MAAA,QAAQ,KAAO;AAAA,QACX,KAAKA,aAAS,CAAA,KAAA;AACV,UAAA,WAAA,CAAY,MAAS,GAAA,CAAA,CAAA;AAErB,UAAA,OAAA;AAAA,QACJ,KAAKA,aAAS,CAAA,KAAA;AACV,UAAA,IAAI,SAAS,CAAG,EAAA;AACZ,YAAA,WAAA,CAAY,MAAS,GAAA,CAAA,CAAA;AACrB,YAAA,MAAA;AAAA,WACJ;AACA,UAAA,MAAMI,OAAwB,GAAAN,UAAA,CAAM,YAAa,CAAA,WAAA,EAAa,WAAW,CAAA,CAAA;AAEzE,UAAI,IAAA,gBAAA,CAAiB,SAAS,IAAM,EAAA;AAEhC,YAAA,MAAM,gBAAgB,gBAAiB,CAAA,QAAA,CAAA;AAEvC,YAAS,KAAA,IAAA,CAAA,GAAI,CAAG,EAAA,CAAA,GAAI,WAAa,EAAA,CAAA,EAAA;AAAK,cAAAM,OAAAA,CAAO,CAAC,CAAM,IAAA,CAAA,aAAA,CAAc,CAAC,CAAIA,GAAAA,OAAAA,CAAO,CAAC,CAAK,IAAA,KAAA,CAAA;AAAA,WACjF,MAAA;AAEH,YAAA,KAAA,GAAQ,CAAI,GAAA,KAAA,CAAA;AACZ,YAAS,KAAA,IAAA,CAAA,GAAI,CAAG,EAAA,CAAA,GAAI,WAAa,EAAA,CAAA,EAAA;AAAK,cAAAA,OAAAA,CAAO,CAAC,CAAK,IAAA,KAAA,CAAA;AAAA,WACvD;AAAA,OACR;AAEA,MAAA,OAAA;AAAA,KACJ;AAEA,IAAA,MAAM,MAAwB,GAAAN,UAAA,CAAM,YAAa,CAAA,WAAA,EAAa,WAAW,CAAA,CAAA;AAEzE,IAAA,IAAI,IAAQ,IAAA,MAAA,CAAO,MAAO,CAAA,MAAA,GAAS,CAAC,CAAG,EAAA;AAEnC,MAAA,MAAM,YAAe,GAAA,aAAA,CAAc,MAAO,CAAA,MAAA,GAAS,CAAC,CAAA,CAAA;AAEpD,MAAA,IAAI,SAAS,CAAG,EAAA;AACZ,QAAI,IAAA,KAAA,IAASE,cAAS,GAAK,EAAA;AACvB,UAAA,MAAM,gBAAmB,GAAA,cAAA,CAAA;AAEzB,UAAI,IAAA,gBAAA,CAAiB,SAAS,IAAM,EAAA;AAEhC,YAAA,MAAM,gBAAgB,gBAAiB,CAAA,QAAA,CAAA;AAEvC,YAAA,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,WAAA,EAAa,CAAK,EAAA,EAAA;AAClC,cAAA,MAAA,CAAO,CAAC,CAAK,IAAA,YAAA,CAAa,CAAC,CAAA,GAAI,cAAc,CAAC,CAAA,CAAA;AAAA,aAClD;AAAA,WACG,MAAA;AAEH,YAAS,KAAA,IAAA,CAAA,GAAI,CAAG,EAAA,CAAA,GAAI,WAAa,EAAA,CAAA,EAAA;AAAK,cAAO,MAAA,CAAA,CAAC,CAAK,IAAA,YAAA,CAAa,CAAC,CAAA,CAAA;AAAA,WACrE;AAAA,SACG,MAAA;AACH,UAAAF,UAAA,CAAM,SAAU,CAAA,YAAA,EAAc,CAAG,EAAA,MAAA,EAAQ,GAAG,WAAW,CAAA,CAAA;AAAA,SAC3D;AAAA,OACG,MAAA;AACH,QAAA,QAAQ,KAAO;AAAA,UACX,KAAKE,cAAS,KAAO,EAAA;AACjB,YAAA,MAAMK,iBAAmB,GAAA,cAAA,CAAA;AAEzB,YAAIA,IAAAA,iBAAAA,CAAiB,SAAS,IAAM,EAAA;AAEhC,cAAA,MAAM,gBAAgBA,iBAAiB,CAAA,QAAA,CAAA;AAEvC,cAAA,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,WAAA,EAAa,CAAK,EAAA,EAAA;AAClC,gBAAM,MAAA,KAAA,GAAQ,cAAc,CAAC,CAAA,CAAA;AAE7B,gBAAA,MAAA,CAAO,CAAC,CAAI,GAAA,KAAA,GAAA,CAAS,YAAa,CAAA,CAAC,IAAI,KAAS,IAAA,KAAA,CAAA;AAAA,eACpD;AAAA,aACG,MAAA;AAEH,cAAS,KAAA,IAAA,CAAA,GAAI,CAAG,EAAA,CAAA,GAAI,WAAa,EAAA,CAAA,EAAA;AAAK,gBAAA,MAAA,CAAO,CAAC,CAAA,GAAI,YAAa,CAAA,CAAC,CAAI,GAAA,KAAA,CAAA;AAAA,aACxE;AACA,YAAA,MAAA;AAAA,WACJ;AAAA,UACA,KAAKL,aAAS,CAAA,KAAA,CAAA;AAAA,UACd,KAAKA,aAAS,CAAA,OAAA;AACV,YAAS,KAAA,IAAA,CAAA,GAAI,CAAG,EAAA,CAAA,GAAI,WAAa,EAAA,CAAA,EAAA;AAAK,cAAA,MAAA,CAAO,CAAC,CAAM,IAAA,CAAA,YAAA,CAAa,CAAC,CAAI,GAAA,MAAA,CAAO,CAAC,CAAK,IAAA,KAAA,CAAA;AACnF,YAAA,MAAA;AAAA,UACJ,KAAKA,aAAS,CAAA,GAAA;AACV,YAAA,MAAM,gBAAmB,GAAA,cAAA,CAAA;AAEzB,YAAI,IAAA,gBAAA,CAAiB,SAAS,IAAM,EAAA;AAEhC,cAAA,MAAM,gBAAgB,gBAAiB,CAAA,QAAA,CAAA;AAEvC,cAAA,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,WAAA,EAAa,CAAK,EAAA,EAAA;AAClC,gBAAA,MAAA,CAAO,CAAC,CAAM,IAAA,CAAA,YAAA,CAAa,CAAC,CAAI,GAAA,aAAA,CAAc,CAAC,CAAK,IAAA,KAAA,CAAA;AAAA,eACxD;AAAA,aACG,MAAA;AAEH,cAAS,KAAA,IAAA,CAAA,GAAI,CAAG,EAAA,CAAA,GAAI,WAAa,EAAA,CAAA,EAAA;AAAK,gBAAA,MAAA,CAAO,CAAC,CAAA,IAAK,YAAa,CAAA,CAAC,CAAI,GAAA,KAAA,CAAA;AAAA,aACzE;AAAA,SACR;AAAA,OACJ;AAEA,MAAA,OAAA;AAAA,KACJ;AAGA,IAAA,MAAM,KAAQ,GAAA,SAAA,CAAU,YAAa,CAAA,MAAA,EAAQ,IAAI,CAAA,CAAA;AACjD,IAAM,MAAA,YAAA,GAAe,aAAc,CAAA,KAAA,GAAQ,CAAC,CAAA,CAAA;AAC5C,IAAM,MAAA,YAAA,GAAe,cAAc,KAAK,CAAA,CAAA;AACxC,IAAM,MAAA,SAAA,GAAY,OAAO,KAAK,CAAA,CAAA;AAC9B,IAAA,MAAM,OAAU,GAAA,IAAA,CAAK,eAAgB,CAAA,KAAA,GAAQ,CAAG,EAAA,CAAA,GAAA,CAAK,IAAO,GAAA,SAAA,KAAc,MAAO,CAAA,KAAA,GAAQ,CAAC,CAAA,GAAI,SAAU,CAAA,CAAA,CAAA;AAExG,IAAA,IAAI,SAAS,CAAG,EAAA;AACZ,MAAI,IAAA,KAAA,IAASA,cAAS,GAAK,EAAA;AACvB,QAAA,MAAM,gBAAmB,GAAA,cAAA,CAAA;AAEzB,QAAI,IAAA,gBAAA,CAAiB,SAAS,IAAM,EAAA;AAEhC,UAAA,MAAM,gBAAgB,gBAAiB,CAAA,QAAA,CAAA;AAEvC,UAAA,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,WAAA,EAAa,CAAK,EAAA,EAAA;AAClC,YAAM,MAAA,IAAA,GAAO,aAAa,CAAC,CAAA,CAAA;AAE3B,YAAO,MAAA,CAAA,CAAC,KAAK,IAAQ,GAAA,CAAA,YAAA,CAAa,CAAC,CAAI,GAAA,IAAA,IAAQ,OAAU,GAAA,aAAA,CAAc,CAAC,CAAA,CAAA;AAAA,WAC5E;AAAA,SACG,MAAA;AAEH,UAAA,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,WAAA,EAAa,CAAK,EAAA,EAAA;AAClC,YAAM,MAAA,IAAA,GAAO,aAAa,CAAC,CAAA,CAAA;AAE3B,YAAA,MAAA,CAAO,CAAC,CAAK,IAAA,IAAA,GAAA,CAAQ,YAAa,CAAA,CAAC,IAAI,IAAQ,IAAA,OAAA,CAAA;AAAA,WACnD;AAAA,SACJ;AAAA,OACG,MAAA;AACH,QAAA,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,WAAA,EAAa,CAAK,EAAA,EAAA;AAClC,UAAM,MAAA,IAAA,GAAO,aAAa,CAAC,CAAA,CAAA;AAE3B,UAAA,MAAA,CAAO,CAAC,CAAI,GAAA,IAAA,GAAA,CAAQ,YAAa,CAAA,CAAC,IAAI,IAAQ,IAAA,OAAA,CAAA;AAAA,SAClD;AAAA,OACJ;AAAA,KACG,MAAA;AACH,MAAA,QAAQ,KAAO;AAAA,QACX,KAAKA,cAAS,KAAO,EAAA;AACjB,UAAA,MAAMK,iBAAmB,GAAA,cAAA,CAAA;AAEzB,UAAIA,IAAAA,iBAAAA,CAAiB,SAAS,IAAM,EAAA;AAEhC,YAAA,MAAM,gBAAgBA,iBAAiB,CAAA,QAAA,CAAA;AAEvC,YAAA,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,WAAA,EAAa,CAAK,EAAA,EAAA;AAClC,cAAM,MAAA,IAAA,GAAO,aAAa,CAAC,CAAA,CAAA;AAC3B,cAAM,MAAA,KAAA,GAAQ,cAAc,CAAC,CAAA,CAAA;AAE7B,cAAO,MAAA,CAAA,CAAC,IAAI,KAAS,GAAA,CAAA,IAAA,GAAA,CAAQ,aAAa,CAAC,CAAA,GAAI,IAAQ,IAAA,OAAA,GAAU,KAAS,IAAA,KAAA,CAAA;AAAA,aAC9E;AAAA,WACG,MAAA;AAEH,YAAA,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,WAAA,EAAa,CAAK,EAAA,EAAA;AAClC,cAAM,MAAA,IAAA,GAAO,aAAa,CAAC,CAAA,CAAA;AAE3B,cAAA,MAAA,CAAO,CAAC,CAAK,GAAA,CAAA,IAAA,GAAA,CAAQ,aAAa,CAAC,CAAA,GAAI,QAAQ,OAAW,IAAA,KAAA,CAAA;AAAA,aAC9D;AAAA,WACJ;AACA,UAAA,MAAA;AAAA,SACJ;AAAA,QACA,KAAKL,aAAS,CAAA,KAAA,CAAA;AAAA,QACd,KAAKA,aAAS,CAAA,OAAA;AACV,UAAA,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,WAAA,EAAa,CAAK,EAAA,EAAA;AAClC,YAAM,MAAA,IAAA,GAAO,aAAa,CAAC,CAAA,CAAA;AAE3B,YAAO,MAAA,CAAA,CAAC,CAAM,IAAA,CAAA,IAAA,GAAA,CAAQ,YAAa,CAAA,CAAC,IAAI,IAAQ,IAAA,OAAA,GAAU,MAAO,CAAA,CAAC,CAAK,IAAA,KAAA,CAAA;AAAA,WAC3E;AACA,UAAA,MAAA;AAAA,QACJ,KAAKA,aAAS,CAAA,GAAA;AACV,UAAA,MAAM,gBAAmB,GAAA,cAAA,CAAA;AAEzB,UAAI,IAAA,gBAAA,CAAiB,SAAS,IAAM,EAAA;AAEhC,YAAA,MAAM,gBAAgB,gBAAiB,CAAA,QAAA,CAAA;AAEvC,YAAA,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,WAAA,EAAa,CAAK,EAAA,EAAA;AAClC,cAAM,MAAA,IAAA,GAAO,aAAa,CAAC,CAAA,CAAA;AAE3B,cAAO,MAAA,CAAA,CAAC,CAAM,IAAA,CAAA,IAAA,GAAA,CAAQ,YAAa,CAAA,CAAC,IAAI,IAAQ,IAAA,OAAA,GAAU,aAAc,CAAA,CAAC,CAAK,IAAA,KAAA,CAAA;AAAA,aAClF;AAAA,WACG,MAAA;AAEH,YAAA,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,WAAA,EAAa,CAAK,EAAA,EAAA;AAClC,cAAM,MAAA,IAAA,GAAO,aAAa,CAAC,CAAA,CAAA;AAE3B,cAAA,MAAA,CAAO,CAAC,CAAM,IAAA,CAAA,IAAA,GAAA,CAAQ,aAAa,CAAC,CAAA,GAAI,QAAQ,OAAW,IAAA,KAAA,CAAA;AAAA,aAC/D;AAAA,WACJ;AAAA,OACR;AAAA,KACJ;AAAA,GACJ;AACJ,CAAA;AAMO,MAAM,aAAkC,CAAA;AAAA,EAQ3C,YAAY,UAAoB,EAAA;AADhC,IAAA,IAAA,CAAA,IAAA,GAA+C,EAAC,CAAA;AAE5C,IAAK,IAAA,CAAA,MAAA,GAASF,UAAM,CAAA,aAAA,CAAc,UAAU,CAAA,CAAA;AAC5C,IAAK,IAAA,CAAA,MAAA,GAAS,IAAI,KAAA,CAAa,UAAU,CAAA,CAAA;AAAA,GAC7C;AAAA,EAEA,aAAgB,GAAA;AACZ,IAAA,OAAO,CAAsB,gBAAA,EAAA,CAAA;AAAA,GACjC;AAAA;AAAA,EAGA,aAAgB,GAAA;AACZ,IAAA,OAAO,KAAK,MAAO,CAAA,MAAA,CAAA;AAAA,GACvB;AAAA;AAAA,EAGA,QAAA,CAAS,YAAoB,KAAc,EAAA;AACvC,IAAA,IAAA,CAAK,IAAK,CAAA,IAAA,CAAK,EAAE,UAAA,EAAY,OAAO,CAAA,CAAA;AACpC,IAAK,IAAA,CAAA,MAAA,CAAO,UAAU,CAAA,GAAI,KAAM,CAAA,IAAA,CAAA;AAChC,IAAK,IAAA,CAAA,MAAA,CAAO,UAAU,CAAI,GAAA,KAAA,CAAA;AAAA,GAC9B;AAAA;AAAA,EAGA,MAAM,QAAoB,EAAA,QAAA,EAAkB,MAAc,WAA2B,EAAA,KAAA,EAAe,OAAiB,SAAyB,EAAA;AAC1I,IAAA,IAAI,WAAe,IAAA,IAAA;AAAM,MAAA,OAAA;AACzB,IAAA,MAAM,SAAS,IAAK,CAAA,MAAA,CAAA;AACpB,IAAM,MAAA,UAAA,GAAa,KAAK,MAAO,CAAA,MAAA,CAAA;AAE/B,IAAA,IAAI,WAAW,IAAM,EAAA;AAEjB,MAAK,IAAA,CAAA,KAAA,CAAM,UAAU,QAAU,EAAA,MAAA,CAAO,WAAW,WAAa,EAAA,KAAA,EAAO,OAAO,SAAS,CAAA,CAAA;AACrF,MAAW,QAAA,GAAA,CAAA,CAAA,CAAA;AAAA,KACJ,MAAA,IAAA,QAAA,IAAY,MAAO,CAAA,UAAA,GAAa,CAAC,CAAA;AAExC,MAAA,OAAA;AACJ,IAAI,IAAA,IAAA,GAAO,OAAO,CAAC,CAAA;AAAG,MAAA,OAAA;AAEtB,IAAA,IAAI,KAAQ,GAAA,CAAA,CAAA;AAEZ,IAAI,IAAA,QAAA,GAAW,OAAO,CAAC,CAAA;AAAG,MAAQ,KAAA,GAAA,CAAA,CAAA;AAAA,SAC7B;AACD,MAAQ,KAAA,GAAA,SAAA,CAAU,YAAa,CAAA,MAAA,EAAQ,QAAQ,CAAA,CAAA;AAC/C,MAAM,MAAA,SAAA,GAAY,OAAO,KAAK,CAAA,CAAA;AAE9B,MAAA,OAAO,QAAQ,CAAG,EAAA;AAEd,QAAI,IAAA,MAAA,CAAO,KAAQ,GAAA,CAAC,CAAK,IAAA,SAAA;AAAW,UAAA,MAAA;AACpC,QAAA,KAAA,EAAA,CAAA;AAAA,OACJ;AAAA,KACJ;AACA,IAAA,OAAO,KAAQ,GAAA,UAAA,IAAc,IAAQ,IAAA,MAAA,CAAO,KAAK,CAAG,EAAA,KAAA,EAAA;AAAS,MAAA,WAAA,CAAY,IAAK,CAAA,IAAA,CAAK,MAAO,CAAA,KAAK,CAAC,CAAA,CAAA;AAAA,GACpG;AACJ,CAAA;AAMO,MAAM,iBAAsC,CAAA;AAAA,EAQ/C,YAAY,UAAoB,EAAA;AADhC,IAAA,IAAA,CAAA,IAAA,GAAyE,EAAC,CAAA;AAEtE,IAAK,IAAA,CAAA,MAAA,GAASA,UAAM,CAAA,aAAA,CAAc,UAAU,CAAA,CAAA;AAC5C,IAAK,IAAA,CAAA,UAAA,GAAa,IAAI,KAAA,CAAqB,UAAU,CAAA,CAAA;AAAA,GACzD;AAAA,EAEA,aAAgB,GAAA;AACZ,IAAA,OAAO,CAA0B,oBAAA,EAAA,CAAA;AAAA,GACrC;AAAA;AAAA,EAGA,aAAgB,GAAA;AACZ,IAAA,OAAO,KAAK,MAAO,CAAA,MAAA,CAAA;AAAA,GACvB;AAAA;AAAA;AAAA;AAAA,EAKA,QAAA,CAAS,UAAoB,EAAA,IAAA,EAAc,SAA0B,EAAA;AACjE,IAAA,IAAA,CAAK,KAAK,IAAK,CAAA,EAAE,UAAY,EAAA,IAAA,EAAM,WAAW,CAAA,CAAA;AAC9C,IAAK,IAAA,CAAA,MAAA,CAAO,UAAU,CAAI,GAAA,IAAA,CAAA;AAC1B,IAAK,IAAA,CAAA,UAAA,CAAW,UAAU,CAAI,GAAA,SAAA,CAAA;AAAA,GAClC;AAAA,EAEA,MAAM,QAAoB,EAAA,QAAA,EAAkB,MAAc,WAA2B,EAAA,KAAA,EAAe,OAAiB,SAAyB,EAAA;AAC1I,IAAA,MAAM,YAAyB,QAAS,CAAA,SAAA,CAAA;AACxC,IAAA,MAAM,QAAqB,QAAS,CAAA,KAAA,CAAA;AAEpC,IAAA,IAAI,SAAa,IAAAI,iBAAA,CAAa,MAAU,IAAA,KAAA,IAASF,cAAS,KAAO,EAAA;AAC7D,MAAMF,UAAA,CAAA,SAAA,CAAU,SAAS,KAAO,EAAA,CAAA,EAAG,SAAS,SAAW,EAAA,CAAA,EAAG,QAAS,CAAA,KAAA,CAAM,MAAM,CAAA,CAAA;AAE/E,MAAA,OAAA;AAAA,KACJ;AAEA,IAAA,MAAM,SAAS,IAAK,CAAA,MAAA,CAAA;AAEpB,IAAI,IAAA,IAAA,GAAO,MAAO,CAAA,CAAC,CAAG,EAAA;AAClB,MAAA,IAAI,KAAS,IAAAE,aAAA,CAAS,KAAS,IAAA,KAAA,IAASA,aAAS,CAAA,KAAA;AAAO,QAAMF,UAAA,CAAA,SAAA,CAAU,SAAS,KAAO,EAAA,CAAA,EAAG,SAAS,SAAW,EAAA,CAAA,EAAG,QAAS,CAAA,KAAA,CAAM,MAAM,CAAA,CAAA;AAEvI,MAAA,OAAA;AAAA,KACJ;AAEA,IAAA,IAAI,KAAQ,GAAA,CAAA,CAAA;AAEZ,IAAA,IAAI,IAAQ,IAAA,MAAA,CAAO,MAAO,CAAA,MAAA,GAAS,CAAC,CAAA;AAEhC,MAAA,KAAA,GAAQ,OAAO,MAAS,GAAA,CAAA,CAAA;AAAA;AACvB,MAAA,KAAA,GAAQ,SAAU,CAAA,YAAA,CAAa,MAAQ,EAAA,IAAI,CAAI,GAAA,CAAA,CAAA;AAEpD,IAAM,MAAA,qBAAA,GAAwB,IAAK,CAAA,UAAA,CAAW,KAAK,CAAA,CAAA;AAEnD,IAAA,IAAI,qBAAyB,IAAA,IAAA;AAAM,MAAAA,UAAA,CAAM,UAAU,KAAO,EAAA,CAAA,EAAG,SAAW,EAAA,CAAA,EAAG,MAAM,MAAM,CAAA,CAAA;AAAA,SAClF;AACD,MAAA,KAAA,IAAS,IAAI,CAAG,EAAA,CAAA,GAAI,qBAAsB,CAAA,MAAA,EAAQ,IAAI,CAAG,EAAA,CAAA,EAAA;AAAK,QAAA,SAAA,CAAU,CAAC,CAAA,GAAI,KAAM,CAAA,qBAAA,CAAsB,CAAC,CAAC,CAAA,CAAA;AAAA,KAC/G;AAAA,GACJ;AACJ,CAAA;AAOO,MAAM,qBAAA,GAAN,cAAmC,aAAc,CAAA;AAAA,EAqBpD,YAAY,UAAoB,EAAA;AAC5B,IAAA,KAAA,CAAM,UAAU,CAAA,CAAA;AAFpB;AAAA,IAAA,IAAA,CAAA,IAAA,GAAmF,EAAC,CAAA;AAGhF,IAAA,IAAA,CAAK,MAAS,GAAAA,UAAA,CAAM,aAAc,CAAA,UAAA,GAAa,sBAAqB,OAAO,CAAA,CAAA;AAAA,GAC/E;AAAA,EAEA,aAAgB,GAAA;AACZ,IAAQ,OAAA,CAAA,CAAA,uBAA6B,MAAM,IAAK,CAAA,iBAAA,CAAA;AAAA,GACpD;AAAA;AAAA,EAGA,QAAS,CAAA,UAAA,EAAoB,IAAc,EAAA,GAAA,EAAa,aAAuB,EAAA;AAC3E,IAAA,IAAA,CAAK,KAAK,IAAK,CAAA,EAAE,YAAY,IAAM,EAAA,GAAA,EAAK,eAAe,CAAA,CAAA;AACvD,IAAA,UAAA,IAAc,qBAAqB,CAAA,OAAA,CAAA;AACnC,IAAK,IAAA,CAAA,MAAA,CAAO,UAAU,CAAI,GAAA,IAAA,CAAA;AAC1B,IAAA,IAAA,CAAK,MAAO,CAAA,UAAA,GAAa,qBAAqB,CAAA,GAAG,CAAI,GAAA,GAAA,CAAA;AACrD,IAAA,IAAA,CAAK,MAAO,CAAA,UAAA,GAAa,qBAAqB,CAAA,cAAc,CAAI,GAAA,aAAA,CAAA;AAAA,GACpE;AAAA,EAEA,MAAM,QAAoB,EAAA,QAAA,EAAkB,MAAc,WAA2B,EAAA,KAAA,EAAe,OAAiB,SAAyB,EAAA;AAC1I,IAAA,MAAM,SAAS,IAAK,CAAA,MAAA,CAAA;AACpB,IAAA,MAAM,UAA2B,GAAA,QAAA,CAAS,aAAc,CAAA,IAAA,CAAK,iBAAiB,CAAA,CAAA;AAE9E,IAAA,IAAI,CAAC,UAAW,CAAA,MAAA;AAAQ,MAAA,OAAA;AAExB,IAAI,IAAA,IAAA,GAAO,MAAO,CAAA,CAAC,CAAG,EAAA;AAClB,MAAA,QAAQ,KAAO;AAAA,QACX,KAAKE,aAAS,CAAA,KAAA;AACV,UAAW,UAAA,CAAA,GAAA,GAAM,WAAW,IAAK,CAAA,GAAA,CAAA;AACjC,UAAW,UAAA,CAAA,QAAA,GAAW,WAAW,IAAK,CAAA,QAAA,CAAA;AACtC,UAAW,UAAA,CAAA,aAAA,GAAgB,WAAW,IAAK,CAAA,aAAA,CAAA;AAC3C,UAAW,UAAA,CAAA,QAAA,GAAW,WAAW,IAAK,CAAA,QAAA,CAAA;AACtC,UAAW,UAAA,CAAA,OAAA,GAAU,WAAW,IAAK,CAAA,OAAA,CAAA;AAErC,UAAA,OAAA;AAAA,QACJ,KAAKA,aAAS,CAAA,KAAA;AACV,UAAA,UAAA,CAAW,GAAQ,IAAA,CAAA,UAAA,CAAW,IAAK,CAAA,GAAA,GAAM,WAAW,GAAO,IAAA,KAAA,CAAA;AAC3D,UAAA,UAAA,CAAW,QAAa,IAAA,CAAA,UAAA,CAAW,IAAK,CAAA,QAAA,GAAW,WAAW,QAAY,IAAA,KAAA,CAAA;AAC1E,UAAW,UAAA,CAAA,aAAA,GAAgB,WAAW,IAAK,CAAA,aAAA,CAAA;AAC3C,UAAW,UAAA,CAAA,QAAA,GAAW,WAAW,IAAK,CAAA,QAAA,CAAA;AACtC,UAAW,UAAA,CAAA,OAAA,GAAU,WAAW,IAAK,CAAA,OAAA,CAAA;AAAA,OAC7C;AAEA,MAAA,OAAA;AAAA,KACJ;AAEA,IAAA,IAAI,QAAQ,MAAO,CAAA,MAAA,CAAO,MAAS,GAAA,qBAAA,CAAqB,OAAO,CAAG,EAAA;AAE9D,MAAI,IAAA,KAAA,KAAUA,cAAS,KAAO,EAAA;AAC1B,QAAA,UAAA,CAAW,GAAM,GAAA,UAAA,CAAW,IAAK,CAAA,GAAA,GAAA,CAAO,MAAO,CAAA,MAAA,CAAO,MAAS,GAAA,qBAAA,CAAqB,QAAQ,CAAA,GAAI,UAAW,CAAA,IAAA,CAAK,GAAO,IAAA,KAAA,CAAA;AACvH,QAAA,UAAA,CAAW,QAAW,GAAA,UAAA,CAAW,IAAK,CAAA,QAAA,GAAA,CAAY,MAAO,CAAA,MAAA,CAAO,MAAS,GAAA,qBAAA,CAAqB,aAAa,CAAA,GAAI,UAAW,CAAA,IAAA,CAAK,QAAY,IAAA,KAAA,CAAA;AAC3I,QAAI,IAAA,SAAA,KAAcE,kBAAa,MAAQ,EAAA;AACnC,UAAW,UAAA,CAAA,aAAA,GAAgB,WAAW,IAAK,CAAA,aAAA,CAAA;AAC3C,UAAW,UAAA,CAAA,QAAA,GAAW,WAAW,IAAK,CAAA,QAAA,CAAA;AACtC,UAAW,UAAA,CAAA,OAAA,GAAU,WAAW,IAAK,CAAA,OAAA,CAAA;AAAA,SAClC,MAAA;AACH,UAAA,UAAA,CAAW,aAAgB,GAAA,MAAA,CAAO,MAAO,CAAA,MAAA,GAAS,sBAAqB,mBAAmB,CAAA,CAAA;AAC1F,UAAA,UAAA,CAAW,WAAW,MAAO,CAAA,MAAA,CAAO,MAAS,GAAA,qBAAA,CAAqB,aAAa,CAAM,KAAA,CAAA,CAAA;AACrF,UAAA,UAAA,CAAW,UAAU,MAAO,CAAA,MAAA,CAAO,MAAS,GAAA,qBAAA,CAAqB,YAAY,CAAM,KAAA,CAAA,CAAA;AAAA,SACvF;AAAA,OACG,MAAA;AACH,QAAW,UAAA,CAAA,GAAA,IAAA,CAAQ,OAAO,MAAO,CAAA,MAAA,GAAS,sBAAqB,QAAQ,CAAA,GAAI,WAAW,GAAO,IAAA,KAAA,CAAA;AAC7F,QAAW,UAAA,CAAA,QAAA,IAAA,CAAa,OAAO,MAAO,CAAA,MAAA,GAAS,sBAAqB,aAAa,CAAA,GAAI,WAAW,QAAY,IAAA,KAAA,CAAA;AAC5G,QAAI,IAAA,SAAA,KAAcA,kBAAa,KAAO,EAAA;AAClC,UAAA,UAAA,CAAW,aAAgB,GAAA,MAAA,CAAO,MAAO,CAAA,MAAA,GAAS,sBAAqB,mBAAmB,CAAA,CAAA;AAC1F,UAAA,UAAA,CAAW,WAAW,MAAO,CAAA,MAAA,CAAO,MAAS,GAAA,qBAAA,CAAqB,aAAa,CAAM,KAAA,CAAA,CAAA;AACrF,UAAA,UAAA,CAAW,UAAU,MAAO,CAAA,MAAA,CAAO,MAAS,GAAA,qBAAA,CAAqB,YAAY,CAAM,KAAA,CAAA,CAAA;AAAA,SACvF;AAAA,OACJ;AAEA,MAAA,OAAA;AAAA,KACJ;AAGA,IAAA,MAAM,QAAQ,SAAU,CAAA,YAAA,CAAa,MAAQ,EAAA,IAAA,EAAM,sBAAqB,OAAO,CAAA,CAAA;AAC/E,IAAA,MAAM,GAAM,GAAA,MAAA,CAAO,KAAQ,GAAA,qBAAA,CAAqB,QAAQ,CAAA,CAAA;AACxD,IAAM,MAAA,SAAA,GAAY,OAAO,KAAK,CAAA,CAAA;AAC9B,IAAA,MAAM,OAAU,GAAA,IAAA,CAAK,eAAgB,CAAA,KAAA,GAAQ,sBAAqB,OAAU,GAAA,CAAA,EAAG,CAAK,GAAA,CAAA,IAAA,GAAO,cAAc,MAAO,CAAA,KAAA,GAAQ,qBAAqB,CAAA,SAAS,IAAI,SAAU,CAAA,CAAA,CAAA;AAEpK,IAAW,UAAA,CAAA,GAAA,IAAA,CAAQ,GAAO,GAAA,CAAA,MAAA,CAAO,KAAQ,GAAA,qBAAA,CAAqB,GAAG,CAAI,GAAA,GAAA,IAAO,OAAU,GAAA,UAAA,CAAW,GAAO,IAAA,KAAA,CAAA;AACxG,IAAA,UAAA,CAAW,gBAAgB,IAAK,CAAA,KAAA,CAAM,OAAO,KAAQ,GAAA,qBAAA,CAAqB,mBAAmB,CAAC,CAAA,CAAA;AAAA,GAClG;AACJ,CAAA,CAAA;AAtGO,IAAM,oBAAN,GAAA,sBAAA;AAAM,oBAAA,CACF,OAAU,GAAA,CAAA,CAAA;AADR,oBAAA,CAEF,SAAY,GAAA,CAAA,CAAA,CAAA;AAFV,oBAAA,CAGF,QAAW,GAAA,CAAA,CAAA,CAAA;AAHT,oBAAA,CAIF,aAAgB,GAAA,CAAA,CAAA,CAAA;AAJd,oBAAA,CAKF,mBAAsB,GAAA,CAAA,CAAA,CAAA;AALpB,oBAAA,CAMF,aAAgB,GAAA,CAAA,CAAA,CAAA;AANd,oBAAA,CAOF,YAAe,GAAA,CAAA,CAAA,CAAA;AAPb,oBAAA,CAQF,GAAM,GAAA,CAAA,CAAA;AARJ,oBAAA,CASF,QAAW,GAAA,CAAA,CAAA;AATT,oBAAA,CAUF,cAAiB,GAAA,CAAA,CAAA;AAVf,oBAAA,CAWF,QAAW,GAAA,CAAA,CAAA;AAXT,oBAAA,CAYF,OAAU,GAAA,CAAA,CAAA;AAiGd,MAAM,4BAAA,GAAN,cAA0C,aAAc,CAAA;AAAA,EAmB3D,YAAY,UAAoB,EAAA;AAC5B,IAAA,KAAA,CAAM,UAAU,CAAA,CAAA;AAFpB;AAAA,IAAA,IAAA,CAAA,IAAA,GAA4H,EAAC,CAAA;AAGzH,IAAA,IAAA,CAAK,MAAS,GAAAJ,UAAA,CAAM,aAAc,CAAA,UAAA,GAAa,6BAA4B,OAAO,CAAA,CAAA;AAAA,GACtF;AAAA,EAEA,aAAgB,GAAA;AACZ,IAAQ,OAAA,CAAA,EAAA,8BAAoC,MAAM,IAAK,CAAA,wBAAA,CAAA;AAAA,GAC3D;AAAA;AAAA,EAGA,SAAS,UAAoB,EAAA,IAAA,EAAc,SAAmB,EAAA,YAAA,EAAsB,UAAkB,QAAkB,EAAA;AACpH,IAAK,IAAA,CAAA,IAAA,CAAK,KAAK,EAAE,UAAA,EAAY,MAAM,SAAW,EAAA,YAAA,EAAc,QAAU,EAAA,QAAA,EAAU,CAAA,CAAA;AAChF,IAAA,UAAA,IAAc,4BAA4B,CAAA,OAAA,CAAA;AAC1C,IAAK,IAAA,CAAA,MAAA,CAAO,UAAU,CAAI,GAAA,IAAA,CAAA;AAC1B,IAAA,IAAA,CAAK,MAAO,CAAA,UAAA,GAAa,4BAA4B,CAAA,MAAM,CAAI,GAAA,SAAA,CAAA;AAC/D,IAAA,IAAA,CAAK,MAAO,CAAA,UAAA,GAAa,4BAA4B,CAAA,SAAS,CAAI,GAAA,YAAA,CAAA;AAClE,IAAA,IAAA,CAAK,MAAO,CAAA,UAAA,GAAa,4BAA4B,CAAA,KAAK,CAAI,GAAA,QAAA,CAAA;AAC9D,IAAA,IAAA,CAAK,MAAO,CAAA,UAAA,GAAa,4BAA4B,CAAA,KAAK,CAAI,GAAA,QAAA,CAAA;AAAA,GAClE;AAAA,EAEA,MAAM,QAAoB,EAAA,QAAA,EAAkB,MAAc,WAA2B,EAAA,KAAA,EAAe,OAAiB,SAAyB,EAAA;AAC1I,IAAA,MAAM,SAAS,IAAK,CAAA,MAAA,CAAA;AAEpB,IAAA,MAAM,UAAkC,GAAA,QAAA,CAAS,oBAAqB,CAAA,IAAA,CAAK,wBAAwB,CAAA,CAAA;AAEnG,IAAA,IAAI,CAAC,UAAW,CAAA,MAAA;AAAQ,MAAA,OAAA;AACxB,IAAI,IAAA,IAAA,GAAO,MAAO,CAAA,CAAC,CAAG,EAAA;AAClB,MAAA,MAAM,OAAO,UAAW,CAAA,IAAA,CAAA;AAExB,MAAA,QAAQ,KAAO;AAAA,QACX,KAAKE,aAAS,CAAA,KAAA;AACV,UAAA,UAAA,CAAW,YAAY,IAAK,CAAA,SAAA,CAAA;AAC5B,UAAA,UAAA,CAAW,eAAe,IAAK,CAAA,YAAA,CAAA;AAC/B,UAAA,UAAA,CAAW,WAAW,IAAK,CAAA,QAAA,CAAA;AAC3B,UAAA,UAAA,CAAW,WAAW,IAAK,CAAA,QAAA,CAAA;AAE3B,UAAA,OAAA;AAAA,QACJ,KAAKA,aAAS,CAAA,KAAA;AACV,UAAA,UAAA,CAAW,SAAc,IAAA,CAAA,IAAA,CAAK,SAAY,GAAA,UAAA,CAAW,SAAa,IAAA,KAAA,CAAA;AAClE,UAAA,UAAA,CAAW,YAAiB,IAAA,CAAA,IAAA,CAAK,YAAe,GAAA,UAAA,CAAW,YAAgB,IAAA,KAAA,CAAA;AAC3E,UAAA,UAAA,CAAW,QAAa,IAAA,CAAA,IAAA,CAAK,QAAW,GAAA,UAAA,CAAW,QAAY,IAAA,KAAA,CAAA;AAC/D,UAAA,UAAA,CAAW,QAAa,IAAA,CAAA,IAAA,CAAK,QAAW,GAAA,UAAA,CAAW,QAAY,IAAA,KAAA,CAAA;AAAA,OACvE;AAEA,MAAA,OAAA;AAAA,KACJ;AAEA,IAAA,IAAI,MAAS,GAAA,CAAA,CAAA;AACb,IAAA,IAAI,SAAY,GAAA,CAAA,CAAA;AAChB,IAAA,IAAI,KAAQ,GAAA,CAAA,CAAA;AACZ,IAAA,IAAI,KAAQ,GAAA,CAAA,CAAA;AAEZ,IAAA,IAAI,QAAQ,MAAO,CAAA,MAAA,CAAO,MAAS,GAAA,4BAAA,CAA4B,OAAO,CAAG,EAAA;AAErE,MAAA,MAAM,IAAI,MAAO,CAAA,MAAA,CAAA;AAEjB,MAAS,MAAA,GAAA,MAAA,CAAO,CAAI,GAAA,4BAAA,CAA4B,WAAW,CAAA,CAAA;AAC3D,MAAY,SAAA,GAAA,MAAA,CAAO,CAAI,GAAA,4BAAA,CAA4B,cAAc,CAAA,CAAA;AACjE,MAAQ,KAAA,GAAA,MAAA,CAAO,CAAI,GAAA,4BAAA,CAA4B,UAAU,CAAA,CAAA;AACzD,MAAQ,KAAA,GAAA,MAAA,CAAO,CAAI,GAAA,4BAAA,CAA4B,UAAU,CAAA,CAAA;AAAA,KACtD,MAAA;AAEH,MAAA,MAAM,QAAQ,SAAU,CAAA,YAAA,CAAa,MAAQ,EAAA,IAAA,EAAM,6BAA4B,OAAO,CAAA,CAAA;AAEtF,MAAS,MAAA,GAAA,MAAA,CAAO,KAAQ,GAAA,4BAAA,CAA4B,WAAW,CAAA,CAAA;AAC/D,MAAY,SAAA,GAAA,MAAA,CAAO,KAAQ,GAAA,4BAAA,CAA4B,cAAc,CAAA,CAAA;AACrE,MAAQ,KAAA,GAAA,MAAA,CAAO,KAAQ,GAAA,4BAAA,CAA4B,UAAU,CAAA,CAAA;AAC7D,MAAQ,KAAA,GAAA,MAAA,CAAO,KAAQ,GAAA,4BAAA,CAA4B,UAAU,CAAA,CAAA;AAC7D,MAAM,MAAA,SAAA,GAAY,OAAO,KAAK,CAAA,CAAA;AAC9B,MAAA,MAAM,UAAU,IAAK,CAAA,eAAA;AAAA,QACjB,KAAA,GAAQ,6BAA4B,OAAU,GAAA,CAAA;AAAA,QAC9C,KAAK,IAAO,GAAA,SAAA,KAAc,OAAO,KAAQ,GAAA,4BAAA,CAA4B,SAAS,CAAI,GAAA,SAAA,CAAA;AAAA,OACtF,CAAA;AAEA,MAAA,MAAA,IAAA,CAAW,MAAO,CAAA,KAAA,GAAQ,4BAA4B,CAAA,MAAM,IAAI,MAAU,IAAA,OAAA,CAAA;AAC1E,MAAA,SAAA,IAAA,CAAc,MAAO,CAAA,KAAA,GAAQ,4BAA4B,CAAA,SAAS,IAAI,SAAa,IAAA,OAAA,CAAA;AACnF,MAAA,KAAA,IAAA,CAAU,MAAO,CAAA,KAAA,GAAQ,4BAA4B,CAAA,KAAK,IAAI,KAAS,IAAA,OAAA,CAAA;AACvE,MAAA,KAAA,IAAA,CAAU,MAAO,CAAA,KAAA,GAAQ,4BAA4B,CAAA,KAAK,IAAI,KAAS,IAAA,OAAA,CAAA;AAAA,KAC3E;AACA,IAAI,IAAA,KAAA,IAASA,cAAS,KAAO,EAAA;AACzB,MAAA,MAAM,OAAO,UAAW,CAAA,IAAA,CAAA;AAExB,MAAA,UAAA,CAAW,SAAY,GAAA,IAAA,CAAK,SAAa,GAAA,CAAA,MAAA,GAAS,KAAK,SAAa,IAAA,KAAA,CAAA;AACpE,MAAA,UAAA,CAAW,YAAe,GAAA,IAAA,CAAK,YAAgB,GAAA,CAAA,SAAA,GAAY,KAAK,YAAgB,IAAA,KAAA,CAAA;AAChF,MAAA,UAAA,CAAW,QAAW,GAAA,IAAA,CAAK,QAAY,GAAA,CAAA,KAAA,GAAQ,KAAK,QAAY,IAAA,KAAA,CAAA;AAChE,MAAA,UAAA,CAAW,QAAW,GAAA,IAAA,CAAK,QAAY,GAAA,CAAA,KAAA,GAAQ,KAAK,QAAY,IAAA,KAAA,CAAA;AAAA,KAC7D,MAAA;AACH,MAAW,UAAA,CAAA,SAAA,IAAA,CAAc,MAAS,GAAA,UAAA,CAAW,SAAa,IAAA,KAAA,CAAA;AAC1D,MAAW,UAAA,CAAA,YAAA,IAAA,CAAiB,SAAY,GAAA,UAAA,CAAW,YAAgB,IAAA,KAAA,CAAA;AACnE,MAAW,UAAA,CAAA,QAAA,IAAA,CAAa,KAAQ,GAAA,UAAA,CAAW,QAAY,IAAA,KAAA,CAAA;AACvD,MAAW,UAAA,CAAA,QAAA,IAAA,CAAa,KAAQ,GAAA,UAAA,CAAW,QAAY,IAAA,KAAA,CAAA;AAAA,KAC3D;AAAA,GACJ;AACJ,CAAA,CAAA;AAhHO,IAAM,2BAAN,GAAA,6BAAA;AAAM,2BAAA,CACF,OAAU,GAAA,CAAA,CAAA;AADR,2BAAA,CAEF,SAAY,GAAA,CAAA,CAAA,CAAA;AAFV,2BAAA,CAGF,WAAc,GAAA,CAAA,CAAA,CAAA;AAHZ,2BAAA,CAIF,cAAiB,GAAA,CAAA,CAAA,CAAA;AAJf,2BAAA,CAKF,UAAa,GAAA,CAAA,CAAA,CAAA;AALX,2BAAA,CAMF,UAAa,GAAA,CAAA,CAAA,CAAA;AANX,2BAAA,CAOF,MAAS,GAAA,CAAA,CAAA;AAPP,2BAAA,CAQF,SAAY,GAAA,CAAA,CAAA;AARV,2BAAA,CASF,KAAQ,GAAA,CAAA,CAAA;AATN,2BAAA,CAUF,KAAQ,GAAA,CAAA,CAAA;AA4GZ,MAAM,+BAAA,GAAN,cAA6C,aAAc,CAAA;AAAA,EAa9D,YAAY,UAAoB,EAAA;AAC5B,IAAA,KAAA,CAAM,UAAU,CAAA,CAAA;AAFpB;AAAA,IAAA,IAAA,CAAA,IAAA,GAA8D,EAAC,CAAA;AAG3D,IAAA,IAAA,CAAK,MAAS,GAAAF,UAAA,CAAM,aAAc,CAAA,UAAA,GAAa,gCAA+B,OAAO,CAAA,CAAA;AAAA,GACzF;AAAA,EAEA,aAAgB,GAAA;AACZ,IAAQ,OAAA,CAAA,EAAA,iCAAuC,MAAM,IAAK,CAAA,mBAAA,CAAA;AAAA,GAC9D;AAAA;AAAA,EAGA,QAAA,CAAS,UAAoB,EAAA,IAAA,EAAc,KAAe,EAAA;AACtD,IAAA,IAAA,CAAK,KAAK,IAAK,CAAA,EAAE,UAAY,EAAA,IAAA,EAAM,OAAO,CAAA,CAAA;AAC1C,IAAA,UAAA,IAAc,+BAA+B,CAAA,OAAA,CAAA;AAC7C,IAAK,IAAA,CAAA,MAAA,CAAO,UAAU,CAAI,GAAA,IAAA,CAAA;AAC1B,IAAA,IAAA,CAAK,MAAO,CAAA,UAAA,GAAa,+BAA+B,CAAA,KAAK,CAAI,GAAA,KAAA,CAAA;AAAA,GACrE;AAAA,EAEA,MAAM,QAAoB,EAAA,QAAA,EAAkB,MAAc,WAA2B,EAAA,KAAA,EAAe,OAAiB,SAAyB,EAAA;AAC1I,IAAA,MAAM,SAAS,IAAK,CAAA,MAAA,CAAA;AACpB,IAAA,MAAM,UAA6B,GAAA,QAAA,CAAS,eAAgB,CAAA,IAAA,CAAK,mBAAmB,CAAA,CAAA;AAEpF,IAAA,IAAI,CAAC,UAAW,CAAA,MAAA;AAAQ,MAAA,OAAA;AACxB,IAAI,IAAA,IAAA,GAAO,MAAO,CAAA,CAAC,CAAG,EAAA;AAClB,MAAA,QAAQ,KAAO;AAAA,QACX,KAAKE,aAAS,CAAA,KAAA;AACV,UAAW,UAAA,CAAA,QAAA,GAAW,WAAW,IAAK,CAAA,QAAA,CAAA;AAEtC,UAAA,OAAA;AAAA,QACJ,KAAKA,aAAS,CAAA,KAAA;AACV,UAAA,UAAA,CAAW,QAAa,IAAA,CAAA,UAAA,CAAW,IAAK,CAAA,QAAA,GAAW,WAAW,QAAY,IAAA,KAAA,CAAA;AAAA,OAClF;AAEA,MAAA,OAAA;AAAA,KACJ;AAEA,IAAA,IAAI,QAAW,GAAA,CAAA,CAAA;AAEf,IAAA,IAAI,IAAQ,IAAA,MAAA,CAAO,MAAO,CAAA,MAAA,GAAS,gCAA+B,OAAO,CAAA;AAErE,MAAA,QAAA,GAAW,MAAO,CAAA,MAAA,CAAO,MAAS,GAAA,+BAAA,CAA+B,UAAU,CAAA,CAAA;AAAA,SAC1E;AAED,MAAA,MAAM,QAAQ,SAAU,CAAA,YAAA,CAAa,MAAQ,EAAA,IAAA,EAAM,gCAA+B,OAAO,CAAA,CAAA;AAEzF,MAAW,QAAA,GAAA,MAAA,CAAO,KAAQ,GAAA,+BAAA,CAA+B,UAAU,CAAA,CAAA;AACnE,MAAM,MAAA,SAAA,GAAY,OAAO,KAAK,CAAA,CAAA;AAC9B,MAAA,MAAM,UAAU,IAAK,CAAA,eAAA;AAAA,QACjB,KAAA,GAAQ,gCAA+B,OAAU,GAAA,CAAA;AAAA,QACjD,KAAK,IAAO,GAAA,SAAA,KAAc,OAAO,KAAQ,GAAA,+BAAA,CAA+B,SAAS,CAAI,GAAA,SAAA,CAAA;AAAA,OACzF,CAAA;AAEA,MAAA,QAAA,IAAA,CAAa,MAAO,CAAA,KAAA,GAAQ,+BAA+B,CAAA,KAAK,IAAI,QAAY,IAAA,OAAA,CAAA;AAAA,KACpF;AACA,IAAA,IAAI,SAASA,aAAS,CAAA,KAAA;AAAO,MAAA,UAAA,CAAW,WAAW,UAAW,CAAA,IAAA,CAAK,YAAY,QAAW,GAAA,UAAA,CAAW,KAAK,QAAY,IAAA,KAAA,CAAA;AAAA;AACjH,MAAW,UAAA,CAAA,QAAA,IAAA,CAAa,QAAW,GAAA,UAAA,CAAW,QAAY,IAAA,KAAA,CAAA;AAAA,GACnE;AACJ,CAAA,CAAA;AArEO,IAAM,8BAAN,GAAA,gCAAA;AAAM,8BAAA,CACF,OAAU,GAAA,CAAA,CAAA;AADR,8BAAA,CAEF,SAAY,GAAA,CAAA,CAAA,CAAA;AAFV,8BAAA,CAGF,UAAa,GAAA,CAAA,CAAA,CAAA;AAHX,8BAAA,CAIF,KAAQ,GAAA,CAAA,CAAA;AAuEZ,MAAM,sCAAsC,8BAA+B,CAAA;AAAA,EAC9E,YAAY,UAAoB,EAAA;AAC5B,IAAA,KAAA,CAAM,UAAU,CAAA,CAAA;AAAA,GACpB;AAAA,EAEA,aAAgB,GAAA;AACZ,IAAQ,OAAA,CAAA,EAAA,gCAAsC,MAAM,IAAK,CAAA,mBAAA,CAAA;AAAA,GAC7D;AAAA,EAEA,MAAM,QAAoB,EAAA,QAAA,EAAkB,MAAc,WAA2B,EAAA,KAAA,EAAe,OAAiB,SAAyB,EAAA;AAC1I,IAAA,MAAM,SAAS,IAAK,CAAA,MAAA,CAAA;AACpB,IAAA,MAAM,UAA6B,GAAA,QAAA,CAAS,eAAgB,CAAA,IAAA,CAAK,mBAAmB,CAAA,CAAA;AAEpF,IAAA,IAAI,CAAC,UAAW,CAAA,MAAA;AAAQ,MAAA,OAAA;AACxB,IAAI,IAAA,IAAA,GAAO,MAAO,CAAA,CAAC,CAAG,EAAA;AAClB,MAAA,QAAQ,KAAO;AAAA,QACX,KAAKA,aAAS,CAAA,KAAA;AACV,UAAW,UAAA,CAAA,OAAA,GAAU,WAAW,IAAK,CAAA,OAAA,CAAA;AAErC,UAAA,OAAA;AAAA,QACJ,KAAKA,aAAS,CAAA,KAAA;AACV,UAAA,UAAA,CAAW,OAAY,IAAA,CAAA,UAAA,CAAW,IAAK,CAAA,OAAA,GAAU,WAAW,OAAW,IAAA,KAAA,CAAA;AAAA,OAC/E;AAEA,MAAA,OAAA;AAAA,KACJ;AAEA,IAAA,IAAI,OAAU,GAAA,CAAA,CAAA;AAEd,IAAA,IAAI,IAAQ,IAAA,MAAA,CAAO,MAAO,CAAA,MAAA,GAAS,8BAA8B,OAAO,CAAA;AAEpE,MAAA,OAAA,GAAU,MAAO,CAAA,MAAA,CAAO,MAAS,GAAA,6BAAA,CAA8B,UAAU,CAAA,CAAA;AAAA,SACxE;AAED,MAAA,MAAM,QAAQ,SAAU,CAAA,YAAA,CAAa,MAAQ,EAAA,IAAA,EAAM,8BAA8B,OAAO,CAAA,CAAA;AAExF,MAAU,OAAA,GAAA,MAAA,CAAO,KAAQ,GAAA,6BAAA,CAA8B,UAAU,CAAA,CAAA;AACjE,MAAM,MAAA,SAAA,GAAY,OAAO,KAAK,CAAA,CAAA;AAC9B,MAAA,MAAM,UAAU,IAAK,CAAA,eAAA;AAAA,QACjB,KAAA,GAAQ,8BAA8B,OAAU,GAAA,CAAA;AAAA,QAChD,KAAK,IAAO,GAAA,SAAA,KAAc,OAAO,KAAQ,GAAA,6BAAA,CAA8B,SAAS,CAAI,GAAA,SAAA,CAAA;AAAA,OACxF,CAAA;AAEA,MAAA,OAAA,IAAA,CAAY,MAAO,CAAA,KAAA,GAAQ,6BAA8B,CAAA,KAAK,IAAI,OAAW,IAAA,OAAA,CAAA;AAAA,KACjF;AAEA,IAAA,IAAI,SAASA,aAAS,CAAA,KAAA;AAAO,MAAA,UAAA,CAAW,UAAU,UAAW,CAAA,IAAA,CAAK,WAAW,OAAU,GAAA,UAAA,CAAW,KAAK,OAAW,IAAA,KAAA,CAAA;AAAA;AAC7G,MAAW,UAAA,CAAA,OAAA,IAAA,CAAY,OAAU,GAAA,UAAA,CAAW,OAAW,IAAA,KAAA,CAAA;AAAA,GAChE;AACJ,CAAA;AAOO,MAAM,0BAAA,GAAN,cAAwC,aAAc,CAAA;AAAA,EAezD,YAAY,UAAoB,EAAA;AAC5B,IAAA,KAAA,CAAM,UAAU,CAAA,CAAA;AAFpB;AAAA,IAAA,IAAA,CAAA,IAAA,GAAwF,EAAC,CAAA;AAGrF,IAAA,IAAA,CAAK,MAAS,GAAAF,UAAA,CAAM,aAAc,CAAA,UAAA,GAAa,2BAA0B,OAAO,CAAA,CAAA;AAAA,GACpF;AAAA,EAEA,aAAgB,GAAA;AACZ,IAAQ,OAAA,CAAA,EAAA,4BAAkC,MAAM,IAAK,CAAA,mBAAA,CAAA;AAAA,GACzD;AAAA;AAAA,EAGA,QAAS,CAAA,UAAA,EAAoB,IAAc,EAAA,SAAA,EAAmB,YAAsB,EAAA;AAChF,IAAA,IAAA,CAAK,KAAK,IAAK,CAAA,EAAE,YAAY,IAAM,EAAA,SAAA,EAAW,cAAc,CAAA,CAAA;AAC5D,IAAA,UAAA,IAAc,0BAA0B,CAAA,OAAA,CAAA;AACxC,IAAK,IAAA,CAAA,MAAA,CAAO,UAAU,CAAI,GAAA,IAAA,CAAA;AAC1B,IAAA,IAAA,CAAK,MAAO,CAAA,UAAA,GAAa,0BAA0B,CAAA,MAAM,CAAI,GAAA,SAAA,CAAA;AAC7D,IAAA,IAAA,CAAK,MAAO,CAAA,UAAA,GAAa,0BAA0B,CAAA,SAAS,CAAI,GAAA,YAAA,CAAA;AAAA,GACpE;AAAA,EAEA,MAAM,QAAoB,EAAA,QAAA,EAAkB,MAAc,WAA2B,EAAA,KAAA,EAAe,OAAiB,SAAyB,EAAA;AAC1I,IAAA,MAAM,SAAS,IAAK,CAAA,MAAA,CAAA;AACpB,IAAA,MAAM,UAA6B,GAAA,QAAA,CAAS,eAAgB,CAAA,IAAA,CAAK,mBAAmB,CAAA,CAAA;AAEpF,IAAA,IAAI,CAAC,UAAW,CAAA,MAAA;AAAQ,MAAA,OAAA;AACxB,IAAI,IAAA,IAAA,GAAO,MAAO,CAAA,CAAC,CAAG,EAAA;AAClB,MAAA,QAAQ,KAAO;AAAA,QACX,KAAKE,aAAS,CAAA,KAAA;AACV,UAAW,UAAA,CAAA,SAAA,GAAY,WAAW,IAAK,CAAA,SAAA,CAAA;AACvC,UAAW,UAAA,CAAA,YAAA,GAAe,WAAW,IAAK,CAAA,YAAA,CAAA;AAE1C,UAAA,OAAA;AAAA,QACJ,KAAKA,aAAS,CAAA,KAAA;AACV,UAAA,UAAA,CAAW,SAAc,IAAA,CAAA,UAAA,CAAW,IAAK,CAAA,SAAA,GAAY,WAAW,SAAa,IAAA,KAAA,CAAA;AAC7E,UAAA,UAAA,CAAW,YAAiB,IAAA,CAAA,UAAA,CAAW,IAAK,CAAA,YAAA,GAAe,WAAW,YAAgB,IAAA,KAAA,CAAA;AAAA,OAC9F;AAEA,MAAA,OAAA;AAAA,KACJ;AAEA,IAAA,IAAI,MAAS,GAAA,CAAA,CAAA;AACb,IAAA,IAAI,SAAY,GAAA,CAAA,CAAA;AAEhB,IAAA,IAAI,QAAQ,MAAO,CAAA,MAAA,CAAO,MAAS,GAAA,0BAAA,CAA0B,OAAO,CAAG,EAAA;AAEnE,MAAA,MAAA,GAAS,MAAO,CAAA,MAAA,CAAO,MAAS,GAAA,0BAAA,CAA0B,WAAW,CAAA,CAAA;AACrE,MAAA,SAAA,GAAY,MAAO,CAAA,MAAA,CAAO,MAAS,GAAA,0BAAA,CAA0B,cAAc,CAAA,CAAA;AAAA,KACxE,MAAA;AAEH,MAAA,MAAM,QAAQ,SAAU,CAAA,YAAA,CAAa,MAAQ,EAAA,IAAA,EAAM,2BAA0B,OAAO,CAAA,CAAA;AAEpF,MAAS,MAAA,GAAA,MAAA,CAAO,KAAQ,GAAA,0BAAA,CAA0B,WAAW,CAAA,CAAA;AAC7D,MAAY,SAAA,GAAA,MAAA,CAAO,KAAQ,GAAA,0BAAA,CAA0B,cAAc,CAAA,CAAA;AACnE,MAAM,MAAA,SAAA,GAAY,OAAO,KAAK,CAAA,CAAA;AAC9B,MAAA,MAAM,UAAU,IAAK,CAAA,eAAA;AAAA,QACjB,KAAA,GAAQ,2BAA0B,OAAU,GAAA,CAAA;AAAA,QAC5C,KAAK,IAAO,GAAA,SAAA,KAAc,OAAO,KAAQ,GAAA,0BAAA,CAA0B,SAAS,CAAI,GAAA,SAAA,CAAA;AAAA,OACpF,CAAA;AAEA,MAAA,MAAA,IAAA,CAAW,MAAO,CAAA,KAAA,GAAQ,0BAA0B,CAAA,MAAM,IAAI,MAAU,IAAA,OAAA,CAAA;AACxE,MAAA,SAAA,IAAA,CAAc,MAAO,CAAA,KAAA,GAAQ,0BAA0B,CAAA,SAAS,IAAI,SAAa,IAAA,OAAA,CAAA;AAAA,KACrF;AAEA,IAAI,IAAA,KAAA,IAASA,cAAS,KAAO,EAAA;AACzB,MAAA,UAAA,CAAW,YAAY,UAAW,CAAA,IAAA,CAAK,aAAa,MAAS,GAAA,UAAA,CAAW,KAAK,SAAa,IAAA,KAAA,CAAA;AAC1F,MAAA,UAAA,CAAW,eAAe,UAAW,CAAA,IAAA,CAAK,gBAAgB,SAAY,GAAA,UAAA,CAAW,KAAK,YAAgB,IAAA,KAAA,CAAA;AAAA,KACnG,MAAA;AACH,MAAW,UAAA,CAAA,SAAA,IAAA,CAAc,MAAS,GAAA,UAAA,CAAW,SAAa,IAAA,KAAA,CAAA;AAC1D,MAAW,UAAA,CAAA,YAAA,IAAA,CAAiB,SAAY,GAAA,UAAA,CAAW,YAAgB,IAAA,KAAA,CAAA;AAAA,KACvE;AAAA,GACJ;AACJ,CAAA,CAAA;AApFO,IAAM,yBAAN,GAAA,2BAAA;AAAM,yBAAA,CACF,OAAU,GAAA,CAAA,CAAA;AADR,yBAAA,CAEF,SAAY,GAAA,CAAA,CAAA,CAAA;AAFV,yBAAA,CAGF,WAAc,GAAA,CAAA,CAAA,CAAA;AAHZ,yBAAA,CAIF,cAAiB,GAAA,CAAA,CAAA,CAAA;AAJf,yBAAA,CAKF,MAAS,GAAA,CAAA,CAAA;AALP,yBAAA,CAMF,SAAY,GAAA,CAAA;;;;;;;;;;;;;;;;;;;;;"}