{"version":3,"file":"loader-base.js","sources":["../src/atlasLoader.ts","../src/SpineLoaderAbstract.ts"],"sourcesContent":["import { TextureAtlas } from '@pixi-spine/base';\r\nimport { type AssetExtension, LoaderParserPriority, LoadAsset, Loader, checkExtension } from '@pixi/assets';\r\nimport { BaseTexture, extensions, ExtensionType, settings, Texture, utils } from '@pixi/core';\r\nimport type { ISpineMetadata } from './SpineLoaderAbstract';\r\n\r\ntype RawAtlas = string;\r\n\r\nconst spineTextureAtlasLoader: AssetExtension<RawAtlas | TextureAtlas, ISpineMetadata> = {\r\n    extension: ExtensionType.Asset,\r\n\r\n    // cache: {\r\n    //     test: (asset: RawAtlas | TextureAtlas) => asset instanceof TextureAtlas,\r\n    //     getCacheableAssets: (keys: string[], asset: RawAtlas | TextureAtlas) => getCacheableAssets(keys, asset),\r\n    // },\r\n\r\n    loader: {\r\n        extension: {\r\n            type: ExtensionType.LoadParser,\r\n            priority: LoaderParserPriority.Normal,\r\n        },\r\n\r\n        test(url: string): boolean {\r\n            return checkExtension(url, '.atlas');\r\n        },\r\n\r\n        async load(url: string): Promise<RawAtlas> {\r\n            const response = await settings.ADAPTER.fetch(url);\r\n\r\n            const txt = await response.text();\r\n\r\n            return txt as RawAtlas;\r\n        },\r\n\r\n        testParse(asset: unknown, options: LoadAsset): Promise<boolean> {\r\n            const isExtensionRight = checkExtension(options.src, '.atlas');\r\n            const isString = typeof asset === 'string';\r\n\r\n            return Promise.resolve(isExtensionRight && isString);\r\n        },\r\n\r\n        async parse(asset: RawAtlas, options: LoadAsset, loader: Loader): Promise<TextureAtlas> {\r\n            const metadata: ISpineMetadata = options.data;\r\n            let basePath = utils.path.dirname(options.src);\r\n\r\n            if (basePath && basePath.lastIndexOf('/') !== basePath.length - 1) {\r\n                basePath += '/';\r\n            }\r\n\r\n            let resolve = null;\r\n            let reject = null;\r\n            const retPromise = new Promise<TextureAtlas>((res, rej) => {\r\n                resolve = res;\r\n                reject = rej;\r\n            });\r\n\r\n            // Retval is going to be a texture atlas. However we need to wait for it's callback to resolve this promise.\r\n            let retval;\r\n            const resolveCallback = (newAtlas: TextureAtlas): void => {\r\n                if (!newAtlas) {\r\n                    reject('Something went terribly wrong loading a spine .atlas file\\nMost likely your texture failed to load.');\r\n                }\r\n                resolve(retval);\r\n            };\r\n\r\n            // if we have an already loaded pixi image in the image field, use that.\r\n            if (metadata.image || metadata.images) {\r\n                // merge the objects\r\n                const pages = Object.assign(metadata.image ? { default: metadata.image } : {}, metadata.images);\r\n\r\n                retval = new TextureAtlas(\r\n                    asset as RawAtlas,\r\n                    (line: any, callback: any) => {\r\n                        const page = pages[line] || (pages.default as any);\r\n\r\n                        if (page && page.baseTexture) callback(page.baseTexture);\r\n                        else callback(page);\r\n                    },\r\n                    resolveCallback\r\n                );\r\n            } else {\r\n                // We don't have ready to use pixi textures, we need to load them now!\r\n                retval = new TextureAtlas(asset as RawAtlas, makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject(loader, basePath, metadata.imageMetadata), resolveCallback);\r\n            }\r\n\r\n            return (await retPromise) as TextureAtlas;\r\n        },\r\n\r\n        unload(atlas: TextureAtlas) {\r\n            atlas.dispose();\r\n        },\r\n    },\r\n} as AssetExtension<RawAtlas | TextureAtlas, ISpineMetadata>;\r\n\r\n/**\r\n * Ugly function to promisify the spine texture atlas loader function.\r\n * @public\r\n */\r\nexport const makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject = (loader: Loader, atlasBasePath: string, imageMetadata: any, imageURI?:string) => {\r\n    return async (pageName: string, textureLoadedCallback: (tex: BaseTexture) => any): Promise<void> => {\r\n        const url = utils.path.join(...atlasBasePath.split(utils.path.sep), pageName);\r\n\r\n        const texture = await loader.load<Texture>(imageURI? imageURI:{ src: url, data: imageMetadata });\r\n\r\n        textureLoadedCallback(texture.baseTexture);\r\n    };\r\n};\r\n\r\nextensions.add(spineTextureAtlasLoader);\r\n","import { ISkeletonData, ISkeletonParser, TextureAtlas } from '@pixi-spine/base';\r\nimport { AssetExtension, checkDataUrl, checkExtension, LoadAsset, Loader, LoaderParserPriority } from '@pixi/assets';\r\nimport { BaseTexture, extensions, ExtensionType, settings, Texture, utils } from '@pixi/core';\r\nimport { makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject } from './atlasLoader';\r\n\r\ntype SPINEJSON = any;\r\ntype SPINEBINARY = ArrayBuffer;\r\n\r\nconst validJSONExtension = '.json';\r\nconst validJSONMIME = 'application/json';\r\n\r\nconst validAtlasSMIME = 'application/octet-stream';\r\n\r\nconst validImageMIMEs = [\r\n  'image/jpeg',\r\n  'image/png',\r\n];\r\n\r\nfunction isJson(resource: unknown): resource is SPINEJSON {\r\n    return resource.hasOwnProperty('bones');\r\n}\r\n\r\nfunction isBuffer(resource: unknown): resource is SPINEBINARY {\r\n    return resource instanceof ArrayBuffer;\r\n}\r\n\r\n/**\r\n * This abstract class is used to create a spine loader specifically for a needed version\r\n * @public\r\n */\r\nexport abstract class SpineLoaderAbstract<SKD extends ISkeletonData> {\r\n    constructor() {}\r\n\r\n    abstract createJsonParser(): ISkeletonParser;\r\n\r\n    abstract createBinaryParser(): ISkeletonParser;\r\n\r\n    abstract parseData(parser: ISkeletonParser, atlas: TextureAtlas, dataToParse: any): ISpineResource<SKD>;\r\n\r\n    public installLoader(): any {\r\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n        const spineAdapter = this;\r\n        const spineLoaderExtension: AssetExtension<SPINEJSON | SPINEBINARY | ISpineResource<SKD>, ISpineMetadata> = {\r\n            extension: ExtensionType.Asset,\r\n\r\n            loader: {\r\n                extension: {\r\n                    type: ExtensionType.LoadParser,\r\n                    priority: LoaderParserPriority.Normal,\r\n                },\r\n\r\n                // #region Downloading skel buffer data\r\n                test(url) {\r\n                    return checkExtension(url, '.skel');\r\n                },\r\n\r\n                async load<SPINEBINARY>(url: string): Promise<SPINEBINARY> {\r\n                    const response = await settings.ADAPTER.fetch(url);\r\n\r\n                    const buffer = await response.arrayBuffer();\r\n\r\n                    return buffer as SPINEBINARY;\r\n                },\r\n                // #endregion\r\n\r\n                // #region Parsing spine data\r\n                testParse(asset: unknown, options: LoadAsset): Promise<boolean> {\r\n                    const isJsonSpineModel = checkDataUrl(options.src, validJSONMIME) || (checkExtension(options.src, validJSONExtension) && isJson(asset));\r\n                    const isBinarySpineModel = checkExtension(options.src, '.skel') && isBuffer(asset);\r\n\r\n                    // From 6.x loader. If the atlas is strictly false we bail\r\n                    const isMetadataAngry = options.data?.spineAtlas === false;\r\n\r\n                    return Promise.resolve((isJsonSpineModel && !isMetadataAngry) || isBinarySpineModel);\r\n                },\r\n\r\n                async parse(asset: SPINEJSON | SPINEBINARY, loadAsset, loader): Promise<ISpineResource<SKD>> {\r\n                    const fileExt = utils.path.extname(loadAsset.src).toLowerCase();\r\n                    const fileName = utils.path.basename(loadAsset.src, fileExt);\r\n                    let basePath = utils.path.dirname(loadAsset.src);\r\n\r\n                    if (basePath && basePath.lastIndexOf('/') !== basePath.length - 1) {\r\n                        basePath += '/';\r\n                    }\r\n\r\n                    const isJsonSpineModel = checkDataUrl(loadAsset.src, validJSONMIME) || (checkExtension(loadAsset.src, validJSONExtension) && isJson(asset));\r\n                    // const isBinarySpineModel = fileExt === 'slel' && isBuffer(asset);\r\n\r\n                    let parser: ISkeletonParser = null;\r\n                    let dataToParse = asset;\r\n\r\n                    if (isJsonSpineModel) {\r\n                        parser = spineAdapter.createJsonParser();\r\n                    } else {\r\n                        parser = spineAdapter.createBinaryParser();\r\n                        dataToParse = new Uint8Array(asset);\r\n                    }\r\n\r\n                    const metadata = (loadAsset.data || {}) as ISpineMetadata;\r\n                    const metadataSkeletonScale = metadata?.spineSkeletonScale ?? null;\r\n\r\n                    if (metadataSkeletonScale) {\r\n                        parser.scale = metadataSkeletonScale;\r\n                    }\r\n\r\n                    // if metadataAtlas is a TextureAtlas, use it directly\r\n                    const metadataAtlas: TextureAtlas = metadata.spineAtlas as TextureAtlas;\r\n\r\n                    if (metadataAtlas && metadataAtlas.pages) {\r\n                        return spineAdapter.parseData(parser, metadataAtlas, dataToParse);\r\n                    }\r\n\r\n                    // if for some odd reason, you dumped the text information of the atlas into the metadata...\r\n                    let textAtlas = metadata.atlasRawData;\r\n\r\n                    // Maybe you passed a data URI to instead of a path\r\n                    const isSpineAtlasFileURI=checkDataUrl(metadata.spineAtlasFile, validAtlasSMIME);\r\n\r\n                    // If it's an URI then decode it and assign it to textAtlas\r\n                    if (isSpineAtlasFileURI) {\r\n                        textAtlas = Buffer.from(metadata.spineAtlasFile.split(',')[1], 'base64').toString('binary');\r\n                    }\r\n                    if (textAtlas) {\r\n                        let auxResolve = null;\r\n                        let auxReject = null;\r\n                        const atlasPromise = new Promise<TextureAtlas>((resolve, reject) => {\r\n                            auxResolve = resolve;\r\n                            auxReject = reject;\r\n                        });\r\n                        const imageURI= (typeof metadata.image === 'string' && checkDataUrl(metadata.image, validImageMIMEs)) ? metadata.image: null;\r\n                        const atlas = new TextureAtlas(textAtlas, makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject(loader, basePath, metadata.imageMetadata, imageURI), (newAtlas) => {\r\n                            if (!newAtlas) {\r\n                                auxReject('Something went terribly wrong loading a spine .atlas file\\nMost likely your texture failed to load.');\r\n                            }\r\n                            auxResolve(atlas);\r\n                        });\r\n                        const textureAtlas = await atlasPromise;\r\n\r\n                        return spineAdapter.parseData(parser, textureAtlas, dataToParse);\r\n                    }\r\n\r\n                    // Maybe you told us where to find the file? (I sure hope you remembered to add the .atlas extension)\r\n                    let atlasPath = metadata.spineAtlasFile;\r\n\r\n                    // Finally, if no information at all about the atlas, we guess the atlas file name\r\n                    if (!atlasPath) {\r\n                        atlasPath = `${basePath + fileName}.atlas`;\r\n                    }\r\n\r\n                    const textureAtlas = await loader.load<TextureAtlas>({ src: atlasPath, data: metadata, alias: metadata.spineAtlasAlias });\r\n\r\n                    return spineAdapter.parseData(parser, textureAtlas, dataToParse);\r\n                },\r\n\r\n                // #endregion\r\n\r\n                // unload(asset: ISpineResource<SKD>, loadAsset, loader) {\r\n                // \t???\r\n                // },\r\n            },\r\n        } as AssetExtension<SPINEJSON | SPINEBINARY | ISpineResource<SKD>, ISpineMetadata>;\r\n\r\n        extensions.add(spineLoaderExtension);\r\n\r\n        return spineLoaderExtension;\r\n    }\r\n}\r\n\r\n/**\r\n * The final spineData+spineAtlas object that can be used to create a Spine.\r\n * @public\r\n */\r\nexport interface ISpineResource<SKD extends ISkeletonData> {\r\n    spineData: SKD;\r\n    spineAtlas: TextureAtlas;\r\n}\r\n\r\n/**\r\n * Metadata for loading spine assets\r\n * @public\r\n */\r\nexport interface ISpineMetadata {\r\n    // Passed directly to Spine's SkeletonJson/BinaryParser\r\n    spineSkeletonScale?: number;\r\n    // If you already have a TextureAtlas, you can pass it directly\r\n    spineAtlas?: Partial<TextureAtlas>;\r\n    // If you are going to download an .atlas file, you can specify an alias here for cache/future lookup\r\n    spineAtlasAlias?: string[];\r\n    // If you want to use a custom .atlas file or data URI, you can specify the path here. **It must be a .atlas file or you need your own parser!**\r\n    spineAtlasFile?: string;\r\n    // If for some reason, you have the raw text content of an .atlas file, and want to use it dump it here\r\n    atlasRawData?: string;\r\n    // If you are hardcore and can write your own loader function to load the textures for the atlas, you can pass it here\r\n    imageLoader?: (loader: Loader, path: string) => (path: string, callback: (tex: BaseTexture) => any) => any;\r\n    // If you are downloading an .atlas file, this metadata will go to the Texture loader\r\n    imageMetadata?: any;\r\n    // If you already have atlas pages loaded as pixi textures and want to use that to create the atlas, you can pass them here\r\n    images?: Record<string, Texture | BaseTexture>;\r\n    // If your spine only uses one atlas page and you have it as a pixi texture or data URI, you can pass it here\r\n    image?: Texture | BaseTexture | string;\r\n}\r\n"],"names":["spineTextureAtlasLoader","ExtensionType","LoaderParserPriority","url","checkExtension","settings","asset","options","isExtensionRight","isString","loader","metadata","basePath","utils","resolve","reject","retPromise","res","rej","retval","resolveCallback","newAtlas","pages","TextureAtlas","line","callback","page","makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject","atlas","atlasBasePath","imageMetadata","imageURI","pageName","textureLoadedCallback","texture","extensions","validJSONExtension","validJSONMIME","validAtlasSMIME","validImageMIMEs","isJson","resource","isBuffer","SpineLoaderAbstract","spineAdapter","spineLoaderExtension","_a","isJsonSpineModel","checkDataUrl","isBinarySpineModel","isMetadataAngry","loadAsset","fileExt","fileName","parser","dataToParse","metadataSkeletonScale","metadataAtlas","textAtlas","auxResolve","auxReject","atlasPromise","textureAtlas","atlasPath"],"mappings":"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"}