{"version":3,"file":"loader-base.js","sources":["../src/atlasLoader.ts","../src/SpineLoaderAbstract.ts"],"sourcesContent":["import { TextureAtlas } from '@pixi-spine/base';\r\nimport { type AssetExtension, LoaderParserPriority, LoadAsset, Loader, checkExtension } from '@pixi/assets';\r\nimport { BaseTexture, extensions, ExtensionType, settings, Texture, utils } from '@pixi/core';\r\nimport type { ISpineMetadata } from './SpineLoaderAbstract';\r\n\r\ntype RawAtlas = string;\r\n\r\nconst spineTextureAtlasLoader: AssetExtension<RawAtlas | TextureAtlas, ISpineMetadata> = {\r\n    extension: ExtensionType.Asset,\r\n\r\n    // cache: {\r\n    //     test: (asset: RawAtlas | TextureAtlas) => asset instanceof TextureAtlas,\r\n    //     getCacheableAssets: (keys: string[], asset: RawAtlas | TextureAtlas) => getCacheableAssets(keys, asset),\r\n    // },\r\n\r\n    loader: {\r\n        extension: {\r\n            type: ExtensionType.LoadParser,\r\n            priority: LoaderParserPriority.Normal,\r\n        },\r\n\r\n        test(url: string): boolean {\r\n            return checkExtension(url, '.atlas');\r\n        },\r\n\r\n        async load(url: string): Promise<RawAtlas> {\r\n            const response = await settings.ADAPTER.fetch(url);\r\n\r\n            const txt = await response.text();\r\n\r\n            return txt as RawAtlas;\r\n        },\r\n\r\n        testParse(asset: unknown, options: LoadAsset): Promise<boolean> {\r\n            const isExtensionRight = checkExtension(options.src, '.atlas');\r\n            const isString = typeof asset === 'string';\r\n\r\n            return Promise.resolve(isExtensionRight && isString);\r\n        },\r\n\r\n        async parse(asset: RawAtlas, options: LoadAsset, loader: Loader): Promise<TextureAtlas> {\r\n            const metadata: ISpineMetadata = options.data;\r\n            let basePath = utils.path.dirname(options.src);\r\n\r\n            if (basePath && basePath.lastIndexOf('/') !== basePath.length - 1) {\r\n                basePath += '/';\r\n            }\r\n\r\n            let resolve = null;\r\n            let reject = null;\r\n            const retPromise = new Promise<TextureAtlas>((res, rej) => {\r\n                resolve = res;\r\n                reject = rej;\r\n            });\r\n\r\n            // Retval is going to be a texture atlas. However we need to wait for it's callback to resolve this promise.\r\n            let retval;\r\n            const resolveCallback = (newAtlas: TextureAtlas): void => {\r\n                if (!newAtlas) {\r\n                    reject('Something went terribly wrong loading a spine .atlas file\\nMost likely your texture failed to load.');\r\n                }\r\n                resolve(retval);\r\n            };\r\n\r\n            // if we have an already loaded pixi image in the image field, use that.\r\n            if (metadata.image || metadata.images) {\r\n                // merge the objects\r\n                const pages = Object.assign(metadata.image ? { default: metadata.image } : {}, metadata.images);\r\n\r\n                retval = new TextureAtlas(\r\n                    asset as RawAtlas,\r\n                    (line: any, callback: any) => {\r\n                        const page = pages[line] || (pages.default as any);\r\n\r\n                        if (page && page.baseTexture) callback(page.baseTexture);\r\n                        else callback(page);\r\n                    },\r\n                    resolveCallback\r\n                );\r\n            } else {\r\n                // We don't have ready to use pixi textures, we need to load them now!\r\n                retval = new TextureAtlas(asset as RawAtlas, makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject(loader, basePath, metadata.imageMetadata), resolveCallback);\r\n            }\r\n\r\n            return (await retPromise) as TextureAtlas;\r\n        },\r\n\r\n        unload(atlas: TextureAtlas) {\r\n            atlas.dispose();\r\n        },\r\n    },\r\n} as AssetExtension<RawAtlas | TextureAtlas, ISpineMetadata>;\r\n\r\n/**\r\n * Ugly function to promisify the spine texture atlas loader function.\r\n * @public\r\n */\r\nexport const makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject = (loader: Loader, atlasBasePath: string, imageMetadata: any, imageURL?: string) => {\r\n    return async (pageName: string, textureLoadedCallback: (tex: BaseTexture) => any): Promise<void> => {\r\n        // const url = utils.path.join(...atlasBasePath.split(utils.path.sep), pageName); // Broken in upstream\r\n\r\n        const url = utils.path.normalize([...atlasBasePath.split(utils.path.sep), pageName].join(utils.path.sep));\r\n\r\n        const texture = await loader.load<Texture>(imageURL ? imageURL : { src: url, data: imageMetadata });\r\n\r\n        textureLoadedCallback(texture.baseTexture);\r\n    };\r\n};\r\n\r\nextensions.add(spineTextureAtlasLoader);\r\n","import { ISkeletonData, ISkeletonParser, TextureAtlas } from '@pixi-spine/base';\r\nimport { AssetExtension, checkDataUrl, checkExtension, LoadAsset, Loader, LoaderParserPriority } from '@pixi/assets';\r\nimport { BaseTexture, extensions, ExtensionType, settings, Texture, utils } from '@pixi/core';\r\nimport { makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject } from './atlasLoader';\r\n\r\ntype SPINEJSON = any;\r\ntype SPINEBINARY = ArrayBuffer;\r\n\r\nconst validJSONExtension = '.json';\r\n\r\nconst validJSONMIME = 'application/json';\r\n\r\nconst validAtlasMIMEs = ['application/octet-stream', 'text/plain'];\r\n\r\nconst validImageMIMEs = ['image/jpeg', 'image/png'];\r\n\r\nfunction isJson(resource: unknown): resource is SPINEJSON {\r\n    return resource.hasOwnProperty('bones');\r\n}\r\n\r\nfunction isBuffer(resource: unknown): resource is SPINEBINARY {\r\n    return resource instanceof ArrayBuffer;\r\n}\r\n\r\n/**\r\n * This abstract class is used to create a spine loader specifically for a needed version\r\n * @public\r\n */\r\nexport abstract class SpineLoaderAbstract<SKD extends ISkeletonData> {\r\n    constructor() {}\r\n\r\n    abstract createJsonParser(): ISkeletonParser;\r\n\r\n    abstract createBinaryParser(): ISkeletonParser;\r\n\r\n    abstract parseData(parser: ISkeletonParser, atlas: TextureAtlas, dataToParse: any): ISpineResource<SKD>;\r\n\r\n    public installLoader(): any {\r\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n        const spineAdapter = this;\r\n        const spineLoaderExtension: AssetExtension<SPINEJSON | SPINEBINARY | ISpineResource<SKD>, ISpineMetadata> = {\r\n            extension: ExtensionType.Asset,\r\n\r\n            loader: {\r\n                extension: {\r\n                    type: ExtensionType.LoadParser,\r\n                    priority: LoaderParserPriority.Normal,\r\n                },\r\n\r\n                // #region Downloading skel buffer data\r\n                test(url) {\r\n                    return checkExtension(url, '.skel');\r\n                },\r\n\r\n                async load<SPINEBINARY>(url: string): Promise<SPINEBINARY> {\r\n                    const isSpineSkelFileURL = checkDataUrl(url, validAtlasMIMEs);\r\n\r\n                    const buffer = isSpineSkelFileURL ? dataURLToArrayBuffer(url.slice(0, url.lastIndexOf('.'))) : await (await settings.ADAPTER.fetch(url)).arrayBuffer();\r\n\r\n                    return buffer as SPINEBINARY;\r\n                },\r\n                // #endregion\r\n\r\n                // #region Parsing spine data\r\n                testParse(asset: unknown, options: LoadAsset): Promise<boolean> {\r\n                    const isJsonSpineModel = checkDataUrl(options.src, validJSONMIME) || (checkExtension(options.src, validJSONExtension) && isJson(asset));\r\n                    const isBinarySpineModel = checkExtension(options.src, '.skel') && isBuffer(asset);\r\n\r\n                    // From 6.x loader. If the atlas is strictly false we bail\r\n                    const isMetadataAngry = options.data?.spineAtlas === false;\r\n\r\n                    return Promise.resolve((isJsonSpineModel && !isMetadataAngry) || isBinarySpineModel);\r\n                },\r\n\r\n                async parse(asset: SPINEJSON | SPINEBINARY, loadAsset, loader): Promise<ISpineResource<SKD>> {\r\n                    const fileExt = utils.path.extname(loadAsset.src).toLowerCase();\r\n                    const fileName = utils.path.basename(loadAsset.src, fileExt);\r\n                    let basePath = utils.path.dirname(loadAsset.src);\r\n\r\n                    if (basePath && basePath.lastIndexOf('/') !== basePath.length - 1) {\r\n                        basePath += '/';\r\n                    }\r\n\r\n                    const isJsonSpineModel = checkDataUrl(loadAsset.src, validJSONMIME) || (checkExtension(loadAsset.src, validJSONExtension) && isJson(asset));\r\n                    // const isBinarySpineModel = fileExt === 'slel' && isBuffer(asset);\r\n\r\n                    let parser: ISkeletonParser = null;\r\n                    let dataToParse = asset;\r\n\r\n                    if (isJsonSpineModel) {\r\n                        parser = spineAdapter.createJsonParser();\r\n                    } else {\r\n                        parser = spineAdapter.createBinaryParser();\r\n                        dataToParse = new Uint8Array(asset);\r\n                    }\r\n\r\n                    const metadata = (loadAsset.data || {}) as ISpineMetadata;\r\n                    const metadataSkeletonScale = metadata?.spineSkeletonScale ?? null;\r\n\r\n                    if (metadataSkeletonScale) {\r\n                        parser.scale = metadataSkeletonScale;\r\n                    }\r\n\r\n                    // if metadataAtlas is a TextureAtlas, use it directly\r\n                    const metadataAtlas: TextureAtlas = metadata.spineAtlas as TextureAtlas;\r\n\r\n                    if (metadataAtlas && metadataAtlas.pages) {\r\n                        return spineAdapter.parseData(parser, metadataAtlas, dataToParse);\r\n                    }\r\n\r\n                    // if for some odd reason, you dumped the text information of the atlas into the metadata...\r\n                    let textAtlas = metadata.atlasRawData;\r\n\r\n                    // Maybe you passed a data URL to instead of a path\r\n                    const isSpineAtlasFileURL = checkDataUrl(metadata.spineAtlasFile, validAtlasMIMEs);\r\n\r\n                    // If it's an URL then decode it and assign it to textAtlas\r\n                    if (isSpineAtlasFileURL) {\r\n                        textAtlas = atob(metadata.spineAtlasFile.split(',')[1]);\r\n                    }\r\n                    if (textAtlas) {\r\n                        let auxResolve = null;\r\n                        let auxReject = null;\r\n                        const atlasPromise = new Promise<TextureAtlas>((resolve, reject) => {\r\n                            auxResolve = resolve;\r\n                            auxReject = reject;\r\n                        });\r\n                        const imageURL = typeof metadata.image === 'string' && checkDataUrl(metadata.image, validImageMIMEs) ? metadata.image : null;\r\n                        const atlas = new TextureAtlas(\r\n                            textAtlas,\r\n                            makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject(loader, basePath, metadata.imageMetadata, imageURL),\r\n                            (newAtlas) => {\r\n                                if (!newAtlas) {\r\n                                    auxReject('Something went terribly wrong loading a spine .atlas file\\nMost likely your texture failed to load.');\r\n                                }\r\n                                auxResolve(atlas);\r\n                            }\r\n                        );\r\n                        const textureAtlas = await atlasPromise;\r\n\r\n                        return spineAdapter.parseData(parser, textureAtlas, dataToParse);\r\n                    }\r\n\r\n                    // Maybe you told us where to find the file? (I sure hope you remembered to add the .atlas extension)\r\n                    let atlasPath = metadata.spineAtlasFile;\r\n\r\n                    // Finally, if no information at all about the atlas, we guess the atlas file name\r\n                    if (!atlasPath) {\r\n                        atlasPath = `${basePath + fileName}.atlas`;\r\n                    }\r\n\r\n                    const textureAtlas = await loader.load<TextureAtlas>({ src: atlasPath, data: metadata, alias: metadata.spineAtlasAlias });\r\n\r\n                    return spineAdapter.parseData(parser, textureAtlas, dataToParse);\r\n                },\r\n\r\n                // #endregion\r\n\r\n                // unload(asset: ISpineResource<SKD>, loadAsset, loader) {\r\n                // \t???\r\n                // },\r\n            },\r\n        } as AssetExtension<SPINEJSON | SPINEBINARY | ISpineResource<SKD>, ISpineMetadata>;\r\n\r\n        extensions.add(spineLoaderExtension);\r\n\r\n        return spineLoaderExtension;\r\n    }\r\n}\r\n\r\n/**\r\n * The final spineData+spineAtlas object that can be used to create a Spine.\r\n * @public\r\n */\r\nexport interface ISpineResource<SKD extends ISkeletonData> {\r\n    spineData: SKD;\r\n    spineAtlas: TextureAtlas;\r\n}\r\n\r\n/**\r\n * Metadata for loading spine assets\r\n * @public\r\n */\r\nexport interface ISpineMetadata {\r\n    // Passed directly to Spine's SkeletonJson/BinaryParser\r\n    spineSkeletonScale?: number;\r\n    // If you already have a TextureAtlas, you can pass it directly\r\n    spineAtlas?: Partial<TextureAtlas>;\r\n    // If you are going to download an .atlas file, you can specify an alias here for cache/future lookup\r\n    spineAtlasAlias?: string[];\r\n    // If you want to use a custom .atlas file or data URL, you can specify the path here. **It must be a .atlas file or you need your own parser!**\r\n    spineAtlasFile?: string;\r\n    // If for some reason, you have the raw text content of an .atlas file, and want to use it dump it here\r\n    atlasRawData?: string;\r\n    // If you are hardcore and can write your own loader function to load the textures for the atlas, you can pass it here\r\n    imageLoader?: (loader: Loader, path: string) => (path: string, callback: (tex: BaseTexture) => any) => any;\r\n    // If you are downloading an .atlas file, this metadata will go to the Texture loader\r\n    imageMetadata?: any;\r\n    // If you already have atlas pages loaded as pixi textures and want to use that to create the atlas, you can pass them here\r\n    images?: Record<string, Texture | BaseTexture>;\r\n    // If your spine only uses one atlas page and you have it as a pixi texture or data URL, you can pass it here\r\n    image?: Texture | BaseTexture | string;\r\n}\r\n\r\nfunction dataURLToArrayBuffer(dataURL: string): ArrayBuffer {\r\n    const base64 = dataURL.split(',')[1];\r\n    const binaryString = atob(base64);\r\n    const length = binaryString.length;\r\n    const arrayBuffer = new ArrayBuffer(length);\r\n    const uint8Array = new Uint8Array(arrayBuffer);\r\n\r\n    for (let i = 0; i < length; i++) {\r\n        uint8Array[i] = binaryString.charCodeAt(i);\r\n    }\r\n\r\n    return arrayBuffer;\r\n}\r\n"],"names":["spineTextureAtlasLoader","ExtensionType","LoaderParserPriority","url","checkExtension","settings","asset","options","isExtensionRight","isString","loader","metadata","basePath","utils","resolve","reject","retPromise","res","rej","retval","resolveCallback","newAtlas","pages","TextureAtlas","line","callback","page","makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject","atlas","atlasBasePath","imageMetadata","imageURL","pageName","textureLoadedCallback","texture","extensions","validJSONExtension","validJSONMIME","validAtlasMIMEs","validImageMIMEs","isJson","resource","isBuffer","SpineLoaderAbstract","spineAdapter","spineLoaderExtension","checkDataUrl","dataURLToArrayBuffer","_a","isJsonSpineModel","isBinarySpineModel","isMetadataAngry","loadAsset","fileExt","fileName","parser","dataToParse","metadataSkeletonScale","metadataAtlas","textAtlas","auxResolve","auxReject","atlasPromise","textureAtlas","atlasPath","dataURL","base64","binaryString","length","arrayBuffer","uint8Array","i"],"mappings":"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"}