{"version":3,"file":"loader-base.mjs","sources":["../src/atlasLoader.ts","../src/SpineLoaderAbstract.ts"],"sourcesContent":["import { TextureAtlas } from '@pixi-spine/base';\nimport { type AssetExtension, LoaderParserPriority, LoadAsset, Loader, checkExtension } from '@pixi/assets';\nimport { BaseTexture, extensions, ExtensionType, settings, Texture, utils } from '@pixi/core';\nimport type { ISpineMetadata } from './SpineLoaderAbstract';\n\ntype RawAtlas = string;\n\nconst spineTextureAtlasLoader: AssetExtension<RawAtlas | TextureAtlas, ISpineMetadata> = {\n    extension: ExtensionType.Asset,\n\n    // cache: {\n    //     test: (asset: RawAtlas | TextureAtlas) => asset instanceof TextureAtlas,\n    //     getCacheableAssets: (keys: string[], asset: RawAtlas | TextureAtlas) => getCacheableAssets(keys, asset),\n    // },\n\n    loader: {\n        extension: {\n            type: ExtensionType.LoadParser,\n            priority: LoaderParserPriority.Normal,\n        },\n\n        test(url: string): boolean {\n            return checkExtension(url, '.atlas');\n        },\n\n        async load(url: string): Promise<RawAtlas> {\n            const response = await settings.ADAPTER.fetch(url);\n\n            const txt = await response.text();\n\n            return txt as RawAtlas;\n        },\n\n        testParse(asset: unknown, options: LoadAsset): Promise<boolean> {\n            const isExtensionRight = checkExtension(options.src, '.atlas');\n            const isString = typeof asset === 'string';\n\n            return Promise.resolve(isExtensionRight && isString);\n        },\n\n        async parse(asset: RawAtlas, options: LoadAsset, loader: Loader): Promise<TextureAtlas> {\n            const metadata: ISpineMetadata = options.data;\n            let basePath = utils.path.dirname(options.src);\n\n            if (basePath && basePath.lastIndexOf('/') !== basePath.length - 1) {\n                basePath += '/';\n            }\n\n            let resolve = null;\n            let reject = null;\n            const retPromise = new Promise<TextureAtlas>((res, rej) => {\n                resolve = res;\n                reject = rej;\n            });\n\n            // Retval is going to be a texture atlas. However we need to wait for it's callback to resolve this promise.\n            let retval;\n            const resolveCallback = (newAtlas: TextureAtlas): void => {\n                if (!newAtlas) {\n                    reject('Something went terribly wrong loading a spine .atlas file\\nMost likely your texture failed to load.');\n                }\n                resolve(retval);\n            };\n\n            // if we have an already loaded pixi image in the image field, use that.\n            if (metadata.image || metadata.images) {\n                // merge the objects\n                const pages = Object.assign(metadata.image ? { default: metadata.image } : {}, metadata.images);\n\n                retval = new TextureAtlas(\n                    asset as RawAtlas,\n                    (line: any, callback: any) => {\n                        const page = pages[line] || (pages.default as any);\n\n                        if (page && page.baseTexture) callback(page.baseTexture);\n                        else callback(page);\n                    },\n                    resolveCallback\n                );\n            } else {\n                // We don't have ready to use pixi textures, we need to load them now!\n                retval = new TextureAtlas(asset as RawAtlas, makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject(loader, basePath, metadata.imageMetadata), resolveCallback);\n            }\n\n            return (await retPromise) as TextureAtlas;\n        },\n\n        unload(atlas: TextureAtlas) {\n            atlas.dispose();\n        },\n    },\n} as AssetExtension<RawAtlas | TextureAtlas, ISpineMetadata>;\n\n/**\n * Ugly function to promisify the spine texture atlas loader function.\n * @public\n */\nexport const makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject = (loader: Loader, atlasBasePath: string, imageMetadata: any, imageURL?: string) => {\n    return async (pageName: string, textureLoadedCallback: (tex: BaseTexture) => any): Promise<void> => {\n        // const url = utils.path.join(...atlasBasePath.split(utils.path.sep), pageName); // Broken in upstream\n\n        const url = utils.path.normalize([...atlasBasePath.split(utils.path.sep), pageName].join(utils.path.sep));\n\n        const texture = await loader.load<Texture>(imageURL ? imageURL : { src: url, data: imageMetadata });\n\n        textureLoadedCallback(texture.baseTexture);\n    };\n};\n\nextensions.add(spineTextureAtlasLoader);\n","import { ISkeletonData, ISkeletonParser, TextureAtlas } from '@pixi-spine/base';\nimport { AssetExtension, checkDataUrl, checkExtension, LoadAsset, Loader, LoaderParserPriority } from '@pixi/assets';\nimport { BaseTexture, extensions, ExtensionType, settings, Texture, utils } from '@pixi/core';\nimport { makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject } from './atlasLoader';\n\ntype SPINEJSON = any;\ntype SPINEBINARY = ArrayBuffer;\n\nconst validJSONExtension = '.json';\n\nconst validJSONMIME = 'application/json';\n\nconst validAtlasMIMEs = ['application/octet-stream', 'text/plain'];\n\nconst validImageMIMEs = ['image/jpeg', 'image/png'];\n\nfunction isJson(resource: unknown): resource is SPINEJSON {\n    return resource.hasOwnProperty('bones');\n}\n\nfunction isBuffer(resource: unknown): resource is SPINEBINARY {\n    return resource instanceof ArrayBuffer;\n}\n\n/**\n * This abstract class is used to create a spine loader specifically for a needed version\n * @public\n */\nexport abstract class SpineLoaderAbstract<SKD extends ISkeletonData> {\n    constructor() {}\n\n    abstract createJsonParser(): ISkeletonParser;\n\n    abstract createBinaryParser(): ISkeletonParser;\n\n    abstract parseData(parser: ISkeletonParser, atlas: TextureAtlas, dataToParse: any): ISpineResource<SKD>;\n\n    public installLoader(): any {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const spineAdapter = this;\n        const spineLoaderExtension: AssetExtension<SPINEJSON | SPINEBINARY | ISpineResource<SKD>, ISpineMetadata> = {\n            extension: ExtensionType.Asset,\n\n            loader: {\n                extension: {\n                    type: ExtensionType.LoadParser,\n                    priority: LoaderParserPriority.Normal,\n                },\n\n                // #region Downloading skel buffer data\n                test(url) {\n                    return checkExtension(url, '.skel');\n                },\n\n                async load<SPINEBINARY>(url: string): Promise<SPINEBINARY> {\n                    const isSpineSkelFileURL = checkDataUrl(url, validAtlasMIMEs);\n\n                    const buffer = isSpineSkelFileURL ? dataURLToArrayBuffer(url.slice(0, url.lastIndexOf('.'))) : await (await settings.ADAPTER.fetch(url)).arrayBuffer();\n\n                    return buffer as SPINEBINARY;\n                },\n                // #endregion\n\n                // #region Parsing spine data\n                testParse(asset: unknown, options: LoadAsset): Promise<boolean> {\n                    const isJsonSpineModel = checkDataUrl(options.src, validJSONMIME) || (checkExtension(options.src, validJSONExtension) && isJson(asset));\n                    const isBinarySpineModel = checkExtension(options.src, '.skel') && isBuffer(asset);\n\n                    // From 6.x loader. If the atlas is strictly false we bail\n                    const isMetadataAngry = options.data?.spineAtlas === false;\n\n                    return Promise.resolve((isJsonSpineModel && !isMetadataAngry) || isBinarySpineModel);\n                },\n\n                async parse(asset: SPINEJSON | SPINEBINARY, loadAsset, loader): Promise<ISpineResource<SKD>> {\n                    const fileExt = utils.path.extname(loadAsset.src).toLowerCase();\n                    const fileName = utils.path.basename(loadAsset.src, fileExt);\n                    let basePath = utils.path.dirname(loadAsset.src);\n\n                    if (basePath && basePath.lastIndexOf('/') !== basePath.length - 1) {\n                        basePath += '/';\n                    }\n\n                    const isJsonSpineModel = checkDataUrl(loadAsset.src, validJSONMIME) || (checkExtension(loadAsset.src, validJSONExtension) && isJson(asset));\n                    // const isBinarySpineModel = fileExt === 'slel' && isBuffer(asset);\n\n                    let parser: ISkeletonParser = null;\n                    let dataToParse = asset;\n\n                    if (isJsonSpineModel) {\n                        parser = spineAdapter.createJsonParser();\n                    } else {\n                        parser = spineAdapter.createBinaryParser();\n                        dataToParse = new Uint8Array(asset);\n                    }\n\n                    const metadata = (loadAsset.data || {}) as ISpineMetadata;\n                    const metadataSkeletonScale = metadata?.spineSkeletonScale ?? null;\n\n                    if (metadataSkeletonScale) {\n                        parser.scale = metadataSkeletonScale;\n                    }\n\n                    // if metadataAtlas is a TextureAtlas, use it directly\n                    const metadataAtlas: TextureAtlas = metadata.spineAtlas as TextureAtlas;\n\n                    if (metadataAtlas && metadataAtlas.pages) {\n                        return spineAdapter.parseData(parser, metadataAtlas, dataToParse);\n                    }\n\n                    // if for some odd reason, you dumped the text information of the atlas into the metadata...\n                    let textAtlas = metadata.atlasRawData;\n\n                    // Maybe you passed a data URL to instead of a path\n                    const isSpineAtlasFileURL = checkDataUrl(metadata.spineAtlasFile, validAtlasMIMEs);\n\n                    // If it's an URL then decode it and assign it to textAtlas\n                    if (isSpineAtlasFileURL) {\n                        textAtlas = atob(metadata.spineAtlasFile.split(',')[1]);\n                    }\n                    if (textAtlas) {\n                        let auxResolve = null;\n                        let auxReject = null;\n                        const atlasPromise = new Promise<TextureAtlas>((resolve, reject) => {\n                            auxResolve = resolve;\n                            auxReject = reject;\n                        });\n                        const imageURL = typeof metadata.image === 'string' && checkDataUrl(metadata.image, validImageMIMEs) ? metadata.image : null;\n                        const atlas = new TextureAtlas(\n                            textAtlas,\n                            makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject(loader, basePath, metadata.imageMetadata, imageURL),\n                            (newAtlas) => {\n                                if (!newAtlas) {\n                                    auxReject('Something went terribly wrong loading a spine .atlas file\\nMost likely your texture failed to load.');\n                                }\n                                auxResolve(atlas);\n                            }\n                        );\n                        const textureAtlas = await atlasPromise;\n\n                        return spineAdapter.parseData(parser, textureAtlas, dataToParse);\n                    }\n\n                    // Maybe you told us where to find the file? (I sure hope you remembered to add the .atlas extension)\n                    let atlasPath = metadata.spineAtlasFile;\n\n                    // Finally, if no information at all about the atlas, we guess the atlas file name\n                    if (!atlasPath) {\n                        atlasPath = `${basePath + fileName}.atlas`;\n                    }\n\n                    const textureAtlas = await loader.load<TextureAtlas>({ src: atlasPath, data: metadata, alias: metadata.spineAtlasAlias });\n\n                    return spineAdapter.parseData(parser, textureAtlas, dataToParse);\n                },\n\n                // #endregion\n\n                // unload(asset: ISpineResource<SKD>, loadAsset, loader) {\n                // \t???\n                // },\n            },\n        } as AssetExtension<SPINEJSON | SPINEBINARY | ISpineResource<SKD>, ISpineMetadata>;\n\n        extensions.add(spineLoaderExtension);\n\n        return spineLoaderExtension;\n    }\n}\n\n/**\n * The final spineData+spineAtlas object that can be used to create a Spine.\n * @public\n */\nexport interface ISpineResource<SKD extends ISkeletonData> {\n    spineData: SKD;\n    spineAtlas: TextureAtlas;\n}\n\n/**\n * Metadata for loading spine assets\n * @public\n */\nexport interface ISpineMetadata {\n    // Passed directly to Spine's SkeletonJson/BinaryParser\n    spineSkeletonScale?: number;\n    // If you already have a TextureAtlas, you can pass it directly\n    spineAtlas?: Partial<TextureAtlas>;\n    // If you are going to download an .atlas file, you can specify an alias here for cache/future lookup\n    spineAtlasAlias?: string[];\n    // If you want to use a custom .atlas file or data URL, you can specify the path here. **It must be a .atlas file or you need your own parser!**\n    spineAtlasFile?: string;\n    // If for some reason, you have the raw text content of an .atlas file, and want to use it dump it here\n    atlasRawData?: string;\n    // If you are hardcore and can write your own loader function to load the textures for the atlas, you can pass it here\n    imageLoader?: (loader: Loader, path: string) => (path: string, callback: (tex: BaseTexture) => any) => any;\n    // If you are downloading an .atlas file, this metadata will go to the Texture loader\n    imageMetadata?: any;\n    // If you already have atlas pages loaded as pixi textures and want to use that to create the atlas, you can pass them here\n    images?: Record<string, Texture | BaseTexture>;\n    // If your spine only uses one atlas page and you have it as a pixi texture or data URL, you can pass it here\n    image?: Texture | BaseTexture | string;\n}\n\nfunction dataURLToArrayBuffer(dataURL: string): ArrayBuffer {\n    const base64 = dataURL.split(',')[1];\n    const binaryString = atob(base64);\n    const length = binaryString.length;\n    const arrayBuffer = new ArrayBuffer(length);\n    const uint8Array = new Uint8Array(arrayBuffer);\n\n    for (let i = 0; i < length; i++) {\n        uint8Array[i] = binaryString.charCodeAt(i);\n    }\n\n    return arrayBuffer;\n}\n"],"names":["spineTextureAtlasLoader","ExtensionType","LoaderParserPriority","url","checkExtension","settings","asset","options","isExtensionRight","isString","loader","metadata","basePath","utils","resolve","reject","retPromise","res","rej","retval","resolveCallback","newAtlas","pages","TextureAtlas","line","callback","page","makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject","atlas","atlasBasePath","imageMetadata","imageURL","pageName","textureLoadedCallback","texture","extensions","validJSONExtension","validJSONMIME","validAtlasMIMEs","validImageMIMEs","isJson","resource","isBuffer","SpineLoaderAbstract","spineAdapter","spineLoaderExtension","checkDataUrl","dataURLToArrayBuffer","_a","isJsonSpineModel","isBinarySpineModel","isMetadataAngry","loadAsset","fileExt","fileName","parser","dataToParse","metadataSkeletonScale","metadataAtlas","textAtlas","auxResolve","auxReject","atlasPromise","textureAtlas","atlasPath","dataURL","base64","binaryString","length","arrayBuffer","uint8Array","i"],"mappings":"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"}