{"version":3,"file":"SpineLoaderAbstract.mjs","sources":["../src/SpineLoaderAbstract.ts"],"sourcesContent":["import { ISkeletonData, ISkeletonParser, TextureAtlas } from '@pixi-spine/base';\r\nimport { AssetExtension, checkDataUrl, checkExtension, LoadAsset, Loader, LoaderParserPriority } from '@pixi/assets';\r\nimport { BaseTexture, extensions, ExtensionType, settings, Texture, utils } from '@pixi/core';\r\nimport { makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject } from './atlasLoader';\r\n\r\ntype SPINEJSON = any;\r\ntype SPINEBINARY = ArrayBuffer;\r\n\r\nconst validJSONExtension = '.json';\r\n\r\nconst validJSONMIME = 'application/json';\r\n\r\nconst validAtlasMIMEs = ['application/octet-stream', 'text/plain'];\r\n\r\nconst validImageMIMEs = ['image/jpeg', 'image/png'];\r\n\r\nfunction isJson(resource: unknown): resource is SPINEJSON {\r\n    return resource.hasOwnProperty('bones');\r\n}\r\n\r\nfunction isBuffer(resource: unknown): resource is SPINEBINARY {\r\n    return resource instanceof ArrayBuffer;\r\n}\r\n\r\n/**\r\n * This abstract class is used to create a spine loader specifically for a needed version\r\n * @public\r\n */\r\nexport abstract class SpineLoaderAbstract<SKD extends ISkeletonData> {\r\n    constructor() {}\r\n\r\n    abstract createJsonParser(): ISkeletonParser;\r\n\r\n    abstract createBinaryParser(): ISkeletonParser;\r\n\r\n    abstract parseData(parser: ISkeletonParser, atlas: TextureAtlas, dataToParse: any): ISpineResource<SKD>;\r\n\r\n    public installLoader(): any {\r\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n        const spineAdapter = this;\r\n        const spineLoaderExtension: AssetExtension<SPINEJSON | SPINEBINARY | ISpineResource<SKD>, ISpineMetadata> = {\r\n            extension: ExtensionType.Asset,\r\n\r\n            loader: {\r\n                extension: {\r\n                    type: ExtensionType.LoadParser,\r\n                    priority: LoaderParserPriority.Normal,\r\n                },\r\n\r\n                // #region Downloading skel buffer data\r\n                test(url) {\r\n                    return checkExtension(url, '.skel');\r\n                },\r\n\r\n                async load<SPINEBINARY>(url: string): Promise<SPINEBINARY> {\r\n                    const isSpineSkelFileURL = checkDataUrl(url, validAtlasMIMEs);\r\n\r\n                    const buffer = isSpineSkelFileURL ? dataURLToArrayBuffer(url.slice(0, url.lastIndexOf('.'))) : await (await settings.ADAPTER.fetch(url)).arrayBuffer();\r\n\r\n                    return buffer as SPINEBINARY;\r\n                },\r\n                // #endregion\r\n\r\n                // #region Parsing spine data\r\n                testParse(asset: unknown, options: LoadAsset): Promise<boolean> {\r\n                    const isJsonSpineModel = checkDataUrl(options.src, validJSONMIME) || (checkExtension(options.src, validJSONExtension) && isJson(asset));\r\n                    const isBinarySpineModel = checkExtension(options.src, '.skel') && isBuffer(asset);\r\n\r\n                    // From 6.x loader. If the atlas is strictly false we bail\r\n                    const isMetadataAngry = options.data?.spineAtlas === false;\r\n\r\n                    return Promise.resolve((isJsonSpineModel && !isMetadataAngry) || isBinarySpineModel);\r\n                },\r\n\r\n                async parse(asset: SPINEJSON | SPINEBINARY, loadAsset, loader): Promise<ISpineResource<SKD>> {\r\n                    const fileExt = utils.path.extname(loadAsset.src).toLowerCase();\r\n                    const fileName = utils.path.basename(loadAsset.src, fileExt);\r\n                    let basePath = utils.path.dirname(loadAsset.src);\r\n\r\n                    if (basePath && basePath.lastIndexOf('/') !== basePath.length - 1) {\r\n                        basePath += '/';\r\n                    }\r\n\r\n                    const isJsonSpineModel = checkDataUrl(loadAsset.src, validJSONMIME) || (checkExtension(loadAsset.src, validJSONExtension) && isJson(asset));\r\n                    // const isBinarySpineModel = fileExt === 'slel' && isBuffer(asset);\r\n\r\n                    let parser: ISkeletonParser = null;\r\n                    let dataToParse = asset;\r\n\r\n                    if (isJsonSpineModel) {\r\n                        parser = spineAdapter.createJsonParser();\r\n                    } else {\r\n                        parser = spineAdapter.createBinaryParser();\r\n                        dataToParse = new Uint8Array(asset);\r\n                    }\r\n\r\n                    const metadata = (loadAsset.data || {}) as ISpineMetadata;\r\n                    const metadataSkeletonScale = metadata?.spineSkeletonScale ?? null;\r\n\r\n                    if (metadataSkeletonScale) {\r\n                        parser.scale = metadataSkeletonScale;\r\n                    }\r\n\r\n                    // if metadataAtlas is a TextureAtlas, use it directly\r\n                    const metadataAtlas: TextureAtlas = metadata.spineAtlas as TextureAtlas;\r\n\r\n                    if (metadataAtlas && metadataAtlas.pages) {\r\n                        return spineAdapter.parseData(parser, metadataAtlas, dataToParse);\r\n                    }\r\n\r\n                    // if for some odd reason, you dumped the text information of the atlas into the metadata...\r\n                    let textAtlas = metadata.atlasRawData;\r\n\r\n                    // Maybe you passed a data URL to instead of a path\r\n                    const isSpineAtlasFileURL = checkDataUrl(metadata.spineAtlasFile, validAtlasMIMEs);\r\n\r\n                    // If it's an URL then decode it and assign it to textAtlas\r\n                    if (isSpineAtlasFileURL) {\r\n                        textAtlas = atob(metadata.spineAtlasFile.split(',')[1]);\r\n                    }\r\n                    if (textAtlas) {\r\n                        let auxResolve = null;\r\n                        let auxReject = null;\r\n                        const atlasPromise = new Promise<TextureAtlas>((resolve, reject) => {\r\n                            auxResolve = resolve;\r\n                            auxReject = reject;\r\n                        });\r\n                        const imageURL = typeof metadata.image === 'string' && checkDataUrl(metadata.image, validImageMIMEs) ? metadata.image : null;\r\n                        const atlas = new TextureAtlas(\r\n                            textAtlas,\r\n                            makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject(loader, basePath, metadata.imageMetadata, imageURL),\r\n                            (newAtlas) => {\r\n                                if (!newAtlas) {\r\n                                    auxReject('Something went terribly wrong loading a spine .atlas file\\nMost likely your texture failed to load.');\r\n                                }\r\n                                auxResolve(atlas);\r\n                            }\r\n                        );\r\n                        const textureAtlas = await atlasPromise;\r\n\r\n                        return spineAdapter.parseData(parser, textureAtlas, dataToParse);\r\n                    }\r\n\r\n                    // Maybe you told us where to find the file? (I sure hope you remembered to add the .atlas extension)\r\n                    let atlasPath = metadata.spineAtlasFile;\r\n\r\n                    // Finally, if no information at all about the atlas, we guess the atlas file name\r\n                    if (!atlasPath) {\r\n                        atlasPath = `${basePath + fileName}.atlas`;\r\n                    }\r\n\r\n                    const textureAtlas = await loader.load<TextureAtlas>({ src: atlasPath, data: metadata, alias: metadata.spineAtlasAlias });\r\n\r\n                    return spineAdapter.parseData(parser, textureAtlas, dataToParse);\r\n                },\r\n\r\n                // #endregion\r\n\r\n                // unload(asset: ISpineResource<SKD>, loadAsset, loader) {\r\n                // \t???\r\n                // },\r\n            },\r\n        } as AssetExtension<SPINEJSON | SPINEBINARY | ISpineResource<SKD>, ISpineMetadata>;\r\n\r\n        extensions.add(spineLoaderExtension);\r\n\r\n        return spineLoaderExtension;\r\n    }\r\n}\r\n\r\n/**\r\n * The final spineData+spineAtlas object that can be used to create a Spine.\r\n * @public\r\n */\r\nexport interface ISpineResource<SKD extends ISkeletonData> {\r\n    spineData: SKD;\r\n    spineAtlas: TextureAtlas;\r\n}\r\n\r\n/**\r\n * Metadata for loading spine assets\r\n * @public\r\n */\r\nexport interface ISpineMetadata {\r\n    // Passed directly to Spine's SkeletonJson/BinaryParser\r\n    spineSkeletonScale?: number;\r\n    // If you already have a TextureAtlas, you can pass it directly\r\n    spineAtlas?: Partial<TextureAtlas>;\r\n    // If you are going to download an .atlas file, you can specify an alias here for cache/future lookup\r\n    spineAtlasAlias?: string[];\r\n    // If you want to use a custom .atlas file or data URL, you can specify the path here. **It must be a .atlas file or you need your own parser!**\r\n    spineAtlasFile?: string;\r\n    // If for some reason, you have the raw text content of an .atlas file, and want to use it dump it here\r\n    atlasRawData?: string;\r\n    // If you are hardcore and can write your own loader function to load the textures for the atlas, you can pass it here\r\n    imageLoader?: (loader: Loader, path: string) => (path: string, callback: (tex: BaseTexture) => any) => any;\r\n    // If you are downloading an .atlas file, this metadata will go to the Texture loader\r\n    imageMetadata?: any;\r\n    // If you already have atlas pages loaded as pixi textures and want to use that to create the atlas, you can pass them here\r\n    images?: Record<string, Texture | BaseTexture>;\r\n    // If your spine only uses one atlas page and you have it as a pixi texture or data URL, you can pass it here\r\n    image?: Texture | BaseTexture | string;\r\n}\r\n\r\nfunction dataURLToArrayBuffer(dataURL: string): ArrayBuffer {\r\n    const base64 = dataURL.split(',')[1];\r\n    const binaryString = atob(base64);\r\n    const length = binaryString.length;\r\n    const arrayBuffer = new ArrayBuffer(length);\r\n    const uint8Array = new Uint8Array(arrayBuffer);\r\n\r\n    for (let i = 0; i < length; i++) {\r\n        uint8Array[i] = binaryString.charCodeAt(i);\r\n    }\r\n\r\n    return arrayBuffer;\r\n}\r\n"],"names":["textureAtlas"],"mappings":"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"}