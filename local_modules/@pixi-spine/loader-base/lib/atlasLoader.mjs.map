{"version":3,"file":"atlasLoader.mjs","sources":["../src/atlasLoader.ts"],"sourcesContent":["import { TextureAtlas } from '@pixi-spine/base';\r\nimport { type AssetExtension, LoaderParserPriority, LoadAsset, Loader, checkExtension } from '@pixi/assets';\r\nimport { BaseTexture, extensions, ExtensionType, settings, Texture, utils } from '@pixi/core';\r\nimport type { ISpineMetadata } from './SpineLoaderAbstract';\r\n\r\ntype RawAtlas = string;\r\n\r\nconst spineTextureAtlasLoader: AssetExtension<RawAtlas | TextureAtlas, ISpineMetadata> = {\r\n    extension: ExtensionType.Asset,\r\n\r\n    // cache: {\r\n    //     test: (asset: RawAtlas | TextureAtlas) => asset instanceof TextureAtlas,\r\n    //     getCacheableAssets: (keys: string[], asset: RawAtlas | TextureAtlas) => getCacheableAssets(keys, asset),\r\n    // },\r\n\r\n    loader: {\r\n        extension: {\r\n            type: ExtensionType.LoadParser,\r\n            priority: LoaderParserPriority.Normal,\r\n        },\r\n\r\n        test(url: string): boolean {\r\n            return checkExtension(url, '.atlas');\r\n        },\r\n\r\n        async load(url: string): Promise<RawAtlas> {\r\n            const response = await settings.ADAPTER.fetch(url);\r\n\r\n            const txt = await response.text();\r\n\r\n            return txt as RawAtlas;\r\n        },\r\n\r\n        testParse(asset: unknown, options: LoadAsset): Promise<boolean> {\r\n            const isExtensionRight = checkExtension(options.src, '.atlas');\r\n            const isString = typeof asset === 'string';\r\n\r\n            return Promise.resolve(isExtensionRight && isString);\r\n        },\r\n\r\n        async parse(asset: RawAtlas, options: LoadAsset, loader: Loader): Promise<TextureAtlas> {\r\n            const metadata: ISpineMetadata = options.data;\r\n            let basePath = utils.path.dirname(options.src);\r\n\r\n            if (basePath && basePath.lastIndexOf('/') !== basePath.length - 1) {\r\n                basePath += '/';\r\n            }\r\n\r\n            let resolve = null;\r\n            let reject = null;\r\n            const retPromise = new Promise<TextureAtlas>((res, rej) => {\r\n                resolve = res;\r\n                reject = rej;\r\n            });\r\n\r\n            // Retval is going to be a texture atlas. However we need to wait for it's callback to resolve this promise.\r\n            let retval;\r\n            const resolveCallback = (newAtlas: TextureAtlas): void => {\r\n                if (!newAtlas) {\r\n                    reject('Something went terribly wrong loading a spine .atlas file\\nMost likely your texture failed to load.');\r\n                }\r\n                resolve(retval);\r\n            };\r\n\r\n            // if we have an already loaded pixi image in the image field, use that.\r\n            if (metadata.image || metadata.images) {\r\n                // merge the objects\r\n                const pages = Object.assign(metadata.image ? { default: metadata.image } : {}, metadata.images);\r\n\r\n                retval = new TextureAtlas(\r\n                    asset as RawAtlas,\r\n                    (line: any, callback: any) => {\r\n                        const page = pages[line] || (pages.default as any);\r\n\r\n                        if (page && page.baseTexture) callback(page.baseTexture);\r\n                        else callback(page);\r\n                    },\r\n                    resolveCallback\r\n                );\r\n            } else {\r\n                // We don't have ready to use pixi textures, we need to load them now!\r\n                retval = new TextureAtlas(asset as RawAtlas, makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject(loader, basePath, metadata.imageMetadata), resolveCallback);\r\n            }\r\n\r\n            return (await retPromise) as TextureAtlas;\r\n        },\r\n\r\n        unload(atlas: TextureAtlas) {\r\n            atlas.dispose();\r\n        },\r\n    },\r\n} as AssetExtension<RawAtlas | TextureAtlas, ISpineMetadata>;\r\n\r\n/**\r\n * Ugly function to promisify the spine texture atlas loader function.\r\n * @public\r\n */\r\nexport const makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject = (loader: Loader, atlasBasePath: string, imageMetadata: any, imageURL?: string) => {\r\n    return async (pageName: string, textureLoadedCallback: (tex: BaseTexture) => any): Promise<void> => {\r\n        // const url = utils.path.join(...atlasBasePath.split(utils.path.sep), pageName); // Broken in upstream\r\n\r\n        const url = utils.path.normalize([...atlasBasePath.split(utils.path.sep), pageName].join(utils.path.sep));\r\n\r\n        const texture = await loader.load<Texture>(imageURL ? imageURL : { src: url, data: imageMetadata });\r\n\r\n        textureLoadedCallback(texture.baseTexture);\r\n    };\r\n};\r\n\r\nextensions.add(spineTextureAtlasLoader);\r\n"],"names":[],"mappings":"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"}