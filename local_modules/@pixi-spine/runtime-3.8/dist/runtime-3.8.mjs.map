{"version":3,"file":"runtime-3.8.mjs","sources":["../src/core/attachments/Attachment.ts","../src/core/attachments/BoundingBoxAttachment.ts","../src/core/attachments/ClippingAttachment.ts","../src/core/attachments/MeshAttachment.ts","../src/core/attachments/PathAttachment.ts","../src/core/attachments/PointAttachment.ts","../src/core/Slot.ts","../src/core/attachments/RegionAttachment.ts","../src/core/vertexeffects/JitterEffect.ts","../src/core/vertexeffects/SwirlEffect.ts","../src/core/Animation.ts","../src/core/AnimationState.ts","../src/core/AnimationStateData.ts","../src/core/AtlasAttachmentLoader.ts","../src/core/Bone.ts","../src/core/BoneData.ts","../src/core/Constraint.ts","../src/core/Event.ts","../src/core/EventData.ts","../src/core/IkConstraint.ts","../src/core/IkConstraintData.ts","../src/core/PathConstraintData.ts","../src/core/PathConstraint.ts","../src/core/TransformConstraint.ts","../src/core/Skeleton.ts","../src/core/SkeletonData.ts","../src/core/SlotData.ts","../src/core/TransformConstraintData.ts","../src/core/Skin.ts","../src/core/SkeletonBinary.ts","../src/core/SkeletonBounds.ts","../src/core/SkeletonJson.ts","../src/Spine.ts"],"sourcesContent":["import { AttachmentType, Utils } from '@pixi-spine/base';\r\nimport type { IAttachment, ArrayLike } from '@pixi-spine/base';\r\n\r\nimport type { Slot } from '../Slot';\r\n\r\n/**\r\n * @public\r\n */\r\nexport abstract class Attachment implements IAttachment {\r\n    name: string;\r\n    type: AttachmentType;\r\n\r\n    constructor(name: string) {\r\n        if (name == null) throw new Error('name cannot be null.');\r\n        this.name = name;\r\n    }\r\n\r\n    abstract copy(): Attachment;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport abstract class VertexAttachment extends Attachment {\r\n    private static nextID = 0;\r\n\r\n    id = (VertexAttachment.nextID++ & 65535) << 11;\r\n    bones: Array<number>;\r\n    vertices: ArrayLike<number>;\r\n    worldVerticesLength = 0;\r\n    deformAttachment: VertexAttachment = this;\r\n\r\n    constructor(name: string) {\r\n        super(name);\r\n    }\r\n\r\n    computeWorldVerticesOld(slot: Slot, worldVertices: ArrayLike<number>) {\r\n        this.computeWorldVertices(slot, 0, this.worldVerticesLength, worldVertices, 0, 2);\r\n    }\r\n\r\n    /** Transforms local vertices to world coordinates.\r\n     * @param start The index of the first local vertex value to transform. Each vertex has 2 values, x and y.\r\n     * @param count The number of world vertex values to output. Must be <= {@link #getWorldVerticesLength()} - start.\r\n     * @param worldVertices The output world vertices. Must have a length >= offset + count.\r\n     * @param offset The worldVertices index to begin writing values. */\r\n    computeWorldVertices(slot: Slot, start: number, count: number, worldVertices: ArrayLike<number>, offset: number, stride: number) {\r\n        count = offset + (count >> 1) * stride;\r\n        const skeleton = slot.bone.skeleton;\r\n        const deformArray = slot.deform;\r\n        let vertices = this.vertices;\r\n        const bones = this.bones;\r\n\r\n        if (bones == null) {\r\n            if (deformArray.length > 0) vertices = deformArray;\r\n            const mat = slot.bone.matrix;\r\n            const x = mat.tx;\r\n            const y = mat.ty;\r\n            const a = mat.a;\r\n            const b = mat.c;\r\n            const c = mat.b;\r\n            const d = mat.d;\r\n\r\n            for (let v = start, w = offset; w < count; v += 2, w += stride) {\r\n                const vx = vertices[v];\r\n                const vy = vertices[v + 1];\r\n\r\n                worldVertices[w] = vx * a + vy * b + x;\r\n                worldVertices[w + 1] = vx * c + vy * d + y;\r\n            }\r\n\r\n            return;\r\n        }\r\n        let v = 0;\r\n        let skip = 0;\r\n\r\n        for (let i = 0; i < start; i += 2) {\r\n            const n = bones[v];\r\n\r\n            v += n + 1;\r\n            skip += n;\r\n        }\r\n        const skeletonBones = skeleton.bones;\r\n\r\n        if (deformArray.length == 0) {\r\n            for (let w = offset, b = skip * 3; w < count; w += stride) {\r\n                let wx = 0;\r\n                let wy = 0;\r\n                let n = bones[v++];\r\n\r\n                n += v;\r\n                for (; v < n; v++, b += 3) {\r\n                    const mat = skeletonBones[bones[v]].matrix;\r\n                    const vx = vertices[b];\r\n                    const vy = vertices[b + 1];\r\n                    const weight = vertices[b + 2];\r\n\r\n                    wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\r\n                    wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\r\n                }\r\n                worldVertices[w] = wx;\r\n                worldVertices[w + 1] = wy;\r\n            }\r\n        } else {\r\n            const deform = deformArray;\r\n\r\n            for (let w = offset, b = skip * 3, f = skip << 1; w < count; w += stride) {\r\n                let wx = 0;\r\n                let wy = 0;\r\n                let n = bones[v++];\r\n\r\n                n += v;\r\n                for (; v < n; v++, b += 3, f += 2) {\r\n                    const mat = skeletonBones[bones[v]].matrix;\r\n                    const vx = vertices[b] + deform[f];\r\n                    const vy = vertices[b + 1] + deform[f + 1];\r\n                    const weight = vertices[b + 2];\r\n\r\n                    wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\r\n                    wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\r\n                }\r\n                worldVertices[w] = wx;\r\n                worldVertices[w + 1] = wy;\r\n            }\r\n        }\r\n    }\r\n\r\n    copyTo(attachment: VertexAttachment) {\r\n        if (this.bones != null) {\r\n            attachment.bones = new Array<number>(this.bones.length);\r\n            Utils.arrayCopy(this.bones, 0, attachment.bones, 0, this.bones.length);\r\n        } else attachment.bones = null;\r\n\r\n        if (this.vertices != null) {\r\n            attachment.vertices = Utils.newFloatArray(this.vertices.length);\r\n            Utils.arrayCopy(this.vertices, 0, attachment.vertices, 0, this.vertices.length);\r\n        } else attachment.vertices = null;\r\n\r\n        attachment.worldVerticesLength = this.worldVerticesLength;\r\n        attachment.deformAttachment = this.deformAttachment;\r\n    }\r\n}\r\n","import { Attachment, VertexAttachment } from './Attachment';\r\nimport { AttachmentType, Color } from '@pixi-spine/base';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class BoundingBoxAttachment extends VertexAttachment {\r\n    type = AttachmentType.BoundingBox;\r\n    color = new Color(1, 1, 1, 1);\r\n\r\n    constructor(name: string) {\r\n        super(name);\r\n    }\r\n\r\n    copy(): Attachment {\r\n        const copy = new BoundingBoxAttachment(this.name);\r\n\r\n        this.copyTo(copy);\r\n        copy.color.setFromColor(this.color);\r\n\r\n        return copy;\r\n    }\r\n}\r\n","import { Attachment, VertexAttachment } from './Attachment';\r\nimport { AttachmentType, Color, IClippingAttachment } from '@pixi-spine/base';\r\nimport type { SlotData } from '../SlotData';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class ClippingAttachment extends VertexAttachment implements IClippingAttachment {\r\n    type = AttachmentType.Clipping;\r\n    endSlot: SlotData;\r\n\r\n    // Nonessential.\r\n    color = new Color(0.2275, 0.2275, 0.8078, 1); // ce3a3aff\r\n\r\n    constructor(name: string) {\r\n        super(name);\r\n    }\r\n\r\n    copy(): Attachment {\r\n        const copy = new ClippingAttachment(this.name);\r\n\r\n        this.copyTo(copy);\r\n        copy.endSlot = this.endSlot;\r\n        copy.color.setFromColor(this.color);\r\n\r\n        return copy;\r\n    }\r\n}\r\n","import { Attachment, VertexAttachment } from './Attachment';\r\nimport { AttachmentType, Color, IMeshAttachment, TextureRegion, Utils } from '@pixi-spine/base';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class MeshAttachment extends VertexAttachment implements IMeshAttachment {\r\n    type = AttachmentType.Mesh;\r\n\r\n    region: TextureRegion;\r\n    path: string;\r\n    regionUVs: Float32Array;\r\n    triangles: Array<number>;\r\n    color = new Color(1, 1, 1, 1);\r\n    width: number;\r\n    height: number;\r\n    hullLength: number;\r\n    edges: Array<number>;\r\n    private parentMesh: MeshAttachment;\r\n    tempColor = new Color(0, 0, 0, 0);\r\n\r\n    constructor(name: string) {\r\n        super(name);\r\n    }\r\n\r\n    getParentMesh() {\r\n        return this.parentMesh;\r\n    }\r\n\r\n    /** @param parentMesh May be null. */\r\n    setParentMesh(parentMesh: MeshAttachment) {\r\n        this.parentMesh = parentMesh;\r\n        if (parentMesh != null) {\r\n            this.bones = parentMesh.bones;\r\n            this.vertices = parentMesh.vertices;\r\n            this.worldVerticesLength = parentMesh.worldVerticesLength;\r\n            this.regionUVs = parentMesh.regionUVs;\r\n            this.triangles = parentMesh.triangles;\r\n            this.hullLength = parentMesh.hullLength;\r\n            this.worldVerticesLength = parentMesh.worldVerticesLength;\r\n        }\r\n    }\r\n\r\n    copy(): Attachment {\r\n        if (this.parentMesh != null) return this.newLinkedMesh();\r\n\r\n        const copy = new MeshAttachment(this.name);\r\n\r\n        copy.region = this.region;\r\n        copy.path = this.path;\r\n        copy.color.setFromColor(this.color);\r\n\r\n        this.copyTo(copy);\r\n        copy.regionUVs = new Float32Array(this.regionUVs.length);\r\n        Utils.arrayCopy(this.regionUVs, 0, copy.regionUVs, 0, this.regionUVs.length);\r\n        copy.triangles = new Array<number>(this.triangles.length);\r\n        Utils.arrayCopy(this.triangles, 0, copy.triangles, 0, this.triangles.length);\r\n        copy.hullLength = this.hullLength;\r\n\r\n        // Nonessential.\r\n        if (this.edges != null) {\r\n            copy.edges = new Array<number>(this.edges.length);\r\n            Utils.arrayCopy(this.edges, 0, copy.edges, 0, this.edges.length);\r\n        }\r\n        copy.width = this.width;\r\n        copy.height = this.height;\r\n\r\n        return copy;\r\n    }\r\n\r\n    newLinkedMesh(): MeshAttachment {\r\n        const copy = new MeshAttachment(this.name);\r\n\r\n        copy.region = this.region;\r\n        copy.path = this.path;\r\n        copy.color.setFromColor(this.color);\r\n        copy.deformAttachment = this.deformAttachment;\r\n        copy.setParentMesh(this.parentMesh != null ? this.parentMesh : this);\r\n        // copy.updateUVs();\r\n\r\n        return copy;\r\n    }\r\n}\r\n","import { Attachment, VertexAttachment } from './Attachment';\r\nimport { AttachmentType, Color, Utils } from '@pixi-spine/base';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class PathAttachment extends VertexAttachment {\r\n    type = AttachmentType.Path;\r\n    lengths: Array<number>;\r\n    closed = false;\r\n    constantSpeed = false;\r\n    color = new Color(1, 1, 1, 1);\r\n\r\n    constructor(name: string) {\r\n        super(name);\r\n    }\r\n\r\n    copy(): Attachment {\r\n        const copy = new PathAttachment(this.name);\r\n\r\n        this.copyTo(copy);\r\n        copy.lengths = new Array<number>(this.lengths.length);\r\n        Utils.arrayCopy(this.lengths, 0, copy.lengths, 0, this.lengths.length);\r\n        copy.closed = closed;\r\n        copy.constantSpeed = this.constantSpeed;\r\n        copy.color.setFromColor(this.color);\r\n\r\n        return copy;\r\n    }\r\n}\r\n","import { Attachment, VertexAttachment } from './Attachment';\r\nimport { AttachmentType, Color, MathUtils, Vector2 } from '@pixi-spine/base';\r\nimport type { Bone } from '../Bone';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class PointAttachment extends VertexAttachment {\r\n    type = AttachmentType.Point;\r\n    x: number;\r\n    y: number;\r\n    rotation: number;\r\n    color = new Color(0.38, 0.94, 0, 1);\r\n\r\n    constructor(name: string) {\r\n        super(name);\r\n    }\r\n\r\n    computeWorldPosition(bone: Bone, point: Vector2) {\r\n        const mat = bone.matrix;\r\n\r\n        point.x = this.x * mat.a + this.y * mat.c + bone.worldX;\r\n        point.y = this.x * mat.b + this.y * mat.d + bone.worldY;\r\n\r\n        return point;\r\n    }\r\n\r\n    computeWorldRotation(bone: Bone) {\r\n        const mat = bone.matrix;\r\n        const cos = MathUtils.cosDeg(this.rotation);\r\n        const sin = MathUtils.sinDeg(this.rotation);\r\n        const x = cos * mat.a + sin * mat.c;\r\n        const y = cos * mat.b + sin * mat.d;\r\n\r\n        return Math.atan2(y, x) * MathUtils.radDeg;\r\n    }\r\n\r\n    copy(): Attachment {\r\n        const copy = new PointAttachment(this.name);\r\n\r\n        copy.x = this.x;\r\n        copy.y = this.y;\r\n        copy.rotation = this.rotation;\r\n        copy.color.setFromColor(this.color);\r\n\r\n        return copy;\r\n    }\r\n}\r\n","import { Color, ISlot } from '@pixi-spine/base';\r\n\r\nimport type { Attachment } from './attachments/Attachment';\r\nimport type { Bone } from './Bone';\r\nimport type { SlotData } from './SlotData';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class Slot implements ISlot {\r\n    // this is canon\r\n    blendMode: number;\r\n    data: SlotData;\r\n    bone: Bone;\r\n    color: Color;\r\n    darkColor: Color;\r\n    attachment: Attachment;\r\n    private attachmentTime: number;\r\n    attachmentState: number;\r\n    deform = new Array<number>();\r\n\r\n    constructor(data: SlotData, bone: Bone) {\r\n        if (data == null) throw new Error('data cannot be null.');\r\n        if (bone == null) throw new Error('bone cannot be null.');\r\n        this.data = data;\r\n        this.bone = bone;\r\n        this.color = new Color();\r\n        this.darkColor = data.darkColor == null ? null : new Color();\r\n        this.setToSetupPose();\r\n\r\n        this.blendMode = this.data.blendMode;\r\n    }\r\n\r\n    /** @return May be null. */\r\n    getAttachment(): Attachment {\r\n        return this.attachment;\r\n    }\r\n\r\n    /** Sets the attachment and if it changed, resets {@link #getAttachmentTime()} and clears {@link #getAttachmentVertices()}.\r\n     * @param attachment May be null. */\r\n    setAttachment(attachment: Attachment) {\r\n        if (this.attachment == attachment) return;\r\n        this.attachment = attachment;\r\n        this.attachmentTime = this.bone.skeleton.time;\r\n        this.deform.length = 0;\r\n    }\r\n\r\n    setAttachmentTime(time: number) {\r\n        this.attachmentTime = this.bone.skeleton.time - time;\r\n    }\r\n\r\n    /** Returns the time since the attachment was set. */\r\n    getAttachmentTime(): number {\r\n        return this.bone.skeleton.time - this.attachmentTime;\r\n    }\r\n\r\n    setToSetupPose() {\r\n        this.color.setFromColor(this.data.color);\r\n        if (this.darkColor != null) this.darkColor.setFromColor(this.data.darkColor);\r\n        if (this.data.attachmentName == null) this.attachment = null;\r\n        else {\r\n            this.attachment = null;\r\n            this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));\r\n        }\r\n    }\r\n}\r\n","import { Attachment } from './Attachment';\r\nimport { AttachmentType, ArrayLike, Color, TextureRegion, Utils, IRegionAttachment } from '@pixi-spine/base';\r\n\r\nimport type { Bone } from '../Bone';\r\nimport { Slot } from '../Slot';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class RegionAttachment extends Attachment implements IRegionAttachment {\r\n    type = AttachmentType.Region;\r\n\r\n    static OX1 = 0;\r\n    static OY1 = 1;\r\n    static OX2 = 2;\r\n    static OY2 = 3;\r\n    static OX3 = 4;\r\n    static OY3 = 5;\r\n    static OX4 = 6;\r\n    static OY4 = 7;\r\n\r\n    static X1 = 0;\r\n    static Y1 = 1;\r\n    static C1R = 2;\r\n    static C1G = 3;\r\n    static C1B = 4;\r\n    static C1A = 5;\r\n    static U1 = 6;\r\n    static V1 = 7;\r\n\r\n    static X2 = 8;\r\n    static Y2 = 9;\r\n    static C2R = 10;\r\n    static C2G = 11;\r\n    static C2B = 12;\r\n    static C2A = 13;\r\n    static U2 = 14;\r\n    static V2 = 15;\r\n\r\n    static X3 = 16;\r\n    static Y3 = 17;\r\n    static C3R = 18;\r\n    static C3G = 19;\r\n    static C3B = 20;\r\n    static C3A = 21;\r\n    static U3 = 22;\r\n    static V3 = 23;\r\n\r\n    static X4 = 24;\r\n    static Y4 = 25;\r\n    static C4R = 26;\r\n    static C4G = 27;\r\n    static C4B = 28;\r\n    static C4A = 29;\r\n    static U4 = 30;\r\n    static V4 = 31;\r\n\r\n    x = 0;\r\n    y = 0;\r\n    scaleX = 1;\r\n    scaleY = 1;\r\n    rotation = 0;\r\n    width = 0;\r\n    height = 0;\r\n    color = new Color(1, 1, 1, 1);\r\n\r\n    path: string;\r\n    rendererObject: any;\r\n    region: TextureRegion;\r\n\r\n    offset = Utils.newFloatArray(8);\r\n    uvs = Utils.newFloatArray(8);\r\n\r\n    tempColor = new Color(1, 1, 1, 1);\r\n\r\n    constructor(name: string) {\r\n        super(name);\r\n    }\r\n\r\n    updateOffset(): void {\r\n        const regionScaleX = (this.width / this.region.originalWidth) * this.scaleX;\r\n        const regionScaleY = (this.height / this.region.originalHeight) * this.scaleY;\r\n        const localX = (-this.width / 2) * this.scaleX + this.region.offsetX * regionScaleX;\r\n        const localY = (-this.height / 2) * this.scaleY + this.region.offsetY * regionScaleY;\r\n        const localX2 = localX + this.region.width * regionScaleX;\r\n        const localY2 = localY + this.region.height * regionScaleY;\r\n        const radians = (this.rotation * Math.PI) / 180;\r\n        const cos = Math.cos(radians);\r\n        const sin = Math.sin(radians);\r\n        const localXCos = localX * cos + this.x;\r\n        const localXSin = localX * sin;\r\n        const localYCos = localY * cos + this.y;\r\n        const localYSin = localY * sin;\r\n        const localX2Cos = localX2 * cos + this.x;\r\n        const localX2Sin = localX2 * sin;\r\n        const localY2Cos = localY2 * cos + this.y;\r\n        const localY2Sin = localY2 * sin;\r\n        const offset = this.offset;\r\n\r\n        offset[RegionAttachment.OX1] = localXCos - localYSin;\r\n        offset[RegionAttachment.OY1] = localYCos + localXSin;\r\n        offset[RegionAttachment.OX2] = localXCos - localY2Sin;\r\n        offset[RegionAttachment.OY2] = localY2Cos + localXSin;\r\n        offset[RegionAttachment.OX3] = localX2Cos - localY2Sin;\r\n        offset[RegionAttachment.OY3] = localY2Cos + localX2Sin;\r\n        offset[RegionAttachment.OX4] = localX2Cos - localYSin;\r\n        offset[RegionAttachment.OY4] = localYCos + localX2Sin;\r\n    }\r\n\r\n    setRegion(region: TextureRegion): void {\r\n        this.region = region;\r\n        const uvs = this.uvs;\r\n\r\n        if (region.rotate) {\r\n            uvs[2] = region.u;\r\n            uvs[3] = region.v2;\r\n            uvs[4] = region.u;\r\n            uvs[5] = region.v;\r\n            uvs[6] = region.u2;\r\n            uvs[7] = region.v;\r\n            uvs[0] = region.u2;\r\n            uvs[1] = region.v2;\r\n        } else {\r\n            uvs[0] = region.u;\r\n            uvs[1] = region.v2;\r\n            uvs[2] = region.u;\r\n            uvs[3] = region.v;\r\n            uvs[4] = region.u2;\r\n            uvs[5] = region.v;\r\n            uvs[6] = region.u2;\r\n            uvs[7] = region.v2;\r\n        }\r\n    }\r\n\r\n    computeWorldVertices(bone: Bone | Slot, worldVertices: ArrayLike<number>, offset: number, stride: number) {\r\n        const vertexOffset = this.offset;\r\n        const mat = bone instanceof Slot ? bone.bone.matrix : bone.matrix;\r\n        const x = mat.tx;\r\n        const y = mat.ty;\r\n        const a = mat.a;\r\n        const b = mat.c;\r\n        const c = mat.b;\r\n        const d = mat.d;\r\n        let offsetX = 0;\r\n        let offsetY = 0;\r\n\r\n        offsetX = vertexOffset[RegionAttachment.OX1];\r\n        offsetY = vertexOffset[RegionAttachment.OY1];\r\n        worldVertices[offset] = offsetX * a + offsetY * b + x; // br\r\n        worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\r\n        offset += stride;\r\n\r\n        offsetX = vertexOffset[RegionAttachment.OX2];\r\n        offsetY = vertexOffset[RegionAttachment.OY2];\r\n        worldVertices[offset] = offsetX * a + offsetY * b + x; // bl\r\n        worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\r\n        offset += stride;\r\n\r\n        offsetX = vertexOffset[RegionAttachment.OX3];\r\n        offsetY = vertexOffset[RegionAttachment.OY3];\r\n        worldVertices[offset] = offsetX * a + offsetY * b + x; // ul\r\n        worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\r\n        offset += stride;\r\n\r\n        offsetX = vertexOffset[RegionAttachment.OX4];\r\n        offsetY = vertexOffset[RegionAttachment.OY4];\r\n        worldVertices[offset] = offsetX * a + offsetY * b + x; // ur\r\n        worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\r\n    }\r\n\r\n    copy(): Attachment {\r\n        const copy = new RegionAttachment(this.name);\r\n\r\n        copy.region = this.region;\r\n        copy.rendererObject = this.rendererObject;\r\n        copy.path = this.path;\r\n        copy.x = this.x;\r\n        copy.y = this.y;\r\n        copy.scaleX = this.scaleX;\r\n        copy.scaleY = this.scaleY;\r\n        copy.rotation = this.rotation;\r\n        copy.width = this.width;\r\n        copy.height = this.height;\r\n        Utils.arrayCopy(this.uvs, 0, copy.uvs, 0, 8);\r\n        Utils.arrayCopy(this.offset, 0, copy.offset, 0, 8);\r\n        copy.color.setFromColor(this.color);\r\n\r\n        return copy;\r\n    }\r\n}\r\n","import type { VertexEffect } from '../VertexEffect';\r\nimport type { Skeleton } from '../Skeleton';\r\nimport { Color, MathUtils, Vector2 } from '@pixi-spine/base';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class JitterEffect implements VertexEffect {\r\n    jitterX = 0;\r\n    jitterY = 0;\r\n\r\n    constructor(jitterX: number, jitterY: number) {\r\n        this.jitterX = jitterX;\r\n        this.jitterY = jitterY;\r\n    }\r\n\r\n    begin(skeleton: Skeleton): void {}\r\n\r\n    transform(position: Vector2, uv: Vector2, light: Color, dark: Color): void {\r\n        position.x += MathUtils.randomTriangular(-this.jitterX, this.jitterY);\r\n        position.y += MathUtils.randomTriangular(-this.jitterX, this.jitterY);\r\n    }\r\n\r\n    end(): void {}\r\n}\r\n","import type { VertexEffect } from '../VertexEffect';\r\nimport type { Skeleton } from '../Skeleton';\r\nimport { Color, MathUtils, PowOut, Vector2 } from '@pixi-spine/base';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class SwirlEffect implements VertexEffect {\r\n    static interpolation = new PowOut(2);\r\n    centerX = 0;\r\n    centerY = 0;\r\n    radius = 0;\r\n    angle = 0;\r\n    private worldX = 0;\r\n    private worldY = 0;\r\n\r\n    constructor(radius: number) {\r\n        this.radius = radius;\r\n    }\r\n\r\n    begin(skeleton: Skeleton): void {\r\n        this.worldX = skeleton.x + this.centerX;\r\n        this.worldY = skeleton.y + this.centerY;\r\n    }\r\n\r\n    transform(position: Vector2, uv: Vector2, light: Color, dark: Color): void {\r\n        const radAngle = this.angle * MathUtils.degreesToRadians;\r\n        const x = position.x - this.worldX;\r\n        const y = position.y - this.worldY;\r\n        const dist = Math.sqrt(x * x + y * y);\r\n\r\n        if (dist < this.radius) {\r\n            const theta = SwirlEffect.interpolation.apply(0, radAngle, (this.radius - dist) / this.radius);\r\n            const cos = Math.cos(theta);\r\n            const sin = Math.sin(theta);\r\n\r\n            position.x = cos * x - sin * y + this.worldX;\r\n            position.y = sin * x + cos * y + this.worldY;\r\n        }\r\n    }\r\n\r\n    end(): void {}\r\n}\r\n","import type { Event } from './Event';\r\nimport type { Skeleton } from './Skeleton';\r\nimport { Attachment, VertexAttachment } from './attachments';\r\nimport { ArrayLike, MathUtils, Utils, MixBlend, MixDirection } from '@pixi-spine/base';\r\nimport type { Slot } from './Slot';\r\nimport type { IkConstraint } from './IkConstraint';\r\nimport type { TransformConstraint } from './TransformConstraint';\r\nimport type { PathConstraint } from './PathConstraint';\r\n/** A simple container for a list of timelines and a name. */\r\n/**\r\n * @public\r\n */\r\nexport class Animation {\r\n    /** The animation's name, which is unique across all animations in the skeleton. */\r\n    name: string;\r\n    timelines: Array<Timeline>;\r\n    timelineIds: Array<boolean>;\r\n\r\n    /** The duration of the animation in seconds, which is the highest time of all keys in the timeline. */\r\n    duration: number;\r\n\r\n    constructor(name: string, timelines: Array<Timeline>, duration: number) {\r\n        if (name == null) throw new Error('name cannot be null.');\r\n        if (timelines == null) throw new Error('timelines cannot be null.');\r\n        this.name = name;\r\n        this.timelines = timelines;\r\n        this.timelineIds = [];\r\n        for (let i = 0; i < timelines.length; i++) this.timelineIds[timelines[i].getPropertyId()] = true;\r\n        this.duration = duration;\r\n    }\r\n\r\n    hasTimeline(id: number) {\r\n        return this.timelineIds[id] == true;\r\n    }\r\n\r\n    /** Applies all the animation's timelines to the specified skeleton.\r\n     *\r\n     * See Timeline {@link Timeline#apply(Skeleton, float, float, Array, float, MixBlend, MixDirection)}.\r\n     * @param loop If true, the animation repeats after {@link #getDuration()}.\r\n     * @param events May be null to ignore fired events. */\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, loop: boolean, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        if (skeleton == null) throw new Error('skeleton cannot be null.');\r\n\r\n        if (loop && this.duration != 0) {\r\n            time %= this.duration;\r\n            if (lastTime > 0) lastTime %= this.duration;\r\n        }\r\n\r\n        const timelines = this.timelines;\r\n\r\n        for (let i = 0, n = timelines.length; i < n; i++) timelines[i].apply(skeleton, lastTime, time, events, alpha, blend, direction);\r\n    }\r\n\r\n    /** @param target After the first and before the last value.\r\n     * @returns index of first value greater than the target. */\r\n    static binarySearch(values: ArrayLike<number>, target: number, step = 1) {\r\n        let low = 0;\r\n        let high = values.length / step - 2;\r\n\r\n        if (high == 0) return step;\r\n        let current = high >>> 1;\r\n\r\n        while (true) {\r\n            if (values[(current + 1) * step] <= target) low = current + 1;\r\n            else high = current;\r\n            if (low == high) return (low + 1) * step;\r\n            current = (low + high) >>> 1;\r\n        }\r\n    }\r\n\r\n    static linearSearch(values: ArrayLike<number>, target: number, step: number) {\r\n        for (let i = 0, last = values.length - step; i <= last; i += step) if (values[i] > target) return i;\r\n\r\n        return -1;\r\n    }\r\n}\r\n\r\n/** The interface for all timelines. */\r\n/**\r\n * @public\r\n */\r\nexport interface Timeline {\r\n    /** Applies this timeline to the skeleton.\r\n     * @param skeleton The skeleton the timeline is being applied to. This provides access to the bones, slots, and other\r\n     *           skeleton components the timeline may change.\r\n     * @param lastTime The time this timeline was last applied. Timelines such as {@link EventTimeline}} trigger only at specific\r\n     *           times rather than every frame. In that case, the timeline triggers everything between `lastTime`\r\n     *           (exclusive) and `time` (inclusive).\r\n     * @param time The time within the animation. Most timelines find the key before and the key after this time so they can\r\n     *           interpolate between the keys.\r\n     * @param events If any events are fired, they are added to this list. Can be null to ignore fired events or if the timeline\r\n     *           does not fire events.\r\n     * @param alpha 0 applies the current or setup value (depending on `blend`). 1 applies the timeline value.\r\n     *           Between 0 and 1 applies a value between the current or setup value and the timeline value. By adjusting\r\n     *           `alpha` over time, an animation can be mixed in or out. `alpha` can also be useful to\r\n     *           apply animations on top of each other (layering).\r\n     * @param blend Controls how mixing is applied when `alpha` < 1.\r\n     * @param direction Indicates whether the timeline is mixing in or out. Used by timelines which perform instant transitions,\r\n     *           such as {@link DrawOrderTimeline} or {@link AttachmentTimeline}. */\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection): void;\r\n\r\n    /** Uniquely encodes both the type of this timeline and the skeleton property that it affects. */\r\n    getPropertyId(): number;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport enum TimelineType {\r\n    rotate,\r\n    translate,\r\n    scale,\r\n    shear,\r\n    attachment,\r\n    color,\r\n    deform,\r\n    event,\r\n    drawOrder,\r\n    ikConstraint,\r\n    transformConstraint,\r\n    pathConstraintPosition,\r\n    pathConstraintSpacing,\r\n    pathConstraintMix,\r\n    twoColor,\r\n}\r\n\r\n/** The base class for timelines that use interpolation between key frame values. */\r\n/**\r\n * @public\r\n */\r\nexport abstract class CurveTimeline implements Timeline {\r\n    static LINEAR = 0;\r\n    static STEPPED = 1;\r\n    static BEZIER = 2;\r\n    static BEZIER_SIZE = 10 * 2 - 1;\r\n\r\n    private curves: ArrayLike<number>; // type, x, y, ...\r\n\r\n    abstract getPropertyId(): number;\r\n\r\n    constructor(frameCount: number) {\r\n        if (frameCount <= 0) throw new Error(`frameCount must be > 0: ${frameCount}`);\r\n        this.curves = Utils.newFloatArray((frameCount - 1) * CurveTimeline.BEZIER_SIZE);\r\n    }\r\n\r\n    /** The number of key frames for this timeline. */\r\n    getFrameCount() {\r\n        return this.curves.length / CurveTimeline.BEZIER_SIZE + 1;\r\n    }\r\n\r\n    /** Sets the specified key frame to linear interpolation. */\r\n    setLinear(frameIndex: number) {\r\n        this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.LINEAR;\r\n    }\r\n\r\n    /** Sets the specified key frame to stepped interpolation. */\r\n    setStepped(frameIndex: number) {\r\n        this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.STEPPED;\r\n    }\r\n\r\n    /** Returns the interpolation type for the specified key frame.\r\n     * @returns Linear is 0, stepped is 1, Bezier is 2. */\r\n    getCurveType(frameIndex: number): number {\r\n        const index = frameIndex * CurveTimeline.BEZIER_SIZE;\r\n\r\n        if (index == this.curves.length) return CurveTimeline.LINEAR;\r\n        const type = this.curves[index];\r\n\r\n        if (type == CurveTimeline.LINEAR) return CurveTimeline.LINEAR;\r\n        if (type == CurveTimeline.STEPPED) return CurveTimeline.STEPPED;\r\n\r\n        return CurveTimeline.BEZIER;\r\n    }\r\n\r\n    /** Sets the specified key frame to Bezier interpolation. `cx1` and `cx2` are from 0 to 1,\r\n     * representing the percent of time between the two key frames. `cy1` and `cy2` are the percent of the\r\n     * difference between the key frame's values. */\r\n    setCurve(frameIndex: number, cx1: number, cy1: number, cx2: number, cy2: number) {\r\n        const tmpx = (-cx1 * 2 + cx2) * 0.03;\r\n        const tmpy = (-cy1 * 2 + cy2) * 0.03;\r\n        const dddfx = ((cx1 - cx2) * 3 + 1) * 0.006;\r\n        const dddfy = ((cy1 - cy2) * 3 + 1) * 0.006;\r\n        let ddfx = tmpx * 2 + dddfx;\r\n        let ddfy = tmpy * 2 + dddfy;\r\n        let dfx = cx1 * 0.3 + tmpx + dddfx * 0.16666667;\r\n        let dfy = cy1 * 0.3 + tmpy + dddfy * 0.16666667;\r\n\r\n        let i = frameIndex * CurveTimeline.BEZIER_SIZE;\r\n        const curves = this.curves;\r\n\r\n        curves[i++] = CurveTimeline.BEZIER;\r\n\r\n        let x = dfx;\r\n        let y = dfy;\r\n\r\n        for (let n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\r\n            curves[i] = x;\r\n            curves[i + 1] = y;\r\n            dfx += ddfx;\r\n            dfy += ddfy;\r\n            ddfx += dddfx;\r\n            ddfy += dddfy;\r\n            x += dfx;\r\n            y += dfy;\r\n        }\r\n    }\r\n\r\n    /** Returns the interpolated percentage for the specified key frame and linear percentage. */\r\n    getCurvePercent(frameIndex: number, percent: number) {\r\n        percent = MathUtils.clamp(percent, 0, 1);\r\n        const curves = this.curves;\r\n        let i = frameIndex * CurveTimeline.BEZIER_SIZE;\r\n        const type = curves[i];\r\n\r\n        if (type == CurveTimeline.LINEAR) return percent;\r\n        if (type == CurveTimeline.STEPPED) return 0;\r\n        i++;\r\n        let x = 0;\r\n\r\n        for (let start = i, n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\r\n            x = curves[i];\r\n            if (x >= percent) {\r\n                let prevX: number;\r\n                let prevY: number;\r\n\r\n                if (i == start) {\r\n                    prevX = 0;\r\n                    prevY = 0;\r\n                } else {\r\n                    prevX = curves[i - 2];\r\n                    prevY = curves[i - 1];\r\n                }\r\n\r\n                return prevY + ((curves[i + 1] - prevY) * (percent - prevX)) / (x - prevX);\r\n            }\r\n        }\r\n        const y = curves[i - 1];\r\n\r\n        return y + ((1 - y) * (percent - x)) / (1 - x); // Last point is 1,1.\r\n    }\r\n\r\n    abstract apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection): void;\r\n}\r\n\r\n/** Changes a bone's local {@link Bone#rotation}. */\r\n/**\r\n * @public\r\n */\r\nexport class RotateTimeline extends CurveTimeline {\r\n    static ENTRIES = 2;\r\n    static PREV_TIME = -2;\r\n    static PREV_ROTATION = -1;\r\n    static ROTATION = 1;\r\n\r\n    /** The index of the bone in {@link Skeleton#bones} that will be changed. */\r\n    boneIndex: number;\r\n\r\n    /** The time in seconds and rotation in degrees for each key frame. */\r\n    frames: ArrayLike<number>; // time, degrees, ...\r\n\r\n    constructor(frameCount: number) {\r\n        super(frameCount);\r\n        this.frames = Utils.newFloatArray(frameCount << 1);\r\n    }\r\n\r\n    getPropertyId() {\r\n        return (TimelineType.rotate << 24) + this.boneIndex;\r\n    }\r\n\r\n    /** Sets the time and angle of the specified keyframe. */\r\n    setFrame(frameIndex: number, time: number, degrees: number) {\r\n        frameIndex <<= 1;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + RotateTimeline.ROTATION] = degrees;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const frames = this.frames;\r\n\r\n        const bone = skeleton.bones[this.boneIndex];\r\n\r\n        if (!bone.active) return;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.rotation = bone.data.rotation;\r\n\r\n                    return;\r\n                case MixBlend.first:\r\n                    const r = bone.data.rotation - bone.rotation;\r\n\r\n                    bone.rotation += (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * alpha;\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        if (time >= frames[frames.length - RotateTimeline.ENTRIES]) {\r\n            // Time is after last frame.\r\n            let r = frames[frames.length + RotateTimeline.PREV_ROTATION];\r\n\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.rotation = bone.data.rotation + r * alpha;\r\n                    break;\r\n                case MixBlend.first:\r\n                case MixBlend.replace:\r\n                    r += bone.data.rotation - bone.rotation;\r\n                    r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360; // Wrap within -180 and 180.\r\n                case MixBlend.add:\r\n                    bone.rotation += r * alpha;\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        const frame = Animation.binarySearch(frames, time, RotateTimeline.ENTRIES);\r\n        const prevRotation = frames[frame + RotateTimeline.PREV_ROTATION];\r\n        const frameTime = frames[frame];\r\n        const percent = this.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + RotateTimeline.PREV_TIME] - frameTime));\r\n\r\n        let r = frames[frame + RotateTimeline.ROTATION] - prevRotation;\r\n\r\n        r = prevRotation + (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * percent;\r\n        switch (blend) {\r\n            case MixBlend.setup:\r\n                bone.rotation = bone.data.rotation + (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * alpha;\r\n                break;\r\n            case MixBlend.first:\r\n            case MixBlend.replace:\r\n                r += bone.data.rotation - bone.rotation;\r\n            case MixBlend.add:\r\n                bone.rotation += (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a bone's local {@link Bone#x} and {@link Bone#y}. */\r\n/**\r\n * @public\r\n */\r\nexport class TranslateTimeline extends CurveTimeline {\r\n    static ENTRIES = 3;\r\n    static PREV_TIME = -3;\r\n    static PREV_X = -2;\r\n    static PREV_Y = -1;\r\n    static X = 1;\r\n    static Y = 2;\r\n\r\n    /** The index of the bone in {@link Skeleton#bones} that will be changed. */\r\n    boneIndex: number;\r\n\r\n    /** The time in seconds, x, and y values for each key frame. */\r\n    frames: ArrayLike<number>; // time, x, y, ...\r\n\r\n    constructor(frameCount: number) {\r\n        super(frameCount);\r\n        this.frames = Utils.newFloatArray(frameCount * TranslateTimeline.ENTRIES);\r\n    }\r\n\r\n    getPropertyId() {\r\n        return (TimelineType.translate << 24) + this.boneIndex;\r\n    }\r\n\r\n    /** Sets the time in seconds, x, and y values for the specified key frame. */\r\n    setFrame(frameIndex: number, time: number, x: number, y: number) {\r\n        frameIndex *= TranslateTimeline.ENTRIES;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + TranslateTimeline.X] = x;\r\n        this.frames[frameIndex + TranslateTimeline.Y] = y;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const frames = this.frames;\r\n\r\n        const bone = skeleton.bones[this.boneIndex];\r\n\r\n        if (!bone.active) return;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.x = bone.data.x;\r\n                    bone.y = bone.data.y;\r\n\r\n                    return;\r\n                case MixBlend.first:\r\n                    bone.x += (bone.data.x - bone.x) * alpha;\r\n                    bone.y += (bone.data.y - bone.y) * alpha;\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        let x = 0;\r\n        let y = 0;\r\n\r\n        if (time >= frames[frames.length - TranslateTimeline.ENTRIES]) {\r\n            // Time is after last frame.\r\n            x = frames[frames.length + TranslateTimeline.PREV_X];\r\n            y = frames[frames.length + TranslateTimeline.PREV_Y];\r\n        } else {\r\n            // Interpolate between the previous frame and the current frame.\r\n            const frame = Animation.binarySearch(frames, time, TranslateTimeline.ENTRIES);\r\n\r\n            x = frames[frame + TranslateTimeline.PREV_X];\r\n            y = frames[frame + TranslateTimeline.PREV_Y];\r\n            const frameTime = frames[frame];\r\n            const percent = this.getCurvePercent(frame / TranslateTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TranslateTimeline.PREV_TIME] - frameTime));\r\n\r\n            x += (frames[frame + TranslateTimeline.X] - x) * percent;\r\n            y += (frames[frame + TranslateTimeline.Y] - y) * percent;\r\n        }\r\n        switch (blend) {\r\n            case MixBlend.setup:\r\n                bone.x = bone.data.x + x * alpha;\r\n                bone.y = bone.data.y + y * alpha;\r\n                break;\r\n            case MixBlend.first:\r\n            case MixBlend.replace:\r\n                bone.x += (bone.data.x + x - bone.x) * alpha;\r\n                bone.y += (bone.data.y + y - bone.y) * alpha;\r\n                break;\r\n            case MixBlend.add:\r\n                bone.x += x * alpha;\r\n                bone.y += y * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a bone's local {@link Bone#scaleX)} and {@link Bone#scaleY}. */\r\n/**\r\n * @public\r\n */\r\nexport class ScaleTimeline extends TranslateTimeline {\r\n    constructor(frameCount: number) {\r\n        super(frameCount);\r\n    }\r\n\r\n    getPropertyId() {\r\n        return (TimelineType.scale << 24) + this.boneIndex;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const frames = this.frames;\r\n\r\n        const bone = skeleton.bones[this.boneIndex];\r\n\r\n        if (!bone.active) return;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.scaleX = bone.data.scaleX;\r\n                    bone.scaleY = bone.data.scaleY;\r\n\r\n                    return;\r\n                case MixBlend.first:\r\n                    bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;\r\n                    bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        let x = 0;\r\n        let y = 0;\r\n\r\n        if (time >= frames[frames.length - ScaleTimeline.ENTRIES]) {\r\n            // Time is after last frame.\r\n            x = frames[frames.length + ScaleTimeline.PREV_X] * bone.data.scaleX;\r\n            y = frames[frames.length + ScaleTimeline.PREV_Y] * bone.data.scaleY;\r\n        } else {\r\n            // Interpolate between the previous frame and the current frame.\r\n            const frame = Animation.binarySearch(frames, time, ScaleTimeline.ENTRIES);\r\n\r\n            x = frames[frame + ScaleTimeline.PREV_X];\r\n            y = frames[frame + ScaleTimeline.PREV_Y];\r\n            const frameTime = frames[frame];\r\n            const percent = this.getCurvePercent(frame / ScaleTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ScaleTimeline.PREV_TIME] - frameTime));\r\n\r\n            x = (x + (frames[frame + ScaleTimeline.X] - x) * percent) * bone.data.scaleX;\r\n            y = (y + (frames[frame + ScaleTimeline.Y] - y) * percent) * bone.data.scaleY;\r\n        }\r\n        if (alpha == 1) {\r\n            if (blend == MixBlend.add) {\r\n                bone.scaleX += x - bone.data.scaleX;\r\n                bone.scaleY += y - bone.data.scaleY;\r\n            } else {\r\n                bone.scaleX = x;\r\n                bone.scaleY = y;\r\n            }\r\n        } else {\r\n            let bx = 0;\r\n            let by = 0;\r\n\r\n            if (direction == MixDirection.mixOut) {\r\n                switch (blend) {\r\n                    case MixBlend.setup:\r\n                        bx = bone.data.scaleX;\r\n                        by = bone.data.scaleY;\r\n                        bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\r\n                        bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\r\n                        break;\r\n                    case MixBlend.first:\r\n                    case MixBlend.replace:\r\n                        bx = bone.scaleX;\r\n                        by = bone.scaleY;\r\n                        bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\r\n                        bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\r\n                        break;\r\n                    case MixBlend.add:\r\n                        bx = bone.scaleX;\r\n                        by = bone.scaleY;\r\n                        bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bone.data.scaleX) * alpha;\r\n                        bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - bone.data.scaleY) * alpha;\r\n                }\r\n            } else {\r\n                switch (blend) {\r\n                    case MixBlend.setup:\r\n                        bx = Math.abs(bone.data.scaleX) * MathUtils.signum(x);\r\n                        by = Math.abs(bone.data.scaleY) * MathUtils.signum(y);\r\n                        bone.scaleX = bx + (x - bx) * alpha;\r\n                        bone.scaleY = by + (y - by) * alpha;\r\n                        break;\r\n                    case MixBlend.first:\r\n                    case MixBlend.replace:\r\n                        bx = Math.abs(bone.scaleX) * MathUtils.signum(x);\r\n                        by = Math.abs(bone.scaleY) * MathUtils.signum(y);\r\n                        bone.scaleX = bx + (x - bx) * alpha;\r\n                        bone.scaleY = by + (y - by) * alpha;\r\n                        break;\r\n                    case MixBlend.add:\r\n                        bx = MathUtils.signum(x);\r\n                        by = MathUtils.signum(y);\r\n                        bone.scaleX = Math.abs(bone.scaleX) * bx + (x - Math.abs(bone.data.scaleX) * bx) * alpha;\r\n                        bone.scaleY = Math.abs(bone.scaleY) * by + (y - Math.abs(bone.data.scaleY) * by) * alpha;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a bone's local {@link Bone#shearX} and {@link Bone#shearY}. */\r\n/**\r\n * @public\r\n */\r\nexport class ShearTimeline extends TranslateTimeline {\r\n    constructor(frameCount: number) {\r\n        super(frameCount);\r\n    }\r\n\r\n    getPropertyId() {\r\n        return (TimelineType.shear << 24) + this.boneIndex;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const frames = this.frames;\r\n\r\n        const bone = skeleton.bones[this.boneIndex];\r\n\r\n        if (!bone.active) return;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.shearX = bone.data.shearX;\r\n                    bone.shearY = bone.data.shearY;\r\n\r\n                    return;\r\n                case MixBlend.first:\r\n                    bone.shearX += (bone.data.shearX - bone.shearX) * alpha;\r\n                    bone.shearY += (bone.data.shearY - bone.shearY) * alpha;\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        let x = 0;\r\n        let y = 0;\r\n\r\n        if (time >= frames[frames.length - ShearTimeline.ENTRIES]) {\r\n            // Time is after last frame.\r\n            x = frames[frames.length + ShearTimeline.PREV_X];\r\n            y = frames[frames.length + ShearTimeline.PREV_Y];\r\n        } else {\r\n            // Interpolate between the previous frame and the current frame.\r\n            const frame = Animation.binarySearch(frames, time, ShearTimeline.ENTRIES);\r\n\r\n            x = frames[frame + ShearTimeline.PREV_X];\r\n            y = frames[frame + ShearTimeline.PREV_Y];\r\n            const frameTime = frames[frame];\r\n            const percent = this.getCurvePercent(frame / ShearTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ShearTimeline.PREV_TIME] - frameTime));\r\n\r\n            x = x + (frames[frame + ShearTimeline.X] - x) * percent;\r\n            y = y + (frames[frame + ShearTimeline.Y] - y) * percent;\r\n        }\r\n        switch (blend) {\r\n            case MixBlend.setup:\r\n                bone.shearX = bone.data.shearX + x * alpha;\r\n                bone.shearY = bone.data.shearY + y * alpha;\r\n                break;\r\n            case MixBlend.first:\r\n            case MixBlend.replace:\r\n                bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;\r\n                bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;\r\n                break;\r\n            case MixBlend.add:\r\n                bone.shearX += x * alpha;\r\n                bone.shearY += y * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a slot's {@link Slot#color}. */\r\n/**\r\n * @public\r\n */\r\nexport class ColorTimeline extends CurveTimeline {\r\n    static ENTRIES = 5;\r\n    static PREV_TIME = -5;\r\n    static PREV_R = -4;\r\n    static PREV_G = -3;\r\n    static PREV_B = -2;\r\n    static PREV_A = -1;\r\n    static R = 1;\r\n    static G = 2;\r\n    static B = 3;\r\n    static A = 4;\r\n\r\n    /** The index of the slot in {@link Skeleton#slots} that will be changed. */\r\n    slotIndex: number;\r\n\r\n    /** The time in seconds, red, green, blue, and alpha values for each key frame. */\r\n    frames: ArrayLike<number>; // time, r, g, b, a, ...\r\n\r\n    constructor(frameCount: number) {\r\n        super(frameCount);\r\n        this.frames = Utils.newFloatArray(frameCount * ColorTimeline.ENTRIES);\r\n    }\r\n\r\n    getPropertyId() {\r\n        return (TimelineType.color << 24) + this.slotIndex;\r\n    }\r\n\r\n    /** Sets the time in seconds, red, green, blue, and alpha for the specified key frame. */\r\n    setFrame(frameIndex: number, time: number, r: number, g: number, b: number, a: number) {\r\n        frameIndex *= ColorTimeline.ENTRIES;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + ColorTimeline.R] = r;\r\n        this.frames[frameIndex + ColorTimeline.G] = g;\r\n        this.frames[frameIndex + ColorTimeline.B] = b;\r\n        this.frames[frameIndex + ColorTimeline.A] = a;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const slot = skeleton.slots[this.slotIndex];\r\n\r\n        if (!slot.bone.active) return;\r\n        const frames = this.frames;\r\n\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    slot.color.setFromColor(slot.data.color);\r\n\r\n                    return;\r\n                case MixBlend.first:\r\n                    const color = slot.color;\r\n                    const setup = slot.data.color;\r\n\r\n                    color.add((setup.r - color.r) * alpha, (setup.g - color.g) * alpha, (setup.b - color.b) * alpha, (setup.a - color.a) * alpha);\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        let r = 0;\r\n        let g = 0;\r\n        let b = 0;\r\n        let a = 0;\r\n\r\n        if (time >= frames[frames.length - ColorTimeline.ENTRIES]) {\r\n            // Time is after last frame.\r\n            const i = frames.length;\r\n\r\n            r = frames[i + ColorTimeline.PREV_R];\r\n            g = frames[i + ColorTimeline.PREV_G];\r\n            b = frames[i + ColorTimeline.PREV_B];\r\n            a = frames[i + ColorTimeline.PREV_A];\r\n        } else {\r\n            // Interpolate between the previous frame and the current frame.\r\n            const frame = Animation.binarySearch(frames, time, ColorTimeline.ENTRIES);\r\n\r\n            r = frames[frame + ColorTimeline.PREV_R];\r\n            g = frames[frame + ColorTimeline.PREV_G];\r\n            b = frames[frame + ColorTimeline.PREV_B];\r\n            a = frames[frame + ColorTimeline.PREV_A];\r\n            const frameTime = frames[frame];\r\n            const percent = this.getCurvePercent(frame / ColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ColorTimeline.PREV_TIME] - frameTime));\r\n\r\n            r += (frames[frame + ColorTimeline.R] - r) * percent;\r\n            g += (frames[frame + ColorTimeline.G] - g) * percent;\r\n            b += (frames[frame + ColorTimeline.B] - b) * percent;\r\n            a += (frames[frame + ColorTimeline.A] - a) * percent;\r\n        }\r\n        if (alpha == 1) slot.color.set(r, g, b, a);\r\n        else {\r\n            const color = slot.color;\r\n\r\n            if (blend == MixBlend.setup) color.setFromColor(slot.data.color);\r\n            color.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a slot's {@link Slot#color} and {@link Slot#darkColor} for two color tinting. */\r\n/**\r\n * @public\r\n */\r\nexport class TwoColorTimeline extends CurveTimeline {\r\n    static ENTRIES = 8;\r\n    static PREV_TIME = -8;\r\n    static PREV_R = -7;\r\n    static PREV_G = -6;\r\n    static PREV_B = -5;\r\n    static PREV_A = -4;\r\n    static PREV_R2 = -3;\r\n    static PREV_G2 = -2;\r\n    static PREV_B2 = -1;\r\n    static R = 1;\r\n    static G = 2;\r\n    static B = 3;\r\n    static A = 4;\r\n    static R2 = 5;\r\n    static G2 = 6;\r\n    static B2 = 7;\r\n\r\n    /** The index of the slot in {@link Skeleton#slots()} that will be changed. The {@link Slot#darkColor()} must not be\r\n     * null. */\r\n    slotIndex: number;\r\n\r\n    /** The time in seconds, red, green, blue, and alpha values of the color, red, green, blue of the dark color, for each key frame. */\r\n    frames: ArrayLike<number>; // time, r, g, b, a, r2, g2, b2, ...\r\n\r\n    constructor(frameCount: number) {\r\n        super(frameCount);\r\n        this.frames = Utils.newFloatArray(frameCount * TwoColorTimeline.ENTRIES);\r\n    }\r\n\r\n    getPropertyId() {\r\n        return (TimelineType.twoColor << 24) + this.slotIndex;\r\n    }\r\n\r\n    /** Sets the time in seconds, light, and dark colors for the specified key frame. */\r\n    setFrame(frameIndex: number, time: number, r: number, g: number, b: number, a: number, r2: number, g2: number, b2: number) {\r\n        frameIndex *= TwoColorTimeline.ENTRIES;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + TwoColorTimeline.R] = r;\r\n        this.frames[frameIndex + TwoColorTimeline.G] = g;\r\n        this.frames[frameIndex + TwoColorTimeline.B] = b;\r\n        this.frames[frameIndex + TwoColorTimeline.A] = a;\r\n        this.frames[frameIndex + TwoColorTimeline.R2] = r2;\r\n        this.frames[frameIndex + TwoColorTimeline.G2] = g2;\r\n        this.frames[frameIndex + TwoColorTimeline.B2] = b2;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const slot = skeleton.slots[this.slotIndex];\r\n\r\n        if (!slot.bone.active) return;\r\n        const frames = this.frames;\r\n\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    slot.color.setFromColor(slot.data.color);\r\n                    slot.darkColor.setFromColor(slot.data.darkColor);\r\n\r\n                    return;\r\n                case MixBlend.first:\r\n                    const light = slot.color;\r\n                    const dark = slot.darkColor;\r\n                    const setupLight = slot.data.color;\r\n                    const setupDark = slot.data.darkColor;\r\n\r\n                    light.add((setupLight.r - light.r) * alpha, (setupLight.g - light.g) * alpha, (setupLight.b - light.b) * alpha, (setupLight.a - light.a) * alpha);\r\n                    dark.add((setupDark.r - dark.r) * alpha, (setupDark.g - dark.g) * alpha, (setupDark.b - dark.b) * alpha, 0);\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        let r = 0;\r\n        let g = 0;\r\n        let b = 0;\r\n        let a = 0;\r\n        let r2 = 0;\r\n        let g2 = 0;\r\n        let b2 = 0;\r\n\r\n        if (time >= frames[frames.length - TwoColorTimeline.ENTRIES]) {\r\n            // Time is after last frame.\r\n            const i = frames.length;\r\n\r\n            r = frames[i + TwoColorTimeline.PREV_R];\r\n            g = frames[i + TwoColorTimeline.PREV_G];\r\n            b = frames[i + TwoColorTimeline.PREV_B];\r\n            a = frames[i + TwoColorTimeline.PREV_A];\r\n            r2 = frames[i + TwoColorTimeline.PREV_R2];\r\n            g2 = frames[i + TwoColorTimeline.PREV_G2];\r\n            b2 = frames[i + TwoColorTimeline.PREV_B2];\r\n        } else {\r\n            // Interpolate between the previous frame and the current frame.\r\n            const frame = Animation.binarySearch(frames, time, TwoColorTimeline.ENTRIES);\r\n\r\n            r = frames[frame + TwoColorTimeline.PREV_R];\r\n            g = frames[frame + TwoColorTimeline.PREV_G];\r\n            b = frames[frame + TwoColorTimeline.PREV_B];\r\n            a = frames[frame + TwoColorTimeline.PREV_A];\r\n            r2 = frames[frame + TwoColorTimeline.PREV_R2];\r\n            g2 = frames[frame + TwoColorTimeline.PREV_G2];\r\n            b2 = frames[frame + TwoColorTimeline.PREV_B2];\r\n            const frameTime = frames[frame];\r\n            const percent = this.getCurvePercent(frame / TwoColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TwoColorTimeline.PREV_TIME] - frameTime));\r\n\r\n            r += (frames[frame + TwoColorTimeline.R] - r) * percent;\r\n            g += (frames[frame + TwoColorTimeline.G] - g) * percent;\r\n            b += (frames[frame + TwoColorTimeline.B] - b) * percent;\r\n            a += (frames[frame + TwoColorTimeline.A] - a) * percent;\r\n            r2 += (frames[frame + TwoColorTimeline.R2] - r2) * percent;\r\n            g2 += (frames[frame + TwoColorTimeline.G2] - g2) * percent;\r\n            b2 += (frames[frame + TwoColorTimeline.B2] - b2) * percent;\r\n        }\r\n        if (alpha == 1) {\r\n            slot.color.set(r, g, b, a);\r\n            slot.darkColor.set(r2, g2, b2, 1);\r\n        } else {\r\n            const light = slot.color;\r\n            const dark = slot.darkColor;\r\n\r\n            if (blend == MixBlend.setup) {\r\n                light.setFromColor(slot.data.color);\r\n                dark.setFromColor(slot.data.darkColor);\r\n            }\r\n            light.add((r - light.r) * alpha, (g - light.g) * alpha, (b - light.b) * alpha, (a - light.a) * alpha);\r\n            dark.add((r2 - dark.r) * alpha, (g2 - dark.g) * alpha, (b2 - dark.b) * alpha, 0);\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a slot's {@link Slot#attachment}. */\r\n/**\r\n * @public\r\n */\r\nexport class AttachmentTimeline implements Timeline {\r\n    /** The index of the slot in {@link Skeleton#slots} that will be changed. */\r\n    slotIndex: number;\r\n\r\n    /** The time in seconds for each key frame. */\r\n    frames: ArrayLike<number>; // time, ...\r\n\r\n    /** The attachment name for each key frame. May contain null values to clear the attachment. */\r\n    attachmentNames: Array<string>;\r\n\r\n    constructor(frameCount: number) {\r\n        this.frames = Utils.newFloatArray(frameCount);\r\n        this.attachmentNames = new Array<string>(frameCount);\r\n    }\r\n\r\n    getPropertyId() {\r\n        return (TimelineType.attachment << 24) + this.slotIndex;\r\n    }\r\n\r\n    /** The number of key frames for this timeline. */\r\n    getFrameCount() {\r\n        return this.frames.length;\r\n    }\r\n\r\n    /** Sets the time in seconds and the attachment name for the specified key frame. */\r\n    setFrame(frameIndex: number, time: number, attachmentName: string) {\r\n        this.frames[frameIndex] = time;\r\n        this.attachmentNames[frameIndex] = attachmentName;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const slot = skeleton.slots[this.slotIndex];\r\n\r\n        if (!slot.bone.active) return;\r\n        if (direction == MixDirection.mixOut) {\r\n            if (blend == MixBlend.setup) this.setAttachment(skeleton, slot, slot.data.attachmentName);\r\n\r\n            return;\r\n        }\r\n\r\n        const frames = this.frames;\r\n\r\n        if (time < frames[0]) {\r\n            if (blend == MixBlend.setup || blend == MixBlend.first) this.setAttachment(skeleton, slot, slot.data.attachmentName);\r\n\r\n            return;\r\n        }\r\n\r\n        let frameIndex = 0;\r\n\r\n        if (time >= frames[frames.length - 1])\r\n            // Time is after last frame.\r\n            frameIndex = frames.length - 1;\r\n        else frameIndex = Animation.binarySearch(frames, time, 1) - 1;\r\n\r\n        const attachmentName = this.attachmentNames[frameIndex];\r\n\r\n        skeleton.slots[this.slotIndex].setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\r\n    }\r\n\r\n    setAttachment(skeleton: Skeleton, slot: Slot, attachmentName: string) {\r\n        slot.setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\r\n    }\r\n}\r\n\r\nlet zeros: ArrayLike<number> = null;\r\n\r\n/** Changes a slot's {@link Slot#deform} to deform a {@link VertexAttachment}. */\r\n/**\r\n * @public\r\n */\r\nexport class DeformTimeline extends CurveTimeline {\r\n    /** The index of the slot in {@link Skeleton#getSlots()} that will be changed. */\r\n    slotIndex: number;\r\n\r\n    /** The attachment that will be deformed. */\r\n    attachment: VertexAttachment;\r\n\r\n    /** The time in seconds for each key frame. */\r\n    frames: ArrayLike<number>; // time, ...\r\n\r\n    /** The vertices for each key frame. */\r\n    frameVertices: Array<ArrayLike<number>>;\r\n\r\n    constructor(frameCount: number) {\r\n        super(frameCount);\r\n        this.frames = Utils.newFloatArray(frameCount);\r\n        this.frameVertices = new Array<ArrayLike<number>>(frameCount);\r\n        if (zeros == null) zeros = Utils.newFloatArray(64);\r\n    }\r\n\r\n    getPropertyId() {\r\n        return (TimelineType.deform << 27) + Number(this.attachment.id) + this.slotIndex;\r\n    }\r\n\r\n    /** Sets the time in seconds and the vertices for the specified key frame.\r\n     * @param vertices Vertex positions for an unweighted VertexAttachment, or deform offsets if it has weights. */\r\n    setFrame(frameIndex: number, time: number, vertices: ArrayLike<number>) {\r\n        this.frames[frameIndex] = time;\r\n        this.frameVertices[frameIndex] = vertices;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const slot: Slot = skeleton.slots[this.slotIndex];\r\n\r\n        if (!slot.bone.active) return;\r\n        const slotAttachment: Attachment = slot.getAttachment();\r\n\r\n        if (!(slotAttachment instanceof VertexAttachment) || !((<VertexAttachment>slotAttachment).deformAttachment == this.attachment)) return;\r\n\r\n        const deformArray: Array<number> = slot.deform;\r\n\r\n        if (deformArray.length == 0) blend = MixBlend.setup;\r\n\r\n        const frameVertices = this.frameVertices;\r\n        const vertexCount = frameVertices[0].length;\r\n\r\n        const frames = this.frames;\r\n\r\n        if (time < frames[0]) {\r\n            const vertexAttachment = <VertexAttachment>slotAttachment;\r\n\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    deformArray.length = 0;\r\n\r\n                    return;\r\n                case MixBlend.first:\r\n                    if (alpha == 1) {\r\n                        deformArray.length = 0;\r\n                        break;\r\n                    }\r\n                    const deform: Array<number> = Utils.setArraySize(deformArray, vertexCount);\r\n\r\n                    if (vertexAttachment.bones == null) {\r\n                        // Unweighted vertex positions.\r\n                        const setupVertices = vertexAttachment.vertices;\r\n\r\n                        for (let i = 0; i < vertexCount; i++) deform[i] += (setupVertices[i] - deform[i]) * alpha;\r\n                    } else {\r\n                        // Weighted deform offsets.\r\n                        alpha = 1 - alpha;\r\n                        for (let i = 0; i < vertexCount; i++) deform[i] *= alpha;\r\n                    }\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        const deform: Array<number> = Utils.setArraySize(deformArray, vertexCount);\r\n\r\n        if (time >= frames[frames.length - 1]) {\r\n            // Time is after last frame.\r\n            const lastVertices = frameVertices[frames.length - 1];\r\n\r\n            if (alpha == 1) {\r\n                if (blend == MixBlend.add) {\r\n                    const vertexAttachment = slotAttachment as VertexAttachment;\r\n\r\n                    if (vertexAttachment.bones == null) {\r\n                        // Unweighted vertex positions, with alpha.\r\n                        const setupVertices = vertexAttachment.vertices;\r\n\r\n                        for (let i = 0; i < vertexCount; i++) {\r\n                            deform[i] += lastVertices[i] - setupVertices[i];\r\n                        }\r\n                    } else {\r\n                        // Weighted deform offsets, with alpha.\r\n                        for (let i = 0; i < vertexCount; i++) deform[i] += lastVertices[i];\r\n                    }\r\n                } else {\r\n                    Utils.arrayCopy(lastVertices, 0, deform, 0, vertexCount);\r\n                }\r\n            } else {\r\n                switch (blend) {\r\n                    case MixBlend.setup: {\r\n                        const vertexAttachment = slotAttachment as VertexAttachment;\r\n\r\n                        if (vertexAttachment.bones == null) {\r\n                            // Unweighted vertex positions, with alpha.\r\n                            const setupVertices = vertexAttachment.vertices;\r\n\r\n                            for (let i = 0; i < vertexCount; i++) {\r\n                                const setup = setupVertices[i];\r\n\r\n                                deform[i] = setup + (lastVertices[i] - setup) * alpha;\r\n                            }\r\n                        } else {\r\n                            // Weighted deform offsets, with alpha.\r\n                            for (let i = 0; i < vertexCount; i++) deform[i] = lastVertices[i] * alpha;\r\n                        }\r\n                        break;\r\n                    }\r\n                    case MixBlend.first:\r\n                    case MixBlend.replace:\r\n                        for (let i = 0; i < vertexCount; i++) deform[i] += (lastVertices[i] - deform[i]) * alpha;\r\n                        break;\r\n                    case MixBlend.add:\r\n                        const vertexAttachment = slotAttachment as VertexAttachment;\r\n\r\n                        if (vertexAttachment.bones == null) {\r\n                            // Unweighted vertex positions, with alpha.\r\n                            const setupVertices = vertexAttachment.vertices;\r\n\r\n                            for (let i = 0; i < vertexCount; i++) {\r\n                                deform[i] += (lastVertices[i] - setupVertices[i]) * alpha;\r\n                            }\r\n                        } else {\r\n                            // Weighted deform offsets, with alpha.\r\n                            for (let i = 0; i < vertexCount; i++) deform[i] += lastVertices[i] * alpha;\r\n                        }\r\n                }\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        const frame = Animation.binarySearch(frames, time);\r\n        const prevVertices = frameVertices[frame - 1];\r\n        const nextVertices = frameVertices[frame];\r\n        const frameTime = frames[frame];\r\n        const percent = this.getCurvePercent(frame - 1, 1 - (time - frameTime) / (frames[frame - 1] - frameTime));\r\n\r\n        if (alpha == 1) {\r\n            if (blend == MixBlend.add) {\r\n                const vertexAttachment = slotAttachment as VertexAttachment;\r\n\r\n                if (vertexAttachment.bones == null) {\r\n                    // Unweighted vertex positions, with alpha.\r\n                    const setupVertices = vertexAttachment.vertices;\r\n\r\n                    for (let i = 0; i < vertexCount; i++) {\r\n                        const prev = prevVertices[i];\r\n\r\n                        deform[i] += prev + (nextVertices[i] - prev) * percent - setupVertices[i];\r\n                    }\r\n                } else {\r\n                    // Weighted deform offsets, with alpha.\r\n                    for (let i = 0; i < vertexCount; i++) {\r\n                        const prev = prevVertices[i];\r\n\r\n                        deform[i] += prev + (nextVertices[i] - prev) * percent;\r\n                    }\r\n                }\r\n            } else {\r\n                for (let i = 0; i < vertexCount; i++) {\r\n                    const prev = prevVertices[i];\r\n\r\n                    deform[i] = prev + (nextVertices[i] - prev) * percent;\r\n                }\r\n            }\r\n        } else {\r\n            switch (blend) {\r\n                case MixBlend.setup: {\r\n                    const vertexAttachment = slotAttachment as VertexAttachment;\r\n\r\n                    if (vertexAttachment.bones == null) {\r\n                        // Unweighted vertex positions, with alpha.\r\n                        const setupVertices = vertexAttachment.vertices;\r\n\r\n                        for (let i = 0; i < vertexCount; i++) {\r\n                            const prev = prevVertices[i];\r\n                            const setup = setupVertices[i];\r\n\r\n                            deform[i] = setup + (prev + (nextVertices[i] - prev) * percent - setup) * alpha;\r\n                        }\r\n                    } else {\r\n                        // Weighted deform offsets, with alpha.\r\n                        for (let i = 0; i < vertexCount; i++) {\r\n                            const prev = prevVertices[i];\r\n\r\n                            deform[i] = (prev + (nextVertices[i] - prev) * percent) * alpha;\r\n                        }\r\n                    }\r\n                    break;\r\n                }\r\n                case MixBlend.first:\r\n                case MixBlend.replace:\r\n                    for (let i = 0; i < vertexCount; i++) {\r\n                        const prev = prevVertices[i];\r\n\r\n                        deform[i] += (prev + (nextVertices[i] - prev) * percent - deform[i]) * alpha;\r\n                    }\r\n                    break;\r\n                case MixBlend.add:\r\n                    const vertexAttachment = slotAttachment as VertexAttachment;\r\n\r\n                    if (vertexAttachment.bones == null) {\r\n                        // Unweighted vertex positions, with alpha.\r\n                        const setupVertices = vertexAttachment.vertices;\r\n\r\n                        for (let i = 0; i < vertexCount; i++) {\r\n                            const prev = prevVertices[i];\r\n\r\n                            deform[i] += (prev + (nextVertices[i] - prev) * percent - setupVertices[i]) * alpha;\r\n                        }\r\n                    } else {\r\n                        // Weighted deform offsets, with alpha.\r\n                        for (let i = 0; i < vertexCount; i++) {\r\n                            const prev = prevVertices[i];\r\n\r\n                            deform[i] += (prev + (nextVertices[i] - prev) * percent) * alpha;\r\n                        }\r\n                    }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/** Fires an {@link Event} when specific animation times are reached. */\r\n/**\r\n * @public\r\n */\r\nexport class EventTimeline implements Timeline {\r\n    /** The time in seconds for each key frame. */\r\n    frames: ArrayLike<number>; // time, ...\r\n\r\n    /** The event for each key frame. */\r\n    events: Array<Event>;\r\n\r\n    constructor(frameCount: number) {\r\n        this.frames = Utils.newFloatArray(frameCount);\r\n        this.events = new Array<Event>(frameCount);\r\n    }\r\n\r\n    getPropertyId() {\r\n        return TimelineType.event << 24;\r\n    }\r\n\r\n    /** The number of key frames for this timeline. */\r\n    getFrameCount() {\r\n        return this.frames.length;\r\n    }\r\n\r\n    /** Sets the time in seconds and the event for the specified key frame. */\r\n    setFrame(frameIndex: number, event: Event) {\r\n        this.frames[frameIndex] = event.time;\r\n        this.events[frameIndex] = event;\r\n    }\r\n\r\n    /** Fires events for frames > `lastTime` and <= `time`. */\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        if (firedEvents == null) return;\r\n        const frames = this.frames;\r\n        const frameCount = this.frames.length;\r\n\r\n        if (lastTime > time) {\r\n            // Fire events after last time for looped animations.\r\n            this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, blend, direction);\r\n            lastTime = -1;\r\n        } else if (lastTime >= frames[frameCount - 1])\r\n            // Last time is after last frame.\r\n            return;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        let frame = 0;\r\n\r\n        if (lastTime < frames[0]) frame = 0;\r\n        else {\r\n            frame = Animation.binarySearch(frames, lastTime);\r\n            const frameTime = frames[frame];\r\n\r\n            while (frame > 0) {\r\n                // Fire multiple events with the same frame.\r\n                if (frames[frame - 1] != frameTime) break;\r\n                frame--;\r\n            }\r\n        }\r\n        for (; frame < frameCount && time >= frames[frame]; frame++) firedEvents.push(this.events[frame]);\r\n    }\r\n}\r\n\r\n/** Changes a skeleton's {@link Skeleton#drawOrder}. */\r\n/**\r\n * @public\r\n */\r\nexport class DrawOrderTimeline implements Timeline {\r\n    /** The time in seconds for each key frame. */\r\n    frames: ArrayLike<number>; // time, ...\r\n\r\n    /** The draw order for each key frame. See {@link #setFrame(int, float, int[])}. */\r\n    drawOrders: Array<Array<number>>;\r\n\r\n    constructor(frameCount: number) {\r\n        this.frames = Utils.newFloatArray(frameCount);\r\n        this.drawOrders = new Array<Array<number>>(frameCount);\r\n    }\r\n\r\n    getPropertyId() {\r\n        return TimelineType.drawOrder << 24;\r\n    }\r\n\r\n    /** The number of key frames for this timeline. */\r\n    getFrameCount() {\r\n        return this.frames.length;\r\n    }\r\n\r\n    /** Sets the time in seconds and the draw order for the specified key frame.\r\n     * @param drawOrder For each slot in {@link Skeleton#slots}, the index of the new draw order. May be null to use setup pose\r\n     *           draw order. */\r\n    setFrame(frameIndex: number, time: number, drawOrder: Array<number>) {\r\n        this.frames[frameIndex] = time;\r\n        this.drawOrders[frameIndex] = drawOrder;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const drawOrder: Array<Slot> = skeleton.drawOrder;\r\n        const slots: Array<Slot> = skeleton.slots;\r\n\r\n        if (direction == MixDirection.mixOut && blend == MixBlend.setup) {\r\n            Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\r\n\r\n            return;\r\n        }\r\n\r\n        const frames = this.frames;\r\n\r\n        if (time < frames[0]) {\r\n            if (blend == MixBlend.setup || blend == MixBlend.first) Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\r\n\r\n            return;\r\n        }\r\n\r\n        let frame = 0;\r\n\r\n        if (time >= frames[frames.length - 1])\r\n            // Time is after last frame.\r\n            frame = frames.length - 1;\r\n        else frame = Animation.binarySearch(frames, time) - 1;\r\n\r\n        const drawOrderToSetupIndex = this.drawOrders[frame];\r\n\r\n        if (drawOrderToSetupIndex == null) Utils.arrayCopy(slots, 0, drawOrder, 0, slots.length);\r\n        else {\r\n            for (let i = 0, n = drawOrderToSetupIndex.length; i < n; i++) drawOrder[i] = slots[drawOrderToSetupIndex[i]];\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes an IK constraint's {@link IkConstraint#mix}, {@link IkConstraint#softness},\r\n * {@link IkConstraint#bendDirection}, {@link IkConstraint#stretch}, and {@link IkConstraint#compress}. */\r\n/**\r\n * @public\r\n */\r\nexport class IkConstraintTimeline extends CurveTimeline {\r\n    static ENTRIES = 6;\r\n    static PREV_TIME = -6;\r\n    static PREV_MIX = -5;\r\n    static PREV_SOFTNESS = -4;\r\n    static PREV_BEND_DIRECTION = -3;\r\n    static PREV_COMPRESS = -2;\r\n    static PREV_STRETCH = -1;\r\n    static MIX = 1;\r\n    static SOFTNESS = 2;\r\n    static BEND_DIRECTION = 3;\r\n    static COMPRESS = 4;\r\n    static STRETCH = 5;\r\n\r\n    /** The index of the IK constraint slot in {@link Skeleton#ikConstraints} that will be changed. */\r\n    ikConstraintIndex: number;\r\n\r\n    /** The time in seconds, mix, softness, bend direction, compress, and stretch for each key frame. */\r\n    frames: ArrayLike<number>; // time, mix, softness, bendDirection, compress, stretch, ...\r\n\r\n    constructor(frameCount: number) {\r\n        super(frameCount);\r\n        this.frames = Utils.newFloatArray(frameCount * IkConstraintTimeline.ENTRIES);\r\n    }\r\n\r\n    getPropertyId() {\r\n        return (TimelineType.ikConstraint << 24) + this.ikConstraintIndex;\r\n    }\r\n\r\n    /** Sets the time in seconds, mix, softness, bend direction, compress, and stretch for the specified key frame. */\r\n    setFrame(frameIndex: number, time: number, mix: number, softness: number, bendDirection: number, compress: boolean, stretch: boolean) {\r\n        frameIndex *= IkConstraintTimeline.ENTRIES;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + IkConstraintTimeline.MIX] = mix;\r\n        this.frames[frameIndex + IkConstraintTimeline.SOFTNESS] = softness;\r\n        this.frames[frameIndex + IkConstraintTimeline.BEND_DIRECTION] = bendDirection;\r\n        this.frames[frameIndex + IkConstraintTimeline.COMPRESS] = compress ? 1 : 0;\r\n        this.frames[frameIndex + IkConstraintTimeline.STRETCH] = stretch ? 1 : 0;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const frames = this.frames;\r\n        const constraint: IkConstraint = skeleton.ikConstraints[this.ikConstraintIndex];\r\n\r\n        if (!constraint.active) return;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    constraint.mix = constraint.data.mix;\r\n                    constraint.softness = constraint.data.softness;\r\n                    constraint.bendDirection = constraint.data.bendDirection;\r\n                    constraint.compress = constraint.data.compress;\r\n                    constraint.stretch = constraint.data.stretch;\r\n\r\n                    return;\r\n                case MixBlend.first:\r\n                    constraint.mix += (constraint.data.mix - constraint.mix) * alpha;\r\n                    constraint.softness += (constraint.data.softness - constraint.softness) * alpha;\r\n                    constraint.bendDirection = constraint.data.bendDirection;\r\n                    constraint.compress = constraint.data.compress;\r\n                    constraint.stretch = constraint.data.stretch;\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        if (time >= frames[frames.length - IkConstraintTimeline.ENTRIES]) {\r\n            // Time is after last frame.\r\n            if (blend == MixBlend.setup) {\r\n                constraint.mix = constraint.data.mix + (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.data.mix) * alpha;\r\n                constraint.softness = constraint.data.softness + (frames[frames.length + IkConstraintTimeline.PREV_SOFTNESS] - constraint.data.softness) * alpha;\r\n                if (direction == MixDirection.mixOut) {\r\n                    constraint.bendDirection = constraint.data.bendDirection;\r\n                    constraint.compress = constraint.data.compress;\r\n                    constraint.stretch = constraint.data.stretch;\r\n                } else {\r\n                    constraint.bendDirection = frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION];\r\n                    constraint.compress = frames[frames.length + IkConstraintTimeline.PREV_COMPRESS] != 0;\r\n                    constraint.stretch = frames[frames.length + IkConstraintTimeline.PREV_STRETCH] != 0;\r\n                }\r\n            } else {\r\n                constraint.mix += (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.mix) * alpha;\r\n                constraint.softness += (frames[frames.length + IkConstraintTimeline.PREV_SOFTNESS] - constraint.softness) * alpha;\r\n                if (direction == MixDirection.mixIn) {\r\n                    constraint.bendDirection = frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION];\r\n                    constraint.compress = frames[frames.length + IkConstraintTimeline.PREV_COMPRESS] != 0;\r\n                    constraint.stretch = frames[frames.length + IkConstraintTimeline.PREV_STRETCH] != 0;\r\n                }\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        const frame = Animation.binarySearch(frames, time, IkConstraintTimeline.ENTRIES);\r\n        const mix = frames[frame + IkConstraintTimeline.PREV_MIX];\r\n        const softness = frames[frame + IkConstraintTimeline.PREV_SOFTNESS];\r\n        const frameTime = frames[frame];\r\n        const percent = this.getCurvePercent(frame / IkConstraintTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + IkConstraintTimeline.PREV_TIME] - frameTime));\r\n\r\n        if (blend == MixBlend.setup) {\r\n            constraint.mix = constraint.data.mix + (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.data.mix) * alpha;\r\n            constraint.softness = constraint.data.softness + (softness + (frames[frame + IkConstraintTimeline.SOFTNESS] - softness) * percent - constraint.data.softness) * alpha;\r\n            if (direction == MixDirection.mixOut) {\r\n                constraint.bendDirection = constraint.data.bendDirection;\r\n                constraint.compress = constraint.data.compress;\r\n                constraint.stretch = constraint.data.stretch;\r\n            } else {\r\n                constraint.bendDirection = frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION];\r\n                constraint.compress = frames[frame + IkConstraintTimeline.PREV_COMPRESS] != 0;\r\n                constraint.stretch = frames[frame + IkConstraintTimeline.PREV_STRETCH] != 0;\r\n            }\r\n        } else {\r\n            constraint.mix += (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.mix) * alpha;\r\n            constraint.softness += (softness + (frames[frame + IkConstraintTimeline.SOFTNESS] - softness) * percent - constraint.softness) * alpha;\r\n            if (direction == MixDirection.mixIn) {\r\n                constraint.bendDirection = frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION];\r\n                constraint.compress = frames[frame + IkConstraintTimeline.PREV_COMPRESS] != 0;\r\n                constraint.stretch = frames[frame + IkConstraintTimeline.PREV_STRETCH] != 0;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a transform constraint's {@link TransformConstraint#rotateMix}, {@link TransformConstraint#translateMix},\r\n * {@link TransformConstraint#scaleMix}, and {@link TransformConstraint#shearMix}. */\r\n/**\r\n * @public\r\n */\r\nexport class TransformConstraintTimeline extends CurveTimeline {\r\n    static ENTRIES = 5;\r\n    static PREV_TIME = -5;\r\n    static PREV_ROTATE = -4;\r\n    static PREV_TRANSLATE = -3;\r\n    static PREV_SCALE = -2;\r\n    static PREV_SHEAR = -1;\r\n    static ROTATE = 1;\r\n    static TRANSLATE = 2;\r\n    static SCALE = 3;\r\n    static SHEAR = 4;\r\n\r\n    /** The index of the transform constraint slot in {@link Skeleton#transformConstraints} that will be changed. */\r\n    transformConstraintIndex: number;\r\n\r\n    /** The time in seconds, rotate mix, translate mix, scale mix, and shear mix for each key frame. */\r\n    frames: ArrayLike<number>; // time, rotate mix, translate mix, scale mix, shear mix, ...\r\n\r\n    constructor(frameCount: number) {\r\n        super(frameCount);\r\n        this.frames = Utils.newFloatArray(frameCount * TransformConstraintTimeline.ENTRIES);\r\n    }\r\n\r\n    getPropertyId() {\r\n        return (TimelineType.transformConstraint << 24) + this.transformConstraintIndex;\r\n    }\r\n\r\n    /** The time in seconds, rotate mix, translate mix, scale mix, and shear mix for the specified key frame. */\r\n    setFrame(frameIndex: number, time: number, rotateMix: number, translateMix: number, scaleMix: number, shearMix: number) {\r\n        frameIndex *= TransformConstraintTimeline.ENTRIES;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + TransformConstraintTimeline.ROTATE] = rotateMix;\r\n        this.frames[frameIndex + TransformConstraintTimeline.TRANSLATE] = translateMix;\r\n        this.frames[frameIndex + TransformConstraintTimeline.SCALE] = scaleMix;\r\n        this.frames[frameIndex + TransformConstraintTimeline.SHEAR] = shearMix;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const frames = this.frames;\r\n\r\n        const constraint: TransformConstraint = skeleton.transformConstraints[this.transformConstraintIndex];\r\n\r\n        if (!constraint.active) return;\r\n        if (time < frames[0]) {\r\n            const data = constraint.data;\r\n\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    constraint.rotateMix = data.rotateMix;\r\n                    constraint.translateMix = data.translateMix;\r\n                    constraint.scaleMix = data.scaleMix;\r\n                    constraint.shearMix = data.shearMix;\r\n\r\n                    return;\r\n                case MixBlend.first:\r\n                    constraint.rotateMix += (data.rotateMix - constraint.rotateMix) * alpha;\r\n                    constraint.translateMix += (data.translateMix - constraint.translateMix) * alpha;\r\n                    constraint.scaleMix += (data.scaleMix - constraint.scaleMix) * alpha;\r\n                    constraint.shearMix += (data.shearMix - constraint.shearMix) * alpha;\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        let rotate = 0;\r\n        let translate = 0;\r\n        let scale = 0;\r\n        let shear = 0;\r\n\r\n        if (time >= frames[frames.length - TransformConstraintTimeline.ENTRIES]) {\r\n            // Time is after last frame.\r\n            const i = frames.length;\r\n\r\n            rotate = frames[i + TransformConstraintTimeline.PREV_ROTATE];\r\n            translate = frames[i + TransformConstraintTimeline.PREV_TRANSLATE];\r\n            scale = frames[i + TransformConstraintTimeline.PREV_SCALE];\r\n            shear = frames[i + TransformConstraintTimeline.PREV_SHEAR];\r\n        } else {\r\n            // Interpolate between the previous frame and the current frame.\r\n            const frame = Animation.binarySearch(frames, time, TransformConstraintTimeline.ENTRIES);\r\n\r\n            rotate = frames[frame + TransformConstraintTimeline.PREV_ROTATE];\r\n            translate = frames[frame + TransformConstraintTimeline.PREV_TRANSLATE];\r\n            scale = frames[frame + TransformConstraintTimeline.PREV_SCALE];\r\n            shear = frames[frame + TransformConstraintTimeline.PREV_SHEAR];\r\n            const frameTime = frames[frame];\r\n            const percent = this.getCurvePercent(\r\n                frame / TransformConstraintTimeline.ENTRIES - 1,\r\n                1 - (time - frameTime) / (frames[frame + TransformConstraintTimeline.PREV_TIME] - frameTime)\r\n            );\r\n\r\n            rotate += (frames[frame + TransformConstraintTimeline.ROTATE] - rotate) * percent;\r\n            translate += (frames[frame + TransformConstraintTimeline.TRANSLATE] - translate) * percent;\r\n            scale += (frames[frame + TransformConstraintTimeline.SCALE] - scale) * percent;\r\n            shear += (frames[frame + TransformConstraintTimeline.SHEAR] - shear) * percent;\r\n        }\r\n        if (blend == MixBlend.setup) {\r\n            const data = constraint.data;\r\n\r\n            constraint.rotateMix = data.rotateMix + (rotate - data.rotateMix) * alpha;\r\n            constraint.translateMix = data.translateMix + (translate - data.translateMix) * alpha;\r\n            constraint.scaleMix = data.scaleMix + (scale - data.scaleMix) * alpha;\r\n            constraint.shearMix = data.shearMix + (shear - data.shearMix) * alpha;\r\n        } else {\r\n            constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;\r\n            constraint.translateMix += (translate - constraint.translateMix) * alpha;\r\n            constraint.scaleMix += (scale - constraint.scaleMix) * alpha;\r\n            constraint.shearMix += (shear - constraint.shearMix) * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a path constraint's {@link PathConstraint#position}. */\r\n/**\r\n * @public\r\n */\r\nexport class PathConstraintPositionTimeline extends CurveTimeline {\r\n    static ENTRIES = 2;\r\n    static PREV_TIME = -2;\r\n    static PREV_VALUE = -1;\r\n    static VALUE = 1;\r\n\r\n    /** The index of the path constraint slot in {@link Skeleton#pathConstraints} that will be changed. */\r\n    pathConstraintIndex: number;\r\n\r\n    /** The time in seconds and path constraint position for each key frame. */\r\n    frames: ArrayLike<number>; // time, position, ...\r\n\r\n    constructor(frameCount: number) {\r\n        super(frameCount);\r\n        this.frames = Utils.newFloatArray(frameCount * PathConstraintPositionTimeline.ENTRIES);\r\n    }\r\n\r\n    getPropertyId() {\r\n        return (TimelineType.pathConstraintPosition << 24) + this.pathConstraintIndex;\r\n    }\r\n\r\n    /** Sets the time in seconds and path constraint position for the specified key frame. */\r\n    setFrame(frameIndex: number, time: number, value: number) {\r\n        frameIndex *= PathConstraintPositionTimeline.ENTRIES;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + PathConstraintPositionTimeline.VALUE] = value;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const frames = this.frames;\r\n        const constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\r\n\r\n        if (!constraint.active) return;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    constraint.position = constraint.data.position;\r\n\r\n                    return;\r\n                case MixBlend.first:\r\n                    constraint.position += (constraint.data.position - constraint.position) * alpha;\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        let position = 0;\r\n\r\n        if (time >= frames[frames.length - PathConstraintPositionTimeline.ENTRIES])\r\n            // Time is after last frame.\r\n            position = frames[frames.length + PathConstraintPositionTimeline.PREV_VALUE];\r\n        else {\r\n            // Interpolate between the previous frame and the current frame.\r\n            const frame = Animation.binarySearch(frames, time, PathConstraintPositionTimeline.ENTRIES);\r\n\r\n            position = frames[frame + PathConstraintPositionTimeline.PREV_VALUE];\r\n            const frameTime = frames[frame];\r\n            const percent = this.getCurvePercent(\r\n                frame / PathConstraintPositionTimeline.ENTRIES - 1,\r\n                1 - (time - frameTime) / (frames[frame + PathConstraintPositionTimeline.PREV_TIME] - frameTime)\r\n            );\r\n\r\n            position += (frames[frame + PathConstraintPositionTimeline.VALUE] - position) * percent;\r\n        }\r\n        if (blend == MixBlend.setup) constraint.position = constraint.data.position + (position - constraint.data.position) * alpha;\r\n        else constraint.position += (position - constraint.position) * alpha;\r\n    }\r\n}\r\n\r\n/** Changes a path constraint's {@link PathConstraint#spacing}. */\r\n/**\r\n * @public\r\n */\r\nexport class PathConstraintSpacingTimeline extends PathConstraintPositionTimeline {\r\n    constructor(frameCount: number) {\r\n        super(frameCount);\r\n    }\r\n\r\n    getPropertyId() {\r\n        return (TimelineType.pathConstraintSpacing << 24) + this.pathConstraintIndex;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const frames = this.frames;\r\n        const constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\r\n\r\n        if (!constraint.active) return;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    constraint.spacing = constraint.data.spacing;\r\n\r\n                    return;\r\n                case MixBlend.first:\r\n                    constraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha;\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        let spacing = 0;\r\n\r\n        if (time >= frames[frames.length - PathConstraintSpacingTimeline.ENTRIES])\r\n            // Time is after last frame.\r\n            spacing = frames[frames.length + PathConstraintSpacingTimeline.PREV_VALUE];\r\n        else {\r\n            // Interpolate between the previous frame and the current frame.\r\n            const frame = Animation.binarySearch(frames, time, PathConstraintSpacingTimeline.ENTRIES);\r\n\r\n            spacing = frames[frame + PathConstraintSpacingTimeline.PREV_VALUE];\r\n            const frameTime = frames[frame];\r\n            const percent = this.getCurvePercent(\r\n                frame / PathConstraintSpacingTimeline.ENTRIES - 1,\r\n                1 - (time - frameTime) / (frames[frame + PathConstraintSpacingTimeline.PREV_TIME] - frameTime)\r\n            );\r\n\r\n            spacing += (frames[frame + PathConstraintSpacingTimeline.VALUE] - spacing) * percent;\r\n        }\r\n\r\n        if (blend == MixBlend.setup) constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha;\r\n        else constraint.spacing += (spacing - constraint.spacing) * alpha;\r\n    }\r\n}\r\n\r\n/** Changes a transform constraint's {@link PathConstraint#rotateMix} and\r\n * {@link TransformConstraint#translateMix}. */\r\n/**\r\n * @public\r\n */\r\nexport class PathConstraintMixTimeline extends CurveTimeline {\r\n    static ENTRIES = 3;\r\n    static PREV_TIME = -3;\r\n    static PREV_ROTATE = -2;\r\n    static PREV_TRANSLATE = -1;\r\n    static ROTATE = 1;\r\n    static TRANSLATE = 2;\r\n\r\n    /** The index of the path constraint slot in {@link Skeleton#getPathConstraints()} that will be changed. */\r\n    pathConstraintIndex: number;\r\n\r\n    /** The time in seconds, rotate mix, and translate mix for each key frame. */\r\n    frames: ArrayLike<number>; // time, rotate mix, translate mix, ...\r\n\r\n    constructor(frameCount: number) {\r\n        super(frameCount);\r\n        this.frames = Utils.newFloatArray(frameCount * PathConstraintMixTimeline.ENTRIES);\r\n    }\r\n\r\n    getPropertyId() {\r\n        return (TimelineType.pathConstraintMix << 24) + this.pathConstraintIndex;\r\n    }\r\n\r\n    /** The time in seconds, rotate mix, and translate mix for the specified key frame. */\r\n    setFrame(frameIndex: number, time: number, rotateMix: number, translateMix: number) {\r\n        frameIndex *= PathConstraintMixTimeline.ENTRIES;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + PathConstraintMixTimeline.ROTATE] = rotateMix;\r\n        this.frames[frameIndex + PathConstraintMixTimeline.TRANSLATE] = translateMix;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const frames = this.frames;\r\n        const constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\r\n\r\n        if (!constraint.active) return;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    constraint.rotateMix = constraint.data.rotateMix;\r\n                    constraint.translateMix = constraint.data.translateMix;\r\n\r\n                    return;\r\n                case MixBlend.first:\r\n                    constraint.rotateMix += (constraint.data.rotateMix - constraint.rotateMix) * alpha;\r\n                    constraint.translateMix += (constraint.data.translateMix - constraint.translateMix) * alpha;\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        let rotate = 0;\r\n        let translate = 0;\r\n\r\n        if (time >= frames[frames.length - PathConstraintMixTimeline.ENTRIES]) {\r\n            // Time is after last frame.\r\n            rotate = frames[frames.length + PathConstraintMixTimeline.PREV_ROTATE];\r\n            translate = frames[frames.length + PathConstraintMixTimeline.PREV_TRANSLATE];\r\n        } else {\r\n            // Interpolate between the previous frame and the current frame.\r\n            const frame = Animation.binarySearch(frames, time, PathConstraintMixTimeline.ENTRIES);\r\n\r\n            rotate = frames[frame + PathConstraintMixTimeline.PREV_ROTATE];\r\n            translate = frames[frame + PathConstraintMixTimeline.PREV_TRANSLATE];\r\n            const frameTime = frames[frame];\r\n            const percent = this.getCurvePercent(\r\n                frame / PathConstraintMixTimeline.ENTRIES - 1,\r\n                1 - (time - frameTime) / (frames[frame + PathConstraintMixTimeline.PREV_TIME] - frameTime)\r\n            );\r\n\r\n            rotate += (frames[frame + PathConstraintMixTimeline.ROTATE] - rotate) * percent;\r\n            translate += (frames[frame + PathConstraintMixTimeline.TRANSLATE] - translate) * percent;\r\n        }\r\n\r\n        if (blend == MixBlend.setup) {\r\n            constraint.rotateMix = constraint.data.rotateMix + (rotate - constraint.data.rotateMix) * alpha;\r\n            constraint.translateMix = constraint.data.translateMix + (translate - constraint.data.translateMix) * alpha;\r\n        } else {\r\n            constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;\r\n            constraint.translateMix += (translate - constraint.translateMix) * alpha;\r\n        }\r\n    }\r\n}\r\n","import { IAnimationState, IAnimationStateListener, ITrackEntry, MixBlend, MixDirection, MathUtils, Pool, IntSet, Utils } from '@pixi-spine/base';\r\nimport { Animation, AttachmentTimeline, DrawOrderTimeline, EventTimeline, RotateTimeline, Timeline } from './Animation';\r\nimport type { AnimationStateData } from './AnimationStateData';\r\nimport type { Event } from './Event';\r\nimport type { Skeleton } from './Skeleton';\r\nimport type { Slot } from './Slot';\r\n\r\n/** Applies animations over time, queues animations for later playback, mixes (crossfading) between animations, and applies\r\n * multiple animations on top of each other (layering).\r\n *\r\n * See [Applying Animations](http://esotericsoftware.com/spine-applying-animations/) in the Spine Runtimes Guide. */\r\n/**\r\n * @public\r\n */\r\nexport class AnimationState implements IAnimationState<AnimationStateData> {\r\n    static emptyAnimation = new Animation('<empty>', [], 0);\r\n\r\n    /** 1. A previously applied timeline has set this property.\r\n     *\r\n     * Result: Mix from the current pose to the timeline pose. */\r\n    static SUBSEQUENT = 0;\r\n    /** 1. This is the first timeline to set this property.\r\n     * 2. The next track entry applied after this one does not have a timeline to set this property.\r\n     *\r\n     * Result: Mix from the setup pose to the timeline pose. */\r\n    static FIRST = 1;\r\n    /** 1) A previously applied timeline has set this property.<br>\r\n     * 2) The next track entry to be applied does have a timeline to set this property.<br>\r\n     * 3) The next track entry after that one does not have a timeline to set this property.<br>\r\n     * Result: Mix from the current pose to the timeline pose, but do not mix out. This avoids \"dipping\" when crossfading\r\n     * animations that key the same property. A subsequent timeline will set this property using a mix. */\r\n    static HOLD_SUBSEQUENT = 2;\r\n    /** 1) This is the first timeline to set this property.<br>\r\n     * 2) The next track entry to be applied does have a timeline to set this property.<br>\r\n     * 3) The next track entry after that one does not have a timeline to set this property.<br>\r\n     * Result: Mix from the setup pose to the timeline pose, but do not mix out. This avoids \"dipping\" when crossfading animations\r\n     * that key the same property. A subsequent timeline will set this property using a mix. */\r\n    static HOLD_FIRST = 3;\r\n    /** 1. This is the first timeline to set this property.\r\n     * 2. The next track entry to be applied does have a timeline to set this property.\r\n     * 3. The next track entry after that one does have a timeline to set this property.\r\n     * 4. timelineHoldMix stores the first subsequent track entry that does not have a timeline to set this property.\r\n     *\r\n     * Result: The same as HOLD except the mix percentage from the timelineHoldMix track entry is used. This handles when more than\r\n     * 2 track entries in a row have a timeline that sets the same property.\r\n     *\r\n     * Eg, A -> B -> C -> D where A, B, and C have a timeline setting same property, but D does not. When A is applied, to avoid\r\n     * \"dipping\" A is not mixed out, however D (the first entry that doesn't set the property) mixing in is used to mix out A\r\n     * (which affects B and C). Without using D to mix out, A would be applied fully until mixing completes, then snap into\r\n     * place. */\r\n    static HOLD_MIX = 4;\r\n\r\n    static SETUP = 1;\r\n    static CURRENT = 2;\r\n\r\n    /** The AnimationStateData to look up mix durations. */\r\n    data: AnimationStateData;\r\n\r\n    /** The list of tracks that currently have animations, which may contain null entries. */\r\n    tracks = new Array<TrackEntry>();\r\n\r\n    /** Multiplier for the delta time when the animation state is updated, causing time for all animations and mixes to play slower\r\n     * or faster. Defaults to 1.\r\n     *\r\n     * See TrackEntry {@link TrackEntry#timeScale} for affecting a single animation. */\r\n    timeScale = 1;\r\n    unkeyedState = 0;\r\n\r\n    events = new Array<Event>();\r\n    listeners = new Array<AnimationStateListener>();\r\n    queue = new EventQueue(this);\r\n    propertyIDs = new IntSet();\r\n    animationsChanged = false;\r\n\r\n    trackEntryPool = new Pool<TrackEntry>(() => new TrackEntry());\r\n\r\n    constructor(data: AnimationStateData) {\r\n        this.data = data;\r\n    }\r\n\r\n    /** Increments each track entry {@link TrackEntry#trackTime()}, setting queued animations as current if needed. */\r\n    update(delta: number) {\r\n        delta *= this.timeScale;\r\n        const tracks = this.tracks;\r\n\r\n        for (let i = 0, n = tracks.length; i < n; i++) {\r\n            const current = tracks[i];\r\n\r\n            if (current == null) continue;\r\n\r\n            current.animationLast = current.nextAnimationLast;\r\n            current.trackLast = current.nextTrackLast;\r\n\r\n            let currentDelta = delta * current.timeScale;\r\n\r\n            if (current.delay > 0) {\r\n                current.delay -= currentDelta;\r\n                if (current.delay > 0) continue;\r\n                currentDelta = -current.delay;\r\n                current.delay = 0;\r\n            }\r\n\r\n            let next = current.next;\r\n\r\n            if (next != null) {\r\n                // When the next entry's delay is passed, change to the next entry, preserving leftover time.\r\n                const nextTime = current.trackLast - next.delay;\r\n\r\n                if (nextTime >= 0) {\r\n                    next.delay = 0;\r\n                    next.trackTime += current.timeScale == 0 ? 0 : (nextTime / current.timeScale + delta) * next.timeScale;\r\n                    current.trackTime += currentDelta;\r\n                    this.setCurrent(i, next, true);\r\n                    while (next.mixingFrom != null) {\r\n                        next.mixTime += delta;\r\n                        next = next.mixingFrom;\r\n                    }\r\n                    continue;\r\n                }\r\n            } else if (current.trackLast >= current.trackEnd && current.mixingFrom == null) {\r\n                tracks[i] = null;\r\n                this.queue.end(current);\r\n                this.disposeNext(current);\r\n                continue;\r\n            }\r\n            if (current.mixingFrom != null && this.updateMixingFrom(current, delta)) {\r\n                // End mixing from entries once all have completed.\r\n                let from = current.mixingFrom;\r\n\r\n                current.mixingFrom = null;\r\n                if (from != null) from.mixingTo = null;\r\n                while (from != null) {\r\n                    this.queue.end(from);\r\n                    from = from.mixingFrom;\r\n                }\r\n            }\r\n\r\n            current.trackTime += currentDelta;\r\n        }\r\n\r\n        this.queue.drain();\r\n    }\r\n\r\n    /** Returns true when all mixing from entries are complete. */\r\n    updateMixingFrom(to: TrackEntry, delta: number): boolean {\r\n        const from = to.mixingFrom;\r\n\r\n        if (from == null) return true;\r\n\r\n        const finished = this.updateMixingFrom(from, delta);\r\n\r\n        from.animationLast = from.nextAnimationLast;\r\n        from.trackLast = from.nextTrackLast;\r\n\r\n        // Require mixTime > 0 to ensure the mixing from entry was applied at least once.\r\n        if (to.mixTime > 0 && to.mixTime >= to.mixDuration) {\r\n            // Require totalAlpha == 0 to ensure mixing is complete, unless mixDuration == 0 (the transition is a single frame).\r\n            if (from.totalAlpha == 0 || to.mixDuration == 0) {\r\n                to.mixingFrom = from.mixingFrom;\r\n                if (from.mixingFrom != null) from.mixingFrom.mixingTo = to;\r\n                to.interruptAlpha = from.interruptAlpha;\r\n                this.queue.end(from);\r\n            }\r\n\r\n            return finished;\r\n        }\r\n\r\n        from.trackTime += delta * from.timeScale;\r\n        to.mixTime += delta;\r\n\r\n        return false;\r\n    }\r\n\r\n    /** Poses the skeleton using the track entry animations. There are no side effects other than invoking listeners, so the\r\n     * animation state can be applied to multiple skeletons to pose them identically.\r\n     * @returns True if any animations were applied. */\r\n    apply(skeleton: Skeleton): boolean {\r\n        if (skeleton == null) throw new Error('skeleton cannot be null.');\r\n        if (this.animationsChanged) this._animationsChanged();\r\n\r\n        const events = this.events;\r\n        const tracks = this.tracks;\r\n        let applied = false;\r\n\r\n        for (let i = 0, n = tracks.length; i < n; i++) {\r\n            const current = tracks[i];\r\n\r\n            if (current == null || current.delay > 0) continue;\r\n            applied = true;\r\n            const blend: MixBlend = i == 0 ? MixBlend.first : current.mixBlend;\r\n\r\n            // Apply mixing from entries first.\r\n            let mix = current.alpha;\r\n\r\n            if (current.mixingFrom != null) mix *= this.applyMixingFrom(current, skeleton, blend);\r\n            else if (current.trackTime >= current.trackEnd && current.next == null) mix = 0;\r\n\r\n            // Apply current entry.\r\n            const animationLast = current.animationLast;\r\n            const animationTime = current.getAnimationTime();\r\n            const timelineCount = current.animation.timelines.length;\r\n            const timelines = current.animation.timelines;\r\n\r\n            if ((i == 0 && mix == 1) || blend == MixBlend.add) {\r\n                for (let ii = 0; ii < timelineCount; ii++) {\r\n                    // Fixes issue #302 on IOS9 where mix, blend sometimes became undefined and caused assets\r\n                    // to sometimes stop rendering when using color correction, as their RGBA values become NaN.\r\n                    // (https://github.com/pixijs/pixi-spine/issues/302)\r\n                    Utils.webkit602BugfixHelper(mix, blend);\r\n                    const timeline = timelines[ii];\r\n\r\n                    if (timeline instanceof AttachmentTimeline) this.applyAttachmentTimeline(timeline, skeleton, animationTime, blend, true);\r\n                    else timeline.apply(skeleton, animationLast, animationTime, events, mix, blend, MixDirection.mixIn);\r\n                }\r\n            } else {\r\n                const timelineMode = current.timelineMode;\r\n\r\n                const firstFrame = current.timelinesRotation.length == 0;\r\n\r\n                if (firstFrame) Utils.setArraySize(current.timelinesRotation, timelineCount << 1, null);\r\n                const timelinesRotation = current.timelinesRotation;\r\n\r\n                for (let ii = 0; ii < timelineCount; ii++) {\r\n                    const timeline = timelines[ii];\r\n                    const timelineBlend = timelineMode[ii] == AnimationState.SUBSEQUENT ? blend : MixBlend.setup;\r\n\r\n                    if (timeline instanceof RotateTimeline) {\r\n                        this.applyRotateTimeline(timeline, skeleton, animationTime, mix, timelineBlend, timelinesRotation, ii << 1, firstFrame);\r\n                    } else if (timeline instanceof AttachmentTimeline) {\r\n                        this.applyAttachmentTimeline(timeline, skeleton, animationTime, blend, true);\r\n                    } else {\r\n                        // This fixes the WebKit 602 specific issue described at http://esotericsoftware.com/forum/iOS-10-disappearing-graphics-10109\r\n                        Utils.webkit602BugfixHelper(mix, blend);\r\n                        timeline.apply(skeleton, animationLast, animationTime, events, mix, timelineBlend, MixDirection.mixIn);\r\n                    }\r\n                }\r\n            }\r\n            this.queueEvents(current, animationTime);\r\n            events.length = 0;\r\n            current.nextAnimationLast = animationTime;\r\n            current.nextTrackLast = current.trackTime;\r\n        }\r\n\r\n        // Set slots attachments to the setup pose, if needed. This occurs if an animation that is mixing out sets attachments so\r\n        // subsequent timelines see any deform, but the subsequent timelines don't set an attachment (eg they are also mixing out or\r\n        // the time is before the first key).\r\n        const setupState = this.unkeyedState + AnimationState.SETUP;\r\n        const slots = skeleton.slots;\r\n\r\n        for (let i = 0, n = skeleton.slots.length; i < n; i++) {\r\n            const slot = slots[i];\r\n\r\n            if (slot.attachmentState == setupState) {\r\n                const attachmentName = slot.data.attachmentName;\r\n\r\n                slot.setAttachment(attachmentName == null ? null : skeleton.getAttachment(slot.data.index, attachmentName));\r\n            }\r\n        }\r\n        this.unkeyedState += 2; // Increasing after each use avoids the need to reset attachmentState for every slot.\r\n\r\n        this.queue.drain();\r\n\r\n        return applied;\r\n    }\r\n\r\n    applyMixingFrom(to: TrackEntry, skeleton: Skeleton, blend: MixBlend) {\r\n        const from = to.mixingFrom;\r\n\r\n        if (from.mixingFrom != null) this.applyMixingFrom(from, skeleton, blend);\r\n\r\n        let mix = 0;\r\n\r\n        if (to.mixDuration == 0) {\r\n            // Single frame mix to undo mixingFrom changes.\r\n            mix = 1;\r\n            if (blend == MixBlend.first) blend = MixBlend.setup;\r\n        } else {\r\n            mix = to.mixTime / to.mixDuration;\r\n            if (mix > 1) mix = 1;\r\n            if (blend != MixBlend.first) blend = from.mixBlend;\r\n        }\r\n\r\n        const events = mix < from.eventThreshold ? this.events : null;\r\n        const attachments = mix < from.attachmentThreshold;\r\n        const drawOrder = mix < from.drawOrderThreshold;\r\n        const animationLast = from.animationLast;\r\n        const animationTime = from.getAnimationTime();\r\n        const timelineCount = from.animation.timelines.length;\r\n        const timelines = from.animation.timelines;\r\n        const alphaHold = from.alpha * to.interruptAlpha;\r\n        const alphaMix = alphaHold * (1 - mix);\r\n\r\n        if (blend == MixBlend.add) {\r\n            for (let i = 0; i < timelineCount; i++) timelines[i].apply(skeleton, animationLast, animationTime, events, alphaMix, blend, MixDirection.mixOut);\r\n        } else {\r\n            const timelineMode = from.timelineMode;\r\n            const timelineHoldMix = from.timelineHoldMix;\r\n\r\n            const firstFrame = from.timelinesRotation.length == 0;\r\n\r\n            if (firstFrame) Utils.setArraySize(from.timelinesRotation, timelineCount << 1, null);\r\n            const timelinesRotation = from.timelinesRotation;\r\n\r\n            from.totalAlpha = 0;\r\n            for (let i = 0; i < timelineCount; i++) {\r\n                const timeline = timelines[i];\r\n                let direction = MixDirection.mixOut;\r\n                let timelineBlend: MixBlend;\r\n                let alpha = 0;\r\n\r\n                switch (timelineMode[i]) {\r\n                    case AnimationState.SUBSEQUENT:\r\n                        if (!drawOrder && timeline instanceof DrawOrderTimeline) continue;\r\n                        timelineBlend = blend;\r\n                        alpha = alphaMix;\r\n                        break;\r\n                    case AnimationState.FIRST:\r\n                        timelineBlend = MixBlend.setup;\r\n                        alpha = alphaMix;\r\n                        break;\r\n                    case AnimationState.HOLD_SUBSEQUENT:\r\n                        timelineBlend = blend;\r\n                        alpha = alphaHold;\r\n                        break;\r\n                    case AnimationState.HOLD_FIRST:\r\n                        timelineBlend = MixBlend.setup;\r\n                        alpha = alphaHold;\r\n                        break;\r\n                    default:\r\n                        timelineBlend = MixBlend.setup;\r\n                        const holdMix = timelineHoldMix[i];\r\n\r\n                        alpha = alphaHold * Math.max(0, 1 - holdMix.mixTime / holdMix.mixDuration);\r\n                        break;\r\n                }\r\n                from.totalAlpha += alpha;\r\n\r\n                if (timeline instanceof RotateTimeline) this.applyRotateTimeline(timeline, skeleton, animationTime, alpha, timelineBlend, timelinesRotation, i << 1, firstFrame);\r\n                else if (timeline instanceof AttachmentTimeline) this.applyAttachmentTimeline(timeline, skeleton, animationTime, timelineBlend, attachments);\r\n                else {\r\n                    // This fixes the WebKit 602 specific issue described at http://esotericsoftware.com/forum/iOS-10-disappearing-graphics-10109\r\n                    Utils.webkit602BugfixHelper(alpha, blend);\r\n                    if (drawOrder && timeline instanceof DrawOrderTimeline && timelineBlend == MixBlend.setup) direction = MixDirection.mixIn;\r\n                    timeline.apply(skeleton, animationLast, animationTime, events, alpha, timelineBlend, direction);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (to.mixDuration > 0) this.queueEvents(from, animationTime);\r\n        this.events.length = 0;\r\n        from.nextAnimationLast = animationTime;\r\n        from.nextTrackLast = from.trackTime;\r\n\r\n        return mix;\r\n    }\r\n\r\n    applyAttachmentTimeline(timeline: AttachmentTimeline, skeleton: Skeleton, time: number, blend: MixBlend, attachments: boolean) {\r\n        const slot = skeleton.slots[timeline.slotIndex];\r\n\r\n        if (!slot.bone.active) return;\r\n\r\n        const frames = timeline.frames;\r\n\r\n        if (time < frames[0]) {\r\n            // Time is before first frame.\r\n            if (blend == MixBlend.setup || blend == MixBlend.first) this.setAttachment(skeleton, slot, slot.data.attachmentName, attachments);\r\n        } else {\r\n            let frameIndex;\r\n\r\n            if (time >= frames[frames.length - 1])\r\n                // Time is after last frame.\r\n                frameIndex = frames.length - 1;\r\n            else frameIndex = Animation.binarySearch(frames, time) - 1;\r\n            this.setAttachment(skeleton, slot, timeline.attachmentNames[frameIndex], attachments);\r\n        }\r\n\r\n        // If an attachment wasn't set (ie before the first frame or attachments is false), set the setup attachment later.\r\n        if (slot.attachmentState <= this.unkeyedState) slot.attachmentState = this.unkeyedState + AnimationState.SETUP;\r\n    }\r\n\r\n    setAttachment(skeleton: Skeleton, slot: Slot, attachmentName: string, attachments: boolean) {\r\n        slot.setAttachment(attachmentName == null ? null : skeleton.getAttachment(slot.data.index, attachmentName));\r\n        if (attachments) slot.attachmentState = this.unkeyedState + AnimationState.CURRENT;\r\n    }\r\n\r\n    applyRotateTimeline(timeline: Timeline, skeleton: Skeleton, time: number, alpha: number, blend: MixBlend, timelinesRotation: Array<number>, i: number, firstFrame: boolean) {\r\n        if (firstFrame) timelinesRotation[i] = 0;\r\n\r\n        if (alpha == 1) {\r\n            timeline.apply(skeleton, 0, time, null, 1, blend, MixDirection.mixIn);\r\n\r\n            return;\r\n        }\r\n\r\n        const rotateTimeline = timeline as RotateTimeline;\r\n        const frames = rotateTimeline.frames;\r\n        const bone = skeleton.bones[rotateTimeline.boneIndex];\r\n\r\n        if (!bone.active) return;\r\n        let r1 = 0;\r\n        let r2 = 0;\r\n\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.rotation = bone.data.rotation;\r\n                default:\r\n                    return;\r\n                case MixBlend.first:\r\n                    r1 = bone.rotation;\r\n                    r2 = bone.data.rotation;\r\n            }\r\n        } else {\r\n            r1 = blend == MixBlend.setup ? bone.data.rotation : bone.rotation;\r\n            if (time >= frames[frames.length - RotateTimeline.ENTRIES])\r\n                // Time is after last frame.\r\n                r2 = bone.data.rotation + frames[frames.length + RotateTimeline.PREV_ROTATION];\r\n            else {\r\n                // Interpolate between the previous frame and the current frame.\r\n                const frame = Animation.binarySearch(frames, time, RotateTimeline.ENTRIES);\r\n                const prevRotation = frames[frame + RotateTimeline.PREV_ROTATION];\r\n                const frameTime = frames[frame];\r\n                const percent = rotateTimeline.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + RotateTimeline.PREV_TIME] - frameTime));\r\n\r\n                r2 = frames[frame + RotateTimeline.ROTATION] - prevRotation;\r\n                r2 -= (16384 - ((16384.499999999996 - r2 / 360) | 0)) * 360;\r\n                r2 = prevRotation + r2 * percent + bone.data.rotation;\r\n                r2 -= (16384 - ((16384.499999999996 - r2 / 360) | 0)) * 360;\r\n            }\r\n        }\r\n\r\n        // Mix between rotations using the direction of the shortest route on the first frame while detecting crosses.\r\n        let total = 0;\r\n        let diff = r2 - r1;\r\n\r\n        diff -= (16384 - ((16384.499999999996 - diff / 360) | 0)) * 360;\r\n        if (diff == 0) {\r\n            total = timelinesRotation[i];\r\n        } else {\r\n            let lastTotal = 0;\r\n            let lastDiff = 0;\r\n\r\n            if (firstFrame) {\r\n                lastTotal = 0;\r\n                lastDiff = diff;\r\n            } else {\r\n                lastTotal = timelinesRotation[i]; // Angle and direction of mix, including loops.\r\n                lastDiff = timelinesRotation[i + 1]; // Difference between bones.\r\n            }\r\n            const current = diff > 0;\r\n            let dir = lastTotal >= 0;\r\n            // Detect cross at 0 (not 180).\r\n\r\n            if (MathUtils.signum(lastDiff) != MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {\r\n                // A cross after a 360 rotation is a loop.\r\n                if (Math.abs(lastTotal) > 180) lastTotal += 360 * MathUtils.signum(lastTotal);\r\n                dir = current;\r\n            }\r\n            total = diff + lastTotal - (lastTotal % 360); // Store loops as part of lastTotal.\r\n            if (dir != current) total += 360 * MathUtils.signum(lastTotal);\r\n            timelinesRotation[i] = total;\r\n        }\r\n        timelinesRotation[i + 1] = diff;\r\n        r1 += total * alpha;\r\n        bone.rotation = r1 - (16384 - ((16384.499999999996 - r1 / 360) | 0)) * 360;\r\n    }\r\n\r\n    queueEvents(entry: TrackEntry, animationTime: number) {\r\n        const animationStart = entry.animationStart;\r\n        const animationEnd = entry.animationEnd;\r\n        const duration = animationEnd - animationStart;\r\n        const trackLastWrapped = entry.trackLast % duration;\r\n\r\n        // Queue events before complete.\r\n        const events = this.events;\r\n        let i = 0;\r\n        const n = events.length;\r\n\r\n        for (; i < n; i++) {\r\n            const event = events[i];\r\n\r\n            if (event.time < trackLastWrapped) break;\r\n            if (event.time > animationEnd) continue; // Discard events outside animation start/end.\r\n            this.queue.event(entry, event);\r\n        }\r\n\r\n        // Queue complete if completed a loop iteration or the animation.\r\n        let complete = false;\r\n\r\n        if (entry.loop) complete = duration == 0 || trackLastWrapped > entry.trackTime % duration;\r\n        else complete = animationTime >= animationEnd && entry.animationLast < animationEnd;\r\n        if (complete) this.queue.complete(entry);\r\n\r\n        // Queue events after complete.\r\n        for (; i < n; i++) {\r\n            const event = events[i];\r\n\r\n            if (event.time < animationStart) continue; // Discard events outside animation start/end.\r\n            this.queue.event(entry, events[i]);\r\n        }\r\n    }\r\n\r\n    /** Removes all animations from all tracks, leaving skeletons in their current pose.\r\n     *\r\n     * It may be desired to use {@link AnimationState#setEmptyAnimation()} to mix the skeletons back to the setup pose,\r\n     * rather than leaving them in their current pose. */\r\n    clearTracks() {\r\n        const oldDrainDisabled = this.queue.drainDisabled;\r\n\r\n        this.queue.drainDisabled = true;\r\n        for (let i = 0, n = this.tracks.length; i < n; i++) this.clearTrack(i);\r\n        this.tracks.length = 0;\r\n        this.queue.drainDisabled = oldDrainDisabled;\r\n        this.queue.drain();\r\n    }\r\n\r\n    /** Removes all animations from the track, leaving skeletons in their current pose.\r\n     *\r\n     * It may be desired to use {@link AnimationState#setEmptyAnimation()} to mix the skeletons back to the setup pose,\r\n     * rather than leaving them in their current pose. */\r\n    clearTrack(trackIndex: number) {\r\n        if (trackIndex >= this.tracks.length) return;\r\n        const current = this.tracks[trackIndex];\r\n\r\n        if (current == null) return;\r\n\r\n        this.queue.end(current);\r\n\r\n        this.disposeNext(current);\r\n\r\n        let entry = current;\r\n\r\n        while (true) {\r\n            const from = entry.mixingFrom;\r\n\r\n            if (from == null) break;\r\n            this.queue.end(from);\r\n            entry.mixingFrom = null;\r\n            entry.mixingTo = null;\r\n            entry = from;\r\n        }\r\n\r\n        this.tracks[current.trackIndex] = null;\r\n\r\n        this.queue.drain();\r\n    }\r\n\r\n    setCurrent(index: number, current: TrackEntry, interrupt: boolean) {\r\n        const from = this.expandToIndex(index);\r\n\r\n        this.tracks[index] = current;\r\n\r\n        if (from != null) {\r\n            if (interrupt) this.queue.interrupt(from);\r\n            current.mixingFrom = from;\r\n            from.mixingTo = current;\r\n            current.mixTime = 0;\r\n\r\n            // Store the interrupted mix percentage.\r\n            if (from.mixingFrom != null && from.mixDuration > 0) current.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);\r\n\r\n            from.timelinesRotation.length = 0; // Reset rotation for mixing out, in case entry was mixed in.\r\n        }\r\n\r\n        this.queue.start(current);\r\n    }\r\n\r\n    /** Sets an animation by name.\r\n     *\r\n     * {@link #setAnimationWith(}. */\r\n    setAnimation(trackIndex: number, animationName: string, loop: boolean) {\r\n        const animation = this.data.skeletonData.findAnimation(animationName);\r\n\r\n        if (animation == null) throw new Error(`Animation not found: ${animationName}`);\r\n\r\n        return this.setAnimationWith(trackIndex, animation, loop);\r\n    }\r\n\r\n    /** Sets the current animation for a track, discarding any queued animations. If the formerly current track entry was never\r\n     * applied to a skeleton, it is replaced (not mixed from).\r\n     * @param loop If true, the animation will repeat. If false it will not, instead its last frame is applied if played beyond its\r\n     *           duration. In either case {@link TrackEntry#trackEnd} determines when the track is cleared.\r\n     * @returns A track entry to allow further customization of animation playback. References to the track entry must not be kept\r\n     *         after the {@link AnimationStateListener#dispose()} event occurs. */\r\n    setAnimationWith(trackIndex: number, animation: Animation, loop: boolean) {\r\n        if (animation == null) throw new Error('animation cannot be null.');\r\n        let interrupt = true;\r\n        let current = this.expandToIndex(trackIndex);\r\n\r\n        if (current != null) {\r\n            if (current.nextTrackLast == -1) {\r\n                // Don't mix from an entry that was never applied.\r\n                this.tracks[trackIndex] = current.mixingFrom;\r\n                this.queue.interrupt(current);\r\n                this.queue.end(current);\r\n                this.disposeNext(current);\r\n                current = current.mixingFrom;\r\n                interrupt = false;\r\n            } else this.disposeNext(current);\r\n        }\r\n        const entry = this.trackEntry(trackIndex, animation, loop, current);\r\n\r\n        this.setCurrent(trackIndex, entry, interrupt);\r\n        this.queue.drain();\r\n\r\n        return entry;\r\n    }\r\n\r\n    /** Queues an animation by name.\r\n     *\r\n     * See {@link #addAnimationWith()}. */\r\n    addAnimation(trackIndex: number, animationName: string, loop: boolean, delay: number) {\r\n        const animation = this.data.skeletonData.findAnimation(animationName);\r\n\r\n        if (animation == null) throw new Error(`Animation not found: ${animationName}`);\r\n\r\n        return this.addAnimationWith(trackIndex, animation, loop, delay);\r\n    }\r\n\r\n    /** Adds an animation to be played after the current or last queued animation for a track. If the track is empty, it is\r\n     * equivalent to calling {@link #setAnimationWith()}.\r\n     * @param delay If > 0, sets {@link TrackEntry#delay}. If <= 0, the delay set is the duration of the previous track entry\r\n     *           minus any mix duration (from the {@link AnimationStateData}) plus the specified `delay` (ie the mix\r\n     *           ends at (`delay` = 0) or before (`delay` < 0) the previous track entry duration). If the\r\n     *           previous entry is looping, its next loop completion is used instead of its duration.\r\n     * @returns A track entry to allow further customization of animation playback. References to the track entry must not be kept\r\n     *         after the {@link AnimationStateListener#dispose()} event occurs. */\r\n    addAnimationWith(trackIndex: number, animation: Animation, loop: boolean, delay: number) {\r\n        if (animation == null) throw new Error('animation cannot be null.');\r\n\r\n        let last = this.expandToIndex(trackIndex);\r\n\r\n        if (last != null) {\r\n            while (last.next != null) last = last.next;\r\n        }\r\n\r\n        const entry = this.trackEntry(trackIndex, animation, loop, last);\r\n\r\n        if (last == null) {\r\n            this.setCurrent(trackIndex, entry, true);\r\n            this.queue.drain();\r\n        } else {\r\n            last.next = entry;\r\n            if (delay <= 0) {\r\n                const duration = last.animationEnd - last.animationStart;\r\n\r\n                if (duration != 0) {\r\n                    if (last.loop) delay += duration * (1 + ((last.trackTime / duration) | 0));\r\n                    else delay += Math.max(duration, last.trackTime);\r\n                    delay -= this.data.getMix(last.animation, animation);\r\n                } else delay = last.trackTime;\r\n            }\r\n        }\r\n\r\n        entry.delay = delay;\r\n\r\n        return entry;\r\n    }\r\n\r\n    /** Sets an empty animation for a track, discarding any queued animations, and sets the track entry's\r\n     * {@link TrackEntry#mixduration}. An empty animation has no timelines and serves as a placeholder for mixing in or out.\r\n     *\r\n     * Mixing out is done by setting an empty animation with a mix duration using either {@link #setEmptyAnimation()},\r\n     * {@link #setEmptyAnimations()}, or {@link #addEmptyAnimation()}. Mixing to an empty animation causes\r\n     * the previous animation to be applied less and less over the mix duration. Properties keyed in the previous animation\r\n     * transition to the value from lower tracks or to the setup pose value if no lower tracks key the property. A mix duration of\r\n     * 0 still mixes out over one frame.\r\n     *\r\n     * Mixing in is done by first setting an empty animation, then adding an animation using\r\n     * {@link #addAnimation()} and on the returned track entry, set the\r\n     * {@link TrackEntry#setMixDuration()}. Mixing from an empty animation causes the new animation to be applied more and\r\n     * more over the mix duration. Properties keyed in the new animation transition from the value from lower tracks or from the\r\n     * setup pose value if no lower tracks key the property to the value keyed in the new animation. */\r\n    setEmptyAnimation(trackIndex: number, mixDuration: number) {\r\n        const entry = this.setAnimationWith(trackIndex, AnimationState.emptyAnimation, false);\r\n\r\n        entry.mixDuration = mixDuration;\r\n        entry.trackEnd = mixDuration;\r\n\r\n        return entry;\r\n    }\r\n\r\n    /** Adds an empty animation to be played after the current or last queued animation for a track, and sets the track entry's\r\n     * {@link TrackEntry#mixDuration}. If the track is empty, it is equivalent to calling\r\n     * {@link #setEmptyAnimation()}.\r\n     *\r\n     * See {@link #setEmptyAnimation()}.\r\n     * @param delay If > 0, sets {@link TrackEntry#delay}. If <= 0, the delay set is the duration of the previous track entry\r\n     *           minus any mix duration plus the specified `delay` (ie the mix ends at (`delay` = 0) or\r\n     *           before (`delay` < 0) the previous track entry duration). If the previous entry is looping, its next\r\n     *           loop completion is used instead of its duration.\r\n     * @return A track entry to allow further customization of animation playback. References to the track entry must not be kept\r\n     *         after the {@link AnimationStateListener#dispose()} event occurs. */\r\n    addEmptyAnimation(trackIndex: number, mixDuration: number, delay: number) {\r\n        if (delay <= 0) delay -= mixDuration;\r\n        const entry = this.addAnimationWith(trackIndex, AnimationState.emptyAnimation, false, delay);\r\n\r\n        entry.mixDuration = mixDuration;\r\n        entry.trackEnd = mixDuration;\r\n\r\n        return entry;\r\n    }\r\n\r\n    /** Sets an empty animation for every track, discarding any queued animations, and mixes to it over the specified mix\r\n     * duration. */\r\n    setEmptyAnimations(mixDuration: number) {\r\n        const oldDrainDisabled = this.queue.drainDisabled;\r\n\r\n        this.queue.drainDisabled = true;\r\n        for (let i = 0, n = this.tracks.length; i < n; i++) {\r\n            const current = this.tracks[i];\r\n\r\n            if (current != null) this.setEmptyAnimation(current.trackIndex, mixDuration);\r\n        }\r\n        this.queue.drainDisabled = oldDrainDisabled;\r\n        this.queue.drain();\r\n    }\r\n\r\n    expandToIndex(index: number) {\r\n        if (index < this.tracks.length) return this.tracks[index];\r\n        Utils.ensureArrayCapacity(this.tracks, index + 1, null);\r\n        this.tracks.length = index + 1;\r\n\r\n        return null;\r\n    }\r\n\r\n    /** @param last May be null. */\r\n    trackEntry(trackIndex: number, animation: Animation, loop: boolean, last: TrackEntry) {\r\n        const entry = this.trackEntryPool.obtain();\r\n\r\n        entry.trackIndex = trackIndex;\r\n        entry.animation = animation;\r\n        entry.loop = loop;\r\n        entry.holdPrevious = false;\r\n\r\n        entry.eventThreshold = 0;\r\n        entry.attachmentThreshold = 0;\r\n        entry.drawOrderThreshold = 0;\r\n\r\n        entry.animationStart = 0;\r\n        entry.animationEnd = animation.duration;\r\n        entry.animationLast = -1;\r\n        entry.nextAnimationLast = -1;\r\n\r\n        entry.delay = 0;\r\n        entry.trackTime = 0;\r\n        entry.trackLast = -1;\r\n        entry.nextTrackLast = -1;\r\n        entry.trackEnd = Number.MAX_VALUE;\r\n        entry.timeScale = 1;\r\n\r\n        entry.alpha = 1;\r\n        entry.interruptAlpha = 1;\r\n        entry.mixTime = 0;\r\n        entry.mixDuration = last == null ? 0 : this.data.getMix(last.animation, animation);\r\n        entry.mixBlend = MixBlend.replace;\r\n\r\n        return entry;\r\n    }\r\n\r\n    disposeNext(entry: TrackEntry) {\r\n        let next = entry.next;\r\n\r\n        while (next != null) {\r\n            this.queue.dispose(next);\r\n            next = next.next;\r\n        }\r\n        entry.next = null;\r\n    }\r\n\r\n    _animationsChanged() {\r\n        this.animationsChanged = false;\r\n\r\n        this.propertyIDs.clear();\r\n\r\n        for (let i = 0, n = this.tracks.length; i < n; i++) {\r\n            let entry = this.tracks[i];\r\n\r\n            if (entry == null) continue;\r\n            while (entry.mixingFrom != null) entry = entry.mixingFrom;\r\n\r\n            do {\r\n                if (entry.mixingFrom == null || entry.mixBlend != MixBlend.add) this.computeHold(entry);\r\n                entry = entry.mixingTo;\r\n            } while (entry != null);\r\n        }\r\n    }\r\n\r\n    computeHold(entry: TrackEntry) {\r\n        const to = entry.mixingTo;\r\n        const timelines = entry.animation.timelines;\r\n        const timelinesCount = entry.animation.timelines.length;\r\n        const timelineMode = Utils.setArraySize(entry.timelineMode, timelinesCount);\r\n\r\n        entry.timelineHoldMix.length = 0;\r\n        const timelineDipMix = Utils.setArraySize(entry.timelineHoldMix, timelinesCount);\r\n        const propertyIDs = this.propertyIDs;\r\n\r\n        if (to != null && to.holdPrevious) {\r\n            for (let i = 0; i < timelinesCount; i++) {\r\n                timelineMode[i] = propertyIDs.add(timelines[i].getPropertyId()) ? AnimationState.HOLD_FIRST : AnimationState.HOLD_SUBSEQUENT;\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        // eslint-disable-next-line no-restricted-syntax, no-labels\r\n        outer: for (let i = 0; i < timelinesCount; i++) {\r\n            const timeline = timelines[i];\r\n            const id = timeline.getPropertyId();\r\n\r\n            if (!propertyIDs.add(id)) timelineMode[i] = AnimationState.SUBSEQUENT;\r\n            else if (\r\n                to == null ||\r\n                timeline instanceof AttachmentTimeline ||\r\n                timeline instanceof DrawOrderTimeline ||\r\n                timeline instanceof EventTimeline ||\r\n                !to.animation.hasTimeline(id)\r\n            ) {\r\n                timelineMode[i] = AnimationState.FIRST;\r\n            } else {\r\n                for (let next = to.mixingTo; next != null; next = next.mixingTo) {\r\n                    if (next.animation.hasTimeline(id)) continue;\r\n                    if (entry.mixDuration > 0) {\r\n                        timelineMode[i] = AnimationState.HOLD_MIX;\r\n                        timelineDipMix[i] = next;\r\n                        // eslint-disable-next-line no-labels\r\n                        continue outer;\r\n                    }\r\n                    break;\r\n                }\r\n                timelineMode[i] = AnimationState.HOLD_FIRST;\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Returns the track entry for the animation currently playing on the track, or null if no animation is currently playing. */\r\n    getCurrent(trackIndex: number) {\r\n        if (trackIndex >= this.tracks.length) return null;\r\n\r\n        return this.tracks[trackIndex];\r\n    }\r\n\r\n    /** Adds a listener to receive events for all track entries. */\r\n    addListener(listener: AnimationStateListener) {\r\n        if (listener == null) throw new Error('listener cannot be null.');\r\n        this.listeners.push(listener);\r\n    }\r\n\r\n    /** Removes the listener added with {@link #addListener()}. */\r\n    removeListener(listener: AnimationStateListener) {\r\n        const index = this.listeners.indexOf(listener);\r\n\r\n        if (index >= 0) this.listeners.splice(index, 1);\r\n    }\r\n\r\n    /** Removes all listeners added with {@link #addListener()}. */\r\n    clearListeners() {\r\n        this.listeners.length = 0;\r\n    }\r\n\r\n    /** Discards all listener notifications that have not yet been delivered. This can be useful to call from an\r\n     * {@link AnimationStateListener} when it is known that further notifications that may have been already queued for delivery\r\n     * are not wanted because new animations are being set. */\r\n    clearListenerNotifications() {\r\n        this.queue.clear();\r\n    }\r\n\r\n    // deprecated stuff\r\n    onComplete: (trackIndex: number, loopCount: number) => any;\r\n    onEvent: (trackIndex: number, event: Event) => any;\r\n    onStart: (trackIndex: number) => any;\r\n    onEnd: (trackIndex: number) => any;\r\n\r\n    private static deprecatedWarning1 = false;\r\n\r\n    setAnimationByName(trackIndex: number, animationName: string, loop: boolean) {\r\n        if (!AnimationState.deprecatedWarning1) {\r\n            AnimationState.deprecatedWarning1 = true;\r\n            console.warn('Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.');\r\n        }\r\n        this.setAnimation(trackIndex, animationName, loop);\r\n    }\r\n\r\n    private static deprecatedWarning2 = false;\r\n\r\n    addAnimationByName(trackIndex: number, animationName: string, loop: boolean, delay: number) {\r\n        if (!AnimationState.deprecatedWarning2) {\r\n            AnimationState.deprecatedWarning2 = true;\r\n            console.warn('Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.');\r\n        }\r\n        this.addAnimation(trackIndex, animationName, loop, delay);\r\n    }\r\n\r\n    private static deprecatedWarning3 = false;\r\n\r\n    hasAnimation(animationName: string): boolean {\r\n        const animation = this.data.skeletonData.findAnimation(animationName);\r\n\r\n        return animation !== null;\r\n    }\r\n\r\n    hasAnimationByName(animationName: string): boolean {\r\n        if (!AnimationState.deprecatedWarning3) {\r\n            AnimationState.deprecatedWarning3 = true;\r\n            console.warn('Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.');\r\n        }\r\n\r\n        return this.hasAnimation(animationName);\r\n    }\r\n}\r\n\r\n/** Stores settings and other state for the playback of an animation on an {@link AnimationState} track.\r\n *\r\n * References to a track entry must not be kept after the {@link AnimationStateListener#dispose()} event occurs. */\r\n/**\r\n * @public\r\n */\r\nexport class TrackEntry implements ITrackEntry {\r\n    /** The animation to apply for this track entry. */\r\n    animation: Animation;\r\n\r\n    /** The animation queued to start after this animation, or null. `next` makes up a linked list. */\r\n    next: TrackEntry;\r\n\r\n    /** The track entry for the previous animation when mixing from the previous animation to this animation, or null if no\r\n     * mixing is currently occuring. When mixing from multiple animations, `mixingFrom` makes up a linked list. */\r\n    mixingFrom: TrackEntry;\r\n\r\n    /** The track entry for the next animation when mixing from this animation to the next animation, or null if no mixing is\r\n     * currently occuring. When mixing to multiple animations, `mixingTo` makes up a linked list. */\r\n    mixingTo: TrackEntry;\r\n\r\n    /** The listener for events generated by this track entry, or null.\r\n     *\r\n     * A track entry returned from {@link AnimationState#setAnimation()} is already the current animation\r\n     * for the track, so the track entry listener {@link AnimationStateListener#start()} will not be called. */\r\n    listener: AnimationStateListener;\r\n\r\n    /** The index of the track where this track entry is either current or queued.\r\n     *\r\n     * See {@link AnimationState#getCurrent()}. */\r\n    trackIndex: number;\r\n\r\n    /** If true, the animation will repeat. If false it will not, instead its last frame is applied if played beyond its\r\n     * duration. */\r\n    loop: boolean;\r\n\r\n    /** If true, when mixing from the previous animation to this animation, the previous animation is applied as normal instead\r\n     * of being mixed out.\r\n     *\r\n     * When mixing between animations that key the same property, if a lower track also keys that property then the value will\r\n     * briefly dip toward the lower track value during the mix. This happens because the first animation mixes from 100% to 0%\r\n     * while the second animation mixes from 0% to 100%. Setting `holdPrevious` to true applies the first animation\r\n     * at 100% during the mix so the lower track value is overwritten. Such dipping does not occur on the lowest track which\r\n     * keys the property, only when a higher track also keys the property.\r\n     *\r\n     * Snapping will occur if `holdPrevious` is true and this animation does not key all the same properties as the\r\n     * previous animation. */\r\n    holdPrevious: boolean;\r\n\r\n    /** When the mix percentage ({@link #mixTime} / {@link #mixDuration}) is less than the\r\n     * `eventThreshold`, event timelines are applied while this animation is being mixed out. Defaults to 0, so event\r\n     * timelines are not applied while this animation is being mixed out. */\r\n    eventThreshold: number;\r\n\r\n    /** When the mix percentage ({@link #mixtime} / {@link #mixDuration}) is less than the\r\n     * `attachmentThreshold`, attachment timelines are applied while this animation is being mixed out. Defaults to\r\n     * 0, so attachment timelines are not applied while this animation is being mixed out. */\r\n    attachmentThreshold: number;\r\n\r\n    /** When the mix percentage ({@link #mixTime} / {@link #mixDuration}) is less than the\r\n     * `drawOrderThreshold`, draw order timelines are applied while this animation is being mixed out. Defaults to 0,\r\n     * so draw order timelines are not applied while this animation is being mixed out. */\r\n    drawOrderThreshold: number;\r\n\r\n    /** Seconds when this animation starts, both initially and after looping. Defaults to 0.\r\n     *\r\n     * When changing the `animationStart` time, it often makes sense to set {@link #animationLast} to the same\r\n     * value to prevent timeline keys before the start time from triggering. */\r\n    animationStart: number;\r\n\r\n    /** Seconds for the last frame of this animation. Non-looping animations won't play past this time. Looping animations will\r\n     * loop back to {@link #animationStart} at this time. Defaults to the animation {@link Animation#duration}. */\r\n    animationEnd: number;\r\n\r\n    /** The time in seconds this animation was last applied. Some timelines use this for one-time triggers. Eg, when this\r\n     * animation is applied, event timelines will fire all events between the `animationLast` time (exclusive) and\r\n     * `animationTime` (inclusive). Defaults to -1 to ensure triggers on frame 0 happen the first time this animation\r\n     * is applied. */\r\n    animationLast: number;\r\n\r\n    nextAnimationLast: number;\r\n\r\n    /** Seconds to postpone playing the animation. When this track entry is the current track entry, `delay`\r\n     * postpones incrementing the {@link #trackTime}. When this track entry is queued, `delay` is the time from\r\n     * the start of the previous animation to when this track entry will become the current track entry (ie when the previous\r\n     * track entry {@link TrackEntry#trackTime} >= this track entry's `delay`).\r\n     *\r\n     * {@link #timeScale} affects the delay. */\r\n    delay: number;\r\n\r\n    /** Current time in seconds this track entry has been the current track entry. The track time determines\r\n     * {@link #animationTime}. The track time can be set to start the animation at a time other than 0, without affecting\r\n     * looping. */\r\n    trackTime: number;\r\n\r\n    trackLast: number;\r\n    nextTrackLast: number;\r\n\r\n    /** The track time in seconds when this animation will be removed from the track. Defaults to the highest possible float\r\n     * value, meaning the animation will be applied until a new animation is set or the track is cleared. If the track end time\r\n     * is reached, no other animations are queued for playback, and mixing from any previous animations is complete, then the\r\n     * properties keyed by the animation are set to the setup pose and the track is cleared.\r\n     *\r\n     * It may be desired to use {@link AnimationState#addEmptyAnimation()} rather than have the animation\r\n     * abruptly cease being applied. */\r\n    trackEnd: number;\r\n\r\n    /** Multiplier for the delta time when this track entry is updated, causing time for this animation to pass slower or\r\n     * faster. Defaults to 1.\r\n     *\r\n     * {@link #mixTime} is not affected by track entry time scale, so {@link #mixDuration} may need to be adjusted to\r\n     * match the animation speed.\r\n     *\r\n     * When using {@link AnimationState#addAnimation()} with a `delay` <= 0, note the\r\n     * {@link #delay} is set using the mix duration from the {@link AnimationStateData}, assuming time scale to be 1. If\r\n     * the time scale is not 1, the delay may need to be adjusted.\r\n     *\r\n     * See AnimationState {@link AnimationState#timeScale} for affecting all animations. */\r\n    timeScale: number;\r\n\r\n    /** Values < 1 mix this animation with the skeleton's current pose (usually the pose resulting from lower tracks). Defaults\r\n     * to 1, which overwrites the skeleton's current pose with this animation.\r\n     *\r\n     * Typically track 0 is used to completely pose the skeleton, then alpha is used on higher tracks. It doesn't make sense to\r\n     * use alpha on track 0 if the skeleton pose is from the last frame render. */\r\n    alpha: number;\r\n\r\n    /** Seconds from 0 to the {@link #getMixDuration()} when mixing from the previous animation to this animation. May be\r\n     * slightly more than `mixDuration` when the mix is complete. */\r\n    mixTime: number;\r\n\r\n    /** Seconds for mixing from the previous animation to this animation. Defaults to the value provided by AnimationStateData\r\n     * {@link AnimationStateData#getMix()} based on the animation before this animation (if any).\r\n     *\r\n     * A mix duration of 0 still mixes out over one frame to provide the track entry being mixed out a chance to revert the\r\n     * properties it was animating.\r\n     *\r\n     * The `mixDuration` can be set manually rather than use the value from\r\n     * {@link AnimationStateData#getMix()}. In that case, the `mixDuration` can be set for a new\r\n     * track entry only before {@link AnimationState#update(float)} is first called.\r\n     *\r\n     * When using {@link AnimationState#addAnimation()} with a `delay` <= 0, note the\r\n     * {@link #delay} is set using the mix duration from the {@link AnimationStateData}, not a mix duration set\r\n     * afterward. */\r\n    mixDuration: number;\r\n    interruptAlpha: number;\r\n    totalAlpha: number;\r\n\r\n    /** Controls how properties keyed in the animation are mixed with lower tracks. Defaults to {@link MixBlend#replace}, which\r\n     * replaces the values from the lower tracks with the animation values. {@link MixBlend#add} adds the animation values to\r\n     * the values from the lower tracks.\r\n     *\r\n     * The `mixBlend` can be set for a new track entry only before {@link AnimationState#apply()} is first\r\n     * called. */\r\n    mixBlend = MixBlend.replace;\r\n    timelineMode = new Array<number>();\r\n    timelineHoldMix = new Array<TrackEntry>();\r\n    timelinesRotation = new Array<number>();\r\n\r\n    reset() {\r\n        this.next = null;\r\n        this.mixingFrom = null;\r\n        this.mixingTo = null;\r\n        this.animation = null;\r\n        this.listener = null;\r\n        this.timelineMode.length = 0;\r\n        this.timelineHoldMix.length = 0;\r\n        this.timelinesRotation.length = 0;\r\n    }\r\n\r\n    /** Uses {@link #trackTime} to compute the `animationTime`, which is between {@link #animationStart}\r\n     * and {@link #animationEnd}. When the `trackTime` is 0, the `animationTime` is equal to the\r\n     * `animationStart` time. */\r\n    getAnimationTime() {\r\n        if (this.loop) {\r\n            const duration = this.animationEnd - this.animationStart;\r\n\r\n            if (duration == 0) return this.animationStart;\r\n\r\n            return (this.trackTime % duration) + this.animationStart;\r\n        }\r\n\r\n        return Math.min(this.trackTime + this.animationStart, this.animationEnd);\r\n    }\r\n\r\n    setAnimationLast(animationLast: number) {\r\n        this.animationLast = animationLast;\r\n        this.nextAnimationLast = animationLast;\r\n    }\r\n\r\n    /** Returns true if at least one loop has been completed.\r\n     *\r\n     * See {@link AnimationStateListener#complete()}. */\r\n    isComplete() {\r\n        return this.trackTime >= this.animationEnd - this.animationStart;\r\n    }\r\n\r\n    /** Resets the rotation directions for mixing this entry's rotate timelines. This can be useful to avoid bones rotating the\r\n     * long way around when using {@link #alpha} and starting animations on other tracks.\r\n     *\r\n     * Mixing with {@link MixBlend#replace} involves finding a rotation between two others, which has two possible solutions:\r\n     * the short way or the long way around. The two rotations likely change over time, so which direction is the short or long\r\n     * way also changes. If the short way was always chosen, bones would flip to the other side when that direction became the\r\n     * long way. TrackEntry chooses the short way the first time it is applied and remembers that direction. */\r\n    resetRotationDirections() {\r\n        this.timelinesRotation.length = 0;\r\n    }\r\n\r\n    // deprecated stuff\r\n    onComplete: (trackIndex: number, loopCount: number) => any;\r\n    onEvent: (trackIndex: number, event: Event) => any;\r\n    onStart: (trackIndex: number) => any;\r\n    onEnd: (trackIndex: number) => any;\r\n\r\n    private static deprecatedWarning1: Boolean = false;\r\n    private static deprecatedWarning2: Boolean = false;\r\n\r\n    get time() {\r\n        if (!TrackEntry.deprecatedWarning1) {\r\n            TrackEntry.deprecatedWarning1 = true;\r\n            console.warn('Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.');\r\n        }\r\n\r\n        return this.trackTime;\r\n    }\r\n\r\n    set time(value: number) {\r\n        if (!TrackEntry.deprecatedWarning1) {\r\n            TrackEntry.deprecatedWarning1 = true;\r\n            console.warn('Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.');\r\n        }\r\n        this.trackTime = value;\r\n    }\r\n\r\n    get endTime() {\r\n        if (!TrackEntry.deprecatedWarning2) {\r\n            TrackEntry.deprecatedWarning2 = true;\r\n            console.warn('Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.');\r\n        }\r\n\r\n        return this.trackTime;\r\n    }\r\n\r\n    set endTime(value: number) {\r\n        if (!TrackEntry.deprecatedWarning2) {\r\n            TrackEntry.deprecatedWarning2 = true;\r\n            console.warn('Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.');\r\n        }\r\n        this.trackTime = value;\r\n    }\r\n\r\n    loopsCount() {\r\n        return Math.floor(this.trackTime / this.trackEnd);\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class EventQueue {\r\n    objects: Array<any> = [];\r\n    drainDisabled = false;\r\n    animState: AnimationState;\r\n\r\n    constructor(animState: AnimationState) {\r\n        this.animState = animState;\r\n    }\r\n\r\n    start(entry: TrackEntry) {\r\n        this.objects.push(EventType.start);\r\n        this.objects.push(entry);\r\n        this.animState.animationsChanged = true;\r\n    }\r\n\r\n    interrupt(entry: TrackEntry) {\r\n        this.objects.push(EventType.interrupt);\r\n        this.objects.push(entry);\r\n    }\r\n\r\n    end(entry: TrackEntry) {\r\n        this.objects.push(EventType.end);\r\n        this.objects.push(entry);\r\n        this.animState.animationsChanged = true;\r\n    }\r\n\r\n    dispose(entry: TrackEntry) {\r\n        this.objects.push(EventType.dispose);\r\n        this.objects.push(entry);\r\n    }\r\n\r\n    complete(entry: TrackEntry) {\r\n        this.objects.push(EventType.complete);\r\n        this.objects.push(entry);\r\n    }\r\n\r\n    event(entry: TrackEntry, event: Event) {\r\n        this.objects.push(EventType.event);\r\n        this.objects.push(entry);\r\n        this.objects.push(event);\r\n    }\r\n\r\n    private static deprecatedWarning1: Boolean = false;\r\n\r\n    deprecateStuff() {\r\n        if (!EventQueue.deprecatedWarning1) {\r\n            EventQueue.deprecatedWarning1 = true;\r\n            console.warn(\r\n                \"Spine Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'\"\r\n            );\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    drain() {\r\n        if (this.drainDisabled) return;\r\n        this.drainDisabled = true;\r\n\r\n        const objects = this.objects;\r\n        const listeners = this.animState.listeners;\r\n\r\n        for (let i = 0; i < objects.length; i += 2) {\r\n            const type = objects[i] as EventType;\r\n            const entry = objects[i + 1] as TrackEntry;\r\n\r\n            switch (type) {\r\n                case EventType.start:\r\n                    if (entry.listener != null && entry.listener.start) entry.listener.start(entry);\r\n                    for (let ii = 0; ii < listeners.length; ii++) if (listeners[ii].start) listeners[ii].start(entry);\r\n                    // deprecation\r\n                    entry.onStart && this.deprecateStuff() && entry.onStart(entry.trackIndex);\r\n                    this.animState.onStart && this.deprecateStuff() && this.deprecateStuff && this.animState.onStart(entry.trackIndex);\r\n                    break;\r\n                case EventType.interrupt:\r\n                    if (entry.listener != null && entry.listener.interrupt) entry.listener.interrupt(entry);\r\n                    for (let ii = 0; ii < listeners.length; ii++) if (listeners[ii].interrupt) listeners[ii].interrupt(entry);\r\n                    break;\r\n                case EventType.end:\r\n                    if (entry.listener != null && entry.listener.end) entry.listener.end(entry);\r\n                    for (let ii = 0; ii < listeners.length; ii++) if (listeners[ii].end) listeners[ii].end(entry);\r\n                    // deprecation\r\n                    entry.onEnd && this.deprecateStuff() && entry.onEnd(entry.trackIndex);\r\n                    this.animState.onEnd && this.deprecateStuff() && this.animState.onEnd(entry.trackIndex);\r\n                // Fall through.\r\n                case EventType.dispose:\r\n                    if (entry.listener != null && entry.listener.dispose) entry.listener.dispose(entry);\r\n                    for (let ii = 0; ii < listeners.length; ii++) if (listeners[ii].dispose) listeners[ii].dispose(entry);\r\n                    this.animState.trackEntryPool.free(entry);\r\n                    break;\r\n                case EventType.complete:\r\n                    if (entry.listener != null && entry.listener.complete) entry.listener.complete(entry);\r\n                    for (let ii = 0; ii < listeners.length; ii++) if (listeners[ii].complete) listeners[ii].complete(entry);\r\n                    // deprecation\r\n\r\n                    const count = MathUtils.toInt(entry.loopsCount());\r\n\r\n                    entry.onComplete && this.deprecateStuff() && entry.onComplete(entry.trackIndex, count);\r\n                    this.animState.onComplete && this.deprecateStuff() && this.animState.onComplete(entry.trackIndex, count);\r\n                    break;\r\n                case EventType.event:\r\n                    const event = objects[i++ + 2] as Event;\r\n\r\n                    if (entry.listener != null && entry.listener.event) entry.listener.event(entry, event);\r\n                    for (let ii = 0; ii < listeners.length; ii++) if (listeners[ii].event) listeners[ii].event(entry, event);\r\n                    // deprecation\r\n                    entry.onEvent && this.deprecateStuff() && entry.onEvent(entry.trackIndex, event);\r\n                    this.animState.onEvent && this.deprecateStuff() && this.animState.onEvent(entry.trackIndex, event);\r\n                    break;\r\n            }\r\n        }\r\n        this.clear();\r\n\r\n        this.drainDisabled = false;\r\n    }\r\n\r\n    clear() {\r\n        this.objects.length = 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport enum EventType {\r\n    start,\r\n    interrupt,\r\n    end,\r\n    dispose,\r\n    complete,\r\n    event,\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface AnimationStateListener extends IAnimationStateListener {\r\n    /** Invoked when this entry has been set as the current entry. */\r\n    start?(entry: TrackEntry): void;\r\n\r\n    /** Invoked when another entry has replaced this entry as the current entry. This entry may continue being applied for\r\n     * mixing. */\r\n    interrupt?(entry: TrackEntry): void;\r\n\r\n    /** Invoked when this entry is no longer the current entry and will never be applied again. */\r\n    end?(entry: TrackEntry): void;\r\n\r\n    /** Invoked when this entry will be disposed. This may occur without the entry ever being set as the current entry.\r\n     * References to the entry should not be kept after dispose is called, as it may be destroyed or reused. */\r\n    dispose?(entry: TrackEntry): void;\r\n\r\n    /** Invoked every time this entry's animation completes a loop. */\r\n    complete?(entry: TrackEntry): void;\r\n\r\n    /** Invoked when this entry's animation triggers an event. */\r\n    event?(entry: TrackEntry, event: Event): void;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport abstract class AnimationStateAdapter implements AnimationStateListener {\r\n    start(entry: TrackEntry) {}\r\n\r\n    interrupt(entry: TrackEntry) {}\r\n\r\n    end(entry: TrackEntry) {}\r\n\r\n    dispose(entry: TrackEntry) {}\r\n\r\n    complete(entry: TrackEntry) {}\r\n\r\n    event(entry: TrackEntry, event: Event) {}\r\n}\r\n","import type { SkeletonData } from './SkeletonData';\r\nimport type { IAnimation, IAnimationStateData, Map } from '@pixi-spine/base';\r\nimport type { Animation } from './Animation';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class AnimationStateData implements IAnimationStateData<SkeletonData, Animation> {\r\n    skeletonData: SkeletonData;\r\n    animationToMixTime: Map<number> = {};\r\n    defaultMix = 0;\r\n\r\n    constructor(skeletonData: SkeletonData) {\r\n        if (skeletonData == null) throw new Error('skeletonData cannot be null.');\r\n        this.skeletonData = skeletonData;\r\n    }\r\n\r\n    setMix(fromName: string, toName: string, duration: number) {\r\n        const from = this.skeletonData.findAnimation(fromName);\r\n\r\n        if (from == null) throw new Error(`Animation not found: ${fromName}`);\r\n        const to = this.skeletonData.findAnimation(toName);\r\n\r\n        if (to == null) throw new Error(`Animation not found: ${toName}`);\r\n        this.setMixWith(from, to, duration);\r\n    }\r\n\r\n    private static deprecatedWarning1 = false;\r\n\r\n    setMixByName(fromName: string, toName: string, duration: number) {\r\n        if (!AnimationStateData.deprecatedWarning1) {\r\n            AnimationStateData.deprecatedWarning1 = true;\r\n            console.warn('Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.');\r\n        }\r\n        this.setMix(fromName, toName, duration);\r\n    }\r\n\r\n    setMixWith(from: IAnimation, to: IAnimation, duration: number) {\r\n        if (from == null) throw new Error('from cannot be null.');\r\n        if (to == null) throw new Error('to cannot be null.');\r\n        const key = `${from.name}.${to.name}`;\r\n\r\n        this.animationToMixTime[key] = duration;\r\n    }\r\n\r\n    getMix(from: IAnimation, to: IAnimation) {\r\n        const key = `${from.name}.${to.name}`;\r\n        const value = this.animationToMixTime[key];\r\n\r\n        return value === undefined ? this.defaultMix : value;\r\n    }\r\n}\r\n","import { AttachmentLoader, RegionAttachment, MeshAttachment, BoundingBoxAttachment, PathAttachment, PointAttachment, ClippingAttachment } from './attachments';\r\nimport type { TextureAtlas } from '@pixi-spine/base';\r\nimport type { Skin } from './Skin';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class AtlasAttachmentLoader implements AttachmentLoader {\r\n    atlas: TextureAtlas;\r\n\r\n    constructor(atlas: TextureAtlas) {\r\n        this.atlas = atlas;\r\n    }\r\n\r\n    /** @return May be null to not load an attachment. */\r\n    newRegionAttachment(skin: Skin, name: string, path: string): RegionAttachment {\r\n        const region = this.atlas.findRegion(path);\r\n\r\n        if (region == null) throw new Error(`Region not found in atlas: ${path} (region attachment: ${name})`);\r\n        const attachment = new RegionAttachment(name);\r\n\r\n        attachment.region = region;\r\n\r\n        return attachment;\r\n    }\r\n\r\n    /** @return May be null to not load an attachment. */\r\n    newMeshAttachment(skin: Skin, name: string, path: string): MeshAttachment {\r\n        const region = this.atlas.findRegion(path);\r\n\r\n        if (region == null) throw new Error(`Region not found in atlas: ${path} (mesh attachment: ${name})`);\r\n        const attachment = new MeshAttachment(name);\r\n\r\n        attachment.region = region;\r\n\r\n        return attachment;\r\n    }\r\n\r\n    /** @return May be null to not load an attachment. */\r\n    newBoundingBoxAttachment(skin: Skin, name: string): BoundingBoxAttachment {\r\n        return new BoundingBoxAttachment(name);\r\n    }\r\n\r\n    /** @return May be null to not load an attachment */\r\n    newPathAttachment(skin: Skin, name: string): PathAttachment {\r\n        return new PathAttachment(name);\r\n    }\r\n\r\n    newPointAttachment(skin: Skin, name: string): PointAttachment {\r\n        return new PointAttachment(name);\r\n    }\r\n\r\n    newClippingAttachment(skin: Skin, name: string): ClippingAttachment {\r\n        return new ClippingAttachment(name);\r\n    }\r\n}\r\n","import { Matrix } from '@pixi/core';\r\nimport type { Updatable } from './Updatable';\r\nimport type { BoneData } from './BoneData';\r\nimport type { Skeleton } from './Skeleton';\r\nimport { IBone, MathUtils, settings, TransformMode, Vector2 } from '@pixi-spine/base';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class Bone implements Updatable, IBone {\r\n    // be careful! Spine b,c is c,b in pixi matrix\r\n    matrix = new Matrix();\r\n\r\n    get worldX(): number {\r\n        return this.matrix.tx;\r\n    }\r\n\r\n    get worldY(): number {\r\n        return this.matrix.ty;\r\n    }\r\n\r\n    data: BoneData;\r\n    skeleton: Skeleton;\r\n    parent: Bone;\r\n    children = new Array<Bone>();\r\n    x = 0;\r\n    y = 0;\r\n    rotation = 0;\r\n    scaleX = 0;\r\n    scaleY = 0;\r\n    shearX = 0;\r\n    shearY = 0;\r\n    ax = 0;\r\n    ay = 0;\r\n    arotation = 0;\r\n    ascaleX = 0;\r\n    ascaleY = 0;\r\n    ashearX = 0;\r\n    ashearY = 0;\r\n    appliedValid = false;\r\n\r\n    sorted = false;\r\n    active = false;\r\n\r\n    /** @param parent May be null. */\r\n    constructor(data: BoneData, skeleton: Skeleton, parent: Bone) {\r\n        if (data == null) throw new Error('data cannot be null.');\r\n        if (skeleton == null) throw new Error('skeleton cannot be null.');\r\n        this.data = data;\r\n        this.skeleton = skeleton;\r\n        this.parent = parent;\r\n        this.setToSetupPose();\r\n    }\r\n\r\n    isActive() {\r\n        return this.active;\r\n    }\r\n\r\n    /** Same as {@link #updateWorldTransform()}. This method exists for Bone to implement {@link Updatable}. */\r\n    update() {\r\n        this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\r\n    }\r\n\r\n    /** Computes the world transform using the parent bone and this bone's local transform. */\r\n    updateWorldTransform() {\r\n        this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\r\n    }\r\n\r\n    /** Computes the world transform using the parent bone and the specified local transform. */\r\n    updateWorldTransformWith(x: number, y: number, rotation: number, scaleX: number, scaleY: number, shearX: number, shearY: number) {\r\n        this.ax = x;\r\n        this.ay = y;\r\n        this.arotation = rotation;\r\n        this.ascaleX = scaleX;\r\n        this.ascaleY = scaleY;\r\n        this.ashearX = shearX;\r\n        this.ashearY = shearY;\r\n        this.appliedValid = true;\r\n\r\n        const parent = this.parent;\r\n        const m = this.matrix;\r\n\r\n        const sx = this.skeleton.scaleX;\r\n        const sy = settings.yDown ? -this.skeleton.scaleY : this.skeleton.scaleY;\r\n\r\n        if (parent == null) {\r\n            // Root bone.\r\n            const skeleton = this.skeleton;\r\n            const rotationY = rotation + 90 + shearY;\r\n\r\n            m.a = MathUtils.cosDeg(rotation + shearX) * scaleX * sx;\r\n            m.c = MathUtils.cosDeg(rotationY) * scaleY * sx;\r\n            m.b = MathUtils.sinDeg(rotation + shearX) * scaleX * sy;\r\n            m.d = MathUtils.sinDeg(rotationY) * scaleY * sy;\r\n            m.tx = x * sx + skeleton.x;\r\n            m.ty = y * sy + skeleton.y;\r\n\r\n            return;\r\n        }\r\n\r\n        let pa = parent.matrix.a;\r\n        let pb = parent.matrix.c;\r\n        let pc = parent.matrix.b;\r\n        let pd = parent.matrix.d;\r\n\r\n        m.tx = pa * x + pb * y + parent.matrix.tx;\r\n        m.ty = pc * x + pd * y + parent.matrix.ty;\r\n        switch (this.data.transformMode) {\r\n            case TransformMode.Normal: {\r\n                const rotationY = rotation + 90 + shearY;\r\n                const la = MathUtils.cosDeg(rotation + shearX) * scaleX;\r\n                const lb = MathUtils.cosDeg(rotationY) * scaleY;\r\n                const lc = MathUtils.sinDeg(rotation + shearX) * scaleX;\r\n                const ld = MathUtils.sinDeg(rotationY) * scaleY;\r\n\r\n                m.a = pa * la + pb * lc;\r\n                m.c = pa * lb + pb * ld;\r\n                m.b = pc * la + pd * lc;\r\n                m.d = pc * lb + pd * ld;\r\n\r\n                return;\r\n            }\r\n            case TransformMode.OnlyTranslation: {\r\n                const rotationY = rotation + 90 + shearY;\r\n\r\n                m.a = MathUtils.cosDeg(rotation + shearX) * scaleX;\r\n                m.c = MathUtils.cosDeg(rotationY) * scaleY;\r\n                m.b = MathUtils.sinDeg(rotation + shearX) * scaleX;\r\n                m.d = MathUtils.sinDeg(rotationY) * scaleY;\r\n                break;\r\n            }\r\n            case TransformMode.NoRotationOrReflection: {\r\n                let s = pa * pa + pc * pc;\r\n                let prx = 0;\r\n\r\n                if (s > 0.0001) {\r\n                    s = Math.abs(pa * pd - pb * pc) / s;\r\n                    pa /= this.skeleton.scaleX;\r\n                    pc /= this.skeleton.scaleY;\r\n                    pb = pc * s;\r\n                    pd = pa * s;\r\n                    prx = Math.atan2(pc, pa) * MathUtils.radDeg;\r\n                } else {\r\n                    pa = 0;\r\n                    pc = 0;\r\n                    prx = 90 - Math.atan2(pd, pb) * MathUtils.radDeg;\r\n                }\r\n                const rx = rotation + shearX - prx;\r\n                const ry = rotation + shearY - prx + 90;\r\n                const la = MathUtils.cosDeg(rx) * scaleX;\r\n                const lb = MathUtils.cosDeg(ry) * scaleY;\r\n                const lc = MathUtils.sinDeg(rx) * scaleX;\r\n                const ld = MathUtils.sinDeg(ry) * scaleY;\r\n\r\n                m.a = pa * la - pb * lc;\r\n                m.c = pa * lb - pb * ld;\r\n                m.b = pc * la + pd * lc;\r\n                m.d = pc * lb + pd * ld;\r\n                break;\r\n            }\r\n            case TransformMode.NoScale:\r\n            case TransformMode.NoScaleOrReflection: {\r\n                const cos = MathUtils.cosDeg(rotation);\r\n                const sin = MathUtils.sinDeg(rotation);\r\n                let za = (pa * cos + pb * sin) / sx;\r\n                let zc = (pc * cos + pd * sin) / sy;\r\n                let s = Math.sqrt(za * za + zc * zc);\r\n\r\n                if (s > 0.00001) s = 1 / s;\r\n                za *= s;\r\n                zc *= s;\r\n                s = Math.sqrt(za * za + zc * zc);\r\n                if (\r\n                    this.data.transformMode == TransformMode.NoScale &&\r\n                    pa * pd - pb * pc < 0 != (settings.yDown ? this.skeleton.scaleX < 0 != this.skeleton.scaleY > 0 : this.skeleton.scaleX < 0 != this.skeleton.scaleY < 0)\r\n                )\r\n                    s = -s;\r\n                const r = Math.PI / 2 + Math.atan2(zc, za);\r\n                const zb = Math.cos(r) * s;\r\n                const zd = Math.sin(r) * s;\r\n                const la = MathUtils.cosDeg(shearX) * scaleX;\r\n                const lb = MathUtils.cosDeg(90 + shearY) * scaleY;\r\n                const lc = MathUtils.sinDeg(shearX) * scaleX;\r\n                const ld = MathUtils.sinDeg(90 + shearY) * scaleY;\r\n\r\n                m.a = za * la + zb * lc;\r\n                m.c = za * lb + zb * ld;\r\n                m.b = zc * la + zd * lc;\r\n                m.d = zc * lb + zd * ld;\r\n                break;\r\n            }\r\n        }\r\n        m.a *= sx;\r\n        m.c *= sx;\r\n        m.b *= sy;\r\n        m.d *= sy;\r\n    }\r\n\r\n    setToSetupPose() {\r\n        const data = this.data;\r\n\r\n        this.x = data.x;\r\n        this.y = data.y;\r\n        this.rotation = data.rotation;\r\n        this.scaleX = data.scaleX;\r\n        this.scaleY = data.scaleY;\r\n        this.shearX = data.shearX;\r\n        this.shearY = data.shearY;\r\n    }\r\n\r\n    getWorldRotationX() {\r\n        return Math.atan2(this.matrix.b, this.matrix.a) * MathUtils.radDeg;\r\n    }\r\n\r\n    getWorldRotationY() {\r\n        return Math.atan2(this.matrix.d, this.matrix.c) * MathUtils.radDeg;\r\n    }\r\n\r\n    getWorldScaleX() {\r\n        const m = this.matrix;\r\n\r\n        return Math.sqrt(m.a * m.a + m.c * m.c);\r\n    }\r\n\r\n    getWorldScaleY() {\r\n        const m = this.matrix;\r\n\r\n        return Math.sqrt(m.b * m.b + m.d * m.d);\r\n    }\r\n\r\n    /** Computes the individual applied transform values from the world transform. This can be useful to perform processing using\r\n     * the applied transform after the world transform has been modified directly (eg, by a constraint).\r\n     * <p>\r\n     * Some information is ambiguous in the world transform, such as -1,-1 scale versus 180 rotation. */\r\n    updateAppliedTransform() {\r\n        this.appliedValid = true;\r\n        const parent = this.parent;\r\n        const m = this.matrix;\r\n\r\n        if (parent == null) {\r\n            this.ax = m.tx;\r\n            this.ay = m.ty;\r\n            this.arotation = Math.atan2(m.b, m.a) * MathUtils.radDeg;\r\n            this.ascaleX = Math.sqrt(m.a * m.a + m.b * m.b);\r\n            this.ascaleY = Math.sqrt(m.c * m.c + m.d * m.d);\r\n            this.ashearX = 0;\r\n            this.ashearY = Math.atan2(m.a * m.c + m.b * m.d, m.a * m.d - m.b * m.c) * MathUtils.radDeg;\r\n\r\n            return;\r\n        }\r\n        const pm = parent.matrix;\r\n        const pid = 1 / (pm.a * pm.d - pm.b * pm.c);\r\n        const dx = m.tx - pm.tx;\r\n        const dy = m.ty - pm.ty;\r\n\r\n        this.ax = dx * pm.d * pid - dy * pm.c * pid;\r\n        this.ay = dy * pm.a * pid - dx * pm.b * pid;\r\n        const ia = pid * pm.d;\r\n        const id = pid * pm.a;\r\n        const ib = pid * pm.c;\r\n        const ic = pid * pm.b;\r\n        const ra = ia * m.a - ib * m.b;\r\n        const rb = ia * m.c - ib * m.d;\r\n        const rc = id * m.b - ic * m.a;\r\n        const rd = id * m.d - ic * m.c;\r\n\r\n        this.ashearX = 0;\r\n        this.ascaleX = Math.sqrt(ra * ra + rc * rc);\r\n        if (this.ascaleX > 0.0001) {\r\n            const det = ra * rd - rb * rc;\r\n\r\n            this.ascaleY = det / this.ascaleX;\r\n            this.ashearY = Math.atan2(ra * rb + rc * rd, det) * MathUtils.radDeg;\r\n            this.arotation = Math.atan2(rc, ra) * MathUtils.radDeg;\r\n        } else {\r\n            this.ascaleX = 0;\r\n            this.ascaleY = Math.sqrt(rb * rb + rd * rd);\r\n            this.ashearY = 0;\r\n            this.arotation = 90 - Math.atan2(rd, rb) * MathUtils.radDeg;\r\n        }\r\n    }\r\n\r\n    worldToLocal(world: Vector2) {\r\n        const m = this.matrix;\r\n        const a = m.a;\r\n        const b = m.c;\r\n        const c = m.b;\r\n        const d = m.d;\r\n        const invDet = 1 / (a * d - b * c);\r\n        const x = world.x - m.tx;\r\n        const y = world.y - m.ty;\r\n\r\n        world.x = x * d * invDet - y * b * invDet;\r\n        world.y = y * a * invDet - x * c * invDet;\r\n\r\n        return world;\r\n    }\r\n\r\n    localToWorld(local: Vector2) {\r\n        const m = this.matrix;\r\n        const x = local.x;\r\n        const y = local.y;\r\n\r\n        local.x = x * m.a + y * m.c + m.tx;\r\n        local.y = x * m.b + y * m.d + m.ty;\r\n\r\n        return local;\r\n    }\r\n\r\n    worldToLocalRotation(worldRotation: number) {\r\n        const sin = MathUtils.sinDeg(worldRotation);\r\n        const cos = MathUtils.cosDeg(worldRotation);\r\n        const mat = this.matrix;\r\n\r\n        return Math.atan2(mat.a * sin - mat.b * cos, mat.d * cos - mat.c * sin) * MathUtils.radDeg;\r\n    }\r\n\r\n    localToWorldRotation(localRotation: number) {\r\n        const sin = MathUtils.sinDeg(localRotation);\r\n        const cos = MathUtils.cosDeg(localRotation);\r\n        const mat = this.matrix;\r\n\r\n        return Math.atan2(cos * mat.b + sin * mat.d, cos * mat.a + sin * mat.c) * MathUtils.radDeg;\r\n    }\r\n\r\n    rotateWorld(degrees: number) {\r\n        const mat = this.matrix;\r\n        const a = mat.a;\r\n        const b = mat.c;\r\n        const c = mat.b;\r\n        const d = mat.d;\r\n        const cos = MathUtils.cosDeg(degrees);\r\n        const sin = MathUtils.sinDeg(degrees);\r\n\r\n        mat.a = cos * a - sin * c;\r\n        mat.c = cos * b - sin * d;\r\n        mat.b = sin * a + cos * c;\r\n        mat.d = sin * b + cos * d;\r\n        this.appliedValid = false;\r\n    }\r\n}\r\n","import { Color, TransformMode } from '@pixi-spine/base';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class BoneData {\r\n    index: number;\r\n    name: string;\r\n    parent: BoneData;\r\n    length: number;\r\n    x = 0;\r\n    y = 0;\r\n    rotation = 0;\r\n    scaleX = 1;\r\n    scaleY = 1;\r\n    shearX = 0;\r\n    shearY = 0;\r\n    transformMode = TransformMode.Normal;\r\n    skinRequired = false;\r\n\r\n    color = new Color();\r\n\r\n    constructor(index: number, name: string, parent: BoneData) {\r\n        if (index < 0) throw new Error('index must be >= 0.');\r\n        if (name == null) throw new Error('name cannot be null.');\r\n        this.index = index;\r\n        this.name = name;\r\n        this.parent = parent;\r\n    }\r\n}\r\n","/**\r\n * @public\r\n */\r\nexport abstract class ConstraintData {\r\n    constructor(public name: string, public order: number, public skinRequired: boolean) {}\r\n}\r\n","import type { EventData } from './EventData';\r\nimport type { IEvent } from '@pixi-spine/base';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class Event implements IEvent {\r\n    data: EventData;\r\n    intValue: number;\r\n    floatValue: number;\r\n    stringValue: string;\r\n    time: number;\r\n    volume: number;\r\n    balance: number;\r\n\r\n    constructor(time: number, data: EventData) {\r\n        if (data == null) throw new Error('data cannot be null.');\r\n        this.time = time;\r\n        this.data = data;\r\n    }\r\n}\r\n","import type { IEventData } from '@pixi-spine/base';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class EventData implements IEventData {\r\n    name: string;\r\n    intValue: number;\r\n    floatValue: number;\r\n    stringValue: string;\r\n    audioPath: string;\r\n    volume: number;\r\n    balance: number;\r\n\r\n    constructor(name: string) {\r\n        this.name = name;\r\n    }\r\n}\r\n","import type { Updatable } from './Updatable';\r\nimport type { IkConstraintData } from './IkConstraintData';\r\nimport type { Bone } from './Bone';\r\nimport type { Skeleton } from './Skeleton';\r\nimport { IIkConstraint, MathUtils, TransformMode } from '@pixi-spine/base';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class IkConstraint implements IIkConstraint, Updatable {\r\n    data: IkConstraintData;\r\n    bones: Array<Bone>;\r\n    target: Bone;\r\n    bendDirection = 0;\r\n    compress = false;\r\n    stretch = false;\r\n    mix = 1;\r\n    softness = 0;\r\n    active = false;\r\n\r\n    constructor(data: IkConstraintData, skeleton: Skeleton) {\r\n        if (data == null) throw new Error('data cannot be null.');\r\n        if (skeleton == null) throw new Error('skeleton cannot be null.');\r\n        this.data = data;\r\n        this.mix = data.mix;\r\n        this.softness = data.softness;\r\n        this.bendDirection = data.bendDirection;\r\n        this.compress = data.compress;\r\n        this.stretch = data.stretch;\r\n\r\n        this.bones = new Array<Bone>();\r\n        for (let i = 0; i < data.bones.length; i++) this.bones.push(skeleton.findBone(data.bones[i].name));\r\n        this.target = skeleton.findBone(data.target.name);\r\n    }\r\n\r\n    isActive() {\r\n        return this.active;\r\n    }\r\n\r\n    apply() {\r\n        this.update();\r\n    }\r\n\r\n    update() {\r\n        const target = this.target;\r\n        const bones = this.bones;\r\n\r\n        switch (bones.length) {\r\n            case 1:\r\n                this.apply1(bones[0], target.worldX, target.worldY, this.compress, this.stretch, this.data.uniform, this.mix);\r\n                break;\r\n            case 2:\r\n                this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.stretch, this.softness, this.mix);\r\n                break;\r\n        }\r\n    }\r\n\r\n    /** Adjusts the bone rotation so the tip is as close to the target position as possible. The target is specified in the world\r\n     * coordinate system. */\r\n    apply1(bone: Bone, targetX: number, targetY: number, compress: boolean, stretch: boolean, uniform: boolean, alpha: number) {\r\n        if (!bone.appliedValid) bone.updateAppliedTransform();\r\n        const p = bone.parent.matrix;\r\n\r\n        const pa = p.a;\r\n        let pb = p.c;\r\n        const pc = p.b;\r\n        let pd = p.d;\r\n        let rotationIK = -bone.ashearX - bone.arotation;\r\n        let tx = 0;\r\n        let ty = 0;\r\n\r\n        switch (bone.data.transformMode) {\r\n            case TransformMode.OnlyTranslation:\r\n                tx = targetX - bone.worldX;\r\n                ty = targetY - bone.worldY;\r\n                break;\r\n            case TransformMode.NoRotationOrReflection:\r\n                const s = Math.abs(pa * pd - pb * pc) / (pa * pa + pc * pc);\r\n                const sa = pa / bone.skeleton.scaleX;\r\n                const sc = pc / bone.skeleton.scaleY;\r\n\r\n                pb = -sc * s * bone.skeleton.scaleX;\r\n                pd = sa * s * bone.skeleton.scaleY;\r\n                rotationIK += Math.atan2(sc, sa) * MathUtils.radDeg;\r\n            // Fall through\r\n            default:\r\n                const x = targetX - p.tx;\r\n                const y = targetY - p.ty;\r\n                const d = pa * pd - pb * pc;\r\n\r\n                tx = (x * pd - y * pb) / d - bone.ax;\r\n                ty = (y * pa - x * pc) / d - bone.ay;\r\n        }\r\n        rotationIK += Math.atan2(ty, tx) * MathUtils.radDeg;\r\n\r\n        if (bone.ascaleX < 0) rotationIK += 180;\r\n        if (rotationIK > 180) rotationIK -= 360;\r\n        else if (rotationIK < -180) rotationIK += 360;\r\n        let sx = bone.ascaleX;\r\n        let sy = bone.ascaleY;\r\n\r\n        if (compress || stretch) {\r\n            switch (bone.data.transformMode) {\r\n                case TransformMode.NoScale:\r\n                case TransformMode.NoScaleOrReflection:\r\n                    tx = targetX - bone.worldX;\r\n                    ty = targetY - bone.worldY;\r\n            }\r\n            const b = bone.data.length * sx;\r\n            const dd = Math.sqrt(tx * tx + ty * ty);\r\n\r\n            if ((compress && dd < b) || (stretch && dd > b && b > 0.0001)) {\r\n                const s = (dd / b - 1) * alpha + 1;\r\n\r\n                sx *= s;\r\n                if (uniform) sy *= s;\r\n            }\r\n        }\r\n        bone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, sx, sy, bone.ashearX, bone.ashearY);\r\n    }\r\n\r\n    /** Adjusts the parent and child bone rotations so the tip of the child is as close to the target position as possible. The\r\n     * target is specified in the world coordinate system.\r\n     * @param child A direct descendant of the parent bone. */\r\n    apply2(parent: Bone, child: Bone, targetX: number, targetY: number, bendDir: number, stretch: boolean, softness: number, alpha: number) {\r\n        if (alpha == 0) {\r\n            child.updateWorldTransform();\r\n\r\n            return;\r\n        }\r\n        if (!parent.appliedValid) parent.updateAppliedTransform();\r\n        if (!child.appliedValid) child.updateAppliedTransform();\r\n        const px = parent.ax;\r\n        const py = parent.ay;\r\n        let psx = parent.ascaleX;\r\n        let sx = psx;\r\n        let psy = parent.ascaleY;\r\n        let csx = child.ascaleX;\r\n        const pmat = parent.matrix;\r\n        let os1 = 0;\r\n        let os2 = 0;\r\n        let s2 = 0;\r\n\r\n        if (psx < 0) {\r\n            psx = -psx;\r\n            os1 = 180;\r\n            s2 = -1;\r\n        } else {\r\n            os1 = 0;\r\n            s2 = 1;\r\n        }\r\n        if (psy < 0) {\r\n            psy = -psy;\r\n            s2 = -s2;\r\n        }\r\n        if (csx < 0) {\r\n            csx = -csx;\r\n            os2 = 180;\r\n        } else os2 = 0;\r\n        const cx = child.ax;\r\n        let cy = 0;\r\n        let cwx = 0;\r\n        let cwy = 0;\r\n        let a = pmat.a;\r\n        let b = pmat.c;\r\n        let c = pmat.b;\r\n        let d = pmat.d;\r\n        const u = Math.abs(psx - psy) <= 0.0001;\r\n\r\n        if (!u) {\r\n            cy = 0;\r\n            cwx = a * cx + pmat.tx;\r\n            cwy = c * cx + pmat.ty;\r\n        } else {\r\n            cy = child.ay;\r\n            cwx = a * cx + b * cy + pmat.tx;\r\n            cwy = c * cx + d * cy + pmat.ty;\r\n        }\r\n        const pp = parent.parent.matrix;\r\n\r\n        a = pp.a;\r\n        b = pp.c;\r\n        c = pp.b;\r\n        d = pp.d;\r\n        const id = 1 / (a * d - b * c);\r\n        let x = cwx - pp.tx;\r\n        let y = cwy - pp.ty;\r\n        const dx = (x * d - y * b) * id - px;\r\n        const dy = (y * a - x * c) * id - py;\r\n        const l1 = Math.sqrt(dx * dx + dy * dy);\r\n        let l2 = child.data.length * csx;\r\n        let a1;\r\n        let a2;\r\n\r\n        if (l1 < 0.0001) {\r\n            this.apply1(parent, targetX, targetY, false, stretch, false, alpha);\r\n            child.updateWorldTransformWith(cx, cy, 0, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\r\n\r\n            return;\r\n        }\r\n        x = targetX - pp.tx;\r\n        y = targetY - pp.ty;\r\n        let tx = (x * d - y * b) * id - px;\r\n        let ty = (y * a - x * c) * id - py;\r\n        let dd = tx * tx + ty * ty;\r\n\r\n        if (softness != 0) {\r\n            softness *= (psx * (csx + 1)) / 2;\r\n            const td = Math.sqrt(dd);\r\n            const sd = td - l1 - l2 * psx + softness;\r\n\r\n            if (sd > 0) {\r\n                let p = Math.min(1, sd / (softness * 2)) - 1;\r\n\r\n                p = (sd - softness * (1 - p * p)) / td;\r\n                tx -= p * tx;\r\n                ty -= p * ty;\r\n                dd = tx * tx + ty * ty;\r\n            }\r\n        }\r\n        // eslint-disable-next-line no-restricted-syntax, no-labels\r\n        outer: if (u) {\r\n            l2 *= psx;\r\n            let cos = (dd - l1 * l1 - l2 * l2) / (2 * l1 * l2);\r\n\r\n            if (cos < -1) cos = -1;\r\n            else if (cos > 1) {\r\n                cos = 1;\r\n                if (stretch) sx *= (Math.sqrt(dd) / (l1 + l2) - 1) * alpha + 1;\r\n            }\r\n            a2 = Math.acos(cos) * bendDir;\r\n            a = l1 + l2 * cos;\r\n            b = l2 * Math.sin(a2);\r\n            a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);\r\n        } else {\r\n            a = psx * l2;\r\n            b = psy * l2;\r\n            const aa = a * a;\r\n            const bb = b * b;\r\n            const ta = Math.atan2(ty, tx);\r\n\r\n            c = bb * l1 * l1 + aa * dd - aa * bb;\r\n            const c1 = -2 * bb * l1;\r\n            const c2 = bb - aa;\r\n\r\n            d = c1 * c1 - 4 * c2 * c;\r\n            if (d >= 0) {\r\n                let q = Math.sqrt(d);\r\n\r\n                if (c1 < 0) q = -q;\r\n                q = -(c1 + q) / 2;\r\n                const r0 = q / c2;\r\n                const r1 = c / q;\r\n                const r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;\r\n\r\n                if (r * r <= dd) {\r\n                    y = Math.sqrt(dd - r * r) * bendDir;\r\n                    a1 = ta - Math.atan2(y, r);\r\n                    a2 = Math.atan2(y / psy, (r - l1) / psx);\r\n                    // eslint-disable-next-line no-labels\r\n                    break outer;\r\n                }\r\n            }\r\n            let minAngle = MathUtils.PI;\r\n            let minX = l1 - a;\r\n            let minDist = minX * minX;\r\n            let minY = 0;\r\n            let maxAngle = 0;\r\n            let maxX = l1 + a;\r\n            let maxDist = maxX * maxX;\r\n            let maxY = 0;\r\n\r\n            c = (-a * l1) / (aa - bb);\r\n            if (c >= -1 && c <= 1) {\r\n                c = Math.acos(c);\r\n                x = a * Math.cos(c) + l1;\r\n                y = b * Math.sin(c);\r\n                d = x * x + y * y;\r\n                if (d < minDist) {\r\n                    minAngle = c;\r\n                    minDist = d;\r\n                    minX = x;\r\n                    minY = y;\r\n                }\r\n                if (d > maxDist) {\r\n                    maxAngle = c;\r\n                    maxDist = d;\r\n                    maxX = x;\r\n                    maxY = y;\r\n                }\r\n            }\r\n            if (dd <= (minDist + maxDist) / 2) {\r\n                a1 = ta - Math.atan2(minY * bendDir, minX);\r\n                a2 = minAngle * bendDir;\r\n            } else {\r\n                a1 = ta - Math.atan2(maxY * bendDir, maxX);\r\n                a2 = maxAngle * bendDir;\r\n            }\r\n        }\r\n        const os = Math.atan2(cy, cx) * s2;\r\n        let rotation = parent.arotation;\r\n\r\n        a1 = (a1 - os) * MathUtils.radDeg + os1 - rotation;\r\n        if (a1 > 180) a1 -= 360;\r\n        else if (a1 < -180) a1 += 360;\r\n        parent.updateWorldTransformWith(px, py, rotation + a1 * alpha, sx, parent.ascaleY, 0, 0);\r\n        rotation = child.arotation;\r\n        a2 = ((a2 + os) * MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;\r\n        if (a2 > 180) a2 -= 360;\r\n        else if (a2 < -180) a2 += 360;\r\n        child.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\r\n    }\r\n}\r\n","import { ConstraintData } from './Constraint';\r\nimport type { BoneData } from './BoneData';\r\nimport type { IIkConstraintData } from '@pixi-spine/base';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class IkConstraintData extends ConstraintData implements IIkConstraintData {\r\n    bones = new Array<BoneData>();\r\n    target: BoneData;\r\n    bendDirection = 1;\r\n    compress = false;\r\n    stretch = false;\r\n    uniform = false;\r\n    mix = 1;\r\n    softness = 0;\r\n\r\n    constructor(name: string) {\r\n        super(name, 0, false);\r\n    }\r\n}\r\n","import { ConstraintData } from './Constraint';\r\nimport type { SlotData } from './SlotData';\r\nimport type { BoneData } from './BoneData';\r\nimport type { RotateMode, PositionMode } from '@pixi-spine/base';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class PathConstraintData extends ConstraintData {\r\n    bones = new Array<BoneData>();\r\n    target: SlotData;\r\n    positionMode: PositionMode;\r\n    spacingMode: SpacingMode;\r\n    rotateMode: RotateMode;\r\n    offsetRotation: number;\r\n    position: number;\r\n    spacing: number;\r\n    rotateMix: number;\r\n    translateMix: number;\r\n\r\n    constructor(name: string) {\r\n        super(name, 0, false);\r\n    }\r\n}\r\n/**\r\n * @public\r\n */\r\nexport enum SpacingMode {\r\n    Length,\r\n    Fixed,\r\n    Percent,\r\n}\r\n","import { PathAttachment } from './attachments';\r\nimport type { Updatable } from './Updatable';\r\nimport { PathConstraintData, SpacingMode } from './PathConstraintData';\r\nimport type { Bone } from './Bone';\r\nimport type { Slot } from './Slot';\r\nimport type { Skeleton } from './Skeleton';\r\nimport { MathUtils, PositionMode, RotateMode, Utils } from '@pixi-spine/base';\r\n/**\r\n * @public\r\n */\r\nexport class PathConstraint implements Updatable {\r\n    static NONE = -1;\r\n    static BEFORE = -2;\r\n    static AFTER = -3;\r\n    static epsilon = 0.00001;\r\n\r\n    data: PathConstraintData;\r\n    bones: Array<Bone>;\r\n    target: Slot;\r\n    position = 0;\r\n    spacing = 0;\r\n    rotateMix = 0;\r\n    translateMix = 0;\r\n\r\n    spaces = new Array<number>();\r\n    positions = new Array<number>();\r\n    world = new Array<number>();\r\n    curves = new Array<number>();\r\n    lengths = new Array<number>();\r\n    segments = new Array<number>();\r\n\r\n    active = false;\r\n\r\n    constructor(data: PathConstraintData, skeleton: Skeleton) {\r\n        if (data == null) throw new Error('data cannot be null.');\r\n        if (skeleton == null) throw new Error('skeleton cannot be null.');\r\n        this.data = data;\r\n        this.bones = new Array<Bone>();\r\n        for (let i = 0, n = data.bones.length; i < n; i++) this.bones.push(skeleton.findBone(data.bones[i].name));\r\n        this.target = skeleton.findSlot(data.target.name);\r\n        this.position = data.position;\r\n        this.spacing = data.spacing;\r\n        this.rotateMix = data.rotateMix;\r\n        this.translateMix = data.translateMix;\r\n    }\r\n\r\n    isActive() {\r\n        return this.active;\r\n    }\r\n\r\n    apply() {\r\n        this.update();\r\n    }\r\n\r\n    update() {\r\n        const attachment = this.target.getAttachment();\r\n\r\n        if (!(attachment instanceof PathAttachment)) return;\r\n\r\n        const rotateMix = this.rotateMix;\r\n        const translateMix = this.translateMix;\r\n        const translate = translateMix > 0;\r\n        const rotate = rotateMix > 0;\r\n\r\n        if (!translate && !rotate) return;\r\n\r\n        const data = this.data;\r\n        const spacingMode = data.spacingMode;\r\n        const lengthSpacing = spacingMode == SpacingMode.Length;\r\n        const rotateMode = data.rotateMode;\r\n        const tangents = rotateMode == RotateMode.Tangent;\r\n        const scale = rotateMode == RotateMode.ChainScale;\r\n        const boneCount = this.bones.length;\r\n        const spacesCount = tangents ? boneCount : boneCount + 1;\r\n        const bones = this.bones;\r\n        const spaces = Utils.setArraySize(this.spaces, spacesCount);\r\n        let lengths: Array<number> = null;\r\n        const spacing = this.spacing;\r\n\r\n        if (scale || lengthSpacing) {\r\n            if (scale) lengths = Utils.setArraySize(this.lengths, boneCount);\r\n            for (let i = 0, n = spacesCount - 1; i < n; ) {\r\n                const bone = bones[i];\r\n                const setupLength = bone.data.length;\r\n\r\n                if (setupLength < PathConstraint.epsilon) {\r\n                    if (scale) lengths[i] = 0;\r\n                    spaces[++i] = 0;\r\n                } else {\r\n                    const x = setupLength * bone.matrix.a;\r\n                    const y = setupLength * bone.matrix.b;\r\n                    const length = Math.sqrt(x * x + y * y);\r\n\r\n                    if (scale) lengths[i] = length;\r\n                    spaces[++i] = ((lengthSpacing ? setupLength + spacing : spacing) * length) / setupLength;\r\n                }\r\n            }\r\n        } else {\r\n            for (let i = 1; i < spacesCount; i++) spaces[i] = spacing;\r\n        }\r\n\r\n        const positions = this.computeWorldPositions(\r\n            <PathAttachment>attachment,\r\n            spacesCount,\r\n            tangents,\r\n            data.positionMode == PositionMode.Percent,\r\n            spacingMode == SpacingMode.Percent\r\n        );\r\n        let boneX = positions[0];\r\n        let boneY = positions[1];\r\n        let offsetRotation = data.offsetRotation;\r\n        let tip = false;\r\n\r\n        if (offsetRotation == 0) tip = rotateMode == RotateMode.Chain;\r\n        else {\r\n            tip = false;\r\n            const p = this.target.bone.matrix;\r\n\r\n            offsetRotation *= p.a * p.d - p.b * p.c > 0 ? MathUtils.degRad : -MathUtils.degRad;\r\n        }\r\n        for (let i = 0, p = 3; i < boneCount; i++, p += 3) {\r\n            const bone = bones[i];\r\n            const mat = bone.matrix;\r\n\r\n            mat.tx += (boneX - mat.tx) * translateMix;\r\n            mat.ty += (boneY - mat.ty) * translateMix;\r\n            const x = positions[p];\r\n            const y = positions[p + 1];\r\n            const dx = x - boneX;\r\n            const dy = y - boneY;\r\n\r\n            if (scale) {\r\n                const length = lengths[i];\r\n\r\n                if (length != 0) {\r\n                    const s = (Math.sqrt(dx * dx + dy * dy) / length - 1) * rotateMix + 1;\r\n\r\n                    mat.a *= s;\r\n                    mat.b *= s;\r\n                }\r\n            }\r\n            boneX = x;\r\n            boneY = y;\r\n            if (rotate) {\r\n                const a = mat.a;\r\n                const b = mat.c;\r\n                const c = mat.b;\r\n                const d = mat.d;\r\n                let r = 0;\r\n                let cos = 0;\r\n                let sin = 0;\r\n\r\n                if (tangents)\r\n                    if (tangents) r = positions[p - 1];\r\n                    else if (spaces[i + 1] == 0) r = positions[p + 2];\r\n                    else r = Math.atan2(dy, dx);\r\n                r -= Math.atan2(c, a);\r\n                if (tip) {\r\n                    cos = Math.cos(r);\r\n                    sin = Math.sin(r);\r\n                    const length = bone.data.length;\r\n\r\n                    boneX += (length * (cos * a - sin * c) - dx) * rotateMix;\r\n                    boneY += (length * (sin * a + cos * c) - dy) * rotateMix;\r\n                } else {\r\n                    r += offsetRotation;\r\n                }\r\n                if (r > MathUtils.PI) r -= MathUtils.PI2;\r\n                else if (r < -MathUtils.PI)\r\n                    //\r\n                    r += MathUtils.PI2;\r\n                r *= rotateMix;\r\n                cos = Math.cos(r);\r\n                sin = Math.sin(r);\r\n                mat.a = cos * a - sin * c;\r\n                mat.c = cos * b - sin * d;\r\n                mat.b = sin * a + cos * c;\r\n                mat.d = sin * b + cos * d;\r\n            }\r\n            bone.appliedValid = false;\r\n        }\r\n    }\r\n\r\n    computeWorldPositions(path: PathAttachment, spacesCount: number, tangents: boolean, percentPosition: boolean, percentSpacing: boolean) {\r\n        const target = this.target;\r\n        let position = this.position;\r\n        const spaces = this.spaces;\r\n        const out = Utils.setArraySize(this.positions, spacesCount * 3 + 2);\r\n        let world: Array<number> = null;\r\n        const closed = path.closed;\r\n        let verticesLength = path.worldVerticesLength;\r\n        let curveCount = verticesLength / 6;\r\n        let prevCurve = PathConstraint.NONE;\r\n\r\n        if (!path.constantSpeed) {\r\n            const lengths = path.lengths;\r\n\r\n            curveCount -= closed ? 1 : 2;\r\n            const pathLength = lengths[curveCount];\r\n\r\n            if (percentPosition) position *= pathLength;\r\n            if (percentSpacing) {\r\n                for (let i = 0; i < spacesCount; i++) spaces[i] *= pathLength;\r\n            }\r\n            world = Utils.setArraySize(this.world, 8);\r\n            for (let i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {\r\n                const space = spaces[i];\r\n\r\n                position += space;\r\n                let p = position;\r\n\r\n                if (closed) {\r\n                    p %= pathLength;\r\n                    if (p < 0) p += pathLength;\r\n                    curve = 0;\r\n                } else if (p < 0) {\r\n                    if (prevCurve != PathConstraint.BEFORE) {\r\n                        prevCurve = PathConstraint.BEFORE;\r\n                        path.computeWorldVertices(target, 2, 4, world, 0, 2);\r\n                    }\r\n                    this.addBeforePosition(p, world, 0, out, o);\r\n                    continue;\r\n                } else if (p > pathLength) {\r\n                    if (prevCurve != PathConstraint.AFTER) {\r\n                        prevCurve = PathConstraint.AFTER;\r\n                        path.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2);\r\n                    }\r\n                    this.addAfterPosition(p - pathLength, world, 0, out, o);\r\n                    continue;\r\n                }\r\n\r\n                // Determine curve containing position.\r\n                for (; ; curve++) {\r\n                    const length = lengths[curve];\r\n\r\n                    if (p > length) continue;\r\n                    if (curve == 0) p /= length;\r\n                    else {\r\n                        const prev = lengths[curve - 1];\r\n\r\n                        p = (p - prev) / (length - prev);\r\n                    }\r\n                    break;\r\n                }\r\n                if (curve != prevCurve) {\r\n                    prevCurve = curve;\r\n                    if (closed && curve == curveCount) {\r\n                        path.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);\r\n                        path.computeWorldVertices(target, 0, 4, world, 4, 2);\r\n                    } else path.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2);\r\n                }\r\n                this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o, tangents || (i > 0 && space == 0));\r\n            }\r\n\r\n            return out;\r\n        }\r\n\r\n        // World vertices.\r\n        if (closed) {\r\n            verticesLength += 2;\r\n            world = Utils.setArraySize(this.world, verticesLength);\r\n            path.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);\r\n            path.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);\r\n            world[verticesLength - 2] = world[0];\r\n            world[verticesLength - 1] = world[1];\r\n        } else {\r\n            curveCount--;\r\n            verticesLength -= 4;\r\n            world = Utils.setArraySize(this.world, verticesLength);\r\n            path.computeWorldVertices(target, 2, verticesLength, world, 0, 2);\r\n        }\r\n\r\n        // Curve lengths.\r\n        const curves = Utils.setArraySize(this.curves, curveCount);\r\n        let pathLength = 0;\r\n        let x1 = world[0];\r\n        let y1 = world[1];\r\n        let cx1 = 0;\r\n        let cy1 = 0;\r\n        let cx2 = 0;\r\n        let cy2 = 0;\r\n        let x2 = 0;\r\n        let y2 = 0;\r\n        let tmpx = 0;\r\n        let tmpy = 0;\r\n        let dddfx = 0;\r\n        let dddfy = 0;\r\n        let ddfx = 0;\r\n        let ddfy = 0;\r\n        let dfx = 0;\r\n        let dfy = 0;\r\n\r\n        for (let i = 0, w = 2; i < curveCount; i++, w += 6) {\r\n            cx1 = world[w];\r\n            cy1 = world[w + 1];\r\n            cx2 = world[w + 2];\r\n            cy2 = world[w + 3];\r\n            x2 = world[w + 4];\r\n            y2 = world[w + 5];\r\n            tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;\r\n            tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;\r\n            dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;\r\n            dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;\r\n            ddfx = tmpx * 2 + dddfx;\r\n            ddfy = tmpy * 2 + dddfy;\r\n            dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;\r\n            dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;\r\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n            dfx += ddfx;\r\n            dfy += ddfy;\r\n            ddfx += dddfx;\r\n            ddfy += dddfy;\r\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n            dfx += ddfx;\r\n            dfy += ddfy;\r\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n            dfx += ddfx + dddfx;\r\n            dfy += ddfy + dddfy;\r\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n            curves[i] = pathLength;\r\n            x1 = x2;\r\n            y1 = y2;\r\n        }\r\n        if (percentPosition) position *= pathLength;\r\n        if (percentSpacing) {\r\n            for (let i = 0; i < spacesCount; i++) spaces[i] *= pathLength;\r\n        }\r\n\r\n        const segments = this.segments;\r\n        let curveLength = 0;\r\n\r\n        for (let i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {\r\n            const space = spaces[i];\r\n\r\n            position += space;\r\n            let p = position;\r\n\r\n            if (closed) {\r\n                p %= pathLength;\r\n                if (p < 0) p += pathLength;\r\n                curve = 0;\r\n            } else if (p < 0) {\r\n                this.addBeforePosition(p, world, 0, out, o);\r\n                continue;\r\n            } else if (p > pathLength) {\r\n                this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);\r\n                continue;\r\n            }\r\n\r\n            // Determine curve containing position.\r\n            for (; ; curve++) {\r\n                const length = curves[curve];\r\n\r\n                if (p > length) continue;\r\n                if (curve == 0) p /= length;\r\n                else {\r\n                    const prev = curves[curve - 1];\r\n\r\n                    p = (p - prev) / (length - prev);\r\n                }\r\n                break;\r\n            }\r\n\r\n            // Curve segment lengths.\r\n            if (curve != prevCurve) {\r\n                prevCurve = curve;\r\n                let ii = curve * 6;\r\n\r\n                x1 = world[ii];\r\n                y1 = world[ii + 1];\r\n                cx1 = world[ii + 2];\r\n                cy1 = world[ii + 3];\r\n                cx2 = world[ii + 4];\r\n                cy2 = world[ii + 5];\r\n                x2 = world[ii + 6];\r\n                y2 = world[ii + 7];\r\n                tmpx = (x1 - cx1 * 2 + cx2) * 0.03;\r\n                tmpy = (y1 - cy1 * 2 + cy2) * 0.03;\r\n                dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.006;\r\n                dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.006;\r\n                ddfx = tmpx * 2 + dddfx;\r\n                ddfy = tmpy * 2 + dddfy;\r\n                dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;\r\n                dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;\r\n                curveLength = Math.sqrt(dfx * dfx + dfy * dfy);\r\n                segments[0] = curveLength;\r\n                for (ii = 1; ii < 8; ii++) {\r\n                    dfx += ddfx;\r\n                    dfy += ddfy;\r\n                    ddfx += dddfx;\r\n                    ddfy += dddfy;\r\n                    curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n                    segments[ii] = curveLength;\r\n                }\r\n                dfx += ddfx;\r\n                dfy += ddfy;\r\n                curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n                segments[8] = curveLength;\r\n                dfx += ddfx + dddfx;\r\n                dfy += ddfy + dddfy;\r\n                curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n                segments[9] = curveLength;\r\n                segment = 0;\r\n            }\r\n\r\n            // Weight by segment length.\r\n            p *= curveLength;\r\n            for (; ; segment++) {\r\n                const length = segments[segment];\r\n\r\n                if (p > length) continue;\r\n                if (segment == 0) p /= length;\r\n                else {\r\n                    const prev = segments[segment - 1];\r\n\r\n                    p = segment + (p - prev) / (length - prev);\r\n                }\r\n                break;\r\n            }\r\n            this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || (i > 0 && space == 0));\r\n        }\r\n\r\n        return out;\r\n    }\r\n\r\n    addBeforePosition(p: number, temp: Array<number>, i: number, out: Array<number>, o: number) {\r\n        const x1 = temp[i];\r\n        const y1 = temp[i + 1];\r\n        const dx = temp[i + 2] - x1;\r\n        const dy = temp[i + 3] - y1;\r\n        const r = Math.atan2(dy, dx);\r\n\r\n        out[o] = x1 + p * Math.cos(r);\r\n        out[o + 1] = y1 + p * Math.sin(r);\r\n        out[o + 2] = r;\r\n    }\r\n\r\n    addAfterPosition(p: number, temp: Array<number>, i: number, out: Array<number>, o: number) {\r\n        const x1 = temp[i + 2];\r\n        const y1 = temp[i + 3];\r\n        const dx = x1 - temp[i];\r\n        const dy = y1 - temp[i + 1];\r\n        const r = Math.atan2(dy, dx);\r\n\r\n        out[o] = x1 + p * Math.cos(r);\r\n        out[o + 1] = y1 + p * Math.sin(r);\r\n        out[o + 2] = r;\r\n    }\r\n\r\n    addCurvePosition(\r\n        p: number,\r\n        x1: number,\r\n        y1: number,\r\n        cx1: number,\r\n        cy1: number,\r\n        cx2: number,\r\n        cy2: number,\r\n        x2: number,\r\n        y2: number,\r\n        out: Array<number>,\r\n        o: number,\r\n        tangents: boolean\r\n    ) {\r\n        if (p == 0 || isNaN(p)) p = 0.0001;\r\n        const tt = p * p;\r\n        const ttt = tt * p;\r\n        const u = 1 - p;\r\n        const uu = u * u;\r\n        const uuu = uu * u;\r\n        const ut = u * p;\r\n        const ut3 = ut * 3;\r\n        const uut3 = u * ut3;\r\n        const utt3 = ut3 * p;\r\n        const x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt;\r\n        const y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;\r\n\r\n        out[o] = x;\r\n        out[o + 1] = y;\r\n        if (tangents) out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));\r\n    }\r\n}\r\n","import type { Updatable } from './Updatable';\r\nimport type { TransformConstraintData } from './TransformConstraintData';\r\nimport type { Bone } from './Bone';\r\nimport { MathUtils, Vector2 } from '@pixi-spine/base';\r\nimport type { Skeleton } from './Skeleton';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class TransformConstraint implements Updatable {\r\n    data: TransformConstraintData;\r\n    bones: Array<Bone>;\r\n    target: Bone;\r\n    rotateMix = 0;\r\n    translateMix = 0;\r\n    scaleMix = 0;\r\n    shearMix = 0;\r\n    temp = new Vector2();\r\n    active = false;\r\n\r\n    constructor(data: TransformConstraintData, skeleton: Skeleton) {\r\n        if (data == null) throw new Error('data cannot be null.');\r\n        if (skeleton == null) throw new Error('skeleton cannot be null.');\r\n        this.data = data;\r\n        this.rotateMix = data.rotateMix;\r\n        this.translateMix = data.translateMix;\r\n        this.scaleMix = data.scaleMix;\r\n        this.shearMix = data.shearMix;\r\n        this.bones = new Array<Bone>();\r\n        for (let i = 0; i < data.bones.length; i++) this.bones.push(skeleton.findBone(data.bones[i].name));\r\n        this.target = skeleton.findBone(data.target.name);\r\n    }\r\n\r\n    isActive() {\r\n        return this.active;\r\n    }\r\n\r\n    apply() {\r\n        this.update();\r\n    }\r\n\r\n    update() {\r\n        if (this.data.local) {\r\n            if (this.data.relative) this.applyRelativeLocal();\r\n            else this.applyAbsoluteLocal();\r\n        } else if (this.data.relative) this.applyRelativeWorld();\r\n        else this.applyAbsoluteWorld();\r\n    }\r\n\r\n    applyAbsoluteWorld() {\r\n        const rotateMix = this.rotateMix;\r\n        const translateMix = this.translateMix;\r\n        const scaleMix = this.scaleMix;\r\n        const shearMix = this.shearMix;\r\n        const target = this.target;\r\n        const targetMat = target.matrix;\r\n        const ta = targetMat.a;\r\n        const tb = targetMat.c;\r\n        const tc = targetMat.b;\r\n        const td = targetMat.d;\r\n        const degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;\r\n        const offsetRotation = this.data.offsetRotation * degRadReflect;\r\n        const offsetShearY = this.data.offsetShearY * degRadReflect;\r\n        const bones = this.bones;\r\n\r\n        for (let i = 0, n = bones.length; i < n; i++) {\r\n            const bone = bones[i];\r\n            let modified = false;\r\n            const mat = bone.matrix;\r\n\r\n            if (rotateMix != 0) {\r\n                const a = mat.a;\r\n                const b = mat.c;\r\n                const c = mat.b;\r\n                const d = mat.d;\r\n                let r = Math.atan2(tc, ta) - Math.atan2(c, a) + offsetRotation;\r\n\r\n                if (r > MathUtils.PI) r -= MathUtils.PI2;\r\n                else if (r < -MathUtils.PI) r += MathUtils.PI2;\r\n                r *= rotateMix;\r\n                const cos = Math.cos(r);\r\n                const sin = Math.sin(r);\r\n\r\n                mat.a = cos * a - sin * c;\r\n                mat.c = cos * b - sin * d;\r\n                mat.b = sin * a + cos * c;\r\n                mat.d = sin * b + cos * d;\r\n                modified = true;\r\n            }\r\n\r\n            if (translateMix != 0) {\r\n                const temp = this.temp;\r\n\r\n                target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\r\n                mat.tx += (temp.x - mat.tx) * translateMix;\r\n                mat.ty += (temp.y - mat.ty) * translateMix;\r\n                modified = true;\r\n            }\r\n\r\n            if (scaleMix > 0) {\r\n                let s = Math.sqrt(mat.a * mat.a + mat.b * mat.b);\r\n                let ts = Math.sqrt(ta * ta + tc * tc);\r\n\r\n                if (s > 0.00001) s = (s + (ts - s + this.data.offsetScaleX) * scaleMix) / s;\r\n                mat.a *= s;\r\n                mat.b *= s;\r\n                s = Math.sqrt(mat.c * mat.c + mat.d * mat.d);\r\n                ts = Math.sqrt(tb * tb + td * td);\r\n                if (s > 0.00001) s = (s + (ts - s + this.data.offsetScaleY) * scaleMix) / s;\r\n                mat.c *= s;\r\n                mat.d *= s;\r\n                modified = true;\r\n            }\r\n\r\n            if (shearMix > 0) {\r\n                const b = mat.c;\r\n                const d = mat.d;\r\n                const by = Math.atan2(d, b);\r\n                let r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(mat.b, mat.a));\r\n\r\n                if (r > MathUtils.PI) r -= MathUtils.PI2;\r\n                else if (r < -MathUtils.PI) r += MathUtils.PI2;\r\n                r = by + (r + offsetShearY) * shearMix;\r\n                const s = Math.sqrt(b * b + d * d);\r\n\r\n                mat.c = Math.cos(r) * s;\r\n                mat.d = Math.sin(r) * s;\r\n                modified = true;\r\n            }\r\n\r\n            if (modified) bone.appliedValid = false;\r\n        }\r\n    }\r\n\r\n    applyRelativeWorld() {\r\n        const rotateMix = this.rotateMix;\r\n        const translateMix = this.translateMix;\r\n        const scaleMix = this.scaleMix;\r\n        const shearMix = this.shearMix;\r\n        const target = this.target;\r\n        const targetMat = target.matrix;\r\n        const ta = targetMat.a;\r\n        const tb = targetMat.c;\r\n        const tc = targetMat.b;\r\n        const td = targetMat.d;\r\n        const degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;\r\n        const offsetRotation = this.data.offsetRotation * degRadReflect;\r\n        const offsetShearY = this.data.offsetShearY * degRadReflect;\r\n        const bones = this.bones;\r\n\r\n        for (let i = 0, n = bones.length; i < n; i++) {\r\n            const bone = bones[i];\r\n            let modified = false;\r\n            const mat = bone.matrix;\r\n\r\n            if (rotateMix != 0) {\r\n                const a = mat.a;\r\n                const b = mat.c;\r\n                const c = mat.b;\r\n                const d = mat.d;\r\n                let r = Math.atan2(tc, ta) + offsetRotation;\r\n\r\n                if (r > MathUtils.PI) r -= MathUtils.PI2;\r\n                else if (r < -MathUtils.PI) r += MathUtils.PI2;\r\n                r *= rotateMix;\r\n                const cos = Math.cos(r);\r\n                const sin = Math.sin(r);\r\n\r\n                mat.a = cos * a - sin * c;\r\n                mat.c = cos * b - sin * d;\r\n                mat.b = sin * a + cos * c;\r\n                mat.d = sin * b + cos * d;\r\n                modified = true;\r\n            }\r\n\r\n            if (translateMix != 0) {\r\n                const temp = this.temp;\r\n\r\n                target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\r\n                mat.tx += temp.x * translateMix;\r\n                mat.ty += temp.y * translateMix;\r\n                modified = true;\r\n            }\r\n\r\n            if (scaleMix > 0) {\r\n                let s = (Math.sqrt(ta * ta + tc * tc) - 1 + this.data.offsetScaleX) * scaleMix + 1;\r\n\r\n                mat.a *= s;\r\n                mat.b *= s;\r\n                s = (Math.sqrt(tb * tb + td * td) - 1 + this.data.offsetScaleY) * scaleMix + 1;\r\n                mat.c *= s;\r\n                mat.d *= s;\r\n                modified = true;\r\n            }\r\n\r\n            if (shearMix > 0) {\r\n                let r = Math.atan2(td, tb) - Math.atan2(tc, ta);\r\n\r\n                if (r > MathUtils.PI) r -= MathUtils.PI2;\r\n                else if (r < -MathUtils.PI) r += MathUtils.PI2;\r\n                const b = mat.c;\r\n                const d = mat.d;\r\n\r\n                r = Math.atan2(d, b) + (r - MathUtils.PI / 2 + offsetShearY) * shearMix;\r\n                const s = Math.sqrt(b * b + d * d);\r\n\r\n                mat.c = Math.cos(r) * s;\r\n                mat.d = Math.sin(r) * s;\r\n                modified = true;\r\n            }\r\n\r\n            if (modified) bone.appliedValid = false;\r\n        }\r\n    }\r\n\r\n    applyAbsoluteLocal() {\r\n        const rotateMix = this.rotateMix;\r\n        const translateMix = this.translateMix;\r\n        const scaleMix = this.scaleMix;\r\n        const shearMix = this.shearMix;\r\n        const target = this.target;\r\n\r\n        if (!target.appliedValid) target.updateAppliedTransform();\r\n        const bones = this.bones;\r\n\r\n        for (let i = 0, n = bones.length; i < n; i++) {\r\n            const bone = bones[i];\r\n\r\n            if (!bone.appliedValid) bone.updateAppliedTransform();\r\n\r\n            let rotation = bone.arotation;\r\n\r\n            if (rotateMix != 0) {\r\n                let r = target.arotation - rotation + this.data.offsetRotation;\r\n\r\n                r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\r\n                rotation += r * rotateMix;\r\n            }\r\n\r\n            let x = bone.ax;\r\n            let y = bone.ay;\r\n\r\n            if (translateMix != 0) {\r\n                x += (target.ax - x + this.data.offsetX) * translateMix;\r\n                y += (target.ay - y + this.data.offsetY) * translateMix;\r\n            }\r\n\r\n            let scaleX = bone.ascaleX;\r\n            let scaleY = bone.ascaleY;\r\n\r\n            if (scaleMix > 0) {\r\n                if (scaleX > 0.00001) scaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * scaleMix) / scaleX;\r\n                if (scaleY > 0.00001) scaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * scaleMix) / scaleY;\r\n            }\r\n\r\n            const shearY = bone.ashearY;\r\n\r\n            if (shearMix > 0) {\r\n                let r = target.ashearY - shearY + this.data.offsetShearY;\r\n\r\n                r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\r\n                bone.shearY += r * shearMix;\r\n            }\r\n\r\n            bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\r\n        }\r\n    }\r\n\r\n    applyRelativeLocal() {\r\n        const rotateMix = this.rotateMix;\r\n        const translateMix = this.translateMix;\r\n        const scaleMix = this.scaleMix;\r\n        const shearMix = this.shearMix;\r\n        const target = this.target;\r\n\r\n        if (!target.appliedValid) target.updateAppliedTransform();\r\n        const bones = this.bones;\r\n\r\n        for (let i = 0, n = bones.length; i < n; i++) {\r\n            const bone = bones[i];\r\n\r\n            if (!bone.appliedValid) bone.updateAppliedTransform();\r\n\r\n            let rotation = bone.arotation;\r\n\r\n            if (rotateMix != 0) rotation += (target.arotation + this.data.offsetRotation) * rotateMix;\r\n\r\n            let x = bone.ax;\r\n            let y = bone.ay;\r\n\r\n            if (translateMix != 0) {\r\n                x += (target.ax + this.data.offsetX) * translateMix;\r\n                y += (target.ay + this.data.offsetY) * translateMix;\r\n            }\r\n\r\n            let scaleX = bone.ascaleX;\r\n            let scaleY = bone.ascaleY;\r\n\r\n            if (scaleMix > 0) {\r\n                if (scaleX > 0.00001) scaleX *= (target.ascaleX - 1 + this.data.offsetScaleX) * scaleMix + 1;\r\n                if (scaleY > 0.00001) scaleY *= (target.ascaleY - 1 + this.data.offsetScaleY) * scaleMix + 1;\r\n            }\r\n\r\n            let shearY = bone.ashearY;\r\n\r\n            if (shearMix > 0) shearY += (target.ashearY + this.data.offsetShearY) * shearMix;\r\n\r\n            bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\r\n        }\r\n    }\r\n}\r\n","import { Attachment, RegionAttachment, MeshAttachment, PathAttachment } from './attachments';\r\nimport { Bone } from './Bone';\r\nimport { Slot } from './Slot';\r\nimport type { Updatable } from './Updatable';\r\nimport type { SkeletonData } from './SkeletonData';\r\nimport { IkConstraint } from './IkConstraint';\r\nimport { TransformConstraint } from './TransformConstraint';\r\nimport { PathConstraint } from './PathConstraint';\r\nimport type { Skin } from './Skin';\r\nimport { Color, Utils, Vector2, ISkeleton } from '@pixi-spine/base';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class Skeleton implements ISkeleton<SkeletonData, Bone, Slot, Skin> {\r\n    data: SkeletonData;\r\n    bones: Array<Bone>;\r\n    slots: Array<Slot>;\r\n    drawOrder: Array<Slot>;\r\n    ikConstraints: Array<IkConstraint>;\r\n    transformConstraints: Array<TransformConstraint>;\r\n    pathConstraints: Array<PathConstraint>;\r\n    _updateCache = new Array<Updatable>();\r\n    updateCacheReset = new Array<Updatable>();\r\n    skin: Skin;\r\n    color: Color;\r\n    time = 0;\r\n    scaleX = 1;\r\n    scaleY = 1;\r\n    x = 0;\r\n    y = 0;\r\n\r\n    constructor(data: SkeletonData) {\r\n        if (data == null) throw new Error('data cannot be null.');\r\n        this.data = data;\r\n\r\n        this.bones = new Array<Bone>();\r\n        for (let i = 0; i < data.bones.length; i++) {\r\n            const boneData = data.bones[i];\r\n            let bone: Bone;\r\n\r\n            if (boneData.parent == null) bone = new Bone(boneData, this, null);\r\n            else {\r\n                const parent = this.bones[boneData.parent.index];\r\n\r\n                bone = new Bone(boneData, this, parent);\r\n                parent.children.push(bone);\r\n            }\r\n            this.bones.push(bone);\r\n        }\r\n\r\n        this.slots = new Array<Slot>();\r\n        this.drawOrder = new Array<Slot>();\r\n        for (let i = 0; i < data.slots.length; i++) {\r\n            const slotData = data.slots[i];\r\n            const bone = this.bones[slotData.boneData.index];\r\n            const slot = new Slot(slotData, bone);\r\n\r\n            this.slots.push(slot);\r\n            this.drawOrder.push(slot);\r\n        }\r\n\r\n        this.ikConstraints = new Array<IkConstraint>();\r\n        for (let i = 0; i < data.ikConstraints.length; i++) {\r\n            const ikConstraintData = data.ikConstraints[i];\r\n\r\n            this.ikConstraints.push(new IkConstraint(ikConstraintData, this));\r\n        }\r\n\r\n        this.transformConstraints = new Array<TransformConstraint>();\r\n        for (let i = 0; i < data.transformConstraints.length; i++) {\r\n            const transformConstraintData = data.transformConstraints[i];\r\n\r\n            this.transformConstraints.push(new TransformConstraint(transformConstraintData, this));\r\n        }\r\n\r\n        this.pathConstraints = new Array<PathConstraint>();\r\n        for (let i = 0; i < data.pathConstraints.length; i++) {\r\n            const pathConstraintData = data.pathConstraints[i];\r\n\r\n            this.pathConstraints.push(new PathConstraint(pathConstraintData, this));\r\n        }\r\n\r\n        this.color = new Color(1, 1, 1, 1);\r\n        this.updateCache();\r\n    }\r\n\r\n    updateCache() {\r\n        const updateCache = this._updateCache;\r\n\r\n        updateCache.length = 0;\r\n        this.updateCacheReset.length = 0;\r\n\r\n        const bones = this.bones;\r\n\r\n        for (let i = 0, n = bones.length; i < n; i++) {\r\n            const bone = bones[i];\r\n\r\n            bone.sorted = bone.data.skinRequired;\r\n            bone.active = !bone.sorted;\r\n        }\r\n\r\n        if (this.skin != null) {\r\n            const skinBones = this.skin.bones;\r\n\r\n            for (let i = 0, n = this.skin.bones.length; i < n; i++) {\r\n                let bone = this.bones[skinBones[i].index];\r\n\r\n                do {\r\n                    bone.sorted = false;\r\n                    bone.active = true;\r\n                    bone = bone.parent;\r\n                } while (bone != null);\r\n            }\r\n        }\r\n\r\n        // IK first, lowest hierarchy depth first.\r\n        const ikConstraints = this.ikConstraints;\r\n        const transformConstraints = this.transformConstraints;\r\n        const pathConstraints = this.pathConstraints;\r\n        const ikCount = ikConstraints.length;\r\n        const transformCount = transformConstraints.length;\r\n        const pathCount = pathConstraints.length;\r\n        const constraintCount = ikCount + transformCount + pathCount;\r\n\r\n        // eslint-disable-next-line no-restricted-syntax, no-labels\r\n        outer: for (let i = 0; i < constraintCount; i++) {\r\n            for (let ii = 0; ii < ikCount; ii++) {\r\n                const constraint = ikConstraints[ii];\r\n\r\n                if (constraint.data.order == i) {\r\n                    this.sortIkConstraint(constraint);\r\n                    // eslint-disable-next-line no-labels\r\n                    continue outer;\r\n                }\r\n            }\r\n            for (let ii = 0; ii < transformCount; ii++) {\r\n                const constraint = transformConstraints[ii];\r\n\r\n                if (constraint.data.order == i) {\r\n                    this.sortTransformConstraint(constraint);\r\n                    // eslint-disable-next-line no-labels\r\n                    continue outer;\r\n                }\r\n            }\r\n            for (let ii = 0; ii < pathCount; ii++) {\r\n                const constraint = pathConstraints[ii];\r\n\r\n                if (constraint.data.order == i) {\r\n                    this.sortPathConstraint(constraint);\r\n                    // eslint-disable-next-line no-labels\r\n                    continue outer;\r\n                }\r\n            }\r\n        }\r\n\r\n        for (let i = 0, n = bones.length; i < n; i++) this.sortBone(bones[i]);\r\n    }\r\n\r\n    sortIkConstraint(constraint: IkConstraint) {\r\n        constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || (this.skin != null && Utils.contains(this.skin.constraints, constraint.data, true)));\r\n        if (!constraint.active) return;\r\n\r\n        const target = constraint.target;\r\n\r\n        this.sortBone(target);\r\n\r\n        const constrained = constraint.bones;\r\n        const parent = constrained[0];\r\n\r\n        this.sortBone(parent);\r\n\r\n        if (constrained.length > 1) {\r\n            const child = constrained[constrained.length - 1];\r\n\r\n            if (!(this._updateCache.indexOf(child) > -1)) this.updateCacheReset.push(child);\r\n        }\r\n\r\n        this._updateCache.push(constraint);\r\n\r\n        this.sortReset(parent.children);\r\n        constrained[constrained.length - 1].sorted = true;\r\n    }\r\n\r\n    sortPathConstraint(constraint: PathConstraint) {\r\n        constraint.active =\r\n            constraint.target.bone.isActive() && (!constraint.data.skinRequired || (this.skin != null && Utils.contains(this.skin.constraints, constraint.data, true)));\r\n        if (!constraint.active) return;\r\n\r\n        const slot = constraint.target;\r\n        const slotIndex = slot.data.index;\r\n        const slotBone = slot.bone;\r\n\r\n        if (this.skin != null) this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);\r\n        if (this.data.defaultSkin != null && this.data.defaultSkin != this.skin) this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);\r\n        for (let i = 0, n = this.data.skins.length; i < n; i++) this.sortPathConstraintAttachment(this.data.skins[i], slotIndex, slotBone);\r\n\r\n        const attachment = slot.getAttachment();\r\n\r\n        if (attachment instanceof PathAttachment) this.sortPathConstraintAttachmentWith(attachment, slotBone);\r\n\r\n        const constrained = constraint.bones;\r\n        const boneCount = constrained.length;\r\n\r\n        for (let i = 0; i < boneCount; i++) this.sortBone(constrained[i]);\r\n\r\n        this._updateCache.push(constraint);\r\n\r\n        for (let i = 0; i < boneCount; i++) this.sortReset(constrained[i].children);\r\n        for (let i = 0; i < boneCount; i++) constrained[i].sorted = true;\r\n    }\r\n\r\n    sortTransformConstraint(constraint: TransformConstraint) {\r\n        constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || (this.skin != null && Utils.contains(this.skin.constraints, constraint.data, true)));\r\n        if (!constraint.active) return;\r\n\r\n        this.sortBone(constraint.target);\r\n\r\n        const constrained = constraint.bones;\r\n        const boneCount = constrained.length;\r\n\r\n        if (constraint.data.local) {\r\n            for (let i = 0; i < boneCount; i++) {\r\n                const child = constrained[i];\r\n\r\n                this.sortBone(child.parent);\r\n                if (!(this._updateCache.indexOf(child) > -1)) this.updateCacheReset.push(child);\r\n            }\r\n        } else {\r\n            for (let i = 0; i < boneCount; i++) {\r\n                this.sortBone(constrained[i]);\r\n            }\r\n        }\r\n\r\n        this._updateCache.push(constraint);\r\n\r\n        for (let ii = 0; ii < boneCount; ii++) this.sortReset(constrained[ii].children);\r\n        for (let ii = 0; ii < boneCount; ii++) constrained[ii].sorted = true;\r\n    }\r\n\r\n    sortPathConstraintAttachment(skin: Skin, slotIndex: number, slotBone: Bone) {\r\n        const attachments = skin.attachments[slotIndex];\r\n\r\n        if (!attachments) return;\r\n        for (const key in attachments) {\r\n            this.sortPathConstraintAttachmentWith(attachments[key], slotBone);\r\n        }\r\n    }\r\n\r\n    sortPathConstraintAttachmentWith(attachment: Attachment, slotBone: Bone) {\r\n        if (!(attachment instanceof PathAttachment)) return;\r\n        const pathBones = (<PathAttachment>attachment).bones;\r\n\r\n        if (pathBones == null) this.sortBone(slotBone);\r\n        else {\r\n            const bones = this.bones;\r\n            let i = 0;\r\n\r\n            while (i < pathBones.length) {\r\n                const boneCount = pathBones[i++];\r\n\r\n                for (let n = i + boneCount; i < n; i++) {\r\n                    const boneIndex = pathBones[i];\r\n\r\n                    this.sortBone(bones[boneIndex]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    sortBone(bone: Bone) {\r\n        if (bone.sorted) return;\r\n        const parent = bone.parent;\r\n\r\n        if (parent != null) this.sortBone(parent);\r\n        bone.sorted = true;\r\n        this._updateCache.push(bone);\r\n    }\r\n\r\n    sortReset(bones: Array<Bone>) {\r\n        for (let i = 0, n = bones.length; i < n; i++) {\r\n            const bone = bones[i];\r\n\r\n            if (!bone.active) continue;\r\n            if (bone.sorted) this.sortReset(bone.children);\r\n            bone.sorted = false;\r\n        }\r\n    }\r\n\r\n    /** Updates the world transform for each bone and applies constraints. */\r\n    updateWorldTransform() {\r\n        const updateCacheReset = this.updateCacheReset;\r\n\r\n        for (let i = 0, n = updateCacheReset.length; i < n; i++) {\r\n            const bone = updateCacheReset[i] as Bone;\r\n\r\n            bone.ax = bone.x;\r\n            bone.ay = bone.y;\r\n            bone.arotation = bone.rotation;\r\n            bone.ascaleX = bone.scaleX;\r\n            bone.ascaleY = bone.scaleY;\r\n            bone.ashearX = bone.shearX;\r\n            bone.ashearY = bone.shearY;\r\n            bone.appliedValid = true;\r\n        }\r\n        const updateCache = this._updateCache;\r\n\r\n        for (let i = 0, n = updateCache.length; i < n; i++) updateCache[i].update();\r\n    }\r\n\r\n    /** Sets the bones, constraints, and slots to their setup pose values. */\r\n    setToSetupPose() {\r\n        this.setBonesToSetupPose();\r\n        this.setSlotsToSetupPose();\r\n    }\r\n\r\n    /** Sets the bones and constraints to their setup pose values. */\r\n    setBonesToSetupPose() {\r\n        const bones = this.bones;\r\n\r\n        for (let i = 0, n = bones.length; i < n; i++) bones[i].setToSetupPose();\r\n\r\n        const ikConstraints = this.ikConstraints;\r\n\r\n        for (let i = 0, n = ikConstraints.length; i < n; i++) {\r\n            const constraint = ikConstraints[i];\r\n\r\n            constraint.mix = constraint.data.mix;\r\n            constraint.softness = constraint.data.softness;\r\n            constraint.bendDirection = constraint.data.bendDirection;\r\n            constraint.compress = constraint.data.compress;\r\n            constraint.stretch = constraint.data.stretch;\r\n        }\r\n\r\n        const transformConstraints = this.transformConstraints;\r\n\r\n        for (let i = 0, n = transformConstraints.length; i < n; i++) {\r\n            const constraint = transformConstraints[i];\r\n            const data = constraint.data;\r\n\r\n            constraint.rotateMix = data.rotateMix;\r\n            constraint.translateMix = data.translateMix;\r\n            constraint.scaleMix = data.scaleMix;\r\n            constraint.shearMix = data.shearMix;\r\n        }\r\n\r\n        const pathConstraints = this.pathConstraints;\r\n\r\n        for (let i = 0, n = pathConstraints.length; i < n; i++) {\r\n            const constraint = pathConstraints[i];\r\n            const data = constraint.data;\r\n\r\n            constraint.position = data.position;\r\n            constraint.spacing = data.spacing;\r\n            constraint.rotateMix = data.rotateMix;\r\n            constraint.translateMix = data.translateMix;\r\n        }\r\n    }\r\n\r\n    setSlotsToSetupPose() {\r\n        const slots = this.slots;\r\n\r\n        Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);\r\n        for (let i = 0, n = slots.length; i < n; i++) slots[i].setToSetupPose();\r\n    }\r\n\r\n    /** @return May return null. */\r\n    getRootBone() {\r\n        if (this.bones.length == 0) return null;\r\n\r\n        return this.bones[0];\r\n    }\r\n\r\n    /** @return May be null. */\r\n    findBone(boneName: string) {\r\n        if (boneName == null) throw new Error('boneName cannot be null.');\r\n        const bones = this.bones;\r\n\r\n        for (let i = 0, n = bones.length; i < n; i++) {\r\n            const bone = bones[i];\r\n\r\n            if (bone.data.name == boneName) return bone;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /** @return -1 if the bone was not found. */\r\n    findBoneIndex(boneName: string) {\r\n        if (boneName == null) throw new Error('boneName cannot be null.');\r\n        const bones = this.bones;\r\n\r\n        for (let i = 0, n = bones.length; i < n; i++) if (bones[i].data.name == boneName) return i;\r\n\r\n        return -1;\r\n    }\r\n\r\n    /** @return May be null. */\r\n    findSlot(slotName: string) {\r\n        if (slotName == null) throw new Error('slotName cannot be null.');\r\n        const slots = this.slots;\r\n\r\n        for (let i = 0, n = slots.length; i < n; i++) {\r\n            const slot = slots[i];\r\n\r\n            if (slot.data.name == slotName) return slot;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /** @return -1 if the bone was not found. */\r\n    findSlotIndex(slotName: string) {\r\n        if (slotName == null) throw new Error('slotName cannot be null.');\r\n        const slots = this.slots;\r\n\r\n        for (let i = 0, n = slots.length; i < n; i++) if (slots[i].data.name == slotName) return i;\r\n\r\n        return -1;\r\n    }\r\n\r\n    /** Sets a skin by name.\r\n     * @see #setSkin(Skin) */\r\n    setSkinByName(skinName: string) {\r\n        const skin = this.data.findSkin(skinName);\r\n\r\n        if (skin == null) throw new Error(`Skin not found: ${skinName}`);\r\n        this.setSkin(skin);\r\n    }\r\n\r\n    /** Sets the skin used to look up attachments before looking in the {@link SkeletonData#getDefaultSkin() default skin}.\r\n     * Attachments from the new skin are attached if the corresponding attachment from the old skin was attached. If there was no\r\n     * old skin, each slot's setup mode attachment is attached from the new skin.\r\n     * @param newSkin May be null. */\r\n    setSkin(newSkin: Skin) {\r\n        if (newSkin == this.skin) return;\r\n        if (newSkin != null) {\r\n            if (this.skin != null) newSkin.attachAll(this, this.skin);\r\n            else {\r\n                const slots = this.slots;\r\n\r\n                for (let i = 0, n = slots.length; i < n; i++) {\r\n                    const slot = slots[i];\r\n                    const name = slot.data.attachmentName;\r\n\r\n                    if (name != null) {\r\n                        const attachment: Attachment = newSkin.getAttachment(i, name);\r\n\r\n                        if (attachment != null) slot.setAttachment(attachment);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this.skin = newSkin;\r\n        this.updateCache();\r\n    }\r\n\r\n    /** @return May be null. */\r\n    getAttachmentByName(slotName: string, attachmentName: string): Attachment {\r\n        return this.getAttachment(this.data.findSlotIndex(slotName), attachmentName);\r\n    }\r\n\r\n    /** @return May be null. */\r\n    getAttachment(slotIndex: number, attachmentName: string): Attachment {\r\n        if (attachmentName == null) throw new Error('attachmentName cannot be null.');\r\n        if (this.skin != null) {\r\n            const attachment: Attachment = this.skin.getAttachment(slotIndex, attachmentName);\r\n\r\n            if (attachment != null) return attachment;\r\n        }\r\n        if (this.data.defaultSkin != null) return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);\r\n\r\n        return null;\r\n    }\r\n\r\n    /** @param attachmentName May be null. */\r\n    setAttachment(slotName: string, attachmentName?: string) {\r\n        if (slotName == null) throw new Error('slotName cannot be null.');\r\n        const slots = this.slots;\r\n\r\n        for (let i = 0, n = slots.length; i < n; i++) {\r\n            const slot = slots[i];\r\n\r\n            if (slot.data.name == slotName) {\r\n                let attachment: Attachment = null;\r\n\r\n                if (attachmentName != null) {\r\n                    attachment = this.getAttachment(i, attachmentName);\r\n                    if (attachment == null) throw new Error(`Attachment not found: ${attachmentName}, for slot: ${slotName}`);\r\n                }\r\n                slot.setAttachment(attachment);\r\n\r\n                return;\r\n            }\r\n        }\r\n        throw new Error(`Slot not found: ${slotName}`);\r\n    }\r\n\r\n    /** @return May be null. */\r\n    findIkConstraint(constraintName: string) {\r\n        if (constraintName == null) throw new Error('constraintName cannot be null.');\r\n        const ikConstraints = this.ikConstraints;\r\n\r\n        for (let i = 0, n = ikConstraints.length; i < n; i++) {\r\n            const ikConstraint = ikConstraints[i];\r\n\r\n            if (ikConstraint.data.name == constraintName) return ikConstraint;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /** @return May be null. */\r\n    findTransformConstraint(constraintName: string) {\r\n        if (constraintName == null) throw new Error('constraintName cannot be null.');\r\n        const transformConstraints = this.transformConstraints;\r\n\r\n        for (let i = 0, n = transformConstraints.length; i < n; i++) {\r\n            const constraint = transformConstraints[i];\r\n\r\n            if (constraint.data.name == constraintName) return constraint;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /** @return May be null. */\r\n    findPathConstraint(constraintName: string) {\r\n        if (constraintName == null) throw new Error('constraintName cannot be null.');\r\n        const pathConstraints = this.pathConstraints;\r\n\r\n        for (let i = 0, n = pathConstraints.length; i < n; i++) {\r\n            const constraint = pathConstraints[i];\r\n\r\n            if (constraint.data.name == constraintName) return constraint;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /** Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose.\r\n     * @param offset The distance from the skeleton origin to the bottom left corner of the AABB.\r\n     * @param size The width and height of the AABB.\r\n     * @param temp Working memory */\r\n    getBounds(offset: Vector2, size: Vector2, temp: Array<number> = new Array<number>(2)) {\r\n        if (offset == null) throw new Error('offset cannot be null.');\r\n        if (size == null) throw new Error('size cannot be null.');\r\n        const drawOrder = this.drawOrder;\r\n        let minX = Number.POSITIVE_INFINITY;\r\n        let minY = Number.POSITIVE_INFINITY;\r\n        let maxX = Number.NEGATIVE_INFINITY;\r\n        let maxY = Number.NEGATIVE_INFINITY;\r\n\r\n        for (let i = 0, n = drawOrder.length; i < n; i++) {\r\n            const slot = drawOrder[i];\r\n\r\n            if (!slot.bone.active) continue;\r\n            let verticesLength = 0;\r\n            let vertices: ArrayLike<number> = null;\r\n            const attachment = slot.getAttachment();\r\n\r\n            if (attachment instanceof RegionAttachment) {\r\n                verticesLength = 8;\r\n                vertices = Utils.setArraySize(temp, verticesLength, 0);\r\n                (<RegionAttachment>attachment).computeWorldVertices(slot.bone, vertices, 0, 2);\r\n            } else if (attachment instanceof MeshAttachment) {\r\n                const mesh = <MeshAttachment>attachment;\r\n\r\n                verticesLength = mesh.worldVerticesLength;\r\n                vertices = Utils.setArraySize(temp, verticesLength, 0);\r\n                mesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);\r\n            }\r\n            if (vertices != null) {\r\n                for (let ii = 0, nn = vertices.length; ii < nn; ii += 2) {\r\n                    const x = vertices[ii];\r\n                    const y = vertices[ii + 1];\r\n\r\n                    minX = Math.min(minX, x);\r\n                    minY = Math.min(minY, y);\r\n                    maxX = Math.max(maxX, x);\r\n                    maxY = Math.max(maxY, y);\r\n                }\r\n            }\r\n        }\r\n        offset.set(minX, minY);\r\n        size.set(maxX - minX, maxY - minY);\r\n    }\r\n\r\n    update(delta: number) {\r\n        this.time += delta;\r\n    }\r\n\r\n    get flipX(): boolean {\r\n        return this.scaleX == -1;\r\n    }\r\n\r\n    set flipX(value: boolean) {\r\n        if (!Skeleton.deprecatedWarning1) {\r\n            Skeleton.deprecatedWarning1 = true;\r\n            console.warn('Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY');\r\n        }\r\n        this.scaleX = value ? 1.0 : -1.0;\r\n    }\r\n\r\n    get flipY(): boolean {\r\n        return this.scaleY == -1;\r\n    }\r\n\r\n    set flipY(value: boolean) {\r\n        if (!Skeleton.deprecatedWarning1) {\r\n            Skeleton.deprecatedWarning1 = true;\r\n            console.warn('Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY');\r\n        }\r\n        this.scaleY = value ? 1.0 : -1.0;\r\n    }\r\n\r\n    private static deprecatedWarning1 = false;\r\n}\r\n","import type { ISkeletonData } from '@pixi-spine/base';\r\nimport type { Animation } from './Animation';\r\nimport type { BoneData } from './BoneData';\r\nimport type { SlotData } from './SlotData';\r\nimport type { Skin } from './Skin';\r\nimport type { EventData } from './EventData';\r\nimport type { IkConstraintData } from './IkConstraintData';\r\nimport type { TransformConstraintData } from './TransformConstraintData';\r\nimport type { PathConstraintData } from './PathConstraintData';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class SkeletonData implements ISkeletonData<BoneData, SlotData, Skin, Animation, EventData, IkConstraintData, TransformConstraintData, PathConstraintData> {\r\n    name: string;\r\n    bones = new Array<BoneData>(); // Ordered parents first.\r\n    slots = new Array<SlotData>(); // Setup pose draw order.\r\n    skins = new Array<Skin>();\r\n    defaultSkin: Skin;\r\n    events = new Array<EventData>();\r\n    animations = new Array<Animation>();\r\n    ikConstraints = new Array<IkConstraintData>();\r\n    transformConstraints = new Array<TransformConstraintData>();\r\n    pathConstraints = new Array<PathConstraintData>();\r\n    x: number;\r\n    y: number;\r\n    width: number;\r\n    height: number;\r\n    version: string;\r\n    hash: string;\r\n\r\n    // Nonessential\r\n    fps = 0;\r\n    imagesPath: string;\r\n    audioPath: string;\r\n\r\n    findBone(boneName: string) {\r\n        if (boneName == null) throw new Error('boneName cannot be null.');\r\n        const bones = this.bones;\r\n\r\n        for (let i = 0, n = bones.length; i < n; i++) {\r\n            const bone = bones[i];\r\n\r\n            if (bone.name == boneName) return bone;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    findBoneIndex(boneName: string) {\r\n        if (boneName == null) throw new Error('boneName cannot be null.');\r\n        const bones = this.bones;\r\n\r\n        for (let i = 0, n = bones.length; i < n; i++) if (bones[i].name == boneName) return i;\r\n\r\n        return -1;\r\n    }\r\n\r\n    findSlot(slotName: string) {\r\n        if (slotName == null) throw new Error('slotName cannot be null.');\r\n        const slots = this.slots;\r\n\r\n        for (let i = 0, n = slots.length; i < n; i++) {\r\n            const slot = slots[i];\r\n\r\n            if (slot.name == slotName) return slot;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    findSlotIndex(slotName: string) {\r\n        if (slotName == null) throw new Error('slotName cannot be null.');\r\n        const slots = this.slots;\r\n\r\n        for (let i = 0, n = slots.length; i < n; i++) if (slots[i].name == slotName) return i;\r\n\r\n        return -1;\r\n    }\r\n\r\n    findSkin(skinName: string) {\r\n        if (skinName == null) throw new Error('skinName cannot be null.');\r\n        const skins = this.skins;\r\n\r\n        for (let i = 0, n = skins.length; i < n; i++) {\r\n            const skin = skins[i];\r\n\r\n            if (skin.name == skinName) return skin;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    findEvent(eventDataName: string) {\r\n        if (eventDataName == null) throw new Error('eventDataName cannot be null.');\r\n        const events = this.events;\r\n\r\n        for (let i = 0, n = events.length; i < n; i++) {\r\n            const event = events[i];\r\n\r\n            if (event.name == eventDataName) return event;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    findAnimation(animationName: string) {\r\n        if (animationName == null) throw new Error('animationName cannot be null.');\r\n        const animations = this.animations;\r\n\r\n        for (let i = 0, n = animations.length; i < n; i++) {\r\n            const animation = animations[i];\r\n\r\n            if (animation.name == animationName) return animation;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    findIkConstraint(constraintName: string) {\r\n        if (constraintName == null) throw new Error('constraintName cannot be null.');\r\n        const ikConstraints = this.ikConstraints;\r\n\r\n        for (let i = 0, n = ikConstraints.length; i < n; i++) {\r\n            const constraint = ikConstraints[i];\r\n\r\n            if (constraint.name == constraintName) return constraint;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    findTransformConstraint(constraintName: string) {\r\n        if (constraintName == null) throw new Error('constraintName cannot be null.');\r\n        const transformConstraints = this.transformConstraints;\r\n\r\n        for (let i = 0, n = transformConstraints.length; i < n; i++) {\r\n            const constraint = transformConstraints[i];\r\n\r\n            if (constraint.name == constraintName) return constraint;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    findPathConstraint(constraintName: string) {\r\n        if (constraintName == null) throw new Error('constraintName cannot be null.');\r\n        const pathConstraints = this.pathConstraints;\r\n\r\n        for (let i = 0, n = pathConstraints.length; i < n; i++) {\r\n            const constraint = pathConstraints[i];\r\n\r\n            if (constraint.name == constraintName) return constraint;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    findPathConstraintIndex(pathConstraintName: string) {\r\n        if (pathConstraintName == null) throw new Error('pathConstraintName cannot be null.');\r\n        const pathConstraints = this.pathConstraints;\r\n\r\n        for (let i = 0, n = pathConstraints.length; i < n; i++) if (pathConstraints[i].name == pathConstraintName) return i;\r\n\r\n        return -1;\r\n    }\r\n}\r\n","import { Color } from '@pixi-spine/base';\r\n\r\nimport type { ISlotData } from '@pixi-spine/base';\r\nimport type { BLEND_MODES } from '@pixi/core';\r\nimport type { BoneData } from './BoneData';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class SlotData implements ISlotData {\r\n    index: number;\r\n    name: string;\r\n    boneData: BoneData;\r\n    color = new Color(1, 1, 1, 1);\r\n    darkColor: Color;\r\n    attachmentName: string;\r\n    blendMode: BLEND_MODES;\r\n\r\n    constructor(index: number, name: string, boneData: BoneData) {\r\n        if (index < 0) throw new Error('index must be >= 0.');\r\n        if (name == null) throw new Error('name cannot be null.');\r\n        if (boneData == null) throw new Error('boneData cannot be null.');\r\n        this.index = index;\r\n        this.name = name;\r\n        this.boneData = boneData;\r\n    }\r\n}\r\n","import type { BoneData } from './BoneData';\r\nimport { ConstraintData } from './Constraint';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class TransformConstraintData extends ConstraintData {\r\n    bones = new Array<BoneData>();\r\n    target: BoneData;\r\n    rotateMix = 0;\r\n    translateMix = 0;\r\n    scaleMix = 0;\r\n    shearMix = 0;\r\n    offsetRotation = 0;\r\n    offsetX = 0;\r\n    offsetY = 0;\r\n    offsetScaleX = 0;\r\n    offsetScaleY = 0;\r\n    offsetShearY = 0;\r\n    relative = false;\r\n    local = false;\r\n\r\n    constructor(name: string) {\r\n        super(name, 0, false);\r\n    }\r\n}\r\n","import { Attachment, MeshAttachment } from './attachments';\r\nimport type { BoneData } from './BoneData';\r\nimport type { ConstraintData } from './Constraint';\r\nimport type { Skeleton } from './Skeleton';\r\n\r\nimport type { Map, ISkin } from '@pixi-spine/base';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class SkinEntry {\r\n    constructor(public slotIndex: number, public name: string, public attachment: Attachment) {}\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class Skin implements ISkin {\r\n    name: string;\r\n    attachments = new Array<Map<Attachment>>();\r\n    bones = Array<BoneData>();\r\n    constraints = new Array<ConstraintData>();\r\n\r\n    constructor(name: string) {\r\n        if (name == null) throw new Error('name cannot be null.');\r\n        this.name = name;\r\n    }\r\n\r\n    setAttachment(slotIndex: number, name: string, attachment: Attachment) {\r\n        if (attachment == null) throw new Error('attachment cannot be null.');\r\n        const attachments = this.attachments;\r\n\r\n        if (slotIndex >= attachments.length) attachments.length = slotIndex + 1;\r\n        if (!attachments[slotIndex]) attachments[slotIndex] = {};\r\n        attachments[slotIndex][name] = attachment;\r\n    }\r\n\r\n    addSkin(skin: Skin) {\r\n        for (let i = 0; i < skin.bones.length; i++) {\r\n            const bone = skin.bones[i];\r\n            let contained = false;\r\n\r\n            for (let j = 0; j < this.bones.length; j++) {\r\n                if (this.bones[j] == bone) {\r\n                    contained = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!contained) this.bones.push(bone);\r\n        }\r\n\r\n        for (let i = 0; i < skin.constraints.length; i++) {\r\n            const constraint = skin.constraints[i];\r\n            let contained = false;\r\n\r\n            for (let j = 0; j < this.constraints.length; j++) {\r\n                if (this.constraints[j] == constraint) {\r\n                    contained = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!contained) this.constraints.push(constraint);\r\n        }\r\n\r\n        const attachments = skin.getAttachments();\r\n\r\n        for (let i = 0; i < attachments.length; i++) {\r\n            const attachment = attachments[i];\r\n\r\n            this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\r\n        }\r\n    }\r\n\r\n    copySkin(skin: Skin) {\r\n        for (let i = 0; i < skin.bones.length; i++) {\r\n            const bone = skin.bones[i];\r\n            let contained = false;\r\n\r\n            for (let j = 0; j < this.bones.length; j++) {\r\n                if (this.bones[j] == bone) {\r\n                    contained = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!contained) this.bones.push(bone);\r\n        }\r\n\r\n        for (let i = 0; i < skin.constraints.length; i++) {\r\n            const constraint = skin.constraints[i];\r\n            let contained = false;\r\n\r\n            for (let j = 0; j < this.constraints.length; j++) {\r\n                if (this.constraints[j] == constraint) {\r\n                    contained = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!contained) this.constraints.push(constraint);\r\n        }\r\n\r\n        const attachments = skin.getAttachments();\r\n\r\n        for (let i = 0; i < attachments.length; i++) {\r\n            const attachment = attachments[i];\r\n\r\n            if (attachment.attachment == null) continue;\r\n            if (attachment.attachment instanceof MeshAttachment) {\r\n                attachment.attachment = attachment.attachment.newLinkedMesh();\r\n                this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\r\n            } else {\r\n                attachment.attachment = attachment.attachment.copy();\r\n                this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @return May be null. */\r\n    getAttachment(slotIndex: number, name: string): Attachment {\r\n        const dictionary = this.attachments[slotIndex];\r\n\r\n        return dictionary ? dictionary[name] : null;\r\n    }\r\n\r\n    removeAttachment(slotIndex: number, name: string) {\r\n        const dictionary = this.attachments[slotIndex];\r\n\r\n        if (dictionary) dictionary[name] = null;\r\n    }\r\n\r\n    getAttachments(): Array<SkinEntry> {\r\n        const entries = new Array<SkinEntry>();\r\n\r\n        for (let i = 0; i < this.attachments.length; i++) {\r\n            const slotAttachments = this.attachments[i];\r\n\r\n            if (slotAttachments) {\r\n                for (const name in slotAttachments) {\r\n                    const attachment = slotAttachments[name];\r\n\r\n                    if (attachment) entries.push(new SkinEntry(i, name, attachment));\r\n                }\r\n            }\r\n        }\r\n\r\n        return entries;\r\n    }\r\n\r\n    getAttachmentsForSlot(slotIndex: number, attachments: Array<SkinEntry>) {\r\n        const slotAttachments = this.attachments[slotIndex];\r\n\r\n        if (slotAttachments) {\r\n            for (const name in slotAttachments) {\r\n                const attachment = slotAttachments[name];\r\n\r\n                if (attachment) attachments.push(new SkinEntry(slotIndex, name, attachment));\r\n            }\r\n        }\r\n    }\r\n\r\n    clear() {\r\n        this.attachments.length = 0;\r\n        this.bones.length = 0;\r\n        this.constraints.length = 0;\r\n    }\r\n\r\n    /** Attach each attachment in this skin if the corresponding attachment in the old skin is currently attached. */\r\n    attachAll(skeleton: Skeleton, oldSkin: Skin) {\r\n        let slotIndex = 0;\r\n\r\n        for (let i = 0; i < skeleton.slots.length; i++) {\r\n            const slot = skeleton.slots[i];\r\n            const slotAttachment = slot.getAttachment();\r\n\r\n            if (slotAttachment && slotIndex < oldSkin.attachments.length) {\r\n                const dictionary = oldSkin.attachments[slotIndex];\r\n\r\n                for (const key in dictionary) {\r\n                    const skinAttachment: Attachment = dictionary[key];\r\n\r\n                    if (slotAttachment == skinAttachment) {\r\n                        const attachment = this.getAttachment(slotIndex, key);\r\n\r\n                        if (attachment != null) slot.setAttachment(attachment);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            slotIndex++;\r\n        }\r\n    }\r\n}\r\n","import type { Attachment, AttachmentLoader, MeshAttachment, VertexAttachment } from './attachments';\r\nimport { Event } from './Event';\r\nimport { SkeletonData } from './SkeletonData';\r\nimport { SlotData } from './SlotData';\r\nimport { BoneData } from './BoneData';\r\nimport { IkConstraintData } from './IkConstraintData';\r\nimport { TransformConstraintData } from './TransformConstraintData';\r\nimport { PathConstraintData, SpacingMode } from './PathConstraintData';\r\nimport { Skin } from './Skin';\r\nimport { EventData } from './EventData';\r\nimport {\r\n    Animation,\r\n    AttachmentTimeline,\r\n    ColorTimeline,\r\n    CurveTimeline,\r\n    DeformTimeline,\r\n    DrawOrderTimeline,\r\n    EventTimeline,\r\n    IkConstraintTimeline,\r\n    PathConstraintMixTimeline,\r\n    PathConstraintPositionTimeline,\r\n    PathConstraintSpacingTimeline,\r\n    RotateTimeline,\r\n    ScaleTimeline,\r\n    ShearTimeline,\r\n    Timeline,\r\n    TransformConstraintTimeline,\r\n    TranslateTimeline,\r\n    TwoColorTimeline,\r\n} from './Animation';\r\nimport { AttachmentType, BinaryInput, Color, PositionMode, RotateMode, TransformMode, Utils } from '@pixi-spine/base';\r\nimport { BLEND_MODES } from '@pixi/core';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class SkeletonBinary {\r\n    static AttachmentTypeValues = [\r\n        0 /* AttachmentType.Region*/, 1 /* AttachmentType.BoundingBox*/, 2 /* AttachmentType.Mesh*/, 3 /* AttachmentType.LinkedMesh*/, 4 /* AttachmentType.Path*/,\r\n        5 /* AttachmentType.Point*/, 6 /* AttachmentType.Clipping*/,\r\n    ];\r\n    static TransformModeValues = [\r\n        TransformMode.Normal,\r\n        TransformMode.OnlyTranslation,\r\n        TransformMode.NoRotationOrReflection,\r\n        TransformMode.NoScale,\r\n        TransformMode.NoScaleOrReflection,\r\n    ];\r\n    static PositionModeValues = [PositionMode.Fixed, PositionMode.Percent];\r\n    static SpacingModeValues = [SpacingMode.Length, SpacingMode.Fixed, SpacingMode.Percent];\r\n    static RotateModeValues = [RotateMode.Tangent, RotateMode.Chain, RotateMode.ChainScale];\r\n    static BlendModeValues = [BLEND_MODES.NORMAL, BLEND_MODES.ADD, BLEND_MODES.MULTIPLY, BLEND_MODES.SCREEN];\r\n\r\n    static BONE_ROTATE = 0;\r\n    static BONE_TRANSLATE = 1;\r\n    static BONE_SCALE = 2;\r\n    static BONE_SHEAR = 3;\r\n\r\n    static SLOT_ATTACHMENT = 0;\r\n    static SLOT_COLOR = 1;\r\n    static SLOT_TWO_COLOR = 2;\r\n\r\n    static PATH_POSITION = 0;\r\n    static PATH_SPACING = 1;\r\n    static PATH_MIX = 2;\r\n\r\n    static CURVE_LINEAR = 0;\r\n    static CURVE_STEPPED = 1;\r\n    static CURVE_BEZIER = 2;\r\n\r\n    attachmentLoader: AttachmentLoader;\r\n    scale = 1;\r\n    private linkedMeshes = new Array<LinkedMesh>();\r\n\r\n    constructor(attachmentLoader: AttachmentLoader) {\r\n        this.attachmentLoader = attachmentLoader;\r\n    }\r\n\r\n    readSkeletonData(binary: Uint8Array): SkeletonData {\r\n        const scale = this.scale;\r\n\r\n        const skeletonData = new SkeletonData();\r\n\r\n        skeletonData.name = ''; // BOZO\r\n\r\n        const input = new BinaryInput(binary);\r\n\r\n        skeletonData.hash = input.readString();\r\n        skeletonData.version = input.readString();\r\n        if (skeletonData.version === '3.8.75') {\r\n            const error = `Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine.`;\r\n\r\n            console.error(error);\r\n        }\r\n        skeletonData.x = input.readFloat();\r\n        skeletonData.y = input.readFloat();\r\n        skeletonData.width = input.readFloat();\r\n        skeletonData.height = input.readFloat();\r\n\r\n        const nonessential = input.readBoolean();\r\n\r\n        if (nonessential) {\r\n            skeletonData.fps = input.readFloat();\r\n\r\n            skeletonData.imagesPath = input.readString();\r\n            skeletonData.audioPath = input.readString();\r\n        }\r\n\r\n        let n = 0;\r\n        // Strings.\r\n\r\n        n = input.readInt(true);\r\n        for (let i = 0; i < n; i++) input.strings.push(input.readString());\r\n\r\n        // Bones.\r\n        n = input.readInt(true);\r\n        for (let i = 0; i < n; i++) {\r\n            const name = input.readString();\r\n            const parent = i == 0 ? null : skeletonData.bones[input.readInt(true)];\r\n            const data = new BoneData(i, name, parent);\r\n\r\n            data.rotation = input.readFloat();\r\n            data.x = input.readFloat() * scale;\r\n            data.y = input.readFloat() * scale;\r\n            data.scaleX = input.readFloat();\r\n            data.scaleY = input.readFloat();\r\n            data.shearX = input.readFloat();\r\n            data.shearY = input.readFloat();\r\n            data.length = input.readFloat() * scale;\r\n            data.transformMode = SkeletonBinary.TransformModeValues[input.readInt(true)];\r\n            data.skinRequired = input.readBoolean();\r\n            if (nonessential) Color.rgba8888ToColor(data.color, input.readInt32());\r\n            skeletonData.bones.push(data);\r\n        }\r\n\r\n        // Slots.\r\n        n = input.readInt(true);\r\n        for (let i = 0; i < n; i++) {\r\n            const slotName = input.readString();\r\n            const boneData = skeletonData.bones[input.readInt(true)];\r\n            const data = new SlotData(i, slotName, boneData);\r\n\r\n            Color.rgba8888ToColor(data.color, input.readInt32());\r\n\r\n            const darkColor = input.readInt32();\r\n\r\n            if (darkColor != -1) Color.rgb888ToColor((data.darkColor = new Color()), darkColor);\r\n\r\n            data.attachmentName = input.readStringRef();\r\n            data.blendMode = SkeletonBinary.BlendModeValues[input.readInt(true)];\r\n            skeletonData.slots.push(data);\r\n        }\r\n\r\n        // IK constraints.\r\n        n = input.readInt(true);\r\n        for (let i = 0, nn; i < n; i++) {\r\n            const data = new IkConstraintData(input.readString());\r\n\r\n            data.order = input.readInt(true);\r\n            data.skinRequired = input.readBoolean();\r\n            nn = input.readInt(true);\r\n            for (let ii = 0; ii < nn; ii++) data.bones.push(skeletonData.bones[input.readInt(true)]);\r\n            data.target = skeletonData.bones[input.readInt(true)];\r\n            data.mix = input.readFloat();\r\n            data.softness = input.readFloat() * scale;\r\n            data.bendDirection = input.readByte();\r\n            data.compress = input.readBoolean();\r\n            data.stretch = input.readBoolean();\r\n            data.uniform = input.readBoolean();\r\n            skeletonData.ikConstraints.push(data);\r\n        }\r\n\r\n        // Transform constraints.\r\n        n = input.readInt(true);\r\n        for (let i = 0, nn; i < n; i++) {\r\n            const data = new TransformConstraintData(input.readString());\r\n\r\n            data.order = input.readInt(true);\r\n            data.skinRequired = input.readBoolean();\r\n            nn = input.readInt(true);\r\n            for (let ii = 0; ii < nn; ii++) data.bones.push(skeletonData.bones[input.readInt(true)]);\r\n            data.target = skeletonData.bones[input.readInt(true)];\r\n            data.local = input.readBoolean();\r\n            data.relative = input.readBoolean();\r\n            data.offsetRotation = input.readFloat();\r\n            data.offsetX = input.readFloat() * scale;\r\n            data.offsetY = input.readFloat() * scale;\r\n            data.offsetScaleX = input.readFloat();\r\n            data.offsetScaleY = input.readFloat();\r\n            data.offsetShearY = input.readFloat();\r\n            data.rotateMix = input.readFloat();\r\n            data.translateMix = input.readFloat();\r\n            data.scaleMix = input.readFloat();\r\n            data.shearMix = input.readFloat();\r\n            skeletonData.transformConstraints.push(data);\r\n        }\r\n\r\n        // Path constraints.\r\n        n = input.readInt(true);\r\n        for (let i = 0, nn; i < n; i++) {\r\n            const data = new PathConstraintData(input.readString());\r\n\r\n            data.order = input.readInt(true);\r\n            data.skinRequired = input.readBoolean();\r\n            nn = input.readInt(true);\r\n            for (let ii = 0; ii < nn; ii++) data.bones.push(skeletonData.bones[input.readInt(true)]);\r\n            data.target = skeletonData.slots[input.readInt(true)];\r\n            data.positionMode = SkeletonBinary.PositionModeValues[input.readInt(true)];\r\n            data.spacingMode = SkeletonBinary.SpacingModeValues[input.readInt(true)];\r\n            data.rotateMode = SkeletonBinary.RotateModeValues[input.readInt(true)];\r\n            data.offsetRotation = input.readFloat();\r\n            data.position = input.readFloat();\r\n            if (data.positionMode == PositionMode.Fixed) data.position *= scale;\r\n            data.spacing = input.readFloat();\r\n            if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) data.spacing *= scale;\r\n            data.rotateMix = input.readFloat();\r\n            data.translateMix = input.readFloat();\r\n            skeletonData.pathConstraints.push(data);\r\n        }\r\n\r\n        // Default skin.\r\n        const defaultSkin = this.readSkin(input, skeletonData, true, nonessential);\r\n\r\n        if (defaultSkin != null) {\r\n            skeletonData.defaultSkin = defaultSkin;\r\n            skeletonData.skins.push(defaultSkin);\r\n        }\r\n\r\n        // Skins.\r\n        {\r\n            let i = skeletonData.skins.length;\r\n\r\n            Utils.setArraySize(skeletonData.skins, (n = i + input.readInt(true)));\r\n            for (; i < n; i++) skeletonData.skins[i] = this.readSkin(input, skeletonData, false, nonessential);\r\n        }\r\n\r\n        // Linked meshes.\r\n        n = this.linkedMeshes.length;\r\n        for (let i = 0; i < n; i++) {\r\n            const linkedMesh = this.linkedMeshes[i];\r\n            const skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\r\n\r\n            if (skin == null) throw new Error(`Skin not found: ${linkedMesh.skin}`);\r\n            const parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\r\n\r\n            if (parent == null) throw new Error(`Parent mesh not found: ${linkedMesh.parent}`);\r\n            linkedMesh.mesh.deformAttachment = linkedMesh.inheritDeform ? (parent as VertexAttachment) : linkedMesh.mesh;\r\n            linkedMesh.mesh.setParentMesh(parent as MeshAttachment);\r\n            // linkedMesh.mesh.updateUVs();\r\n        }\r\n        this.linkedMeshes.length = 0;\r\n\r\n        // Events.\r\n        n = input.readInt(true);\r\n        for (let i = 0; i < n; i++) {\r\n            const data = new EventData(input.readStringRef());\r\n\r\n            data.intValue = input.readInt(false);\r\n            data.floatValue = input.readFloat();\r\n            data.stringValue = input.readString();\r\n            data.audioPath = input.readString();\r\n            if (data.audioPath != null) {\r\n                data.volume = input.readFloat();\r\n                data.balance = input.readFloat();\r\n            }\r\n            skeletonData.events.push(data);\r\n        }\r\n\r\n        // Animations.\r\n        n = input.readInt(true);\r\n        for (let i = 0; i < n; i++) skeletonData.animations.push(this.readAnimation(input, input.readString(), skeletonData));\r\n\r\n        return skeletonData;\r\n    }\r\n\r\n    private readSkin(input: BinaryInput, skeletonData: SkeletonData, defaultSkin: boolean, nonessential: boolean): Skin {\r\n        let skin = null;\r\n        let slotCount = 0;\r\n\r\n        if (defaultSkin) {\r\n            slotCount = input.readInt(true);\r\n            if (slotCount == 0) return null;\r\n            skin = new Skin('default');\r\n        } else {\r\n            skin = new Skin(input.readStringRef());\r\n            skin.bones.length = input.readInt(true);\r\n            for (let i = 0, n = skin.bones.length; i < n; i++) skin.bones[i] = skeletonData.bones[input.readInt(true)];\r\n\r\n            for (let i = 0, n = input.readInt(true); i < n; i++) skin.constraints.push(skeletonData.ikConstraints[input.readInt(true)]);\r\n            for (let i = 0, n = input.readInt(true); i < n; i++) skin.constraints.push(skeletonData.transformConstraints[input.readInt(true)]);\r\n            for (let i = 0, n = input.readInt(true); i < n; i++) skin.constraints.push(skeletonData.pathConstraints[input.readInt(true)]);\r\n\r\n            slotCount = input.readInt(true);\r\n        }\r\n\r\n        for (let i = 0; i < slotCount; i++) {\r\n            const slotIndex = input.readInt(true);\r\n\r\n            for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\r\n                const name = input.readStringRef();\r\n                const attachment = this.readAttachment(input, skeletonData, skin, slotIndex, name, nonessential);\r\n\r\n                if (attachment != null) skin.setAttachment(slotIndex, name, attachment);\r\n            }\r\n        }\r\n\r\n        return skin;\r\n    }\r\n\r\n    private readAttachment(input: BinaryInput, skeletonData: SkeletonData, skin: Skin, slotIndex: number, attachmentName: string, nonessential: boolean): Attachment {\r\n        const scale = this.scale;\r\n\r\n        let name = input.readStringRef();\r\n\r\n        if (name == null) name = attachmentName;\r\n\r\n        const typeIndex = input.readByte();\r\n        const type = SkeletonBinary.AttachmentTypeValues[typeIndex];\r\n\r\n        switch (type) {\r\n            case AttachmentType.Region: {\r\n                let path = input.readStringRef();\r\n                const rotation = input.readFloat();\r\n                const x = input.readFloat();\r\n                const y = input.readFloat();\r\n                const scaleX = input.readFloat();\r\n                const scaleY = input.readFloat();\r\n                const width = input.readFloat();\r\n                const height = input.readFloat();\r\n                const color = input.readInt32();\r\n\r\n                if (path == null) path = name;\r\n                const region = this.attachmentLoader.newRegionAttachment(skin, name, path);\r\n\r\n                if (region == null) return null;\r\n                region.path = path;\r\n                region.x = x * scale;\r\n                region.y = y * scale;\r\n                region.scaleX = scaleX;\r\n                region.scaleY = scaleY;\r\n                region.rotation = rotation;\r\n                region.width = width * scale;\r\n                region.height = height * scale;\r\n                Color.rgba8888ToColor(region.color, color);\r\n                // region.updateOffset();\r\n\r\n                return region;\r\n            }\r\n            case AttachmentType.BoundingBox: {\r\n                const vertexCount = input.readInt(true);\r\n                const vertices = this.readVertices(input, vertexCount);\r\n                const color = nonessential ? input.readInt32() : 0;\r\n\r\n                const box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\r\n\r\n                if (box == null) return null;\r\n                box.worldVerticesLength = vertexCount << 1;\r\n                box.vertices = vertices.vertices;\r\n                box.bones = vertices.bones;\r\n                if (nonessential) Color.rgba8888ToColor(box.color, color);\r\n\r\n                return box;\r\n            }\r\n            case AttachmentType.Mesh: {\r\n                let path = input.readStringRef();\r\n                const color = input.readInt32();\r\n                const vertexCount = input.readInt(true);\r\n                const uvs = this.readFloatArray(input, vertexCount << 1, 1);\r\n                const triangles = this.readShortArray(input);\r\n                const vertices = this.readVertices(input, vertexCount);\r\n                const hullLength = input.readInt(true);\r\n                let edges = null;\r\n                let width = 0;\r\n                let height = 0;\r\n\r\n                if (nonessential) {\r\n                    edges = this.readShortArray(input);\r\n                    width = input.readFloat();\r\n                    height = input.readFloat();\r\n                }\r\n\r\n                if (path == null) path = name;\r\n                const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\r\n\r\n                if (mesh == null) return null;\r\n                mesh.path = path;\r\n                Color.rgba8888ToColor(mesh.color, color);\r\n                mesh.bones = vertices.bones;\r\n                mesh.vertices = vertices.vertices;\r\n                mesh.worldVerticesLength = vertexCount << 1;\r\n                mesh.triangles = triangles;\r\n                mesh.regionUVs = new Float32Array(uvs);\r\n                // mesh.updateUVs();\r\n                mesh.hullLength = hullLength << 1;\r\n                if (nonessential) {\r\n                    mesh.edges = edges;\r\n                    mesh.width = width * scale;\r\n                    mesh.height = height * scale;\r\n                }\r\n\r\n                return mesh;\r\n            }\r\n            case AttachmentType.LinkedMesh: {\r\n                let path = input.readStringRef();\r\n                const color = input.readInt32();\r\n                const skinName = input.readStringRef();\r\n                const parent = input.readStringRef();\r\n                const inheritDeform = input.readBoolean();\r\n                let width = 0;\r\n                let height = 0;\r\n\r\n                if (nonessential) {\r\n                    width = input.readFloat();\r\n                    height = input.readFloat();\r\n                }\r\n\r\n                if (path == null) path = name;\r\n                const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\r\n\r\n                if (mesh == null) return null;\r\n                mesh.path = path;\r\n                Color.rgba8888ToColor(mesh.color, color);\r\n                if (nonessential) {\r\n                    mesh.width = width * scale;\r\n                    mesh.height = height * scale;\r\n                }\r\n                this.linkedMeshes.push(new LinkedMesh(mesh, skinName, slotIndex, parent, inheritDeform));\r\n\r\n                return mesh;\r\n            }\r\n            case AttachmentType.Path: {\r\n                const closed = input.readBoolean();\r\n                const constantSpeed = input.readBoolean();\r\n                const vertexCount = input.readInt(true);\r\n                const vertices = this.readVertices(input, vertexCount);\r\n                const lengths = Utils.newArray(vertexCount / 3, 0);\r\n\r\n                for (let i = 0, n = lengths.length; i < n; i++) lengths[i] = input.readFloat() * scale;\r\n                const color = nonessential ? input.readInt32() : 0;\r\n\r\n                const path = this.attachmentLoader.newPathAttachment(skin, name);\r\n\r\n                if (path == null) return null;\r\n                path.closed = closed;\r\n                path.constantSpeed = constantSpeed;\r\n                path.worldVerticesLength = vertexCount << 1;\r\n                path.vertices = vertices.vertices;\r\n                path.bones = vertices.bones;\r\n                path.lengths = lengths;\r\n                if (nonessential) Color.rgba8888ToColor(path.color, color);\r\n\r\n                return path;\r\n            }\r\n            case AttachmentType.Point: {\r\n                const rotation = input.readFloat();\r\n                const x = input.readFloat();\r\n                const y = input.readFloat();\r\n                const color = nonessential ? input.readInt32() : 0;\r\n\r\n                const point = this.attachmentLoader.newPointAttachment(skin, name);\r\n\r\n                if (point == null) return null;\r\n                point.x = x * scale;\r\n                point.y = y * scale;\r\n                point.rotation = rotation;\r\n                if (nonessential) Color.rgba8888ToColor(point.color, color);\r\n\r\n                return point;\r\n            }\r\n            case AttachmentType.Clipping: {\r\n                const endSlotIndex = input.readInt(true);\r\n                const vertexCount = input.readInt(true);\r\n                const vertices = this.readVertices(input, vertexCount);\r\n                const color = nonessential ? input.readInt32() : 0;\r\n\r\n                const clip = this.attachmentLoader.newClippingAttachment(skin, name);\r\n\r\n                if (clip == null) return null;\r\n                clip.endSlot = skeletonData.slots[endSlotIndex];\r\n                clip.worldVerticesLength = vertexCount << 1;\r\n                clip.vertices = vertices.vertices;\r\n                clip.bones = vertices.bones;\r\n                if (nonessential) Color.rgba8888ToColor(clip.color, color);\r\n\r\n                return clip;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private readVertices(input: BinaryInput, vertexCount: number): Vertices {\r\n        const verticesLength = vertexCount << 1;\r\n        const vertices = new Vertices();\r\n        const scale = this.scale;\r\n\r\n        if (!input.readBoolean()) {\r\n            vertices.vertices = this.readFloatArray(input, verticesLength, scale);\r\n\r\n            return vertices;\r\n        }\r\n        const weights = new Array<number>();\r\n        const bonesArray = new Array<number>();\r\n\r\n        for (let i = 0; i < vertexCount; i++) {\r\n            const boneCount = input.readInt(true);\r\n\r\n            bonesArray.push(boneCount);\r\n            for (let ii = 0; ii < boneCount; ii++) {\r\n                bonesArray.push(input.readInt(true));\r\n                weights.push(input.readFloat() * scale);\r\n                weights.push(input.readFloat() * scale);\r\n                weights.push(input.readFloat());\r\n            }\r\n        }\r\n        vertices.vertices = Utils.toFloatArray(weights);\r\n        vertices.bones = bonesArray;\r\n\r\n        return vertices;\r\n    }\r\n\r\n    private readFloatArray(input: BinaryInput, n: number, scale: number): number[] {\r\n        const array = new Array<number>(n);\r\n\r\n        if (scale == 1) {\r\n            for (let i = 0; i < n; i++) array[i] = input.readFloat();\r\n        } else {\r\n            for (let i = 0; i < n; i++) array[i] = input.readFloat() * scale;\r\n        }\r\n\r\n        return array;\r\n    }\r\n\r\n    private readShortArray(input: BinaryInput): number[] {\r\n        const n = input.readInt(true);\r\n        const array = new Array<number>(n);\r\n\r\n        for (let i = 0; i < n; i++) array[i] = input.readShort();\r\n\r\n        return array;\r\n    }\r\n\r\n    private readAnimation(input: BinaryInput, name: string, skeletonData: SkeletonData): Animation {\r\n        const timelines = new Array<Timeline>();\r\n        const scale = this.scale;\r\n        let duration = 0;\r\n        const tempColor1 = new Color();\r\n        const tempColor2 = new Color();\r\n\r\n        // Slot timelines.\r\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\r\n            const slotIndex = input.readInt(true);\r\n\r\n            for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\r\n                const timelineType = input.readByte();\r\n                const frameCount = input.readInt(true);\r\n\r\n                switch (timelineType) {\r\n                    case SkeletonBinary.SLOT_ATTACHMENT: {\r\n                        const timeline = new AttachmentTimeline(frameCount);\r\n\r\n                        timeline.slotIndex = slotIndex;\r\n                        for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) timeline.setFrame(frameIndex, input.readFloat(), input.readStringRef());\r\n                        timelines.push(timeline);\r\n                        duration = Math.max(duration, timeline.frames[frameCount - 1]);\r\n                        break;\r\n                    }\r\n                    case SkeletonBinary.SLOT_COLOR: {\r\n                        const timeline = new ColorTimeline(frameCount);\r\n\r\n                        timeline.slotIndex = slotIndex;\r\n                        for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n                            const time = input.readFloat();\r\n\r\n                            Color.rgba8888ToColor(tempColor1, input.readInt32());\r\n                            timeline.setFrame(frameIndex, time, tempColor1.r, tempColor1.g, tempColor1.b, tempColor1.a);\r\n                            if (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);\r\n                        }\r\n                        timelines.push(timeline);\r\n                        duration = Math.max(duration, timeline.frames[(frameCount - 1) * ColorTimeline.ENTRIES]);\r\n                        break;\r\n                    }\r\n                    case SkeletonBinary.SLOT_TWO_COLOR: {\r\n                        const timeline = new TwoColorTimeline(frameCount);\r\n\r\n                        timeline.slotIndex = slotIndex;\r\n                        for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n                            const time = input.readFloat();\r\n\r\n                            Color.rgba8888ToColor(tempColor1, input.readInt32());\r\n                            Color.rgb888ToColor(tempColor2, input.readInt32());\r\n                            timeline.setFrame(frameIndex, time, tempColor1.r, tempColor1.g, tempColor1.b, tempColor1.a, tempColor2.r, tempColor2.g, tempColor2.b);\r\n                            if (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);\r\n                        }\r\n                        timelines.push(timeline);\r\n                        duration = Math.max(duration, timeline.frames[(frameCount - 1) * TwoColorTimeline.ENTRIES]);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Bone timelines.\r\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\r\n            const boneIndex = input.readInt(true);\r\n\r\n            for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\r\n                const timelineType = input.readByte();\r\n                const frameCount = input.readInt(true);\r\n\r\n                switch (timelineType) {\r\n                    case SkeletonBinary.BONE_ROTATE: {\r\n                        const timeline = new RotateTimeline(frameCount);\r\n\r\n                        timeline.boneIndex = boneIndex;\r\n                        for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n                            timeline.setFrame(frameIndex, input.readFloat(), input.readFloat());\r\n                            if (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);\r\n                        }\r\n                        timelines.push(timeline);\r\n                        duration = Math.max(duration, timeline.frames[(frameCount - 1) * RotateTimeline.ENTRIES]);\r\n                        break;\r\n                    }\r\n                    case SkeletonBinary.BONE_TRANSLATE:\r\n                    case SkeletonBinary.BONE_SCALE:\r\n                    case SkeletonBinary.BONE_SHEAR: {\r\n                        let timeline;\r\n                        let timelineScale = 1;\r\n\r\n                        if (timelineType == SkeletonBinary.BONE_SCALE) timeline = new ScaleTimeline(frameCount);\r\n                        else if (timelineType == SkeletonBinary.BONE_SHEAR) timeline = new ShearTimeline(frameCount);\r\n                        else {\r\n                            timeline = new TranslateTimeline(frameCount);\r\n                            timelineScale = scale;\r\n                        }\r\n                        timeline.boneIndex = boneIndex;\r\n                        for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n                            timeline.setFrame(frameIndex, input.readFloat(), input.readFloat() * timelineScale, input.readFloat() * timelineScale);\r\n                            if (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);\r\n                        }\r\n                        timelines.push(timeline);\r\n                        duration = Math.max(duration, timeline.frames[(frameCount - 1) * TranslateTimeline.ENTRIES]);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // IK constraint timelines.\r\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\r\n            const index = input.readInt(true);\r\n            const frameCount = input.readInt(true);\r\n            const timeline = new IkConstraintTimeline(frameCount);\r\n\r\n            timeline.ikConstraintIndex = index;\r\n            for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n                timeline.setFrame(frameIndex, input.readFloat(), input.readFloat(), input.readFloat() * scale, input.readByte(), input.readBoolean(), input.readBoolean());\r\n                if (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);\r\n            }\r\n            timelines.push(timeline);\r\n            duration = Math.max(duration, timeline.frames[(frameCount - 1) * IkConstraintTimeline.ENTRIES]);\r\n        }\r\n\r\n        // Transform constraint timelines.\r\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\r\n            const index = input.readInt(true);\r\n            const frameCount = input.readInt(true);\r\n            const timeline = new TransformConstraintTimeline(frameCount);\r\n\r\n            timeline.transformConstraintIndex = index;\r\n            for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n                timeline.setFrame(frameIndex, input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat());\r\n                if (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);\r\n            }\r\n            timelines.push(timeline);\r\n            duration = Math.max(duration, timeline.frames[(frameCount - 1) * TransformConstraintTimeline.ENTRIES]);\r\n        }\r\n\r\n        // Path constraint timelines.\r\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\r\n            const index = input.readInt(true);\r\n            const data = skeletonData.pathConstraints[index];\r\n\r\n            for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\r\n                const timelineType = input.readByte();\r\n                const frameCount = input.readInt(true);\r\n\r\n                switch (timelineType) {\r\n                    case SkeletonBinary.PATH_POSITION:\r\n                    case SkeletonBinary.PATH_SPACING: {\r\n                        let timeline;\r\n                        let timelineScale = 1;\r\n\r\n                        if (timelineType == SkeletonBinary.PATH_SPACING) {\r\n                            timeline = new PathConstraintSpacingTimeline(frameCount);\r\n                            if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) timelineScale = scale;\r\n                        } else {\r\n                            timeline = new PathConstraintPositionTimeline(frameCount);\r\n                            if (data.positionMode == PositionMode.Fixed) timelineScale = scale;\r\n                        }\r\n                        timeline.pathConstraintIndex = index;\r\n                        for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n                            timeline.setFrame(frameIndex, input.readFloat(), input.readFloat() * timelineScale);\r\n                            if (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);\r\n                        }\r\n                        timelines.push(timeline);\r\n                        duration = Math.max(duration, timeline.frames[(frameCount - 1) * PathConstraintPositionTimeline.ENTRIES]);\r\n                        break;\r\n                    }\r\n                    case SkeletonBinary.PATH_MIX: {\r\n                        const timeline = new PathConstraintMixTimeline(frameCount);\r\n\r\n                        timeline.pathConstraintIndex = index;\r\n                        for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n                            timeline.setFrame(frameIndex, input.readFloat(), input.readFloat(), input.readFloat());\r\n                            if (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);\r\n                        }\r\n                        timelines.push(timeline);\r\n                        duration = Math.max(duration, timeline.frames[(frameCount - 1) * PathConstraintMixTimeline.ENTRIES]);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Deform timelines.\r\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\r\n            const skin = skeletonData.skins[input.readInt(true)];\r\n\r\n            for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\r\n                const slotIndex = input.readInt(true);\r\n\r\n                for (let iii = 0, nnn = input.readInt(true); iii < nnn; iii++) {\r\n                    const attachment = skin.getAttachment(slotIndex, input.readStringRef()) as VertexAttachment;\r\n                    const weighted = attachment.bones != null;\r\n                    const vertices = attachment.vertices;\r\n                    const deformLength = weighted ? (vertices.length / 3) * 2 : vertices.length;\r\n\r\n                    const frameCount = input.readInt(true);\r\n                    const timeline = new DeformTimeline(frameCount);\r\n\r\n                    timeline.slotIndex = slotIndex;\r\n                    timeline.attachment = attachment;\r\n\r\n                    for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n                        const time = input.readFloat();\r\n                        let deform;\r\n                        let end = input.readInt(true);\r\n\r\n                        if (end == 0) deform = weighted ? Utils.newFloatArray(deformLength) : vertices;\r\n                        else {\r\n                            deform = Utils.newFloatArray(deformLength);\r\n                            const start = input.readInt(true);\r\n\r\n                            end += start;\r\n                            if (scale == 1) {\r\n                                for (let v = start; v < end; v++) deform[v] = input.readFloat();\r\n                            } else {\r\n                                for (let v = start; v < end; v++) deform[v] = input.readFloat() * scale;\r\n                            }\r\n                            if (!weighted) {\r\n                                for (let v = 0, vn = deform.length; v < vn; v++) deform[v] += vertices[v];\r\n                            }\r\n                        }\r\n\r\n                        timeline.setFrame(frameIndex, time, deform);\r\n                        if (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);\r\n                    }\r\n                    timelines.push(timeline);\r\n                    duration = Math.max(duration, timeline.frames[frameCount - 1]);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Draw order timeline.\r\n        const drawOrderCount = input.readInt(true);\r\n\r\n        if (drawOrderCount > 0) {\r\n            const timeline = new DrawOrderTimeline(drawOrderCount);\r\n            const slotCount = skeletonData.slots.length;\r\n\r\n            for (let i = 0; i < drawOrderCount; i++) {\r\n                const time = input.readFloat();\r\n                const offsetCount = input.readInt(true);\r\n                const drawOrder = Utils.newArray(slotCount, 0);\r\n\r\n                for (let ii = slotCount - 1; ii >= 0; ii--) drawOrder[ii] = -1;\r\n                const unchanged = Utils.newArray(slotCount - offsetCount, 0);\r\n                let originalIndex = 0;\r\n                let unchangedIndex = 0;\r\n\r\n                for (let ii = 0; ii < offsetCount; ii++) {\r\n                    const slotIndex = input.readInt(true);\r\n                    // Collect unchanged items.\r\n\r\n                    while (originalIndex != slotIndex) unchanged[unchangedIndex++] = originalIndex++;\r\n                    // Set changed items.\r\n                    drawOrder[originalIndex + input.readInt(true)] = originalIndex++;\r\n                }\r\n                // Collect remaining unchanged items.\r\n                while (originalIndex < slotCount) unchanged[unchangedIndex++] = originalIndex++;\r\n                // Fill in unchanged items.\r\n                for (let ii = slotCount - 1; ii >= 0; ii--) if (drawOrder[ii] == -1) drawOrder[ii] = unchanged[--unchangedIndex];\r\n                timeline.setFrame(i, time, drawOrder);\r\n            }\r\n            timelines.push(timeline);\r\n            duration = Math.max(duration, timeline.frames[drawOrderCount - 1]);\r\n        }\r\n\r\n        // Event timeline.\r\n        const eventCount = input.readInt(true);\r\n\r\n        if (eventCount > 0) {\r\n            const timeline = new EventTimeline(eventCount);\r\n\r\n            for (let i = 0; i < eventCount; i++) {\r\n                const time = input.readFloat();\r\n                const eventData = skeletonData.events[input.readInt(true)];\r\n                const event = new Event(time, eventData);\r\n\r\n                event.intValue = input.readInt(false);\r\n                event.floatValue = input.readFloat();\r\n                event.stringValue = input.readBoolean() ? input.readString() : eventData.stringValue;\r\n                if (event.data.audioPath != null) {\r\n                    event.volume = input.readFloat();\r\n                    event.balance = input.readFloat();\r\n                }\r\n                timeline.setFrame(i, event);\r\n            }\r\n            timelines.push(timeline);\r\n            duration = Math.max(duration, timeline.frames[eventCount - 1]);\r\n        }\r\n\r\n        return new Animation(name, timelines, duration);\r\n    }\r\n\r\n    private readCurve(input: BinaryInput, frameIndex: number, timeline: CurveTimeline) {\r\n        switch (input.readByte()) {\r\n            case SkeletonBinary.CURVE_STEPPED:\r\n                timeline.setStepped(frameIndex);\r\n                break;\r\n            case SkeletonBinary.CURVE_BEZIER:\r\n                this.setCurve(timeline, frameIndex, input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat());\r\n                break;\r\n        }\r\n    }\r\n\r\n    setCurve(timeline: CurveTimeline, frameIndex: number, cx1: number, cy1: number, cx2: number, cy2: number) {\r\n        timeline.setCurve(frameIndex, cx1, cy1, cx2, cy2);\r\n    }\r\n}\r\n\r\nclass LinkedMesh {\r\n    parent: string;\r\n    skin: string;\r\n    slotIndex: number;\r\n    mesh: MeshAttachment;\r\n    inheritDeform: boolean;\r\n\r\n    constructor(mesh: MeshAttachment, skin: string, slotIndex: number, parent: string, inheritDeform: boolean) {\r\n        this.mesh = mesh;\r\n        this.skin = skin;\r\n        this.slotIndex = slotIndex;\r\n        this.parent = parent;\r\n        this.inheritDeform = inheritDeform;\r\n    }\r\n}\r\n\r\nclass Vertices {\r\n    constructor(public bones: Array<number> = null, public vertices: Array<number> | Float32Array = null) {}\r\n}\r\n","import type { BoundingBoxAttachment } from './attachments';\r\nimport { SkeletonBoundsBase } from '@pixi-spine/base';\r\n\r\n/** Collects each visible {@link BoundingBoxAttachment} and computes the world vertices for its polygon. The polygon vertices are\r\n * provided along with convenience methods for doing hit detection.\r\n * @public\r\n * */\r\nexport class SkeletonBounds extends SkeletonBoundsBase<BoundingBoxAttachment> {}\r\n","import type { Attachment, AttachmentLoader, MeshAttachment, VertexAttachment } from './attachments';\r\nimport { Event } from './Event';\r\nimport { SkeletonData } from './SkeletonData';\r\nimport { SlotData } from './SlotData';\r\nimport { BoneData } from './BoneData';\r\nimport { IkConstraintData } from './IkConstraintData';\r\nimport { TransformConstraintData } from './TransformConstraintData';\r\nimport { PathConstraintData, SpacingMode } from './PathConstraintData';\r\nimport { Skin } from './Skin';\r\nimport { EventData } from './EventData';\r\nimport {\r\n    Animation,\r\n    AttachmentTimeline,\r\n    ColorTimeline,\r\n    CurveTimeline,\r\n    DeformTimeline,\r\n    DrawOrderTimeline,\r\n    EventTimeline,\r\n    IkConstraintTimeline,\r\n    PathConstraintMixTimeline,\r\n    PathConstraintPositionTimeline,\r\n    PathConstraintSpacingTimeline,\r\n    RotateTimeline,\r\n    ScaleTimeline,\r\n    ShearTimeline,\r\n    Timeline,\r\n    TransformConstraintTimeline,\r\n    TranslateTimeline,\r\n    TwoColorTimeline,\r\n} from './Animation';\r\nimport { ArrayLike, Color, PositionMode, RotateMode, TransformMode, Utils, settings } from '@pixi-spine/base';\r\nimport { BLEND_MODES } from '@pixi/core';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class SkeletonJson {\r\n    attachmentLoader: AttachmentLoader;\r\n    scale = 1;\r\n    private linkedMeshes = new Array<LinkedMesh>();\r\n\r\n    constructor(attachmentLoader: AttachmentLoader) {\r\n        this.attachmentLoader = attachmentLoader;\r\n    }\r\n\r\n    readSkeletonData(json: string | any): SkeletonData {\r\n        const scale = this.scale;\r\n        const skeletonData = new SkeletonData();\r\n        const root = typeof json === 'string' ? JSON.parse(json) : json;\r\n\r\n        // Skeleton\r\n        const skeletonMap = root.skeleton;\r\n\r\n        if (skeletonMap != null) {\r\n            skeletonData.hash = skeletonMap.hash;\r\n            skeletonData.version = skeletonMap.spine;\r\n            if (skeletonData.version.substr(0, 3) !== '3.8') {\r\n                const error = `Spine 3.8 loader cant load version ${skeletonMap.spine}. Please configure your pixi-spine bundle`;\r\n\r\n                console.error(error);\r\n            }\r\n            if (skeletonData.version === '3.8.75') {\r\n                const error = `Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine.`;\r\n\r\n                console.error(error);\r\n            }\r\n            skeletonData.x = skeletonMap.x;\r\n            skeletonData.y = skeletonMap.y;\r\n            skeletonData.width = skeletonMap.width;\r\n            skeletonData.height = skeletonMap.height;\r\n            skeletonData.fps = skeletonMap.fps;\r\n            skeletonData.imagesPath = skeletonMap.images;\r\n        }\r\n\r\n        // Bones\r\n        if (root.bones) {\r\n            for (let i = 0; i < root.bones.length; i++) {\r\n                const boneMap = root.bones[i];\r\n\r\n                let parent: BoneData = null;\r\n                const parentName: string = this.getValue(boneMap, 'parent', null);\r\n\r\n                if (parentName != null) {\r\n                    parent = skeletonData.findBone(parentName);\r\n                    if (parent == null) throw new Error(`Parent bone not found: ${parentName}`);\r\n                }\r\n                const data = new BoneData(skeletonData.bones.length, boneMap.name, parent);\r\n\r\n                data.length = this.getValue(boneMap, 'length', 0) * scale;\r\n                data.x = this.getValue(boneMap, 'x', 0) * scale;\r\n                data.y = this.getValue(boneMap, 'y', 0) * scale;\r\n                data.rotation = this.getValue(boneMap, 'rotation', 0);\r\n                data.scaleX = this.getValue(boneMap, 'scaleX', 1);\r\n                data.scaleY = this.getValue(boneMap, 'scaleY', 1);\r\n                data.shearX = this.getValue(boneMap, 'shearX', 0);\r\n                data.shearY = this.getValue(boneMap, 'shearY', 0);\r\n                data.transformMode = SkeletonJson.transformModeFromString(this.getValue(boneMap, 'transform', 'normal'));\r\n                data.skinRequired = this.getValue(boneMap, 'skin', false);\r\n\r\n                skeletonData.bones.push(data);\r\n            }\r\n        }\r\n\r\n        // Slots.\r\n        if (root.slots) {\r\n            for (let i = 0; i < root.slots.length; i++) {\r\n                const slotMap = root.slots[i];\r\n                const slotName: string = slotMap.name;\r\n                const boneName: string = slotMap.bone;\r\n                const boneData = skeletonData.findBone(boneName);\r\n\r\n                if (boneData == null) throw new Error(`Slot bone not found: ${boneName}`);\r\n                const data = new SlotData(skeletonData.slots.length, slotName, boneData);\r\n\r\n                const color: string = this.getValue(slotMap, 'color', null);\r\n\r\n                if (color != null) data.color.setFromString(color);\r\n\r\n                const dark: string = this.getValue(slotMap, 'dark', null);\r\n\r\n                if (dark != null) {\r\n                    data.darkColor = new Color(1, 1, 1, 1);\r\n                    data.darkColor.setFromString(dark);\r\n                }\r\n\r\n                data.attachmentName = this.getValue(slotMap, 'attachment', null);\r\n                data.blendMode = SkeletonJson.blendModeFromString(this.getValue(slotMap, 'blend', 'normal'));\r\n                skeletonData.slots.push(data);\r\n            }\r\n        }\r\n\r\n        // IK constraints\r\n        if (root.ik) {\r\n            for (let i = 0; i < root.ik.length; i++) {\r\n                const constraintMap = root.ik[i];\r\n                const data = new IkConstraintData(constraintMap.name);\r\n\r\n                data.order = this.getValue(constraintMap, 'order', 0);\r\n                data.skinRequired = this.getValue(constraintMap, 'skin', false);\r\n\r\n                for (let j = 0; j < constraintMap.bones.length; j++) {\r\n                    const boneName = constraintMap.bones[j];\r\n                    const bone = skeletonData.findBone(boneName);\r\n\r\n                    if (bone == null) throw new Error(`IK bone not found: ${boneName}`);\r\n                    data.bones.push(bone);\r\n                }\r\n\r\n                const targetName: string = constraintMap.target;\r\n\r\n                data.target = skeletonData.findBone(targetName);\r\n                if (data.target == null) throw new Error(`IK target bone not found: ${targetName}`);\r\n\r\n                data.mix = this.getValue(constraintMap, 'mix', 1);\r\n                data.softness = this.getValue(constraintMap, 'softness', 0) * scale;\r\n                data.bendDirection = this.getValue(constraintMap, 'bendPositive', true) ? 1 : -1;\r\n                data.compress = this.getValue(constraintMap, 'compress', false);\r\n                data.stretch = this.getValue(constraintMap, 'stretch', false);\r\n                data.uniform = this.getValue(constraintMap, 'uniform', false);\r\n\r\n                skeletonData.ikConstraints.push(data);\r\n            }\r\n        }\r\n\r\n        // Transform constraints.\r\n        if (root.transform) {\r\n            for (let i = 0; i < root.transform.length; i++) {\r\n                const constraintMap = root.transform[i];\r\n                const data = new TransformConstraintData(constraintMap.name);\r\n\r\n                data.order = this.getValue(constraintMap, 'order', 0);\r\n                data.skinRequired = this.getValue(constraintMap, 'skin', false);\r\n\r\n                for (let j = 0; j < constraintMap.bones.length; j++) {\r\n                    const boneName = constraintMap.bones[j];\r\n                    const bone = skeletonData.findBone(boneName);\r\n\r\n                    if (bone == null) throw new Error(`Transform constraint bone not found: ${boneName}`);\r\n                    data.bones.push(bone);\r\n                }\r\n\r\n                const targetName: string = constraintMap.target;\r\n\r\n                data.target = skeletonData.findBone(targetName);\r\n                if (data.target == null) throw new Error(`Transform constraint target bone not found: ${targetName}`);\r\n\r\n                data.local = this.getValue(constraintMap, 'local', false);\r\n                data.relative = this.getValue(constraintMap, 'relative', false);\r\n                data.offsetRotation = this.getValue(constraintMap, 'rotation', 0);\r\n                data.offsetX = this.getValue(constraintMap, 'x', 0) * scale;\r\n                data.offsetY = this.getValue(constraintMap, 'y', 0) * scale;\r\n                data.offsetScaleX = this.getValue(constraintMap, 'scaleX', 0);\r\n                data.offsetScaleY = this.getValue(constraintMap, 'scaleY', 0);\r\n                data.offsetShearY = this.getValue(constraintMap, 'shearY', 0);\r\n\r\n                data.rotateMix = this.getValue(constraintMap, 'rotateMix', 1);\r\n                data.translateMix = this.getValue(constraintMap, 'translateMix', 1);\r\n                data.scaleMix = this.getValue(constraintMap, 'scaleMix', 1);\r\n                data.shearMix = this.getValue(constraintMap, 'shearMix', 1);\r\n\r\n                skeletonData.transformConstraints.push(data);\r\n            }\r\n        }\r\n\r\n        // Path constraints.\r\n        if (root.path) {\r\n            for (let i = 0; i < root.path.length; i++) {\r\n                const constraintMap = root.path[i];\r\n                const data = new PathConstraintData(constraintMap.name);\r\n\r\n                data.order = this.getValue(constraintMap, 'order', 0);\r\n                data.skinRequired = this.getValue(constraintMap, 'skin', false);\r\n\r\n                for (let j = 0; j < constraintMap.bones.length; j++) {\r\n                    const boneName = constraintMap.bones[j];\r\n                    const bone = skeletonData.findBone(boneName);\r\n\r\n                    if (bone == null) throw new Error(`Transform constraint bone not found: ${boneName}`);\r\n                    data.bones.push(bone);\r\n                }\r\n\r\n                const targetName: string = constraintMap.target;\r\n\r\n                data.target = skeletonData.findSlot(targetName);\r\n                if (data.target == null) throw new Error(`Path target slot not found: ${targetName}`);\r\n\r\n                data.positionMode = SkeletonJson.positionModeFromString(this.getValue(constraintMap, 'positionMode', 'percent'));\r\n                data.spacingMode = SkeletonJson.spacingModeFromString(this.getValue(constraintMap, 'spacingMode', 'length'));\r\n                data.rotateMode = SkeletonJson.rotateModeFromString(this.getValue(constraintMap, 'rotateMode', 'tangent'));\r\n                data.offsetRotation = this.getValue(constraintMap, 'rotation', 0);\r\n                data.position = this.getValue(constraintMap, 'position', 0);\r\n                if (data.positionMode == PositionMode.Fixed) data.position *= scale;\r\n                data.spacing = this.getValue(constraintMap, 'spacing', 0);\r\n                if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) data.spacing *= scale;\r\n                data.rotateMix = this.getValue(constraintMap, 'rotateMix', 1);\r\n                data.translateMix = this.getValue(constraintMap, 'translateMix', 1);\r\n\r\n                skeletonData.pathConstraints.push(data);\r\n            }\r\n        }\r\n\r\n        // Skins.\r\n        if (root.skins) {\r\n            for (let i = 0; i < root.skins.length; i++) {\r\n                const skinMap = root.skins[i];\r\n                const skin = new Skin(skinMap.name);\r\n\r\n                if (skinMap.bones) {\r\n                    for (let ii = 0; ii < skinMap.bones.length; ii++) {\r\n                        const bone = skeletonData.findBone(skinMap.bones[ii]);\r\n\r\n                        if (bone == null) throw new Error(`Skin bone not found: ${skinMap.bones[i]}`);\r\n                        skin.bones.push(bone);\r\n                    }\r\n                }\r\n\r\n                if (skinMap.ik) {\r\n                    for (let ii = 0; ii < skinMap.ik.length; ii++) {\r\n                        const constraint = skeletonData.findIkConstraint(skinMap.ik[ii]);\r\n\r\n                        if (constraint == null) throw new Error(`Skin IK constraint not found: ${skinMap.ik[i]}`);\r\n                        skin.constraints.push(constraint);\r\n                    }\r\n                }\r\n\r\n                if (skinMap.transform) {\r\n                    for (let ii = 0; ii < skinMap.transform.length; ii++) {\r\n                        const constraint = skeletonData.findTransformConstraint(skinMap.transform[ii]);\r\n\r\n                        if (constraint == null) throw new Error(`Skin transform constraint not found: ${skinMap.transform[i]}`);\r\n                        skin.constraints.push(constraint);\r\n                    }\r\n                }\r\n\r\n                if (skinMap.path) {\r\n                    for (let ii = 0; ii < skinMap.path.length; ii++) {\r\n                        const constraint = skeletonData.findPathConstraint(skinMap.path[ii]);\r\n\r\n                        if (constraint == null) throw new Error(`Skin path constraint not found: ${skinMap.path[i]}`);\r\n                        skin.constraints.push(constraint);\r\n                    }\r\n                }\r\n\r\n                for (const slotName in skinMap.attachments) {\r\n                    const slot = skeletonData.findSlot(slotName);\r\n\r\n                    if (slot == null) throw new Error(`Slot not found: ${slotName}`);\r\n                    const slotMap = skinMap.attachments[slotName];\r\n\r\n                    for (const entryName in slotMap) {\r\n                        const attachment = this.readAttachment(slotMap[entryName], skin, slot.index, entryName, skeletonData);\r\n\r\n                        if (attachment != null) skin.setAttachment(slot.index, entryName, attachment);\r\n                    }\r\n                }\r\n                skeletonData.skins.push(skin);\r\n                if (skin.name == 'default') skeletonData.defaultSkin = skin;\r\n            }\r\n        }\r\n\r\n        // Linked meshes.\r\n        for (let i = 0, n = this.linkedMeshes.length; i < n; i++) {\r\n            const linkedMesh = this.linkedMeshes[i];\r\n            const skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\r\n\r\n            if (skin == null) throw new Error(`Skin not found: ${linkedMesh.skin}`);\r\n            const parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\r\n\r\n            if (parent == null) throw new Error(`Parent mesh not found: ${linkedMesh.parent}`);\r\n            linkedMesh.mesh.deformAttachment = linkedMesh.inheritDeform ? <VertexAttachment>parent : <VertexAttachment>linkedMesh.mesh;\r\n            linkedMesh.mesh.setParentMesh(<MeshAttachment>parent);\r\n            // linkedMesh.mesh.updateUVs();\r\n        }\r\n        this.linkedMeshes.length = 0;\r\n\r\n        // Events.\r\n        if (root.events) {\r\n            for (const eventName in root.events) {\r\n                const eventMap = root.events[eventName];\r\n                const data = new EventData(eventName);\r\n\r\n                data.intValue = this.getValue(eventMap, 'int', 0);\r\n                data.floatValue = this.getValue(eventMap, 'float', 0);\r\n                data.stringValue = this.getValue(eventMap, 'string', '');\r\n                data.audioPath = this.getValue(eventMap, 'audio', null);\r\n                if (data.audioPath != null) {\r\n                    data.volume = this.getValue(eventMap, 'volume', 1);\r\n                    data.balance = this.getValue(eventMap, 'balance', 0);\r\n                }\r\n                skeletonData.events.push(data);\r\n            }\r\n        }\r\n\r\n        // Animations.\r\n        if (root.animations) {\r\n            for (const animationName in root.animations) {\r\n                const animationMap = root.animations[animationName];\r\n\r\n                this.readAnimation(animationMap, animationName, skeletonData);\r\n            }\r\n        }\r\n\r\n        return skeletonData;\r\n    }\r\n\r\n    readAttachment(map: any, skin: Skin, slotIndex: number, name: string, skeletonData: SkeletonData): Attachment {\r\n        const scale = this.scale;\r\n\r\n        name = this.getValue(map, 'name', name);\r\n\r\n        const type = this.getValue(map, 'type', 'region');\r\n\r\n        switch (type) {\r\n            case 'region': {\r\n                const path = this.getValue(map, 'path', name);\r\n                const region = this.attachmentLoader.newRegionAttachment(skin, name, path);\r\n\r\n                if (region == null) return null;\r\n                region.path = path;\r\n                region.x = this.getValue(map, 'x', 0) * scale;\r\n                region.y = this.getValue(map, 'y', 0) * scale;\r\n                region.scaleX = this.getValue(map, 'scaleX', 1);\r\n                region.scaleY = this.getValue(map, 'scaleY', 1);\r\n                region.rotation = this.getValue(map, 'rotation', 0);\r\n                region.width = map.width * scale;\r\n                region.height = map.height * scale;\r\n\r\n                const color: string = this.getValue(map, 'color', null);\r\n\r\n                if (color != null) region.color.setFromString(color);\r\n\r\n                // region.updateOffset();\r\n                return region;\r\n            }\r\n            case 'boundingbox': {\r\n                const box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\r\n\r\n                if (box == null) return null;\r\n                this.readVertices(map, box, map.vertexCount << 1);\r\n                const color: string = this.getValue(map, 'color', null);\r\n\r\n                if (color != null) box.color.setFromString(color);\r\n\r\n                return box;\r\n            }\r\n            case 'mesh':\r\n            case 'linkedmesh': {\r\n                const path = this.getValue(map, 'path', name);\r\n                const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\r\n\r\n                if (mesh == null) return null;\r\n                mesh.path = path;\r\n\r\n                const color = this.getValue(map, 'color', null);\r\n\r\n                if (color != null) mesh.color.setFromString(color);\r\n\r\n                mesh.width = this.getValue(map, 'width', 0) * scale;\r\n                mesh.height = this.getValue(map, 'height', 0) * scale;\r\n\r\n                const parent: string = this.getValue(map, 'parent', null);\r\n\r\n                if (parent != null) {\r\n                    this.linkedMeshes.push(new LinkedMesh(mesh, <string>this.getValue(map, 'skin', null), slotIndex, parent, this.getValue(map, 'deform', true)));\r\n\r\n                    return mesh;\r\n                }\r\n\r\n                const uvs: Array<number> = map.uvs;\r\n\r\n                this.readVertices(map, mesh, uvs.length);\r\n                mesh.triangles = map.triangles;\r\n                mesh.regionUVs = new Float32Array(uvs);\r\n                // mesh.updateUVs();\r\n\r\n                mesh.edges = this.getValue(map, 'edges', null);\r\n                mesh.hullLength = this.getValue(map, 'hull', 0) * 2;\r\n\r\n                return mesh;\r\n            }\r\n            case 'path': {\r\n                const path = this.attachmentLoader.newPathAttachment(skin, name);\r\n\r\n                if (path == null) return null;\r\n                path.closed = this.getValue(map, 'closed', false);\r\n                path.constantSpeed = this.getValue(map, 'constantSpeed', true);\r\n\r\n                const vertexCount = map.vertexCount;\r\n\r\n                this.readVertices(map, path, vertexCount << 1);\r\n\r\n                const lengths: Array<number> = Utils.newArray(vertexCount / 3, 0);\r\n\r\n                for (let i = 0; i < map.lengths.length; i++) lengths[i] = map.lengths[i] * scale;\r\n                path.lengths = lengths;\r\n\r\n                const color: string = this.getValue(map, 'color', null);\r\n\r\n                if (color != null) path.color.setFromString(color);\r\n\r\n                return path;\r\n            }\r\n            case 'point': {\r\n                const point = this.attachmentLoader.newPointAttachment(skin, name);\r\n\r\n                if (point == null) return null;\r\n                point.x = this.getValue(map, 'x', 0) * scale;\r\n                point.y = this.getValue(map, 'y', 0) * scale;\r\n                point.rotation = this.getValue(map, 'rotation', 0);\r\n\r\n                const color = this.getValue(map, 'color', null);\r\n\r\n                if (color != null) point.color.setFromString(color);\r\n\r\n                return point;\r\n            }\r\n            case 'clipping': {\r\n                const clip = this.attachmentLoader.newClippingAttachment(skin, name);\r\n\r\n                if (clip == null) return null;\r\n\r\n                const end = this.getValue(map, 'end', null);\r\n\r\n                if (end != null) {\r\n                    const slot = skeletonData.findSlot(end);\r\n\r\n                    if (slot == null) throw new Error(`Clipping end slot not found: ${end}`);\r\n                    clip.endSlot = slot;\r\n                }\r\n\r\n                const vertexCount = map.vertexCount;\r\n\r\n                this.readVertices(map, clip, vertexCount << 1);\r\n\r\n                const color: string = this.getValue(map, 'color', null);\r\n\r\n                if (color != null) clip.color.setFromString(color);\r\n\r\n                return clip;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    readVertices(map: any, attachment: VertexAttachment, verticesLength: number) {\r\n        const scale = this.scale;\r\n\r\n        attachment.worldVerticesLength = verticesLength;\r\n        const vertices: Array<number> = map.vertices;\r\n\r\n        if (verticesLength == vertices.length) {\r\n            const scaledVertices = Utils.toFloatArray(vertices);\r\n\r\n            if (scale != 1) {\r\n                for (let i = 0, n = vertices.length; i < n; i++) scaledVertices[i] *= scale;\r\n            }\r\n            attachment.vertices = scaledVertices;\r\n\r\n            return;\r\n        }\r\n        const weights = new Array<number>();\r\n        const bones = new Array<number>();\r\n\r\n        for (let i = 0, n = vertices.length; i < n; ) {\r\n            const boneCount = vertices[i++];\r\n\r\n            bones.push(boneCount);\r\n            for (let nn = i + boneCount * 4; i < nn; i += 4) {\r\n                bones.push(vertices[i]);\r\n                weights.push(vertices[i + 1] * scale);\r\n                weights.push(vertices[i + 2] * scale);\r\n                weights.push(vertices[i + 3]);\r\n            }\r\n        }\r\n        attachment.bones = bones;\r\n        attachment.vertices = Utils.toFloatArray(weights);\r\n    }\r\n\r\n    readAnimation(map: any, name: string, skeletonData: SkeletonData) {\r\n        const scale = this.scale;\r\n        const timelines = new Array<Timeline>();\r\n        let duration = 0;\r\n\r\n        // Slot timelines.\r\n        if (map.slots) {\r\n            for (const slotName in map.slots) {\r\n                const slotMap = map.slots[slotName];\r\n                const slotIndex = skeletonData.findSlotIndex(slotName);\r\n\r\n                if (slotIndex == -1) throw new Error(`Slot not found: ${slotName}`);\r\n                for (const timelineName in slotMap) {\r\n                    const timelineMap = slotMap[timelineName];\r\n\r\n                    if (timelineName == 'attachment') {\r\n                        const timeline = new AttachmentTimeline(timelineMap.length);\r\n\r\n                        timeline.slotIndex = slotIndex;\r\n\r\n                        let frameIndex = 0;\r\n\r\n                        for (let i = 0; i < timelineMap.length; i++) {\r\n                            const valueMap = timelineMap[i];\r\n\r\n                            timeline.setFrame(frameIndex++, this.getValue(valueMap, 'time', 0), valueMap.name);\r\n                        }\r\n                        timelines.push(timeline);\r\n                        duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n                    } else if (timelineName == 'color') {\r\n                        const timeline = new ColorTimeline(timelineMap.length);\r\n\r\n                        timeline.slotIndex = slotIndex;\r\n\r\n                        let frameIndex = 0;\r\n\r\n                        for (let i = 0; i < timelineMap.length; i++) {\r\n                            const valueMap = timelineMap[i];\r\n                            const color = new Color();\r\n\r\n                            color.setFromString(valueMap.color || 'ffffffff');\r\n                            timeline.setFrame(frameIndex, this.getValue(valueMap, 'time', 0), color.r, color.g, color.b, color.a);\r\n                            this.readCurve(valueMap, timeline, frameIndex);\r\n                            frameIndex++;\r\n                        }\r\n                        timelines.push(timeline);\r\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * ColorTimeline.ENTRIES]);\r\n                    } else if (timelineName == 'twoColor') {\r\n                        const timeline = new TwoColorTimeline(timelineMap.length);\r\n\r\n                        timeline.slotIndex = slotIndex;\r\n\r\n                        let frameIndex = 0;\r\n\r\n                        for (let i = 0; i < timelineMap.length; i++) {\r\n                            const valueMap = timelineMap[i];\r\n                            const light = new Color();\r\n                            const dark = new Color();\r\n\r\n                            light.setFromString(valueMap.light);\r\n                            dark.setFromString(valueMap.dark);\r\n                            timeline.setFrame(frameIndex, this.getValue(valueMap, 'time', 0), light.r, light.g, light.b, light.a, dark.r, dark.g, dark.b);\r\n                            this.readCurve(valueMap, timeline, frameIndex);\r\n                            frameIndex++;\r\n                        }\r\n                        timelines.push(timeline);\r\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TwoColorTimeline.ENTRIES]);\r\n                    } else throw new Error(`Invalid timeline type for a slot: ${timelineName} (${slotName})`);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Bone timelines.\r\n        if (map.bones) {\r\n            for (const boneName in map.bones) {\r\n                const boneMap = map.bones[boneName];\r\n                const boneIndex = skeletonData.findBoneIndex(boneName);\r\n\r\n                if (boneIndex == -1) throw new Error(`Bone not found: ${boneName}`);\r\n                for (const timelineName in boneMap) {\r\n                    const timelineMap = boneMap[timelineName];\r\n\r\n                    if (timelineName === 'rotate') {\r\n                        const timeline = new RotateTimeline(timelineMap.length);\r\n\r\n                        timeline.boneIndex = boneIndex;\r\n\r\n                        let frameIndex = 0;\r\n\r\n                        for (let i = 0; i < timelineMap.length; i++) {\r\n                            const valueMap = timelineMap[i];\r\n\r\n                            timeline.setFrame(frameIndex, this.getValue(valueMap, 'time', 0), this.getValue(valueMap, 'angle', 0));\r\n                            this.readCurve(valueMap, timeline, frameIndex);\r\n                            frameIndex++;\r\n                        }\r\n                        timelines.push(timeline);\r\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * RotateTimeline.ENTRIES]);\r\n                    } else if (timelineName === 'translate' || timelineName === 'scale' || timelineName === 'shear') {\r\n                        let timeline: TranslateTimeline = null;\r\n                        let timelineScale = 1;\r\n                        let defaultValue = 0;\r\n\r\n                        if (timelineName === 'scale') {\r\n                            timeline = new ScaleTimeline(timelineMap.length);\r\n                            defaultValue = 1;\r\n                        } else if (timelineName === 'shear') timeline = new ShearTimeline(timelineMap.length);\r\n                        else {\r\n                            timeline = new TranslateTimeline(timelineMap.length);\r\n                            timelineScale = scale;\r\n                        }\r\n                        timeline.boneIndex = boneIndex;\r\n\r\n                        let frameIndex = 0;\r\n\r\n                        for (let i = 0; i < timelineMap.length; i++) {\r\n                            const valueMap = timelineMap[i];\r\n                            const x = this.getValue(valueMap, 'x', defaultValue);\r\n                            const y = this.getValue(valueMap, 'y', defaultValue);\r\n\r\n                            timeline.setFrame(frameIndex, this.getValue(valueMap, 'time', 0), x * timelineScale, y * timelineScale);\r\n                            this.readCurve(valueMap, timeline, frameIndex);\r\n                            frameIndex++;\r\n                        }\r\n                        timelines.push(timeline);\r\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TranslateTimeline.ENTRIES]);\r\n                    } else throw new Error(`Invalid timeline type for a bone: ${timelineName} (${boneName})`);\r\n                }\r\n            }\r\n        }\r\n\r\n        // IK constraint timelines.\r\n        if (map.ik) {\r\n            for (const constraintName in map.ik) {\r\n                const constraintMap = map.ik[constraintName];\r\n                const constraint = skeletonData.findIkConstraint(constraintName);\r\n                const timeline = new IkConstraintTimeline(constraintMap.length);\r\n\r\n                timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(constraint);\r\n                let frameIndex = 0;\r\n\r\n                for (let i = 0; i < constraintMap.length; i++) {\r\n                    const valueMap = constraintMap[i];\r\n\r\n                    timeline.setFrame(\r\n                        frameIndex,\r\n                        this.getValue(valueMap, 'time', 0),\r\n                        this.getValue(valueMap, 'mix', 1),\r\n                        this.getValue(valueMap, 'softness', 0) * scale,\r\n                        this.getValue(valueMap, 'bendPositive', true) ? 1 : -1,\r\n                        this.getValue(valueMap, 'compress', false),\r\n                        this.getValue(valueMap, 'stretch', false)\r\n                    );\r\n                    this.readCurve(valueMap, timeline, frameIndex);\r\n                    frameIndex++;\r\n                }\r\n                timelines.push(timeline);\r\n                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * IkConstraintTimeline.ENTRIES]);\r\n            }\r\n        }\r\n\r\n        // Transform constraint timelines.\r\n        if (map.transform) {\r\n            for (const constraintName in map.transform) {\r\n                const constraintMap = map.transform[constraintName];\r\n                const constraint = skeletonData.findTransformConstraint(constraintName);\r\n                const timeline = new TransformConstraintTimeline(constraintMap.length);\r\n\r\n                timeline.transformConstraintIndex = skeletonData.transformConstraints.indexOf(constraint);\r\n                let frameIndex = 0;\r\n\r\n                for (let i = 0; i < constraintMap.length; i++) {\r\n                    const valueMap = constraintMap[i];\r\n\r\n                    timeline.setFrame(\r\n                        frameIndex,\r\n                        this.getValue(valueMap, 'time', 0),\r\n                        this.getValue(valueMap, 'rotateMix', 1),\r\n                        this.getValue(valueMap, 'translateMix', 1),\r\n                        this.getValue(valueMap, 'scaleMix', 1),\r\n                        this.getValue(valueMap, 'shearMix', 1)\r\n                    );\r\n                    this.readCurve(valueMap, timeline, frameIndex);\r\n                    frameIndex++;\r\n                }\r\n                timelines.push(timeline);\r\n                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TransformConstraintTimeline.ENTRIES]);\r\n            }\r\n        }\r\n\r\n        // Path constraint timelines.\r\n        if (map.path) {\r\n            for (const constraintName in map.path) {\r\n                const constraintMap = map.path[constraintName];\r\n                const index = skeletonData.findPathConstraintIndex(constraintName);\r\n\r\n                if (index == -1) throw new Error(`Path constraint not found: ${constraintName}`);\r\n                const data = skeletonData.pathConstraints[index];\r\n\r\n                for (const timelineName in constraintMap) {\r\n                    const timelineMap = constraintMap[timelineName];\r\n\r\n                    if (timelineName === 'position' || timelineName === 'spacing') {\r\n                        let timeline: PathConstraintPositionTimeline = null;\r\n                        let timelineScale = 1;\r\n\r\n                        if (timelineName === 'spacing') {\r\n                            timeline = new PathConstraintSpacingTimeline(timelineMap.length);\r\n                            if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) timelineScale = scale;\r\n                        } else {\r\n                            timeline = new PathConstraintPositionTimeline(timelineMap.length);\r\n                            if (data.positionMode == PositionMode.Fixed) timelineScale = scale;\r\n                        }\r\n                        timeline.pathConstraintIndex = index;\r\n                        let frameIndex = 0;\r\n\r\n                        for (let i = 0; i < timelineMap.length; i++) {\r\n                            const valueMap = timelineMap[i];\r\n\r\n                            timeline.setFrame(frameIndex, this.getValue(valueMap, 'time', 0), this.getValue(valueMap, timelineName, 0) * timelineScale);\r\n                            this.readCurve(valueMap, timeline, frameIndex);\r\n                            frameIndex++;\r\n                        }\r\n                        timelines.push(timeline);\r\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * PathConstraintPositionTimeline.ENTRIES]);\r\n                    } else if (timelineName === 'mix') {\r\n                        const timeline = new PathConstraintMixTimeline(timelineMap.length);\r\n\r\n                        timeline.pathConstraintIndex = index;\r\n                        let frameIndex = 0;\r\n\r\n                        for (let i = 0; i < timelineMap.length; i++) {\r\n                            const valueMap = timelineMap[i];\r\n\r\n                            timeline.setFrame(frameIndex, this.getValue(valueMap, 'time', 0), this.getValue(valueMap, 'rotateMix', 1), this.getValue(valueMap, 'translateMix', 1));\r\n                            this.readCurve(valueMap, timeline, frameIndex);\r\n                            frameIndex++;\r\n                        }\r\n                        timelines.push(timeline);\r\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * PathConstraintMixTimeline.ENTRIES]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Deform timelines.\r\n        if (map.deform) {\r\n            for (const deformName in map.deform) {\r\n                const deformMap = map.deform[deformName];\r\n                const skin = skeletonData.findSkin(deformName);\r\n\r\n                if (skin == null) {\r\n                    if (settings.FAIL_ON_NON_EXISTING_SKIN) {\r\n                        throw new Error(`Skin not found: ${deformName}`);\r\n                    } else {\r\n                        continue;\r\n                    }\r\n                }\r\n                for (const slotName in deformMap) {\r\n                    const slotMap = deformMap[slotName];\r\n                    const slotIndex = skeletonData.findSlotIndex(slotName);\r\n\r\n                    if (slotIndex == -1) throw new Error(`Slot not found: ${slotMap.name}`);\r\n                    for (const timelineName in slotMap) {\r\n                        const timelineMap = slotMap[timelineName];\r\n                        const attachment = <VertexAttachment>skin.getAttachment(slotIndex, timelineName);\r\n\r\n                        if (attachment == null) throw new Error(`Deform attachment not found: ${timelineMap.name}`);\r\n                        const weighted = attachment.bones != null;\r\n                        const vertices = attachment.vertices;\r\n                        const deformLength = weighted ? (vertices.length / 3) * 2 : vertices.length;\r\n\r\n                        const timeline = new DeformTimeline(timelineMap.length);\r\n\r\n                        timeline.slotIndex = slotIndex;\r\n                        timeline.attachment = attachment;\r\n\r\n                        let frameIndex = 0;\r\n\r\n                        for (let j = 0; j < timelineMap.length; j++) {\r\n                            const valueMap = timelineMap[j];\r\n                            let deform: ArrayLike<number>;\r\n                            const verticesValue: Array<Number> = this.getValue(valueMap, 'vertices', null);\r\n\r\n                            if (verticesValue == null) deform = weighted ? Utils.newFloatArray(deformLength) : vertices;\r\n                            else {\r\n                                deform = Utils.newFloatArray(deformLength);\r\n                                const start = <number>this.getValue(valueMap, 'offset', 0);\r\n\r\n                                Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);\r\n                                if (scale != 1) {\r\n                                    for (let i = start, n = i + verticesValue.length; i < n; i++) deform[i] *= scale;\r\n                                }\r\n                                if (!weighted) {\r\n                                    for (let i = 0; i < deformLength; i++) deform[i] += vertices[i];\r\n                                }\r\n                            }\r\n\r\n                            timeline.setFrame(frameIndex, this.getValue(valueMap, 'time', 0), deform);\r\n                            this.readCurve(valueMap, timeline, frameIndex);\r\n                            frameIndex++;\r\n                        }\r\n                        timelines.push(timeline);\r\n                        duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Draw order timeline.\r\n        let drawOrderNode = map.drawOrder;\r\n\r\n        if (drawOrderNode == null) drawOrderNode = map.draworder;\r\n        if (drawOrderNode != null) {\r\n            const timeline = new DrawOrderTimeline(drawOrderNode.length);\r\n            const slotCount = skeletonData.slots.length;\r\n            let frameIndex = 0;\r\n\r\n            for (let j = 0; j < drawOrderNode.length; j++) {\r\n                const drawOrderMap = drawOrderNode[j];\r\n                let drawOrder: Array<number> = null;\r\n                const offsets = this.getValue(drawOrderMap, 'offsets', null);\r\n\r\n                if (offsets != null) {\r\n                    drawOrder = Utils.newArray<number>(slotCount, -1);\r\n                    const unchanged = Utils.newArray<number>(slotCount - offsets.length, 0);\r\n                    let originalIndex = 0;\r\n                    let unchangedIndex = 0;\r\n\r\n                    for (let i = 0; i < offsets.length; i++) {\r\n                        const offsetMap = offsets[i];\r\n                        const slotIndex = skeletonData.findSlotIndex(offsetMap.slot);\r\n\r\n                        if (slotIndex == -1) throw new Error(`Slot not found: ${offsetMap.slot}`);\r\n                        // Collect unchanged items.\r\n                        while (originalIndex != slotIndex) unchanged[unchangedIndex++] = originalIndex++;\r\n                        // Set changed items.\r\n                        drawOrder[originalIndex + offsetMap.offset] = originalIndex++;\r\n                    }\r\n                    // Collect remaining unchanged items.\r\n                    while (originalIndex < slotCount) unchanged[unchangedIndex++] = originalIndex++;\r\n                    // Fill in unchanged items.\r\n                    for (let i = slotCount - 1; i >= 0; i--) if (drawOrder[i] == -1) drawOrder[i] = unchanged[--unchangedIndex];\r\n                }\r\n                timeline.setFrame(frameIndex++, this.getValue(drawOrderMap, 'time', 0), drawOrder);\r\n            }\r\n            timelines.push(timeline);\r\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n        }\r\n\r\n        // Event timeline.\r\n        if (map.events) {\r\n            const timeline = new EventTimeline(map.events.length);\r\n            let frameIndex = 0;\r\n\r\n            for (let i = 0; i < map.events.length; i++) {\r\n                const eventMap = map.events[i];\r\n                const eventData = skeletonData.findEvent(eventMap.name);\r\n\r\n                if (eventData == null) throw new Error(`Event not found: ${eventMap.name}`);\r\n                const event = new Event(Utils.toSinglePrecision(this.getValue(eventMap, 'time', 0)), eventData);\r\n\r\n                event.intValue = this.getValue(eventMap, 'int', eventData.intValue);\r\n                event.floatValue = this.getValue(eventMap, 'float', eventData.floatValue);\r\n                event.stringValue = this.getValue(eventMap, 'string', eventData.stringValue);\r\n                if (event.data.audioPath != null) {\r\n                    event.volume = this.getValue(eventMap, 'volume', 1);\r\n                    event.balance = this.getValue(eventMap, 'balance', 0);\r\n                }\r\n                timeline.setFrame(frameIndex++, event);\r\n            }\r\n            timelines.push(timeline);\r\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n        }\r\n\r\n        if (isNaN(duration)) {\r\n            throw new Error('Error while parsing animation, duration is NaN');\r\n        }\r\n\r\n        skeletonData.animations.push(new Animation(name, timelines, duration));\r\n    }\r\n\r\n    readCurve(map: any, timeline: CurveTimeline, frameIndex: number) {\r\n        if (!map.hasOwnProperty('curve')) return;\r\n        if (map.curve === 'stepped') timeline.setStepped(frameIndex);\r\n        else {\r\n            const curve: number = map.curve;\r\n\r\n            timeline.setCurve(frameIndex, curve, this.getValue(map, 'c2', 0), this.getValue(map, 'c3', 1), this.getValue(map, 'c4', 1));\r\n        }\r\n    }\r\n\r\n    getValue(map: any, prop: string, defaultValue: any) {\r\n        return map[prop] !== undefined ? map[prop] : defaultValue;\r\n    }\r\n\r\n    static blendModeFromString(str: string) {\r\n        str = str.toLowerCase();\r\n        if (str == 'normal') return BLEND_MODES.NORMAL;\r\n        if (str == 'additive') return BLEND_MODES.ADD;\r\n        if (str == 'multiply') return BLEND_MODES.MULTIPLY;\r\n        if (str == 'screen') return BLEND_MODES.SCREEN;\r\n        throw new Error(`Unknown blend mode: ${str}`);\r\n    }\r\n\r\n    static positionModeFromString(str: string) {\r\n        str = str.toLowerCase();\r\n        if (str == 'fixed') return PositionMode.Fixed;\r\n        if (str == 'percent') return PositionMode.Percent;\r\n        throw new Error(`Unknown position mode: ${str}`);\r\n    }\r\n\r\n    static spacingModeFromString(str: string) {\r\n        str = str.toLowerCase();\r\n        if (str == 'length') return SpacingMode.Length;\r\n        if (str == 'fixed') return SpacingMode.Fixed;\r\n        if (str == 'percent') return SpacingMode.Percent;\r\n        throw new Error(`Unknown position mode: ${str}`);\r\n    }\r\n\r\n    static rotateModeFromString(str: string) {\r\n        str = str.toLowerCase();\r\n        if (str == 'tangent') return RotateMode.Tangent;\r\n        if (str == 'chain') return RotateMode.Chain;\r\n        if (str == 'chainscale') return RotateMode.ChainScale;\r\n        throw new Error(`Unknown rotate mode: ${str}`);\r\n    }\r\n\r\n    static transformModeFromString(str: string) {\r\n        str = str.toLowerCase();\r\n        if (str == 'normal') return TransformMode.Normal;\r\n        if (str == 'onlytranslation') return TransformMode.OnlyTranslation;\r\n        if (str == 'norotationorreflection') return TransformMode.NoRotationOrReflection;\r\n        if (str == 'noscale') return TransformMode.NoScale;\r\n        if (str == 'noscaleorreflection') return TransformMode.NoScaleOrReflection;\r\n        throw new Error(`Unknown transform mode: ${str}`);\r\n    }\r\n}\r\n\r\nclass LinkedMesh {\r\n    parent: string;\r\n    skin: string;\r\n    slotIndex: number;\r\n    mesh: MeshAttachment;\r\n    inheritDeform: boolean;\r\n\r\n    constructor(mesh: MeshAttachment, skin: string, slotIndex: number, parent: string, inheritDeform: boolean) {\r\n        this.mesh = mesh;\r\n        this.skin = skin;\r\n        this.slotIndex = slotIndex;\r\n        this.parent = parent;\r\n        this.inheritDeform = inheritDeform;\r\n    }\r\n}\r\n","import { SpineBase } from '@pixi-spine/base';\r\nimport { Skeleton } from './core/Skeleton';\r\nimport type { SkeletonData } from './core/SkeletonData';\r\nimport { AnimationState } from './core/AnimationState';\r\nimport { AnimationStateData } from './core/AnimationStateData';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class Spine extends SpineBase<Skeleton, SkeletonData, AnimationState, AnimationStateData> {\r\n    createSkeleton(spineData: SkeletonData) {\r\n        this.skeleton = new Skeleton(spineData);\r\n        this.skeleton.updateWorldTransform();\r\n        this.stateData = new AnimationStateData(spineData);\r\n        this.state = new AnimationState(this.stateData);\r\n    }\r\n}\r\n"],"names":["Attachment","name","_VertexAttachment","slot","worldVertices","start","count","offset","stride","skeleton","deformArray","vertices","bones","mat","x","y","a","b","c","d","v","w","vx","vy","skip","i","n","skeletonBones","wx","wy","weight","deform","f","attachment","Utils","VertexAttachment","BoundingBoxAttachment","AttachmentType","Color","copy","ClippingAttachment","MeshAttachment","parentMesh","PathAttachment","PointAttachment","bone","point","cos","MathUtils","sin","Slot","data","time","_RegionAttachment","regionScaleX","regionScaleY","localX","localY","localX2","localY2","radians","localXCos","localXSin","localYCos","localYSin","localX2Cos","localX2Sin","localY2Cos","localY2Sin","region","uvs","vertexOffset","offsetX","offsetY","RegionAttachment","JitterEffect","jitterX","jitterY","position","uv","light","dark","_SwirlEffect","radius","radAngle","dist","theta","SwirlEffect","PowOut","Animation","timelines","duration","id","lastTime","loop","events","alpha","blend","direction","values","target","step","low","high","current","last","TimelineType","s","_CurveTimeline","frameCount","frameIndex","index","type","cx1","cy1","cx2","cy2","tmpx","tmpy","dddfx","dddfy","ddfx","ddfy","dfx","dfy","curves","percent","prevX","prevY","CurveTimeline","_RotateTimeline","degrees","frames","MixBlend","r","frame","prevRotation","frameTime","RotateTimeline","_TranslateTimeline","TranslateTimeline","ScaleTimeline","bx","by","MixDirection","ShearTimeline","_ColorTimeline","g","color","setup","ColorTimeline","_TwoColorTimeline","r2","g2","b2","setupLight","setupDark","TwoColorTimeline","AttachmentTimeline","attachmentName","zeros","DeformTimeline","firedEvents","slotAttachment","frameVertices","vertexCount","vertexAttachment","setupVertices","lastVertices","prevVertices","nextVertices","prev","EventTimeline","event","DrawOrderTimeline","drawOrder","slots","drawOrderToSetupIndex","_IkConstraintTimeline","mix","softness","bendDirection","compress","stretch","constraint","IkConstraintTimeline","_TransformConstraintTimeline","rotateMix","translateMix","scaleMix","shearMix","rotate","translate","scale","shear","TransformConstraintTimeline","_PathConstraintPositionTimeline","value","PathConstraintPositionTimeline","PathConstraintSpacingTimeline","spacing","_PathConstraintMixTimeline","PathConstraintMixTimeline","_AnimationState","EventQueue","IntSet","Pool","TrackEntry","delta","tracks","currentDelta","next","nextTime","from","to","finished","applied","animationLast","animationTime","timelineCount","ii","timeline","timelineMode","firstFrame","timelinesRotation","timelineBlend","setupState","attachments","alphaHold","alphaMix","timelineHoldMix","holdMix","rotateTimeline","r1","total","diff","lastTotal","lastDiff","dir","entry","animationStart","animationEnd","trackLastWrapped","complete","oldDrainDisabled","trackIndex","interrupt","animationName","animation","delay","mixDuration","timelinesCount","timelineDipMix","propertyIDs","outer","listener","AnimationState","_TrackEntry","_EventQueue","animState","EventType","objects","listeners","o","AnimationStateAdapter","_AnimationStateData","skeletonData","fromName","toName","key","AnimationStateData","AtlasAttachmentLoader","atlas","skin","path","Bone","parent","Matrix","rotation","scaleX","scaleY","shearX","shearY","m","sx","sy","settings","rotationY","pa","pb","pc","pd","TransformMode","la","lb","lc","ld","prx","rx","ry","za","zc","zb","zd","pm","pid","dx","dy","ia","ib","ic","ra","rb","rc","rd","det","world","invDet","local","worldRotation","localRotation","BoneData","ConstraintData","order","skinRequired","Event","EventData","IkConstraint","targetX","targetY","uniform","p","rotationIK","tx","ty","sa","sc","dd","child","bendDir","px","py","psx","psy","csx","pmat","os1","os2","s2","cx","cy","cwx","cwy","u","pp","l1","l2","a1","a2","td","sd","aa","bb","ta","c1","c2","q","r0","minAngle","minX","minDist","minY","maxAngle","maxX","maxDist","maxY","os","IkConstraintData","PathConstraintData","SpacingMode","_PathConstraint","spacingMode","lengthSpacing","rotateMode","tangents","RotateMode","boneCount","spacesCount","spaces","lengths","setupLength","length","positions","PositionMode","boneX","boneY","offsetRotation","tip","percentPosition","percentSpacing","out","closed","verticesLength","curveCount","prevCurve","pathLength","curve","space","x1","y1","x2","y2","segments","curveLength","segment","temp","tt","ttt","uu","uuu","ut","ut3","uut3","utt3","PathConstraint","TransformConstraint","Vector2","targetMat","tb","tc","degRadReflect","offsetShearY","modified","ts","_Skeleton","boneData","slotData","ikConstraintData","transformConstraintData","pathConstraintData","updateCache","skinBones","ikConstraints","transformConstraints","pathConstraints","ikCount","transformCount","pathCount","constraintCount","constrained","slotIndex","slotBone","pathBones","boneIndex","updateCacheReset","boneName","slotName","skinName","newSkin","constraintName","ikConstraint","size","mesh","nn","Skeleton","SkeletonData","skins","eventDataName","animations","pathConstraintName","SlotData","TransformConstraintData","SkinEntry","Skin","contained","j","dictionary","entries","slotAttachments","oldSkin","skinAttachment","_SkeletonBinary","attachmentLoader","binary","input","BinaryInput","nonessential","darkColor","defaultSkin","linkedMesh","slotCount","typeIndex","width","height","box","triangles","hullLength","edges","inheritDeform","LinkedMesh","constantSpeed","endSlotIndex","clip","Vertices","weights","bonesArray","array","tempColor1","tempColor2","timelineType","timelineScale","iii","nnn","weighted","deformLength","end","vn","drawOrderCount","offsetCount","unchanged","originalIndex","unchangedIndex","eventCount","eventData","SkeletonBinary","BLEND_MODES","SkeletonBounds","SkeletonBoundsBase","SkeletonJson","json","root","skeletonMap","error","boneMap","parentName","slotMap","constraintMap","targetName","skinMap","entryName","eventName","eventMap","animationMap","map","scaledVertices","timelineName","timelineMap","valueMap","defaultValue","deformName","deformMap","verticesValue","drawOrderNode","drawOrderMap","offsets","offsetMap","prop","str","Spine","SpineBase","spineData"],"mappings":"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"}