/*!
 * pixi-spine - v4.0.4
 * Compiled Fri, 16 Jun 2023 00:33:59 UTC
 *
 * pixi-spine is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 * 
 * Copyright 2023, Ivan Igorevich Popelyshev <ivan.popelyshev@gmail.com>, All Rights Reserved
 */this.PIXI=this.PIXI||{},this.PIXI.spine=function(st,G,zn,La,Oa,$e,Ie){"use strict";var Z=(f=>(f[f.Region=0]="Region",f[f.BoundingBox=1]="BoundingBox",f[f.Mesh=2]="Mesh",f[f.LinkedMesh=3]="LinkedMesh",f[f.Path=4]="Path",f[f.Point=5]="Point",f[f.Clipping=6]="Clipping",f))(Z||{});class Gn{constructor(t,n=new Array,e=0,r=new DataView(t.buffer)){this.strings=n,this.index=e,this.buffer=r}readByte(){return this.buffer.getInt8(this.index++)}readUnsignedByte(){return this.buffer.getUint8(this.index++)}readShort(){const t=this.buffer.getInt16(this.index);return this.index+=2,t}readInt32(){const t=this.buffer.getInt32(this.index);return this.index+=4,t}readInt(t){let n=this.readByte(),e=n&127;return n&128&&(n=this.readByte(),e|=(n&127)<<7,n&128&&(n=this.readByte(),e|=(n&127)<<14,n&128&&(n=this.readByte(),e|=(n&127)<<21,n&128&&(n=this.readByte(),e|=(n&127)<<28)))),t?e:e>>>1^-(e&1)}readStringRef(){const t=this.readInt(!0);return t==0?null:this.strings[t-1]}readString(){let t=this.readInt(!0);switch(t){case 0:return null;case 1:return""}t--;let n="";for(let e=0;e<t;){const r=this.readUnsignedByte();switch(r>>4){case 12:case 13:n+=String.fromCharCode((r&31)<<6|this.readByte()&63),e+=2;break;case 14:n+=String.fromCharCode((r&15)<<12|(this.readByte()&63)<<6|this.readByte()&63),e+=3;break;default:n+=String.fromCharCode(r),e++}}return n}readFloat(){const t=this.buffer.getFloat32(this.index);return this.index+=4,t}readBoolean(){return this.readByte()!=0}}var A=(f=>(f[f.setup=0]="setup",f[f.first=1]="first",f[f.replace=2]="replace",f[f.add=3]="add",f))(A||{}),Q=(f=>(f[f.mixIn=0]="mixIn",f[f.mixOut=1]="mixOut",f))(Q||{}),dt=(f=>(f[f.Fixed=0]="Fixed",f[f.Percent=1]="Percent",f))(dt||{}),ut=(f=>(f[f.Tangent=0]="Tangent",f[f.Chain=1]="Chain",f[f.ChainScale=2]="ChainScale",f))(ut||{}),z=(f=>(f[f.Normal=0]="Normal",f[f.OnlyTranslation=1]="OnlyTranslation",f[f.NoRotationOrReflection=2]="NoRotationOrReflection",f[f.NoScale=3]="NoScale",f[f.NoScaleOrReflection=4]="NoScaleOrReflection",f))(z||{});function qs(f){switch(f.toLowerCase()){case"nearest":return re.Nearest;case"linear":return re.Linear;case"mipmap":return re.MipMap;case"mipmapnearestnearest":return re.MipMapNearestNearest;case"mipmaplinearnearest":return re.MipMapLinearNearest;case"mipmapnearestlinear":return re.MipMapNearestLinear;case"mipmaplinearlinear":return re.MipMapLinearLinear;default:throw new Error(`Unknown texture filter ${f}`)}}function $a(f){switch(f.toLowerCase()){case"mirroredtepeat":return Ue.MirroredRepeat;case"clamptoedge":return Ue.ClampToEdge;case"repeat":return Ue.Repeat;default:throw new Error(`Unknown texture wrap ${f}`)}}var re=(f=>(f[f.Nearest=9728]="Nearest",f[f.Linear=9729]="Linear",f[f.MipMap=9987]="MipMap",f[f.MipMapNearestNearest=9984]="MipMapNearestNearest",f[f.MipMapLinearNearest=9985]="MipMapLinearNearest",f[f.MipMapNearestLinear=9986]="MipMapNearestLinear",f[f.MipMapLinearLinear=9987]="MipMapLinearLinear",f))(re||{}),Ue=(f=>(f[f.MirroredRepeat=33648]="MirroredRepeat",f[f.ClampToEdge=33071]="ClampToEdge",f[f.Repeat=10497]="Repeat",f))(Ue||{});class ws{constructor(){this.size=null,this.names=null,this.values=null,this.renderObject=null}get width(){const t=this.texture;return t.trim?t.trim.width:t.orig.width}get height(){const t=this.texture;return t.trim?t.trim.height:t.orig.height}get u(){return this.texture._uvs.x0}get v(){return this.texture._uvs.y0}get u2(){return this.texture._uvs.x2}get v2(){return this.texture._uvs.y2}get offsetX(){const t=this.texture;return t.trim?t.trim.x:0}get offsetY(){return this.spineOffsetY}get pixiOffsetY(){const t=this.texture;return t.trim?t.trim.y:0}get spineOffsetY(){const t=this.texture;return this.originalHeight-this.height-(t.trim?t.trim.y:0)}get originalWidth(){return this.texture.orig.width}get originalHeight(){return this.texture.orig.height}get x(){return this.texture.frame.x}get y(){return this.texture.frame.y}get rotate(){return this.texture.rotate!==0}get degrees(){return(360-this.texture.rotate*45)%360}}class Wa{constructor(){this.x=0,this.y=0,this.width=0,this.height=0,this.offsetX=0,this.offsetY=0,this.originalWidth=0,this.originalHeight=0,this.rotate=0,this.index=0}}class bs{constructor(t,n,e){this.pages=new Array,this.regions=new Array,t&&this.addSpineAtlas(t,n,e)}addTexture(t,n){const e=this.pages;let r=null;for(let h=0;h<e.length;h++)if(e[h].baseTexture===n.baseTexture){r=e[h];break}if(r===null){r=new Us,r.name="texturePage";const h=n.baseTexture;r.width=h.realWidth,r.height=h.realHeight,r.baseTexture=h,r.minFilter=r.magFilter=re.Nearest,r.uWrap=Ue.ClampToEdge,r.vWrap=Ue.ClampToEdge,e.push(r)}const i=new Hs;return i.name=t,i.page=r,i.texture=n,i.index=-1,this.regions.push(i),i}addTextureHash(t,n){for(const e in t)t.hasOwnProperty(e)&&this.addTexture(n&&e.indexOf(".")!==-1?e.substr(0,e.lastIndexOf(".")):e,t[e])}addSpineAtlas(t,n,e){return this.load(t,n,e)}load(t,n,e){if(n==null)throw new Error("textureLoader cannot be null.");const r=new qa(t),i=new Array(4);let h=null;const l={};let s=null;l.size=()=>{h.width=parseInt(i[1]),h.height=parseInt(i[2])},l.format=()=>{},l.filter=()=>{h.minFilter=qs(i[1]),h.magFilter=qs(i[2])},l.repeat=()=>{i[1].indexOf("x")!=-1&&(h.uWrap=Ue.Repeat),i[1].indexOf("y")!=-1&&(h.vWrap=Ue.Repeat)},l.pma=()=>{h.pma=i[1]=="true"};const a={};a.xy=()=>{s.x=parseInt(i[1]),s.y=parseInt(i[2])},a.size=()=>{s.width=parseInt(i[1]),s.height=parseInt(i[2])},a.bounds=()=>{s.x=parseInt(i[1]),s.y=parseInt(i[2]),s.width=parseInt(i[3]),s.height=parseInt(i[4])},a.offset=()=>{s.offsetX=parseInt(i[1]),s.offsetY=parseInt(i[2])},a.orig=()=>{s.originalWidth=parseInt(i[1]),s.originalHeight=parseInt(i[2])},a.offsets=()=>{s.offsetX=parseInt(i[1]),s.offsetY=parseInt(i[2]),s.originalWidth=parseInt(i[3]),s.originalHeight=parseInt(i[4])},a.rotate=()=>{const d=i[1];let u=0;d.toLocaleLowerCase()=="true"?u=6:d.toLocaleLowerCase()=="false"?u=0:u=(720-parseFloat(d))%360/45,s.rotate=u},a.index=()=>{s.index=parseInt(i[1])};let o=r.readLine();for(;o!=null&&o.trim().length==0;)o=r.readLine();for(;!(o==null||o.trim().length==0||r.readEntry(i,o)==0);)o=r.readLine();const c=()=>{for(;;){if(o==null)return e&&e(this);if(o.trim().length==0)h=null,o=r.readLine();else if(h===null){for(h=new Us,h.name=o.trim();r.readEntry(i,o=r.readLine())!=0;){const d=l[i[0]];d&&d()}this.pages.push(h),n(h.name,d=>{if(d===null)return this.pages.splice(this.pages.indexOf(h),1),e&&e(null);h.baseTexture=d,h.pma&&(d.alphaMode=G.ALPHA_MODES.PMA),d.valid||d.setSize(h.width,h.height),h.setFilters(),(!h.width||!h.height)&&(h.width=d.realWidth,h.height=d.realHeight,(!h.width||!h.height)&&console.log(`ERROR spine atlas page ${h.name}: meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)`)),c()});break}else{s=new Wa;const d=new Hs;d.name=o,d.page=h;let u=null,m=null;for(;;){const p=r.readEntry(i,o=r.readLine());if(p==0)break;const S=a[i[0]];if(S)S();else{u==null&&(u=[],m=[]),u.push(i[0]);const y=[];for(let M=0;M<p;M++)y.push(parseInt(i[M+1]));m.push(y)}}s.originalWidth==0&&s.originalHeight==0&&(s.originalWidth=s.width,s.originalHeight=s.height);const g=h.baseTexture.resolution;s.x/=g,s.y/=g,s.width/=g,s.height/=g,s.originalWidth/=g,s.originalHeight/=g,s.offsetX/=g,s.offsetY/=g;const x=s.rotate%4!==0,w=new G.Rectangle(s.x,s.y,x?s.height:s.width,x?s.width:s.height),b=new G.Rectangle(0,0,s.originalWidth,s.originalHeight),E=new G.Rectangle(s.offsetX,s.originalHeight-s.height-s.offsetY,s.width,s.height);d.texture=new G.Texture(d.page.baseTexture,w,b,E,s.rotate),d.index=s.index,d.texture.updateUvs(),this.regions.push(d)}}};c()}findRegion(t){for(let n=0;n<this.regions.length;n++)if(this.regions[n].name==t)return this.regions[n];return null}dispose(){for(let t=0;t<this.pages.length;t++)this.pages[t].baseTexture.dispose()}}class qa{constructor(t){this.index=0,this.lines=t.split(/\r\n|\r|\n/)}readLine(){return this.index>=this.lines.length?null:this.lines[this.index++]}readEntry(t,n){if(n==null||(n=n.trim(),n.length==0))return 0;const e=n.indexOf(":");if(e==-1)return 0;t[0]=n.substr(0,e).trim();for(let r=1,i=e+1;;r++){const h=n.indexOf(",",i);if(h==-1)return t[r]=n.substr(i).trim(),r;if(t[r]=n.substr(i,h-i).trim(),i=h+1,r==4)return 4}}}class Us{constructor(){this.minFilter=re.Nearest,this.magFilter=re.Nearest,this.uWrap=Ue.ClampToEdge,this.vWrap=Ue.ClampToEdge}setFilters(){const t=this.baseTexture,n=this.minFilter;n==re.Linear?t.scaleMode=G.SCALE_MODES.LINEAR:this.minFilter==re.Nearest?t.scaleMode=G.SCALE_MODES.NEAREST:(t.mipmap=G.MIPMAP_MODES.POW2,n==re.MipMapNearestNearest?t.scaleMode=G.SCALE_MODES.NEAREST:t.scaleMode=G.SCALE_MODES.LINEAR)}}class Hs extends ws{}class Es{constructor(){this.array=new Array}add(t){const n=this.contains(t);return this.array[t|0]=t|0,!n}contains(t){return this.array[t|0]!=null}remove(t){this.array[t|0]=void 0}clear(){this.array.length=0}}class zs{constructor(){this.entries={},this.size=0}add(t){const n=this.entries[t];return this.entries[t]=!0,n?!1:(this.size++,!0)}addAll(t){const n=this.size;for(let e=0,r=t.length;e<r;e++)this.add(t[e]);return n!=this.size}contains(t){return this.entries[t]}clear(){this.entries={},this.size=0}}const Fn=class{constructor(f=0,t=0,n=0,e=0){this.r=f,this.g=t,this.b=n,this.a=e}set(f,t,n,e){return this.r=f,this.g=t,this.b=n,this.a=e,this.clamp()}setFromColor(f){return this.r=f.r,this.g=f.g,this.b=f.b,this.a=f.a,this}setFromString(f){return f=f.charAt(0)=="#"?f.substr(1):f,this.r=parseInt(f.substr(0,2),16)/255,this.g=parseInt(f.substr(2,2),16)/255,this.b=parseInt(f.substr(4,2),16)/255,this.a=f.length!=8?1:parseInt(f.substr(6,2),16)/255,this}add(f,t,n,e){return this.r+=f,this.g+=t,this.b+=n,this.a+=e,this.clamp()}clamp(){return this.r<0?this.r=0:this.r>1&&(this.r=1),this.g<0?this.g=0:this.g>1&&(this.g=1),this.b<0?this.b=0:this.b>1&&(this.b=1),this.a<0?this.a=0:this.a>1&&(this.a=1),this}static rgba8888ToColor(f,t){f.r=((t&4278190080)>>>24)/255,f.g=((t&16711680)>>>16)/255,f.b=((t&65280)>>>8)/255,f.a=(t&255)/255}static rgb888ToColor(f,t){f.r=((t&16711680)>>>16)/255,f.g=((t&65280)>>>8)/255,f.b=(t&255)/255}static fromString(f){return new Fn().setFromString(f)}};let O=Fn;O.WHITE=new Fn(1,1,1,1),O.RED=new Fn(1,0,0,1),O.GREEN=new Fn(0,1,0,1),O.BLUE=new Fn(0,0,1,1),O.MAGENTA=new Fn(1,0,1,1);const mn=class{static clamp(f,t,n){return f<t?t:f>n?n:f}static cosDeg(f){return Math.cos(f*mn.degRad)}static sinDeg(f){return Math.sin(f*mn.degRad)}static signum(f){return Math.sign(f)}static toInt(f){return f>0?Math.floor(f):Math.ceil(f)}static cbrt(f){const t=Math.pow(Math.abs(f),.3333333333333333);return f<0?-t:t}static randomTriangular(f,t){return mn.randomTriangularWith(f,t,(f+t)*.5)}static randomTriangularWith(f,t,n){const e=Math.random(),r=t-f;return e<=(n-f)/r?f+Math.sqrt(e*r*(n-f)):t-Math.sqrt((1-e)*r*(t-n))}static isPowerOfTwo(f){return f&&(f&f-1)===0}};let T=mn;T.PI=3.1415927,T.PI2=mn.PI*2,T.radiansToDegrees=180/mn.PI,T.radDeg=mn.radiansToDegrees,T.degreesToRadians=mn.PI/180,T.degRad=mn.degreesToRadians;class Pr{apply(t,n,e){return t+(n-t)*this.applyInternal(e)}}class Fr extends Pr{constructor(t){super(),this.power=2,this.power=t}applyInternal(t){return t<=.5?Math.pow(t*2,this.power)/2:Math.pow((t-1)*2,this.power)/(this.power%2==0?-2:2)+1}}class Ss extends Fr{applyInternal(t){return Math.pow(t-1,this.power)*(this.power%2==0?-1:1)+1}}const jn=class{static arrayCopy(f,t,n,e,r){for(let i=t,h=e;i<t+r;i++,h++)n[h]=f[i]}static arrayFill(f,t,n,e){for(let r=t;r<n;r++)f[r]=e}static setArraySize(f,t,n=0){const e=f.length;if(e==t)return f;if(f.length=t,e<t)for(let r=e;r<t;r++)f[r]=n;return f}static ensureArrayCapacity(f,t,n=0){return f.length>=t?f:jn.setArraySize(f,t,n)}static newArray(f,t){const n=new Array(f);for(let e=0;e<f;e++)n[e]=t;return n}static newFloatArray(f){if(jn.SUPPORTS_TYPED_ARRAYS)return new Float32Array(f);const t=new Array(f);for(let n=0;n<t.length;n++)t[n]=0;return t}static newShortArray(f){if(jn.SUPPORTS_TYPED_ARRAYS)return new Int16Array(f);const t=new Array(f);for(let n=0;n<t.length;n++)t[n]=0;return t}static toFloatArray(f){return jn.SUPPORTS_TYPED_ARRAYS?new Float32Array(f):f}static toSinglePrecision(f){return jn.SUPPORTS_TYPED_ARRAYS?Math.fround(f):f}static webkit602BugfixHelper(f,t){}static contains(f,t,n=!0){for(let e=0;e<f.length;e++)if(f[e]==t)return!0;return!1}static enumValue(f,t){return f[t[0].toUpperCase()+t.slice(1)]}};let k=jn;k.SUPPORTS_TYPED_ARRAYS=typeof Float32Array!="undefined";class Ua{static logBones(t){for(let n=0;n<t.bones.length;n++){const e=t.bones[n],r=e.matrix;console.log(`${e.data.name}, ${r.a}, ${r.b}, ${r.c}, ${r.d}, ${r.tx}, ${r.ty}`)}}}class Zn{constructor(t){this.items=new Array,this.instantiator=t}obtain(){return this.items.length>0?this.items.pop():this.instantiator()}free(t){t.reset&&t.reset(),this.items.push(t)}freeAll(t){for(let n=0;n<t.length;n++)this.free(t[n])}clear(){this.items.length=0}}class Yn{constructor(t=0,n=0){this.x=t,this.y=n}set(t,n){return this.x=t,this.y=n,this}length(){const t=this.x,n=this.y;return Math.sqrt(t*t+n*n)}normalize(){const t=this.length();return t!=0&&(this.x/=t,this.y/=t),this}}class Ha{constructor(){this.maxDelta=.064,this.framesPerSecond=0,this.delta=0,this.totalTime=0,this.lastTime=Date.now()/1e3,this.frameCount=0,this.frameTime=0}update(){const t=Date.now()/1e3;this.delta=t-this.lastTime,this.frameTime+=this.delta,this.totalTime+=this.delta,this.delta>this.maxDelta&&(this.delta=this.maxDelta),this.lastTime=t,this.frameCount++,this.frameTime>1&&(this.framesPerSecond=this.frameCount/this.frameTime,this.frameTime=0,this.frameCount=0)}}class za{constructor(t=32){this.addedValues=0,this.lastValue=0,this.mean=0,this.dirty=!0,this.values=new Array(t)}hasEnoughData(){return this.addedValues>=this.values.length}addValue(t){this.addedValues<this.values.length&&this.addedValues++,this.values[this.lastValue++]=t,this.lastValue>this.values.length-1&&(this.lastValue=0),this.dirty=!0}getMean(){if(this.hasEnoughData()){if(this.dirty){let t=0;for(let n=0;n<this.values.length;n++)t+=this.values[n];this.mean=t/this.values.length,this.dirty=!1}return this.mean}return 0}}class Qn{constructor(){this.minX=0,this.minY=0,this.maxX=0,this.maxY=0,this.boundingBoxes=new Array,this.polygons=new Array,this.polygonPool=new Zn(()=>k.newFloatArray(16))}update(t,n){if(!t)throw new Error("skeleton cannot be null.");const e=this.boundingBoxes,r=this.polygons,i=this.polygonPool,h=t.slots,l=h.length;e.length=0,i.freeAll(r),r.length=0;for(let s=0;s<l;s++){const a=h[s];if(!a.bone.active)continue;const o=a.getAttachment();if(o!=null&&o.type===Z.BoundingBox){const c=o;e.push(c);let d=i.obtain();d.length!=c.worldVerticesLength&&(d=k.newFloatArray(c.worldVerticesLength)),r.push(d),c.computeWorldVertices(a,0,c.worldVerticesLength,d,0,2)}}n?this.aabbCompute():(this.minX=Number.POSITIVE_INFINITY,this.minY=Number.POSITIVE_INFINITY,this.maxX=Number.NEGATIVE_INFINITY,this.maxY=Number.NEGATIVE_INFINITY)}aabbCompute(){let t=Number.POSITIVE_INFINITY,n=Number.POSITIVE_INFINITY,e=Number.NEGATIVE_INFINITY,r=Number.NEGATIVE_INFINITY;const i=this.polygons;for(let h=0,l=i.length;h<l;h++){const s=i[h],a=s;for(let o=0,c=s.length;o<c;o+=2){const d=a[o],u=a[o+1];t=Math.min(t,d),n=Math.min(n,u),e=Math.max(e,d),r=Math.max(r,u)}}this.minX=t,this.minY=n,this.maxX=e,this.maxY=r}aabbContainsPoint(t,n){return t>=this.minX&&t<=this.maxX&&n>=this.minY&&n<=this.maxY}aabbIntersectsSegment(t,n,e,r){const i=this.minX,h=this.minY,l=this.maxX,s=this.maxY;if(t<=i&&e<=i||n<=h&&r<=h||t>=l&&e>=l||n>=s&&r>=s)return!1;const a=(r-n)/(e-t);let o=a*(i-t)+n;if(o>h&&o<s||(o=a*(l-t)+n,o>h&&o<s))return!0;let c=(h-n)/a+t;return c>i&&c<l||(c=(s-n)/a+t,c>i&&c<l)}aabbIntersectsSkeleton(t){return this.minX<t.maxX&&this.maxX>t.minX&&this.minY<t.maxY&&this.maxY>t.minY}containsPoint(t,n){const e=this.polygons;for(let r=0,i=e.length;r<i;r++)if(this.containsPointPolygon(e[r],t,n))return this.boundingBoxes[r];return null}containsPointPolygon(t,n,e){const r=t,i=t.length;let h=i-2,l=!1;for(let s=0;s<i;s+=2){const a=r[s+1],o=r[h+1];if(a<e&&o>=e||o<e&&a>=e){const c=r[s];c+(e-a)/(o-a)*(r[h]-c)<n&&(l=!l)}h=s}return l}intersectsSegment(t,n,e,r){const i=this.polygons;for(let h=0,l=i.length;h<l;h++)if(this.intersectsSegmentPolygon(i[h],t,n,e,r))return this.boundingBoxes[h];return null}intersectsSegmentPolygon(t,n,e,r,i){const h=t,l=t.length,s=n-r,a=e-i,o=n*i-e*r;let c=h[l-2],d=h[l-1];for(let u=0;u<l;u+=2){const m=h[u],g=h[u+1],x=c*g-d*m,w=c-m,b=d-g,E=s*b-a*w,p=(o*w-s*x)/E;if((p>=c&&p<=m||p>=m&&p<=c)&&(p>=n&&p<=r||p>=r&&p<=n)){const S=(o*b-a*x)/E;if((S>=d&&S<=g||S>=g&&S<=d)&&(S>=e&&S<=i||S>=i&&S<=e))return!0}c=m,d=g}return!1}getPolygon(t){if(!t)throw new Error("boundingBox cannot be null.");const n=this.boundingBoxes.indexOf(t);return n==-1?null:this.polygons[n]}getWidth(){return this.maxX-this.minX}getHeight(){return this.maxY-this.minY}}const jt={yDown:!0,FAIL_ON_NON_EXISTING_SKIN:!1,GLOBAL_AUTO_UPDATE:!0,GLOBAL_DELAY_LIMIT:0},Mn=[0,0,0];class Yr extends La.Sprite{constructor(){super(...arguments),this.region=null,this.attachment=null}}class Nr extends Oa.SimpleMesh{constructor(t,n,e,r,i){super(t,n,e,r,i),this.region=null,this.attachment=null}}const Xr=class extends zn.Container{constructor(f){if(super(),!f)throw new Error("The spineData param is required.");if(typeof f=="string")throw new Error('spineData param cant be string. Please use spine.Spine.fromAtlas("YOUR_RESOURCE_NAME") from now on.');this.spineData=f,this.createSkeleton(f),this.slotContainers=[],this.tempClipContainers=[];for(let t=0,n=this.skeleton.slots.length;t<n;t++){const e=this.skeleton.slots[t],r=e.getAttachment(),i=this.newContainer();if(this.slotContainers.push(i),this.addChild(i),this.tempClipContainers.push(null),!!r)if(r.type===Z.Region){const h=r.name,l=this.createSprite(e,r,h);e.currentSprite=l,e.currentSpriteName=h,i.addChild(l)}else if(r.type===Z.Mesh){const h=this.createMesh(e,r);e.currentMesh=h,e.currentMeshId=r.id,e.currentMeshName=r.name,i.addChild(h)}else r.type===Z.Clipping&&(this.createGraphics(e,r),i.addChild(e.clippingContainer),i.addChild(e.currentGraphics))}this.tintRgb=new Float32Array([1,1,1]),this.autoUpdate=!0,this.visible=!0}get debug(){return this._debug}set debug(f){var t;f!=this._debug&&((t=this._debug)==null||t.unregisterSpine(this),f==null||f.registerSpine(this),this._debug=f)}get autoUpdate(){return this._autoUpdate}set autoUpdate(f){f!==this._autoUpdate&&(this._autoUpdate=f,this.updateTransform=f?Xr.prototype.autoUpdateTransform:zn.Container.prototype.updateTransform)}get tint(){return G.utils.rgb2hex(this.tintRgb)}set tint(f){this.tintRgb=G.utils.hex2rgb(f,this.tintRgb)}get delayLimit(){return(typeof this.localDelayLimit!="undefined"?this.localDelayLimit:jt.GLOBAL_DELAY_LIMIT)||Number.MAX_VALUE}update(f){var a;const t=this.delayLimit;if(f>t&&(f=t),this.state.update(f),this.state.apply(this.skeleton),!this.skeleton)return;this.skeleton.updateWorldTransform();const n=this.skeleton.slots,e=this.color;let r=null,i=null;e?(r=e.light,i=e.dark):r=this.tintRgb;for(let o=0,c=n.length;o<c;o++){const d=n[o],u=d.getAttachment(),m=this.slotContainers[o];if(!u){m.visible=!1;continue}let g=null;u.sequence&&u.sequence.apply(d,u);let x=u.region;const w=u.color;switch(u!=null&&u.type){case Z.Region:if(m.transform.setFromMatrix(d.bone.matrix),x=u.region,d.currentMesh&&(d.currentMesh.visible=!1,d.currentMesh=null,d.currentMeshId=void 0,d.currentMeshName=void 0),!x){d.currentSprite&&(d.currentSprite.renderable=!1);break}if(!d.currentSpriteName||d.currentSpriteName!==u.name){const p=u.name;if(d.currentSprite&&(d.currentSprite.visible=!1),d.sprites=d.sprites||{},d.sprites[p]!==void 0)d.sprites[p].visible=!0;else{const S=this.createSprite(d,u,p);m.addChild(S)}d.currentSprite=d.sprites[p],d.currentSpriteName=p}d.currentSprite.renderable=!0,d.hackRegion||this.setSpriteRegion(u,d.currentSprite,x),d.currentSprite.color?g=d.currentSprite.color:(Mn[0]=r[0]*d.color.r*w.r,Mn[1]=r[1]*d.color.g*w.g,Mn[2]=r[2]*d.color.b*w.b,d.currentSprite.tint=G.utils.rgb2hex(Mn)),d.currentSprite.blendMode=d.blendMode;break;case Z.Mesh:if(d.currentSprite){d.currentSprite.visible=!1,d.currentSprite=null,d.currentSpriteName=void 0;const p=new G.Transform;p._parentID=-1,p._worldID=m.transform._worldID,m.transform=p}if(!x){d.currentMesh&&(d.currentMesh.renderable=!1);break}const E=u.id;if(d.currentMeshId===void 0||d.currentMeshId!==E){const p=E;if(d.currentMesh&&(d.currentMesh.visible=!1),d.meshes=d.meshes||{},d.meshes[p]!==void 0)d.meshes[p].visible=!0;else{const S=this.createMesh(d,u);m.addChild(S)}d.currentMesh=d.meshes[p],d.currentMeshName=u.name,d.currentMeshId=p}d.currentMesh.renderable=!0,u.computeWorldVerticesOld(d,d.currentMesh.vertices),d.currentMesh.color?g=d.currentMesh.color:(Mn[0]=r[0]*d.color.r*w.r,Mn[1]=r[1]*d.color.g*w.g,Mn[2]=r[2]*d.color.b*w.b,d.currentMesh.tint=G.utils.rgb2hex(Mn)),d.currentMesh.blendMode=d.blendMode,d.hackRegion||this.setMeshRegion(u,d.currentMesh,x);break;case Z.Clipping:d.currentGraphics||(this.createGraphics(d,u),m.addChild(d.clippingContainer),m.addChild(d.currentGraphics)),this.updateGraphics(d,u),m.alpha=1,m.visible=!0;continue;default:m.visible=!1;continue}if(m.visible=!0,g){let b=d.color.r*w.r,E=d.color.g*w.g,p=d.color.b*w.b;g.setLight(r[0]*b+i[0]*(1-b),r[1]*E+i[1]*(1-E),r[2]*p+i[2]*(1-p)),d.darkColor?(b=d.darkColor.r,E=d.darkColor.g,p=d.darkColor.b):(b=0,E=0,p=0),g.setDark(r[0]*b+i[0]*(1-b),r[1]*E+i[1]*(1-E),r[2]*p+i[2]*(1-p))}m.alpha=d.color.a}const h=this.skeleton.drawOrder;let l=null,s=null;for(let o=0,c=h.length;o<c;o++){const d=n[h[o].data.index],u=this.slotContainers[h[o].data.index];if(s||u.parent!==null&&u.parent!==this&&(u.parent.removeChild(u),u.parent=this),d.currentGraphics&&d.getAttachment())s=d.clippingContainer,l=d.getAttachment(),s.children.length=0,this.children[o]=u,l.endSlot===d.data&&(l.endSlot=null);else if(s){let m=this.tempClipContainers[o];m||(m=this.tempClipContainers[o]=this.newContainer(),m.visible=!1),this.children[o]=m,u.parent=null,s.addChild(u),l.endSlot==d.data&&(s.renderable=!0,s=null,l=null)}else this.children[o]=u}(a=this._debug)==null||a.renderDebug(this)}setSpriteRegion(f,t,n){t.attachment===f&&t.region===n||(t.region=n,t.attachment=f,t.texture=n.texture,t.rotation=f.rotation*T.degRad,t.position.x=f.x,t.position.y=f.y,t.alpha=f.color.a,n.size?(t.scale.x=n.size.width/n.originalWidth,t.scale.y=-n.size.height/n.originalHeight):(t.scale.x=f.scaleX*f.width/n.originalWidth,t.scale.y=-f.scaleY*f.height/n.originalHeight))}setMeshRegion(f,t,n){t.attachment===f&&t.region===n||(t.region=n,t.attachment=f,t.texture=n.texture,n.texture.updateUvs(),t.uvBuffer.update(f.regionUVs))}autoUpdateTransform(){if(jt.GLOBAL_AUTO_UPDATE){this.lastTime=this.lastTime||Date.now();const f=(Date.now()-this.lastTime)*.001;this.lastTime=Date.now(),this.update(f)}else this.lastTime=0;zn.Container.prototype.updateTransform.call(this)}createSprite(f,t,n){let e=t.region;f.hackAttachment===t&&(e=f.hackRegion);const r=e?e.texture:null,i=this.newSprite(r);return i.anchor.set(.5),e&&this.setSpriteRegion(t,i,t.region),f.sprites=f.sprites||{},f.sprites[n]=i,i}createMesh(f,t){let n=t.region;f.hackAttachment===t&&(n=f.hackRegion,f.hackAttachment=null,f.hackRegion=null);const e=this.newMesh(n?n.texture:null,new Float32Array(t.regionUVs.length),t.regionUVs,new Uint16Array(t.triangles),G.DRAW_MODES.TRIANGLES);return typeof e._canvasPadding!="undefined"&&(e._canvasPadding=1.5),e.alpha=t.color.a,e.region=t.region,n&&this.setMeshRegion(t,e,n),f.meshes=f.meshes||{},f.meshes[t.id]=e,e}createGraphics(f,t){const n=this.newGraphics(),e=new G.Polygon([]);return n.clear(),n.beginFill(16777215,1),n.drawPolygon(e),n.renderable=!1,f.currentGraphics=n,f.clippingContainer=this.newContainer(),f.clippingContainer.mask=f.currentGraphics,n}updateGraphics(f,t){const n=f.currentGraphics.geometry,e=n.graphicsData[0].shape.points,r=t.worldVerticesLength;e.length=r,t.computeWorldVertices(f,0,r,e,0,2),n.invalidate()}hackTextureBySlotIndex(f,t=null,n=null){const e=this.skeleton.slots[f];if(!e)return!1;const r=e.getAttachment();let i=r.region;return t?(i=new ws,i.texture=t,i.size=n,e.hackRegion=i,e.hackAttachment=r):(e.hackRegion=null,e.hackAttachment=null),e.currentSprite?this.setSpriteRegion(r,e.currentSprite,i):e.currentMesh&&this.setMeshRegion(r,e.currentMesh,i),!0}hackTextureBySlotName(f,t=null,n=null){const e=this.skeleton.findSlotIndex(f);return e==-1?!1:this.hackTextureBySlotIndex(e,t,n)}hackTextureAttachment(f,t,n,e=null){const r=this.skeleton.findSlotIndex(f),i=this.skeleton.getAttachmentByName(f,t);i.region.texture=n;const h=this.skeleton.slots[r];if(!h)return!1;const l=h.getAttachment();if(t===l.name){let s=i.region;return n?(s=new ws,s.texture=n,s.size=e,h.hackRegion=s,h.hackAttachment=l):(h.hackRegion=null,h.hackAttachment=null),h.currentSprite&&h.currentSprite.region!=s?(this.setSpriteRegion(l,h.currentSprite,s),h.currentSprite.region=s):h.currentMesh&&h.currentMesh.region!=s&&this.setMeshRegion(l,h.currentMesh,s),!0}return!1}newContainer(){return new zn.Container}newSprite(f){return new Yr(f)}newGraphics(){return new $e.Graphics}newMesh(f,t,n,e,r){return new Nr(f,t,n,e,r)}transformHack(){return 1}hackAttachmentGroups(f,t,n){if(!f)return;const e=[],r=[];for(let i=0,h=this.skeleton.slots.length;i<h;i++){const l=this.skeleton.slots[i],s=l.currentSpriteName||l.currentMeshName||"",a=l.currentSprite||l.currentMesh;s.endsWith(f)?(a.parentGroup=t,r.push(a)):n&&a&&(a.parentGroup=n,e.push(a))}return[e,r]}destroy(f){this.debug=null;for(let t=0,n=this.skeleton.slots.length;t<n;t++){const e=this.skeleton.slots[t];for(const r in e.meshes)e.meshes[r].destroy(f);e.meshes=null;for(const r in e.sprites)e.sprites[r].destroy(f);e.sprites=null}for(let t=0,n=this.slotContainers.length;t<n;t++)this.slotContainers[t].destroy(f);this.spineData=null,this.skeleton=null,this.slotContainers=null,this.stateData=null,this.state=null,this.tempClipContainers=null,super.destroy(f)}};let An=Xr;An.clippingPolygon=[],Object.defineProperty(An.prototype,"visible",{get(){return this._visible},set(f){f!==this._visible&&(this._visible=f,f&&(this.lastTime=0))}});class Ga{constructor(){this.registeredSpines=new Map,this.drawDebug=!0,this.drawMeshHull=!0,this.drawMeshTriangles=!0,this.drawBones=!0,this.drawPaths=!0,this.drawBoundingBoxes=!0,this.drawClipping=!0,this.drawRegionAttachments=!0,this.lineWidth=1,this.regionAttachmentsColor=30975,this.meshHullColor=30975,this.meshTrianglesColor=16763904,this.clippingPolygonColor=16711935,this.boundingBoxesRectColor=65280,this.boundingBoxesPolygonColor=65280,this.boundingBoxesCircleColor=65280,this.pathsCurveColor=16711680,this.pathsLineColor=16711935,this.skeletonXYColor=16711680,this.bonesColor=61132}registerSpine(t){this.registeredSpines.has(t)&&console.warn("SpineDebugRenderer.registerSpine() - this spine is already registered!",t);const n={parentDebugContainer:new zn.Container,bones:new zn.Container,skeletonXY:new $e.Graphics,regionAttachmentsShape:new $e.Graphics,meshTrianglesLine:new $e.Graphics,meshHullLine:new $e.Graphics,clippingPolygon:new $e.Graphics,boundingBoxesRect:new $e.Graphics,boundingBoxesCircle:new $e.Graphics,boundingBoxesPolygon:new $e.Graphics,pathsCurve:new $e.Graphics,pathsLine:new $e.Graphics};n.parentDebugContainer.addChild(n.bones),n.parentDebugContainer.addChild(n.skeletonXY),n.parentDebugContainer.addChild(n.regionAttachmentsShape),n.parentDebugContainer.addChild(n.meshTrianglesLine),n.parentDebugContainer.addChild(n.meshHullLine),n.parentDebugContainer.addChild(n.clippingPolygon),n.parentDebugContainer.addChild(n.boundingBoxesRect),n.parentDebugContainer.addChild(n.boundingBoxesCircle),n.parentDebugContainer.addChild(n.boundingBoxesPolygon),n.parentDebugContainer.addChild(n.pathsCurve),n.parentDebugContainer.addChild(n.pathsLine),t.addChild(n.parentDebugContainer),this.registeredSpines.set(t,n)}renderDebug(t){this.registeredSpines.has(t)||this.registerSpine(t);const n=this.registeredSpines.get(t);n.skeletonXY.clear(),n.regionAttachmentsShape.clear(),n.meshTrianglesLine.clear(),n.meshHullLine.clear(),n.clippingPolygon.clear(),n.boundingBoxesRect.clear(),n.boundingBoxesCircle.clear(),n.boundingBoxesPolygon.clear(),n.pathsCurve.clear(),n.pathsLine.clear();for(let i=n.bones.children.length;i>0;i--)n.bones.children[i-1].destroy({children:!0,texture:!0,baseTexture:!0});const e=t.scale.x||t.scale.y||1,r=this.lineWidth/e;this.drawBones&&this.drawBonesFunc(t,n,r,e),this.drawPaths&&this.drawPathsFunc(t,n,r),this.drawBoundingBoxes&&this.drawBoundingBoxesFunc(t,n,r),this.drawClipping&&this.drawClippingFunc(t,n,r),(this.drawMeshHull||this.drawMeshTriangles)&&this.drawMeshHullAndMeshTriangles(t,n,r),this.drawRegionAttachments&&this.drawRegionAttachmentsFunc(t,n,r)}drawBonesFunc(t,n,e,r){const i=t.skeleton,h=i.x,l=i.y,s=i.bones;n.skeletonXY.lineStyle(e,this.skeletonXYColor,1);for(let o=0,c=s.length;o<c;o++){const d=s[o],u=d.data.length,m=h+d.matrix.tx,g=l+d.matrix.ty,x=h+u*d.matrix.a+d.matrix.tx,w=l+u*d.matrix.b+d.matrix.ty;if(d.data.name==="root"||d.data.parent===null)continue;const b=Math.abs(m-x),E=Math.abs(g-w),p=Math.pow(b,2),S=E,y=Math.pow(E,2),M=Math.sqrt(p+y),C=Math.pow(M,2),I=Math.PI/180,R=Math.acos((C+y-p)/(2*S*M))||0;if(M===0)continue;const v=new $e.Graphics;n.bones.addChild(v);const V=M/50/r;v.beginFill(this.bonesColor,1),v.drawPolygon(0,0,0-V,M-V*3,0,M-V,0+V,M-V*3),v.endFill(),v.x=m,v.y=g,v.pivot.y=M;let P=0;m<x&&g<w?P=-R+180*I:m>x&&g<w?P=180*I+R:m>x&&g>w?P=-R:m<x&&g>w?P=R:g===w&&m<x?P=90*I:g===w&&m>x?P=-90*I:m===x&&g<w?P=180*I:m===x&&g>w&&(P=0),v.rotation=P,v.lineStyle(e+V/2.4,this.bonesColor,1),v.beginFill(0,.6),v.drawCircle(0,M,V*1.2),v.endFill()}const a=e*3;n.skeletonXY.moveTo(h-a,l-a),n.skeletonXY.lineTo(h+a,l+a),n.skeletonXY.moveTo(h+a,l-a),n.skeletonXY.lineTo(h-a,l+a)}drawRegionAttachmentsFunc(t,n,e){const i=t.skeleton.slots;n.regionAttachmentsShape.lineStyle(e,this.regionAttachmentsColor,1);for(let h=0,l=i.length;h<l;h++){const s=i[h],a=s.getAttachment();if(a==null||a.type!==Z.Region)continue;const o=a,c=new Float32Array(8);o.updateOffset&&o.updateOffset(),o.computeWorldVertices(s,c,0,2),n.regionAttachmentsShape.drawPolygon(Array.from(c.slice(0,8)))}}drawMeshHullAndMeshTriangles(t,n,e){const i=t.skeleton.slots;n.meshHullLine.lineStyle(e,this.meshHullColor,1),n.meshTrianglesLine.lineStyle(e,this.meshTrianglesColor,1);for(let h=0,l=i.length;h<l;h++){const s=i[h];if(!s.bone.active)continue;const a=s.getAttachment();if(a==null||a.type!==Z.Mesh)continue;const o=a,c=new Float32Array(o.worldVerticesLength),d=o.triangles;let u=o.hullLength;if(o.computeWorldVertices(s,0,o.worldVerticesLength,c,0,2),this.drawMeshTriangles)for(let m=0,g=d.length;m<g;m+=3){const x=d[m]*2,w=d[m+1]*2,b=d[m+2]*2;n.meshTrianglesLine.moveTo(c[x],c[x+1]),n.meshTrianglesLine.lineTo(c[w],c[w+1]),n.meshTrianglesLine.lineTo(c[b],c[b+1])}if(this.drawMeshHull&&u>0){u=(u>>1)*2;let m=c[u-2],g=c[u-1];for(let x=0,w=u;x<w;x+=2){const b=c[x],E=c[x+1];n.meshHullLine.moveTo(b,E),n.meshHullLine.lineTo(m,g),m=b,g=E}}}}drawClippingFunc(t,n,e){const i=t.skeleton.slots;n.clippingPolygon.lineStyle(e,this.clippingPolygonColor,1);for(let h=0,l=i.length;h<l;h++){const s=i[h];if(!s.bone.active)continue;const a=s.getAttachment();if(a==null||a.type!==Z.Clipping)continue;const o=a,c=o.worldVerticesLength,d=new Float32Array(c);o.computeWorldVertices(s,0,c,d,0,2),n.clippingPolygon.drawPolygon(Array.from(d))}}drawBoundingBoxesFunc(t,n,e){n.boundingBoxesRect.lineStyle(e,this.boundingBoxesRectColor,5);const r=new Qn;r.update(t.skeleton,!0),n.boundingBoxesRect.drawRect(r.minX,r.minY,r.getWidth(),r.getHeight());const i=r.polygons,h=(l,s,a)=>{if(n.boundingBoxesPolygon.lineStyle(e,this.boundingBoxesPolygonColor,1),n.boundingBoxesPolygon.beginFill(this.boundingBoxesPolygonColor,.1),a<3)throw new Error("Polygon must contain at least 3 vertices");const o=[],c=e*2;for(let d=0,u=l.length;d<u;d+=2){const m=l[d],g=l[d+1];n.boundingBoxesCircle.lineStyle(0),n.boundingBoxesCircle.beginFill(this.boundingBoxesCircleColor),n.boundingBoxesCircle.drawCircle(m,g,c),n.boundingBoxesCircle.endFill(),o.push(m,g)}n.boundingBoxesPolygon.drawPolygon(o),n.boundingBoxesPolygon.endFill()};for(let l=0,s=i.length;l<s;l++){const a=i[l];h(a,0,a.length)}}drawPathsFunc(t,n,e){const i=t.skeleton.slots;n.pathsCurve.lineStyle(e,this.pathsCurveColor,1),n.pathsLine.lineStyle(e,this.pathsLineColor,1);for(let h=0,l=i.length;h<l;h++){const s=i[h];if(!s.bone.active)continue;const a=s.getAttachment();if(a==null||a.type!==Z.Path)continue;const o=a;let c=o.worldVerticesLength;const d=new Float32Array(c);o.computeWorldVertices(s,0,c,d,0,2);let u=d[2],m=d[3],g=0,x=0;if(o.closed){const w=d[0],b=d[1],E=d[c-2],p=d[c-1];g=d[c-4],x=d[c-3],n.pathsCurve.moveTo(u,m),n.pathsCurve.bezierCurveTo(w,b,E,p,g,x),n.pathsLine.moveTo(u,m),n.pathsLine.lineTo(w,b),n.pathsLine.moveTo(g,x),n.pathsLine.lineTo(E,p)}c-=4;for(let w=4;w<c;w+=6){const b=d[w],E=d[w+1],p=d[w+2],S=d[w+3];g=d[w+4],x=d[w+5],n.pathsCurve.moveTo(u,m),n.pathsCurve.bezierCurveTo(b,E,p,S,g,x),n.pathsLine.moveTo(u,m),n.pathsLine.lineTo(b,E),n.pathsLine.moveTo(g,x),n.pathsLine.lineTo(p,S),u=g,m=x}}}unregisterSpine(t){this.registeredSpines.has(t)||console.warn("SpineDebugRenderer.unregisterSpine() - spine is not registered, can't unregister!",t),this.registeredSpines.get(t).parentDebugContainer.destroy({baseTexture:!0,children:!0,texture:!0}),this.registeredSpines.delete(t)}}const ja={extension:G.ExtensionType.Asset,loader:{extension:{type:G.ExtensionType.LoadParser,priority:Ie.LoaderParserPriority.Normal},test(f){return Ie.checkExtension(f,".atlas")},async load(f){return await(await G.settings.ADAPTER.fetch(f)).text()},testParse(f,t){const n=Ie.checkExtension(t.src,".atlas"),e=typeof f=="string";return Promise.resolve(n&&e)},async parse(f,t,n){const e=t.data;let r=G.utils.path.dirname(t.src);r&&r.lastIndexOf("/")!==r.length-1&&(r+="/");let i=null,h=null;const l=new Promise((o,c)=>{i=o,h=c});let s;const a=o=>{o||h(`Something went terribly wrong loading a spine .atlas file
Most likely your texture failed to load.`),i(s)};if(e.image||e.images){const o=Object.assign(e.image?{default:e.image}:{},e.images);s=new bs(f,(c,d)=>{const u=o[c]||o.default;u&&u.baseTexture?d(u.baseTexture):d(u)},a)}else s=new bs(f,Br(n,r,e.imageMetadata),a);return await l},unload(f){f.dispose()}}},Br=(f,t,n,e)=>async(r,i)=>{const h=G.utils.path.normalize([...t.split(G.utils.path.sep),r].join(G.utils.path.sep)),l=await f.load(e||{src:h,data:n});i(l.baseTexture)};G.extensions.add(ja);const Dr=".json",_r="application/json",Lr=["application/octet-stream","text/plain"],Za=["image/jpeg","image/png"];function Or(f){return f.hasOwnProperty("bones")}function Qa(f){return f instanceof ArrayBuffer}class Ka{constructor(){}installLoader(){const t=this,n={extension:G.ExtensionType.Asset,loader:{extension:{type:G.ExtensionType.LoadParser,priority:Ie.LoaderParserPriority.Normal},test(e){return Ie.checkExtension(e,".skel")},async load(e){return Ie.checkDataUrl(e,Lr)?Ja(e.slice(0,e.lastIndexOf("."))):await(await G.settings.ADAPTER.fetch(e)).arrayBuffer()},testParse(e,r){var s;const i=Ie.checkDataUrl(r.src,_r)||Ie.checkExtension(r.src,Dr)&&Or(e),h=Ie.checkExtension(r.src,".skel")&&Qa(e),l=((s=r.data)==null?void 0:s.spineAtlas)===!1;return Promise.resolve(i&&!l||h)},async parse(e,r,i){var E;const h=G.utils.path.extname(r.src).toLowerCase(),l=G.utils.path.basename(r.src,h);let s=G.utils.path.dirname(r.src);s&&s.lastIndexOf("/")!==s.length-1&&(s+="/");const a=Ie.checkDataUrl(r.src,_r)||Ie.checkExtension(r.src,Dr)&&Or(e);let o=null,c=e;a?o=t.createJsonParser():(o=t.createBinaryParser(),c=new Uint8Array(e));const d=r.data||{},u=(E=d==null?void 0:d.spineSkeletonScale)!=null?E:null;u&&(o.scale=u);const m=d.spineAtlas;if(m&&m.pages)return t.parseData(o,m,c);let g=d.atlasRawData;if(Ie.checkDataUrl(d.spineAtlasFile,Lr)&&(g=atob(d.spineAtlasFile.split(",")[1])),g){let p=null,S=null;const y=new Promise((R,v)=>{p=R,S=v}),M=typeof d.image=="string"&&Ie.checkDataUrl(d.image,Za)?d.image:null,C=new bs(g,Br(i,s,d.imageMetadata,M),R=>{R||S(`Something went terribly wrong loading a spine .atlas file
Most likely your texture failed to load.`),p(C)}),I=await y;return t.parseData(o,I,c)}let w=d.spineAtlasFile;w||(w=`${s+l}.atlas`);const b=await i.load({src:w,data:d,alias:d.spineAtlasAlias});return t.parseData(o,b,c)}}};return G.extensions.add(n),n}}function Ja(f){const t=f.split(",")[1],n=atob(t),e=n.length,r=new ArrayBuffer(e),i=new Uint8Array(r);for(let h=0;h<e;h++)i[h]=n.charCodeAt(h);return r}let Gs=class{constructor(t){if(t==null)throw new Error("name cannot be null.");this.name=t}};const $r=class extends Gs{constructor(t){super(t),this.id=($r.nextID++&65535)<<11,this.worldVerticesLength=0,this.deformAttachment=this}computeWorldVerticesOld(t,n){this.computeWorldVertices(t,0,this.worldVerticesLength,n,0,2)}computeWorldVertices(t,n,e,r,i,h){e=i+(e>>1)*h;const l=t.bone.skeleton,s=t.deform;let a=this.vertices;const o=this.bones;if(o==null){s.length>0&&(a=s);const m=t.bone.matrix,g=m.tx,x=m.ty,w=m.a,b=m.c,E=m.b,p=m.d;for(let S=n,y=i;y<e;S+=2,y+=h){const M=a[S],C=a[S+1];r[y]=M*w+C*b+g,r[y+1]=M*E+C*p+x}return}let c=0,d=0;for(let m=0;m<n;m+=2){const g=o[c];c+=g+1,d+=g}const u=l.bones;if(s.length==0)for(let m=i,g=d*3;m<e;m+=h){let x=0,w=0,b=o[c++];for(b+=c;c<b;c++,g+=3){const E=u[o[c]].matrix,p=a[g],S=a[g+1],y=a[g+2];x+=(p*E.a+S*E.c+E.tx)*y,w+=(p*E.b+S*E.d+E.ty)*y}r[m]=x,r[m+1]=w}else{const m=s;for(let g=i,x=d*3,w=d<<1;g<e;g+=h){let b=0,E=0,p=o[c++];for(p+=c;c<p;c++,x+=3,w+=2){const S=u[o[c]].matrix,y=a[x]+m[w],M=a[x+1]+m[w+1],C=a[x+2];b+=(y*S.a+M*S.c+S.tx)*C,E+=(y*S.b+M*S.d+S.ty)*C}r[g]=b,r[g+1]=E}}}copyTo(t){this.bones!=null?(t.bones=new Array(this.bones.length),k.arrayCopy(this.bones,0,t.bones,0,this.bones.length)):t.bones=null,this.vertices!=null?(t.vertices=k.newFloatArray(this.vertices.length),k.arrayCopy(this.vertices,0,t.vertices,0,this.vertices.length)):t.vertices=null,t.worldVerticesLength=this.worldVerticesLength,t.deformAttachment=this.deformAttachment}};let Tn=$r;Tn.nextID=0;let js=class{constructor(t,n){if(this.deform=new Array,t==null)throw new Error("data cannot be null.");if(n==null)throw new Error("bone cannot be null.");this.data=t,this.bone=n,this.color=new O,this.darkColor=t.darkColor==null?null:new O,this.setToSetupPose(),this.blendMode=this.data.blendMode}getAttachment(){return this.attachment}setAttachment(t){this.attachment!=t&&(this.attachment=t,this.attachmentTime=this.bone.skeleton.time,this.deform.length=0)}setAttachmentTime(t){this.attachmentTime=this.bone.skeleton.time-t}getAttachmentTime(){return this.bone.skeleton.time-this.attachmentTime}setToSetupPose(){this.color.setFromColor(this.data.color),this.darkColor!=null&&this.darkColor.setFromColor(this.data.darkColor),this.data.attachmentName==null?this.attachment=null:(this.attachment=null,this.setAttachment(this.bone.skeleton.getAttachment(this.data.index,this.data.attachmentName)))}};const Wt=class extends Gs{constructor(t){super(t),this.type=Z.Region,this.x=0,this.y=0,this.scaleX=1,this.scaleY=1,this.rotation=0,this.width=0,this.height=0,this.color=new O(1,1,1,1),this.offset=k.newFloatArray(8),this.uvs=k.newFloatArray(8),this.tempColor=new O(1,1,1,1)}updateOffset(){const t=this.width/this.region.originalWidth*this.scaleX,n=this.height/this.region.originalHeight*this.scaleY,e=-this.width/2*this.scaleX+this.region.offsetX*t,r=-this.height/2*this.scaleY+this.region.offsetY*n,i=e+this.region.width*t,h=r+this.region.height*n,l=this.rotation*Math.PI/180,s=Math.cos(l),a=Math.sin(l),o=e*s+this.x,c=e*a,d=r*s+this.y,u=r*a,m=i*s+this.x,g=i*a,x=h*s+this.y,w=h*a,b=this.offset;b[Wt.OX1]=o-u,b[Wt.OY1]=d+c,b[Wt.OX2]=o-w,b[Wt.OY2]=x+c,b[Wt.OX3]=m-w,b[Wt.OY3]=x+g,b[Wt.OX4]=m-u,b[Wt.OY4]=d+g}setRegion(t){this.region=t;const n=this.uvs;t.rotate?(n[2]=t.u,n[3]=t.v2,n[4]=t.u,n[5]=t.v,n[6]=t.u2,n[7]=t.v,n[0]=t.u2,n[1]=t.v2):(n[0]=t.u,n[1]=t.v2,n[2]=t.u,n[3]=t.v,n[4]=t.u2,n[5]=t.v,n[6]=t.u2,n[7]=t.v2)}computeWorldVertices(t,n,e,r){const i=this.offset,h=t instanceof js?t.bone.matrix:t.matrix,l=h.tx,s=h.ty,a=h.a,o=h.c,c=h.b,d=h.d;let u=0,m=0;u=i[Wt.OX1],m=i[Wt.OY1],n[e]=u*a+m*o+l,n[e+1]=u*c+m*d+s,e+=r,u=i[Wt.OX2],m=i[Wt.OY2],n[e]=u*a+m*o+l,n[e+1]=u*c+m*d+s,e+=r,u=i[Wt.OX3],m=i[Wt.OY3],n[e]=u*a+m*o+l,n[e+1]=u*c+m*d+s,e+=r,u=i[Wt.OX4],m=i[Wt.OY4],n[e]=u*a+m*o+l,n[e+1]=u*c+m*d+s}copy(){const t=new Wt(this.name);return t.region=this.region,t.rendererObject=this.rendererObject,t.path=this.path,t.x=this.x,t.y=this.y,t.scaleX=this.scaleX,t.scaleY=this.scaleY,t.rotation=this.rotation,t.width=this.width,t.height=this.height,k.arrayCopy(this.uvs,0,t.uvs,0,8),k.arrayCopy(this.offset,0,t.offset,0,8),t.color.setFromColor(this.color),t}};let J=Wt;J.OX1=0,J.OY1=1,J.OX2=2,J.OY2=3,J.OX3=4,J.OY3=5,J.OX4=6,J.OY4=7,J.X1=0,J.Y1=1,J.C1R=2,J.C1G=3,J.C1B=4,J.C1A=5,J.U1=6,J.V1=7,J.X2=8,J.Y2=9,J.C2R=10,J.C2G=11,J.C2B=12,J.C2A=13,J.U2=14,J.V2=15,J.X3=16,J.Y3=17,J.C3R=18,J.C3G=19,J.C3B=20,J.C3A=21,J.U3=22,J.V3=23,J.X4=24,J.Y4=25,J.C4R=26,J.C4G=27,J.C4B=28,J.C4A=29,J.U4=30,J.V4=31;const Wr=class{constructor(t){this.centerX=0,this.centerY=0,this.radius=0,this.angle=0,this.worldX=0,this.worldY=0,this.radius=t}begin(t){this.worldX=t.x+this.centerX,this.worldY=t.y+this.centerY}transform(t,n,e,r){const i=this.angle*T.degreesToRadians,h=t.x-this.worldX,l=t.y-this.worldY,s=Math.sqrt(h*h+l*l);if(s<this.radius){const a=Wr.interpolation.apply(0,i,(this.radius-s)/this.radius),o=Math.cos(a),c=Math.sin(a);t.x=o*h-c*l+this.worldX,t.y=c*h+o*l+this.worldY}}end(){}};let qr=Wr;qr.interpolation=new Ss(2);let Rt=class{constructor(t,n,e){if(t==null)throw new Error("name cannot be null.");if(n==null)throw new Error("timelines cannot be null.");this.name=t,this.timelines=n,this.timelineIds=[];for(let r=0;r<n.length;r++)this.timelineIds[n[r].getPropertyId()]=!0;this.duration=e}hasTimeline(t){return this.timelineIds[t]==!0}apply(t,n,e,r,i,h,l,s){if(t==null)throw new Error("skeleton cannot be null.");r&&this.duration!=0&&(e%=this.duration,n>0&&(n%=this.duration));const a=this.timelines;for(let o=0,c=a.length;o<c;o++)a[o].apply(t,n,e,i,h,l,s)}static binarySearch(t,n,e=1){let r=0,i=t.length/e-2;if(i==0)return e;let h=i>>>1;for(;;){if(t[(h+1)*e]<=n?r=h+1:i=h,r==i)return(r+1)*e;h=r+i>>>1}}static linearSearch(t,n,e){for(let r=0,i=t.length-e;r<=i;r+=e)if(t[r]>n)return r;return-1}};var Ur=(f=>(f[f.rotate=0]="rotate",f[f.translate=1]="translate",f[f.scale=2]="scale",f[f.shear=3]="shear",f[f.attachment=4]="attachment",f[f.color=5]="color",f[f.deform=6]="deform",f[f.event=7]="event",f[f.drawOrder=8]="drawOrder",f[f.ikConstraint=9]="ikConstraint",f[f.transformConstraint=10]="transformConstraint",f[f.pathConstraintPosition=11]="pathConstraintPosition",f[f.pathConstraintSpacing=12]="pathConstraintSpacing",f[f.pathConstraintMix=13]="pathConstraintMix",f[f.twoColor=14]="twoColor",f))(Ur||{});const kt=class{constructor(t){if(this.curveData=[],t<=0)throw new Error(`frameCount must be > 0: ${t}`);this.curves=k.newFloatArray((t-1)*kt.BEZIER_SIZE)}getFrameCount(){return this.curves.length/kt.BEZIER_SIZE+1}setLinear(t){this.curves[t*kt.BEZIER_SIZE]=kt.LINEAR}setStepped(t){this.curves[t*kt.BEZIER_SIZE]=kt.STEPPED}getCurveType(t){const n=t*kt.BEZIER_SIZE;if(n==this.curves.length)return kt.LINEAR;const e=this.curves[n];return e==kt.LINEAR?kt.LINEAR:e==kt.STEPPED?kt.STEPPED:kt.BEZIER}setCurve(t,n,e,r,i){this.curveData.push({frameIndex:t,cx1:n,cy1:e,cx2:r,cy2:i});const h=(-n*2+r)*.03,l=(-e*2+i)*.03,s=((n-r)*3+1)*.006,a=((e-i)*3+1)*.006;let o=h*2+s,c=l*2+a,d=n*.3+h+s*.16666667,u=e*.3+l+a*.16666667,m=t*kt.BEZIER_SIZE;const g=this.curves;g[m++]=kt.BEZIER;let x=d,w=u;for(let b=m+kt.BEZIER_SIZE-1;m<b;m+=2)g[m]=x,g[m+1]=w,d+=o,u+=c,o+=s,c+=a,x+=d,w+=u}getCurvePercent(t,n){n=T.clamp(n,0,1);const e=this.curves;let r=t*kt.BEZIER_SIZE;const i=e[r];if(i==kt.LINEAR)return n;if(i==kt.STEPPED)return 0;r++;let h=0;for(let s=r,a=r+kt.BEZIER_SIZE-1;r<a;r+=2)if(h=e[r],h>=n){let o,c;return r==s?(o=0,c=0):(o=e[r-2],c=e[r-1]),c+(e[r+1]-c)*(n-o)/(h-o)}const l=e[r-1];return l+(1-l)*(n-h)/(1-h)}};let we=kt;we.LINEAR=0,we.STEPPED=1,we.BEZIER=2,we.BEZIER_SIZE=10*2-1;const Cn=class extends we{constructor(t){super(t),this.type="RotateTimeline",this.data=[],this.frames=k.newFloatArray(t<<1)}getPropertyId(){return(0<<24)+this.boneIndex}setFrame(t,n,e){this.data.push({frameIndex:t,time:n,degrees:e}),t<<=1,this.frames[t]=n,this.frames[t+Cn.ROTATION]=e}apply(t,n,e,r,i,h,l){const s=this.frames,a=t.bones[this.boneIndex];if(!a.active)return;if(e<s[0]){switch(h){case A.setup:a.rotation=a.data.rotation;return;case A.first:const g=a.data.rotation-a.rotation;a.rotation+=(g-(16384-(16384.499999999996-g/360|0))*360)*i}return}if(e>=s[s.length-Cn.ENTRIES]){let g=s[s.length+Cn.PREV_ROTATION];switch(h){case A.setup:a.rotation=a.data.rotation+g*i;break;case A.first:case A.replace:g+=a.data.rotation-a.rotation,g-=(16384-(16384.499999999996-g/360|0))*360;case A.add:a.rotation+=g*i}return}const o=Rt.binarySearch(s,e,Cn.ENTRIES),c=s[o+Cn.PREV_ROTATION],d=s[o],u=this.getCurvePercent((o>>1)-1,1-(e-d)/(s[o+Cn.PREV_TIME]-d));let m=s[o+Cn.ROTATION]-c;switch(m=c+(m-(16384-(16384.499999999996-m/360|0))*360)*u,h){case A.setup:a.rotation=a.data.rotation+(m-(16384-(16384.499999999996-m/360|0))*360)*i;break;case A.first:case A.replace:m+=a.data.rotation-a.rotation;case A.add:a.rotation+=(m-(16384-(16384.499999999996-m/360|0))*360)*i}}};let Zt=Cn;Zt.ENTRIES=2,Zt.PREV_TIME=-2,Zt.PREV_ROTATION=-1,Zt.ROTATION=1;const ae=class extends we{constructor(t){super(t),this.type="TranslateTimeline",this.data=[],this.frames=k.newFloatArray(t*ae.ENTRIES)}getPropertyId(){return(1<<24)+this.boneIndex}setFrame(t,n,e,r){this.data.push({frameIndex:t,time:n,x:e,y:r}),t*=ae.ENTRIES,this.frames[t]=n,this.frames[t+ae.X]=e,this.frames[t+ae.Y]=r}apply(t,n,e,r,i,h,l){const s=this.frames,a=t.bones[this.boneIndex];if(!a.active)return;if(e<s[0]){switch(h){case A.setup:a.x=a.data.x,a.y=a.data.y;return;case A.first:a.x+=(a.data.x-a.x)*i,a.y+=(a.data.y-a.y)*i}return}let o=0,c=0;if(e>=s[s.length-ae.ENTRIES])o=s[s.length+ae.PREV_X],c=s[s.length+ae.PREV_Y];else{const d=Rt.binarySearch(s,e,ae.ENTRIES);o=s[d+ae.PREV_X],c=s[d+ae.PREV_Y];const u=s[d],m=this.getCurvePercent(d/ae.ENTRIES-1,1-(e-u)/(s[d+ae.PREV_TIME]-u));o+=(s[d+ae.X]-o)*m,c+=(s[d+ae.Y]-c)*m}switch(h){case A.setup:a.x=a.data.x+o*i,a.y=a.data.y+c*i;break;case A.first:case A.replace:a.x+=(a.data.x+o-a.x)*i,a.y+=(a.data.y+c-a.y)*i;break;case A.add:a.x+=o*i,a.y+=c*i}}};let Re=ae;Re.ENTRIES=3,Re.PREV_TIME=-3,Re.PREV_X=-2,Re.PREV_Y=-1,Re.X=1,Re.Y=2;let ke=class extends Re{constructor(t){super(t),this.type="ScaleTimeline"}getPropertyId(){return(2<<24)+this.boneIndex}apply(t,n,e,r,i,h,l){const s=this.frames,a=t.bones[this.boneIndex];if(!a.active)return;if(e<s[0]){switch(h){case A.setup:a.scaleX=a.data.scaleX,a.scaleY=a.data.scaleY;return;case A.first:a.scaleX+=(a.data.scaleX-a.scaleX)*i,a.scaleY+=(a.data.scaleY-a.scaleY)*i}return}let o=0,c=0;if(e>=s[s.length-ke.ENTRIES])o=s[s.length+ke.PREV_X]*a.data.scaleX,c=s[s.length+ke.PREV_Y]*a.data.scaleY;else{const d=Rt.binarySearch(s,e,ke.ENTRIES);o=s[d+ke.PREV_X],c=s[d+ke.PREV_Y];const u=s[d],m=this.getCurvePercent(d/ke.ENTRIES-1,1-(e-u)/(s[d+ke.PREV_TIME]-u));o=(o+(s[d+ke.X]-o)*m)*a.data.scaleX,c=(c+(s[d+ke.Y]-c)*m)*a.data.scaleY}if(i==1)h==A.add?(a.scaleX+=o-a.data.scaleX,a.scaleY+=c-a.data.scaleY):(a.scaleX=o,a.scaleY=c);else{let d=0,u=0;if(l==Q.mixOut)switch(h){case A.setup:d=a.data.scaleX,u=a.data.scaleY,a.scaleX=d+(Math.abs(o)*T.signum(d)-d)*i,a.scaleY=u+(Math.abs(c)*T.signum(u)-u)*i;break;case A.first:case A.replace:d=a.scaleX,u=a.scaleY,a.scaleX=d+(Math.abs(o)*T.signum(d)-d)*i,a.scaleY=u+(Math.abs(c)*T.signum(u)-u)*i;break;case A.add:d=a.scaleX,u=a.scaleY,a.scaleX=d+(Math.abs(o)*T.signum(d)-a.data.scaleX)*i,a.scaleY=u+(Math.abs(c)*T.signum(u)-a.data.scaleY)*i}else switch(h){case A.setup:d=Math.abs(a.data.scaleX)*T.signum(o),u=Math.abs(a.data.scaleY)*T.signum(c),a.scaleX=d+(o-d)*i,a.scaleY=u+(c-u)*i;break;case A.first:case A.replace:d=Math.abs(a.scaleX)*T.signum(o),u=Math.abs(a.scaleY)*T.signum(c),a.scaleX=d+(o-d)*i,a.scaleY=u+(c-u)*i;break;case A.add:d=T.signum(o),u=T.signum(c),a.scaleX=Math.abs(a.scaleX)*d+(o-Math.abs(a.data.scaleX)*d)*i,a.scaleY=Math.abs(a.scaleY)*u+(c-Math.abs(a.data.scaleY)*u)*i}}}},ve=class extends Re{constructor(t){super(t),this.type="ShearTimeline"}getPropertyId(){return(3<<24)+this.boneIndex}apply(t,n,e,r,i,h,l){const s=this.frames,a=t.bones[this.boneIndex];if(!a.active)return;if(e<s[0]){switch(h){case A.setup:a.shearX=a.data.shearX,a.shearY=a.data.shearY;return;case A.first:a.shearX+=(a.data.shearX-a.shearX)*i,a.shearY+=(a.data.shearY-a.shearY)*i}return}let o=0,c=0;if(e>=s[s.length-ve.ENTRIES])o=s[s.length+ve.PREV_X],c=s[s.length+ve.PREV_Y];else{const d=Rt.binarySearch(s,e,ve.ENTRIES);o=s[d+ve.PREV_X],c=s[d+ve.PREV_Y];const u=s[d],m=this.getCurvePercent(d/ve.ENTRIES-1,1-(e-u)/(s[d+ve.PREV_TIME]-u));o=o+(s[d+ve.X]-o)*m,c=c+(s[d+ve.Y]-c)*m}switch(h){case A.setup:a.shearX=a.data.shearX+o*i,a.shearY=a.data.shearY+c*i;break;case A.first:case A.replace:a.shearX+=(a.data.shearX+o-a.shearX)*i,a.shearY+=(a.data.shearY+c-a.shearY)*i;break;case A.add:a.shearX+=o*i,a.shearY+=c*i}}};const xt=class extends we{constructor(t){super(t),this.type="ColorTimeline",this.data=[],this.frames=k.newFloatArray(t*xt.ENTRIES)}getPropertyId(){return(5<<24)+this.slotIndex}setFrame(t,n,e,r,i,h){this.data.push({frameIndex:t,time:n,r:e,g:r,b:i,a:h}),t*=xt.ENTRIES,this.frames[t]=n,this.frames[t+xt.R]=e,this.frames[t+xt.G]=r,this.frames[t+xt.B]=i,this.frames[t+xt.A]=h}apply(t,n,e,r,i,h,l){const s=t.slots[this.slotIndex];if(!s.bone.active)return;const a=this.frames;if(e<a[0]){switch(h){case A.setup:s.color.setFromColor(s.data.color);return;case A.first:const m=s.color,g=s.data.color;m.add((g.r-m.r)*i,(g.g-m.g)*i,(g.b-m.b)*i,(g.a-m.a)*i)}return}let o=0,c=0,d=0,u=0;if(e>=a[a.length-xt.ENTRIES]){const m=a.length;o=a[m+xt.PREV_R],c=a[m+xt.PREV_G],d=a[m+xt.PREV_B],u=a[m+xt.PREV_A]}else{const m=Rt.binarySearch(a,e,xt.ENTRIES);o=a[m+xt.PREV_R],c=a[m+xt.PREV_G],d=a[m+xt.PREV_B],u=a[m+xt.PREV_A];const g=a[m],x=this.getCurvePercent(m/xt.ENTRIES-1,1-(e-g)/(a[m+xt.PREV_TIME]-g));o+=(a[m+xt.R]-o)*x,c+=(a[m+xt.G]-c)*x,d+=(a[m+xt.B]-d)*x,u+=(a[m+xt.A]-u)*x}if(i==1)s.color.set(o,c,d,u);else{const m=s.color;h==A.setup&&m.setFromColor(s.data.color),m.add((o-m.r)*i,(c-m.g)*i,(d-m.b)*i,(u-m.a)*i)}}};let oe=xt;oe.ENTRIES=5,oe.PREV_TIME=-5,oe.PREV_R=-4,oe.PREV_G=-3,oe.PREV_B=-2,oe.PREV_A=-1,oe.R=1,oe.G=2,oe.B=3,oe.A=4;const rt=class extends we{constructor(t){super(t),this.type="TwoColorTimeline",this.data=[],this.frames=k.newFloatArray(t*rt.ENTRIES)}getPropertyId(){return(14<<24)+this.slotIndex}setFrame(t,n,e,r,i,h,l,s,a){this.data.push({frameIndex:t,time:n,r:e,g:r,b:i,a:h,r2:l,g2:s,b2:a}),t*=rt.ENTRIES,this.frames[t]=n,this.frames[t+rt.R]=e,this.frames[t+rt.G]=r,this.frames[t+rt.B]=i,this.frames[t+rt.A]=h,this.frames[t+rt.R2]=l,this.frames[t+rt.G2]=s,this.frames[t+rt.B2]=a}apply(t,n,e,r,i,h,l){const s=t.slots[this.slotIndex];if(!s.bone.active)return;const a=this.frames;if(e<a[0]){switch(h){case A.setup:s.color.setFromColor(s.data.color),s.darkColor.setFromColor(s.data.darkColor);return;case A.first:const w=s.color,b=s.darkColor,E=s.data.color,p=s.data.darkColor;w.add((E.r-w.r)*i,(E.g-w.g)*i,(E.b-w.b)*i,(E.a-w.a)*i),b.add((p.r-b.r)*i,(p.g-b.g)*i,(p.b-b.b)*i,0)}return}let o=0,c=0,d=0,u=0,m=0,g=0,x=0;if(e>=a[a.length-rt.ENTRIES]){const w=a.length;o=a[w+rt.PREV_R],c=a[w+rt.PREV_G],d=a[w+rt.PREV_B],u=a[w+rt.PREV_A],m=a[w+rt.PREV_R2],g=a[w+rt.PREV_G2],x=a[w+rt.PREV_B2]}else{const w=Rt.binarySearch(a,e,rt.ENTRIES);o=a[w+rt.PREV_R],c=a[w+rt.PREV_G],d=a[w+rt.PREV_B],u=a[w+rt.PREV_A],m=a[w+rt.PREV_R2],g=a[w+rt.PREV_G2],x=a[w+rt.PREV_B2];const b=a[w],E=this.getCurvePercent(w/rt.ENTRIES-1,1-(e-b)/(a[w+rt.PREV_TIME]-b));o+=(a[w+rt.R]-o)*E,c+=(a[w+rt.G]-c)*E,d+=(a[w+rt.B]-d)*E,u+=(a[w+rt.A]-u)*E,m+=(a[w+rt.R2]-m)*E,g+=(a[w+rt.G2]-g)*E,x+=(a[w+rt.B2]-x)*E}if(i==1)s.color.set(o,c,d,u),s.darkColor.set(m,g,x,1);else{const w=s.color,b=s.darkColor;h==A.setup&&(w.setFromColor(s.data.color),b.setFromColor(s.data.darkColor)),w.add((o-w.r)*i,(c-w.g)*i,(d-w.b)*i,(u-w.a)*i),b.add((m-b.r)*i,(g-b.g)*i,(x-b.b)*i,0)}}};let Dt=rt;Dt.ENTRIES=8,Dt.PREV_TIME=-8,Dt.PREV_R=-7,Dt.PREV_G=-6,Dt.PREV_B=-5,Dt.PREV_A=-4,Dt.PREV_R2=-3,Dt.PREV_G2=-2,Dt.PREV_B2=-1,Dt.R=1,Dt.G=2,Dt.B=3,Dt.A=4,Dt.R2=5,Dt.G2=6,Dt.B2=7;let Nn=class{constructor(t){this.type="AttachmentTimeline",this.data=[],this.frames=k.newFloatArray(t),this.attachmentNames=new Array(t)}getPropertyId(){return(4<<24)+this.slotIndex}getFrameCount(){return this.frames.length}setFrame(t,n,e){this.data.push({frameIndex:t,time:n,attachmentName:e}),this.frames[t]=n,this.attachmentNames[t]=e}apply(t,n,e,r,i,h,l){const s=t.slots[this.slotIndex];if(!s.bone.active)return;if(l==Q.mixOut){h==A.setup&&this.setAttachment(t,s,s.data.attachmentName);return}const a=this.frames;if(e<a[0]){(h==A.setup||h==A.first)&&this.setAttachment(t,s,s.data.attachmentName);return}let o=0;e>=a[a.length-1]?o=a.length-1:o=Rt.binarySearch(a,e,1)-1;const c=this.attachmentNames[o];t.slots[this.slotIndex].setAttachment(c==null?null:t.getAttachment(this.slotIndex,c))}setAttachment(t,n,e){n.setAttachment(e==null?null:t.getAttachment(this.slotIndex,e))}},Hr=null,Zs=class extends we{constructor(t){super(t),this.type="DeformTimeline",this.data=[],this.frames=k.newFloatArray(t),this.frameVertices=new Array(t),Hr==null&&(Hr=k.newFloatArray(64))}getPropertyId(){return(6<<27)+Number(this.attachment.id)+this.slotIndex}setFrame(t,n,e,r){this.data.push({frameIndex:t,time:n,vertices:e,skin:r}),this.frames[t]=n,this.frameVertices[t]=e}apply(t,n,e,r,i,h,l){const s=t.slots[this.slotIndex];if(!s.bone.active)return;const a=s.getAttachment();if(!(a instanceof Tn)||a.deformAttachment!=this.attachment)return;const o=s.deform||[];o.length==0&&(h=A.setup);const c=this.frameVertices,d=c[0].length,u=this.frames;if(e<u[0]){const p=a;switch(h){case A.setup:o.length=0;return;case A.first:if(i==1){o.length=0;break}const S=k.setArraySize(o,d);if(p.bones==null){const y=p.vertices;for(let M=0;M<d;M++)S[M]+=(y[M]-S[M])*i}else{i=1-i;for(let y=0;y<d;y++)S[y]*=i}}return}const m=k.setArraySize(o,d);if(e>=u[u.length-1]){const p=c[u.length-1];if(i==1)if(h==A.add){const S=a;if(S.bones==null){const y=S.vertices;for(let M=0;M<d;M++)m[M]+=p[M]-y[M]}else for(let y=0;y<d;y++)m[y]+=p[y]}else k.arrayCopy(p,0,m,0,d);else switch(h){case A.setup:{const y=a;if(y.bones==null){const M=y.vertices;for(let C=0;C<d;C++){const I=M[C];m[C]=I+(p[C]-I)*i}}else for(let M=0;M<d;M++)m[M]=p[M]*i;break}case A.first:case A.replace:for(let y=0;y<d;y++)m[y]+=(p[y]-m[y])*i;break;case A.add:const S=a;if(S.bones==null){const y=S.vertices;for(let M=0;M<d;M++)m[M]+=(p[M]-y[M])*i}else for(let y=0;y<d;y++)m[y]+=p[y]*i}return}const g=Rt.binarySearch(u,e),x=c[g-1],w=c[g],b=u[g],E=this.getCurvePercent(g-1,1-(e-b)/(u[g-1]-b));if(i==1)if(h==A.add){const p=a;if(p.bones==null){const S=p.vertices;for(let y=0;y<d;y++){const M=x[y];m[y]+=M+(w[y]-M)*E-S[y]}}else for(let S=0;S<d;S++){const y=x[S];m[S]+=y+(w[S]-y)*E}}else for(let p=0;p<d;p++){const S=x[p];m[p]=S+(w[p]-S)*E}else switch(h){case A.setup:{const S=a;if(S.bones==null){const y=S.vertices;for(let M=0;M<d;M++){const C=x[M],I=y[M];m[M]=I+(C+(w[M]-C)*E-I)*i}}else for(let y=0;y<d;y++){const M=x[y];m[y]=(M+(w[y]-M)*E)*i}break}case A.first:case A.replace:for(let S=0;S<d;S++){const y=x[S];m[S]+=(y+(w[S]-y)*E-m[S])*i}break;case A.add:const p=a;if(p.bones==null){const S=p.vertices;for(let y=0;y<d;y++){const M=x[y];m[y]+=(M+(w[y]-M)*E-S[y])*i}}else for(let S=0;S<d;S++){const y=x[S];m[S]+=(y+(w[S]-y)*E)*i}}}},ys=class{constructor(t){this.type="EventTimeline",this.data=[],this.frames=k.newFloatArray(t),this.events=new Array(t)}getPropertyId(){return 7<<24}getFrameCount(){return this.frames.length}setFrame(t,n){this.data.push({frameIndex:t,event:n}),this.frames[t]=n.time,this.events[t]=n}apply(t,n,e,r,i,h,l){if(r==null)return;const s=this.frames,a=this.frames.length;if(n>e)this.apply(t,n,Number.MAX_VALUE,r,i,h,l),n=-1;else if(n>=s[a-1])return;if(e<s[0])return;let o=0;if(n<s[0])o=0;else{o=Rt.binarySearch(s,n);const c=s[o];for(;o>0&&s[o-1]==c;)o--}for(;o<a&&e>=s[o];o++)r.push(this.events[o])}},Kn=class{constructor(t){this.type="DrawOrderTimeline",this.data=[],this.frames=k.newFloatArray(t),this.drawOrders=new Array(t)}getPropertyId(){return 8<<24}getFrameCount(){return this.frames.length}setFrame(t,n,e){this.data.push({frameIndex:t,time:n,drawOrder:e}),this.frames[t]=n,this.drawOrders[t]=e}apply(t,n,e,r,i,h,l){const s=t.drawOrder,a=t.slots;if(l==Q.mixOut&&h==A.setup){k.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}const o=this.frames;if(e<o[0]){(h==A.setup||h==A.first)&&k.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}let c=0;e>=o[o.length-1]?c=o.length-1:c=Rt.binarySearch(o,e)-1;const d=this.drawOrders[c];if(d==null)k.arrayCopy(a,0,s,0,a.length);else for(let u=0,m=d.length;u<m;u++)s[u]=a[d[u]]}};const At=class extends we{constructor(t){super(t),this.type="IkConstraintTimeline",this.data=[],this.frames=k.newFloatArray(t*At.ENTRIES)}getPropertyId(){return(9<<24)+this.ikConstraintIndex}setFrame(t,n,e,r){this.data.push({frameIndex:t,time:n,mix:e,bendDirection:r}),t*=At.ENTRIES,this.frames[t]=n,this.frames[t+At.MIX]=e,this.frames[t+At.BEND_DIRECTION]=r}apply(t,n,e,r,i,h,l){const s=this.frames,a=t.ikConstraints[this.ikConstraintIndex];if(!a.active)return;if(e<s[0]){switch(h){case A.setup:a.mix=a.data.mix,a.softness=a.data.softness,a.bendDirection=a.data.bendDirection,a.compress=a.data.compress,a.stretch=a.data.stretch;return;case A.first:a.mix+=(a.data.mix-a.mix)*i,a.softness+=(a.data.softness-a.softness)*i,a.bendDirection=a.data.bendDirection,a.compress=a.data.compress,a.stretch=a.data.stretch}return}if(e>=s[s.length-At.ENTRIES]){h===A.setup?(a.mix=a.data.mix+(s[s.length+At.PREV_MIX]-a.data.mix)*i,a.softness=a.data.softness+(s[s.length+At.PREV_SOFTNESS]-a.data.softness)*i,l===Q.mixOut?(a.bendDirection=a.data.bendDirection,a.compress=a.data.compress,a.stretch=a.data.stretch):(a.bendDirection=s[s.length+At.PREV_BEND_DIRECTION],a.compress=s[s.length+At.PREV_COMPRESS]!==0,a.stretch=s[s.length+At.PREV_STRETCH]!==0)):(a.mix+=(s[s.length+At.PREV_MIX]-a.mix)*i,a.softness+=(s[s.length+At.PREV_SOFTNESS]-a.softness)*i,l===Q.mixIn&&(a.bendDirection=s[s.length+At.PREV_BEND_DIRECTION],a.compress=s[s.length+At.PREV_COMPRESS]!==0,a.stretch=s[s.length+At.PREV_STRETCH]!==0));return}const o=Rt.binarySearch(s,e,At.ENTRIES),c=s[o+At.PREV_MIX],d=s[o],u=this.getCurvePercent(o/At.ENTRIES-1,1-(e-d)/(s[o+At.PREV_TIME]-d));a.mix+=(c+(s[o+At.MIX]-c)*u-a.mix)*i,a.bendDirection=Math.floor(s[o+At.PREV_BEND_DIRECTION])}};let Qt=At;Qt.ENTRIES=6,Qt.PREV_TIME=-6,Qt.PREV_MIX=-5,Qt.PREV_SOFTNESS=-4,Qt.PREV_BEND_DIRECTION=-3,Qt.PREV_COMPRESS=-2,Qt.PREV_STRETCH=-1,Qt.MIX=1,Qt.SOFTNESS=2,Qt.BEND_DIRECTION=3,Qt.COMPRESS=4,Qt.STRETCH=5;const pt=class extends we{constructor(t){super(t),this.type="TransformConstraintTimeline",this.data=[],this.frames=k.newFloatArray(t*pt.ENTRIES)}getPropertyId(){return(10<<24)+this.transformConstraintIndex}setFrame(t,n,e,r,i,h){this.data.push({frameIndex:t,time:n,rotateMix:e,translateMix:r,scaleMix:i,shearMix:h}),t*=pt.ENTRIES,this.frames[t]=n,this.frames[t+pt.ROTATE]=e,this.frames[t+pt.TRANSLATE]=r,this.frames[t+pt.SCALE]=i,this.frames[t+pt.SHEAR]=h}apply(t,n,e,r,i,h,l){const s=this.frames,a=t.transformConstraints[this.transformConstraintIndex];if(!a.active)return;if(e<s[0]){const m=a.data;switch(h){case A.setup:a.rotateMix=m.rotateMix,a.translateMix=m.translateMix,a.scaleMix=m.scaleMix,a.shearMix=m.shearMix;return;case A.first:a.rotateMix+=(m.rotateMix-a.rotateMix)*i,a.translateMix+=(m.translateMix-a.translateMix)*i,a.scaleMix+=(m.scaleMix-a.scaleMix)*i,a.shearMix+=(m.shearMix-a.shearMix)*i}return}let o=0,c=0,d=0,u=0;if(e>=s[s.length-pt.ENTRIES]){const m=s.length;o=s[m+pt.PREV_ROTATE],c=s[m+pt.PREV_TRANSLATE],d=s[m+pt.PREV_SCALE],u=s[m+pt.PREV_SHEAR]}else{const m=Rt.binarySearch(s,e,pt.ENTRIES);o=s[m+pt.PREV_ROTATE],c=s[m+pt.PREV_TRANSLATE],d=s[m+pt.PREV_SCALE],u=s[m+pt.PREV_SHEAR];const g=s[m],x=this.getCurvePercent(m/pt.ENTRIES-1,1-(e-g)/(s[m+pt.PREV_TIME]-g));o+=(s[m+pt.ROTATE]-o)*x,c+=(s[m+pt.TRANSLATE]-c)*x,d+=(s[m+pt.SCALE]-d)*x,u+=(s[m+pt.SHEAR]-u)*x}if(h==A.setup){const m=a.data;a.rotateMix=m.rotateMix+(o-m.rotateMix)*i,a.translateMix=m.translateMix+(c-m.translateMix)*i,a.scaleMix=m.scaleMix+(d-m.scaleMix)*i,a.shearMix=m.shearMix+(u-m.shearMix)*i}else a.rotateMix+=(o-a.rotateMix)*i,a.translateMix+=(c-a.translateMix)*i,a.scaleMix+=(d-a.scaleMix)*i,a.shearMix+=(u-a.shearMix)*i}};let le=pt;le.ENTRIES=5,le.PREV_TIME=-5,le.PREV_ROTATE=-4,le.PREV_TRANSLATE=-3,le.PREV_SCALE=-2,le.PREV_SHEAR=-1,le.ROTATE=1,le.TRANSLATE=2,le.SCALE=3,le.SHEAR=4;const He=class extends we{constructor(t){super(t),this.type="PathConstraintPositionTimeline",this.data=[],this.frames=k.newFloatArray(t*He.ENTRIES)}getPropertyId(){return(11<<24)+this.pathConstraintIndex}setFrame(t,n,e){this.data.push({frameIndex:t,time:n,value:e}),t*=He.ENTRIES,this.frames[t]=n,this.frames[t+He.VALUE]=e}apply(t,n,e,r,i,h,l){const s=this.frames,a=t.pathConstraints[this.pathConstraintIndex];if(!a.active)return;if(e<s[0]){switch(h){case A.setup:a.position=a.data.position;return;case A.first:a.position+=(a.data.position-a.position)*i}return}let o=0;if(e>=s[s.length-He.ENTRIES])o=s[s.length+He.PREV_VALUE];else{const c=Rt.binarySearch(s,e,He.ENTRIES);o=s[c+He.PREV_VALUE];const d=s[c],u=this.getCurvePercent(c/He.ENTRIES-1,1-(e-d)/(s[c+He.PREV_TIME]-d));o+=(s[c+He.VALUE]-o)*u}h==A.setup?a.position=a.data.position+(o-a.data.position)*i:a.position+=(o-a.position)*i}};let an=He;an.ENTRIES=2,an.PREV_TIME=-2,an.PREV_VALUE=-1,an.VALUE=1;let on=class extends an{constructor(t){super(t),this.type="PathConstraintSpacingTimeline"}getPropertyId(){return(12<<24)+this.pathConstraintIndex}apply(t,n,e,r,i,h,l){const s=this.frames,a=t.pathConstraints[this.pathConstraintIndex];if(!a.active)return;if(e<s[0]){switch(h){case A.setup:a.spacing=a.data.spacing;return;case A.first:a.spacing+=(a.data.spacing-a.spacing)*i}return}let o=0;if(e>=s[s.length-on.ENTRIES])o=s[s.length+on.PREV_VALUE];else{const c=Rt.binarySearch(s,e,on.ENTRIES);o=s[c+on.PREV_VALUE];const d=s[c],u=this.getCurvePercent(c/on.ENTRIES-1,1-(e-d)/(s[c+on.PREV_TIME]-d));o+=(s[c+on.VALUE]-o)*u}h==A.setup?a.spacing=a.data.spacing+(o-a.data.spacing)*i:a.spacing+=(o-a.spacing)*i}};const ce=class extends we{constructor(t){super(t),this.type="PathConstraintMixTimeline",this.data=[],this.frames=k.newFloatArray(t*ce.ENTRIES)}getPropertyId(){return(13<<24)+this.pathConstraintIndex}setFrame(t,n,e,r){this.data.push({frameIndex:t,time:n,rotateMix:e,translateMix:r}),t*=ce.ENTRIES,this.frames[t]=n,this.frames[t+ce.ROTATE]=e,this.frames[t+ce.TRANSLATE]=r}apply(t,n,e,r,i,h,l){const s=this.frames,a=t.pathConstraints[this.pathConstraintIndex];if(!a.active)return;if(e<s[0]){switch(h){case A.setup:a.rotateMix=a.data.rotateMix,a.translateMix=a.data.translateMix;return;case A.first:a.rotateMix+=(a.data.rotateMix-a.rotateMix)*i,a.translateMix+=(a.data.translateMix-a.translateMix)*i}return}let o=0,c=0;if(e>=s[s.length-ce.ENTRIES])o=s[s.length+ce.PREV_ROTATE],c=s[s.length+ce.PREV_TRANSLATE];else{const d=Rt.binarySearch(s,e,ce.ENTRIES);o=s[d+ce.PREV_ROTATE],c=s[d+ce.PREV_TRANSLATE];const u=s[d],m=this.getCurvePercent(d/ce.ENTRIES-1,1-(e-u)/(s[d+ce.PREV_TIME]-u));o+=(s[d+ce.ROTATE]-o)*m,c+=(s[d+ce.TRANSLATE]-c)*m}h==A.setup?(a.rotateMix=a.data.rotateMix+(o-a.data.rotateMix)*i,a.translateMix=a.data.translateMix+(c-a.data.translateMix)*i):(a.rotateMix+=(o-a.rotateMix)*i,a.translateMix+=(c-a.translateMix)*i)}};let ze=ce;ze.ENTRIES=3,ze.PREV_TIME=-3,ze.PREV_ROTATE=-2,ze.PREV_TRANSLATE=-1,ze.ROTATE=1,ze.TRANSLATE=2;const wt=class{constructor(t){this.tracks=new Array,this.timeScale=1,this.unkeyedState=0,this.events=new Array,this.listeners=new Array,this.queue=new Ks(this),this.propertyIDs=new Es,this.animationsChanged=!1,this.trackEntryPool=new Zn(()=>new Ms),this.data=t}update(t){t*=this.timeScale;const n=this.tracks;for(let e=0,r=n.length;e<r;e++){const i=n[e];if(i==null)continue;i.animationLast=i.nextAnimationLast,i.trackLast=i.nextTrackLast;let h=t*i.timeScale;if(i.delay>0){if(i.delay-=h,i.delay>0)continue;h=-i.delay,i.delay=0}let l=i.next;if(l!=null){const s=i.trackLast-l.delay;if(s>=0){for(l.delay=0,l.trackTime+=i.timeScale==0?0:(s/i.timeScale+t)*l.timeScale,i.trackTime+=h,this.setCurrent(e,l,!0);l.mixingFrom!=null;)l.mixTime+=t,l=l.mixingFrom;continue}}else if(i.trackLast>=i.trackEnd&&i.mixingFrom==null){n[e]=null,this.queue.end(i),this.disposeNext(i);continue}if(i.mixingFrom!=null&&this.updateMixingFrom(i,t)){let s=i.mixingFrom;for(i.mixingFrom=null,s!=null&&(s.mixingTo=null);s!=null;)this.queue.end(s),s=s.mixingFrom}i.trackTime+=h}this.queue.drain()}updateMixingFrom(t,n){const e=t.mixingFrom;if(e==null)return!0;const r=this.updateMixingFrom(e,n);return e.animationLast=e.nextAnimationLast,e.trackLast=e.nextTrackLast,t.mixTime>0&&t.mixTime>=t.mixDuration?((e.totalAlpha==0||t.mixDuration==0)&&(t.mixingFrom=e.mixingFrom,e.mixingFrom!=null&&(e.mixingFrom.mixingTo=t),t.interruptAlpha=e.interruptAlpha,this.queue.end(e)),r):(e.trackTime+=n*e.timeScale,t.mixTime+=n,!1)}apply(t){if(t==null)throw new Error("skeleton cannot be null.");this.animationsChanged&&this._animationsChanged();const n=this.events,e=this.tracks;let r=!1;for(let l=0,s=e.length;l<s;l++){const a=e[l];if(a==null||a.delay>0)continue;r=!0;const o=l==0?A.first:a.mixBlend;let c=a.alpha;a.mixingFrom!=null?c*=this.applyMixingFrom(a,t,o):a.trackTime>=a.trackEnd&&a.next==null&&(c=0);const d=a.animationLast,u=a.getAnimationTime(),m=a.animation.timelines.length,g=a.animation.timelines;if(l==0&&c==1||o==A.add)for(let x=0;x<m;x++){k.webkit602BugfixHelper(c,o);const w=g[x];w instanceof Nn?this.applyAttachmentTimeline(w,t,u,o,!0):w.apply(t,d,u,n,c,o,Q.mixIn)}else{const x=a.timelineMode,w=a.timelinesRotation.length==0;w&&k.setArraySize(a.timelinesRotation,m<<1,null);const b=a.timelinesRotation;for(let E=0;E<m;E++){const p=g[E],S=x[E]==wt.SUBSEQUENT?o:A.setup;p instanceof Zt?this.applyRotateTimeline(p,t,u,c,S,b,E<<1,w):p instanceof Nn?this.applyAttachmentTimeline(p,t,u,o,!0):(k.webkit602BugfixHelper(c,o),p.apply(t,d,u,n,c,S,Q.mixIn))}}this.queueEvents(a,u),n.length=0,a.nextAnimationLast=u,a.nextTrackLast=a.trackTime}const i=this.unkeyedState+wt.SETUP,h=t.slots;for(let l=0,s=t.slots.length;l<s;l++){const a=h[l];if(a.attachmentState==i){const o=a.data.attachmentName;a.setAttachment(o==null?null:t.getAttachment(a.data.index,o))}}return this.unkeyedState+=2,this.queue.drain(),r}applyMixingFrom(t,n,e){const r=t.mixingFrom;r.mixingFrom!=null&&this.applyMixingFrom(r,n,e);let i=0;t.mixDuration==0?(i=1,e==A.first&&(e=A.setup)):(i=t.mixTime/t.mixDuration,i>1&&(i=1),e!=A.first&&(e=r.mixBlend));const h=i<r.eventThreshold?this.events:null,l=i<r.attachmentThreshold,s=i<r.drawOrderThreshold,a=r.animationLast,o=r.getAnimationTime(),c=r.animation.timelines.length,d=r.animation.timelines,u=r.alpha*t.interruptAlpha,m=u*(1-i);if(e==A.add)for(let g=0;g<c;g++)d[g].apply(n,a,o,h,m,e,Q.mixOut);else{const g=r.timelineMode,x=r.timelineHoldMix,w=r.timelinesRotation.length==0;w&&k.setArraySize(r.timelinesRotation,c<<1,null);const b=r.timelinesRotation;r.totalAlpha=0;for(let E=0;E<c;E++){const p=d[E];let S=Q.mixOut,y,M=0;switch(g[E]){case wt.SUBSEQUENT:if(!s&&p instanceof Kn)continue;y=e,M=m;break;case wt.FIRST:y=A.setup,M=m;break;case wt.HOLD_SUBSEQUENT:y=e,M=u;break;case wt.HOLD_FIRST:y=A.setup,M=u;break;default:y=A.setup;const C=x[E];M=u*Math.max(0,1-C.mixTime/C.mixDuration);break}r.totalAlpha+=M,p instanceof Zt?this.applyRotateTimeline(p,n,o,M,y,b,E<<1,w):p instanceof Nn?this.applyAttachmentTimeline(p,n,o,y,l):(k.webkit602BugfixHelper(M,e),s&&p instanceof Kn&&y==A.setup&&(S=Q.mixIn),p.apply(n,a,o,h,M,y,S))}}return t.mixDuration>0&&this.queueEvents(r,o),this.events.length=0,r.nextAnimationLast=o,r.nextTrackLast=r.trackTime,i}applyAttachmentTimeline(t,n,e,r,i){const h=n.slots[t.slotIndex];if(!h.bone.active)return;const l=t.frames;if(e<l[0])(r==A.setup||r==A.first)&&this.setAttachment(n,h,h.data.attachmentName,i);else{let s;e>=l[l.length-1]?s=l.length-1:s=Rt.binarySearch(l,e)-1,this.setAttachment(n,h,t.attachmentNames[s],i)}h.attachmentState<=this.unkeyedState&&(h.attachmentState=this.unkeyedState+wt.SETUP)}setAttachment(t,n,e,r){n.setAttachment(e==null?null:t.getAttachment(n.data.index,e)),r&&(n.attachmentState=this.unkeyedState+wt.CURRENT)}applyRotateTimeline(t,n,e,r,i,h,l,s){if(s&&(h[l]=0),r==1){t.apply(n,0,e,null,1,i,Q.mixIn);return}const a=t,o=a.frames,c=n.bones[a.boneIndex];if(!c.active)return;let d=0,u=0;if(e<o[0])switch(i){case A.setup:c.rotation=c.data.rotation;default:return;case A.first:d=c.rotation,u=c.data.rotation}else if(d=i==A.setup?c.data.rotation:c.rotation,e>=o[o.length-Zt.ENTRIES])u=c.data.rotation+o[o.length+Zt.PREV_ROTATION];else{const x=Rt.binarySearch(o,e,Zt.ENTRIES),w=o[x+Zt.PREV_ROTATION],b=o[x],E=a.getCurvePercent((x>>1)-1,1-(e-b)/(o[x+Zt.PREV_TIME]-b));u=o[x+Zt.ROTATION]-w,u-=(16384-(16384.499999999996-u/360|0))*360,u=w+u*E+c.data.rotation,u-=(16384-(16384.499999999996-u/360|0))*360}let m=0,g=u-d;if(g-=(16384-(16384.499999999996-g/360|0))*360,g==0)m=h[l];else{let x=0,w=0;s?(x=0,w=g):(x=h[l],w=h[l+1]);const b=g>0;let E=x>=0;T.signum(w)!=T.signum(g)&&Math.abs(w)<=90&&(Math.abs(x)>180&&(x+=360*T.signum(x)),E=b),m=g+x-x%360,E!=b&&(m+=360*T.signum(x)),h[l]=m}h[l+1]=g,d+=m*r,c.rotation=d-(16384-(16384.499999999996-d/360|0))*360}queueEvents(t,n){const e=t.animationStart,r=t.animationEnd,i=r-e,h=t.trackLast%i,l=this.events;let s=0;const a=l.length;for(;s<a;s++){const c=l[s];if(c.time<h)break;c.time>r||this.queue.event(t,c)}let o=!1;for(t.loop?o=i==0||h>t.trackTime%i:o=n>=r&&t.animationLast<r,o&&this.queue.complete(t);s<a;s++)l[s].time<e||this.queue.event(t,l[s])}clearTracks(){const t=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let n=0,e=this.tracks.length;n<e;n++)this.clearTrack(n);this.tracks.length=0,this.queue.drainDisabled=t,this.queue.drain()}clearTrack(t){if(t>=this.tracks.length)return;const n=this.tracks[t];if(n==null)return;this.queue.end(n),this.disposeNext(n);let e=n;for(;;){const r=e.mixingFrom;if(r==null)break;this.queue.end(r),e.mixingFrom=null,e.mixingTo=null,e=r}this.tracks[n.trackIndex]=null,this.queue.drain()}setCurrent(t,n,e){const r=this.expandToIndex(t);this.tracks[t]=n,r!=null&&(e&&this.queue.interrupt(r),n.mixingFrom=r,r.mixingTo=n,n.mixTime=0,r.mixingFrom!=null&&r.mixDuration>0&&(n.interruptAlpha*=Math.min(1,r.mixTime/r.mixDuration)),r.timelinesRotation.length=0),this.queue.start(n)}setAnimation(t,n,e){const r=this.data.skeletonData.findAnimation(n);if(r==null)throw new Error(`Animation not found: ${n}`);return this.setAnimationWith(t,r,e)}setAnimationWith(t,n,e){if(n==null)throw new Error("animation cannot be null.");let r=!0,i=this.expandToIndex(t);i!=null&&(i.nextTrackLast==-1?(this.tracks[t]=i.mixingFrom,this.queue.interrupt(i),this.queue.end(i),this.disposeNext(i),i=i.mixingFrom,r=!1):this.disposeNext(i));const h=this.trackEntry(t,n,e,i);return this.setCurrent(t,h,r),this.queue.drain(),h}addAnimation(t,n,e,r){const i=this.data.skeletonData.findAnimation(n);if(i==null)throw new Error(`Animation not found: ${n}`);return this.addAnimationWith(t,i,e,r)}addAnimationWith(t,n,e,r){if(n==null)throw new Error("animation cannot be null.");let i=this.expandToIndex(t);if(i!=null)for(;i.next!=null;)i=i.next;const h=this.trackEntry(t,n,e,i);if(i==null)this.setCurrent(t,h,!0),this.queue.drain();else if(i.next=h,r<=0){const l=i.animationEnd-i.animationStart;l!=0?(i.loop?r+=l*(1+(i.trackTime/l|0)):r+=Math.max(l,i.trackTime),r-=this.data.getMix(i.animation,n)):r=i.trackTime}return h.delay=r,h}setEmptyAnimation(t,n){const e=this.setAnimationWith(t,wt.emptyAnimation,!1);return e.mixDuration=n,e.trackEnd=n,e}addEmptyAnimation(t,n,e){e<=0&&(e-=n);const r=this.addAnimationWith(t,wt.emptyAnimation,!1,e);return r.mixDuration=n,r.trackEnd=n,r}setEmptyAnimations(t){const n=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let e=0,r=this.tracks.length;e<r;e++){const i=this.tracks[e];i!=null&&this.setEmptyAnimation(i.trackIndex,t)}this.queue.drainDisabled=n,this.queue.drain()}expandToIndex(t){return t<this.tracks.length?this.tracks[t]:(k.ensureArrayCapacity(this.tracks,t+1,null),this.tracks.length=t+1,null)}trackEntry(t,n,e,r){const i=this.trackEntryPool.obtain();return i.trackIndex=t,i.animation=n,i.loop=e,i.holdPrevious=!1,i.eventThreshold=0,i.attachmentThreshold=0,i.drawOrderThreshold=0,i.animationStart=0,i.animationEnd=n.duration,i.animationLast=-1,i.nextAnimationLast=-1,i.delay=0,i.trackTime=0,i.trackLast=-1,i.nextTrackLast=-1,i.trackEnd=Number.MAX_VALUE,i.timeScale=1,i.alpha=1,i.interruptAlpha=1,i.mixTime=0,i.mixDuration=r==null?0:this.data.getMix(r.animation,n),i.mixBlend=A.replace,i}disposeNext(t){let n=t.next;for(;n!=null;)this.queue.dispose(n),n=n.next;t.next=null}_animationsChanged(){this.animationsChanged=!1,this.propertyIDs.clear();for(let t=0,n=this.tracks.length;t<n;t++){let e=this.tracks[t];if(e!=null){for(;e.mixingFrom!=null;)e=e.mixingFrom;do(e.mixingFrom==null||e.mixBlend!=A.add)&&this.computeHold(e),e=e.mixingTo;while(e!=null)}}}computeHold(t){const n=t.mixingTo,e=t.animation.timelines,r=t.animation.timelines.length,i=k.setArraySize(t.timelineMode,r);t.timelineHoldMix.length=0;const h=k.setArraySize(t.timelineHoldMix,r),l=this.propertyIDs;if(n!=null&&n.holdPrevious){for(let s=0;s<r;s++)i[s]=l.add(e[s].getPropertyId())?wt.HOLD_FIRST:wt.HOLD_SUBSEQUENT;return}t:for(let s=0;s<r;s++){const a=e[s],o=a.getPropertyId();if(!l.add(o))i[s]=wt.SUBSEQUENT;else if(n==null||a instanceof Nn||a instanceof Kn||a instanceof ys||!n.animation.hasTimeline(o))i[s]=wt.FIRST;else{for(let c=n.mixingTo;c!=null;c=c.mixingTo)if(!c.animation.hasTimeline(o)){if(t.mixDuration>0){i[s]=wt.HOLD_MIX,h[s]=c;continue t}break}i[s]=wt.HOLD_FIRST}}}getCurrent(t){return t>=this.tracks.length?null:this.tracks[t]}addListener(t){if(t==null)throw new Error("listener cannot be null.");this.listeners.push(t)}removeListener(t){const n=this.listeners.indexOf(t);n>=0&&this.listeners.splice(n,1)}clearListeners(){this.listeners.length=0}clearListenerNotifications(){this.queue.clear()}setAnimationByName(t,n,e){wt.deprecatedWarning1||(wt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.")),this.setAnimation(t,n,e)}addAnimationByName(t,n,e,r){wt.deprecatedWarning2||(wt.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.")),this.addAnimation(t,n,e,r)}hasAnimation(t){return this.data.skeletonData.findAnimation(t)!==null}hasAnimationByName(t){return wt.deprecatedWarning3||(wt.deprecatedWarning3=!0,console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.")),this.hasAnimation(t)}};let Ve=wt;Ve.emptyAnimation=new Rt("<empty>",[],0),Ve.SUBSEQUENT=0,Ve.FIRST=1,Ve.HOLD_SUBSEQUENT=2,Ve.HOLD_FIRST=3,Ve.HOLD_MIX=4,Ve.SETUP=1,Ve.CURRENT=2,Ve.deprecatedWarning1=!1,Ve.deprecatedWarning2=!1,Ve.deprecatedWarning3=!1;const gn=class{constructor(){this.mixBlend=A.replace,this.timelineMode=new Array,this.timelineHoldMix=new Array,this.timelinesRotation=new Array}reset(){this.next=null,this.mixingFrom=null,this.mixingTo=null,this.animation=null,this.listener=null,this.timelineMode.length=0,this.timelineHoldMix.length=0,this.timelinesRotation.length=0}getAnimationTime(){if(this.loop){const t=this.animationEnd-this.animationStart;return t==0?this.animationStart:this.trackTime%t+this.animationStart}return Math.min(this.trackTime+this.animationStart,this.animationEnd)}setAnimationLast(t){this.animationLast=t,this.nextAnimationLast=t}isComplete(){return this.trackTime>=this.animationEnd-this.animationStart}resetRotationDirections(){this.timelinesRotation.length=0}get time(){return gn.deprecatedWarning1||(gn.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime}set time(t){gn.deprecatedWarning1||(gn.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime=t}get endTime(){return gn.deprecatedWarning2||(gn.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime}set endTime(t){gn.deprecatedWarning2||(gn.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime=t}loopsCount(){return Math.floor(this.trackTime/this.trackEnd)}};let Ms=gn;Ms.deprecatedWarning1=!1,Ms.deprecatedWarning2=!1;const Qs=class{constructor(t){this.objects=[],this.drainDisabled=!1,this.animState=t}start(t){this.objects.push(be.start),this.objects.push(t),this.animState.animationsChanged=!0}interrupt(t){this.objects.push(be.interrupt),this.objects.push(t)}end(t){this.objects.push(be.end),this.objects.push(t),this.animState.animationsChanged=!0}dispose(t){this.objects.push(be.dispose),this.objects.push(t)}complete(t){this.objects.push(be.complete),this.objects.push(t)}event(t,n){this.objects.push(be.event),this.objects.push(t),this.objects.push(n)}deprecateStuff(){return Qs.deprecatedWarning1||(Qs.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'")),!0}drain(){if(this.drainDisabled)return;this.drainDisabled=!0;const t=this.objects,n=this.animState.listeners;for(let e=0;e<t.length;e+=2){const r=t[e],i=t[e+1];switch(r){case be.start:i.listener!=null&&i.listener.start&&i.listener.start(i);for(let s=0;s<n.length;s++)n[s].start&&n[s].start(i);i.onStart&&this.deprecateStuff()&&i.onStart(i.trackIndex),this.animState.onStart&&this.deprecateStuff()&&this.deprecateStuff&&this.animState.onStart(i.trackIndex);break;case be.interrupt:i.listener!=null&&i.listener.interrupt&&i.listener.interrupt(i);for(let s=0;s<n.length;s++)n[s].interrupt&&n[s].interrupt(i);break;case be.end:i.listener!=null&&i.listener.end&&i.listener.end(i);for(let s=0;s<n.length;s++)n[s].end&&n[s].end(i);i.onEnd&&this.deprecateStuff()&&i.onEnd(i.trackIndex),this.animState.onEnd&&this.deprecateStuff()&&this.animState.onEnd(i.trackIndex);case be.dispose:i.listener!=null&&i.listener.dispose&&i.listener.dispose(i);for(let s=0;s<n.length;s++)n[s].dispose&&n[s].dispose(i);this.animState.trackEntryPool.free(i);break;case be.complete:i.listener!=null&&i.listener.complete&&i.listener.complete(i);for(let s=0;s<n.length;s++)n[s].complete&&n[s].complete(i);const h=T.toInt(i.loopsCount());i.onComplete&&this.deprecateStuff()&&i.onComplete(i.trackIndex,h),this.animState.onComplete&&this.deprecateStuff()&&this.animState.onComplete(i.trackIndex,h);break;case be.event:const l=t[e+++2];i.listener!=null&&i.listener.event&&i.listener.event(i,l);for(let s=0;s<n.length;s++)n[s].event&&n[s].event(i,l);i.onEvent&&this.deprecateStuff()&&i.onEvent(i.trackIndex,l),this.animState.onEvent&&this.deprecateStuff()&&this.animState.onEvent(i.trackIndex,l);break}}this.clear(),this.drainDisabled=!1}clear(){this.objects.length=0}};let Ks=Qs;Ks.deprecatedWarning1=!1;var be=(f=>(f[f.start=0]="start",f[f.interrupt=1]="interrupt",f[f.end=2]="end",f[f.dispose=3]="dispose",f[f.complete=4]="complete",f[f.event=5]="event",f))(be||{});let to=class{start(t){}interrupt(t){}end(t){}dispose(t){}complete(t){}event(t,n){}};const Js=class{constructor(t){if(this.animationToMixTime={},this.defaultMix=0,t==null)throw new Error("skeletonData cannot be null.");this.skeletonData=t}setMix(t,n,e){const r=this.skeletonData.findAnimation(t);if(r==null)throw new Error(`Animation not found: ${t}`);const i=this.skeletonData.findAnimation(n);if(i==null)throw new Error(`Animation not found: ${n}`);this.setMixWith(r,i,e)}setMixByName(t,n,e){Js.deprecatedWarning1||(Js.deprecatedWarning1=!0,console.warn("Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.")),this.setMix(t,n,e)}setMixWith(t,n,e){if(t==null)throw new Error("from cannot be null.");if(n==null)throw new Error("to cannot be null.");const r=`${t.name}.${n.name}`;this.animationToMixTime[r]=e}getMix(t,n){const e=`${t.name}.${n.name}`,r=this.animationToMixTime[e];return r===void 0?this.defaultMix:r}};let ti=Js;ti.deprecatedWarning1=!1;let ei=class extends Tn{constructor(t){super(t),this.type=Z.BoundingBox,this.color=new O(1,1,1,1)}copy(){const t=new ei(this.name);return this.copyTo(t),t.color.setFromColor(this.color),t}},ni=class extends Tn{constructor(t){super(t),this.type=Z.Clipping,this.color=new O(.2275,.2275,.8078,1)}copy(){const t=new ni(this.name);return this.copyTo(t),t.endSlot=this.endSlot,t.color.setFromColor(this.color),t}},Jn=class extends Tn{constructor(t){super(t),this.type=Z.Mesh,this.color=new O(1,1,1,1),this.tempColor=new O(0,0,0,0)}getParentMesh(){return this.parentMesh}setParentMesh(t){this.parentMesh=t,t!=null&&(this.bones=t.bones,this.vertices=t.vertices,this.worldVerticesLength=t.worldVerticesLength,this.regionUVs=t.regionUVs,this.triangles=t.triangles,this.hullLength=t.hullLength,this.worldVerticesLength=t.worldVerticesLength)}copy(){if(this.parentMesh!=null)return this.newLinkedMesh();const t=new Jn(this.name);return t.region=this.region,t.path=this.path,t.color.setFromColor(this.color),this.copyTo(t),t.regionUVs=new Float32Array(this.regionUVs.length),k.arrayCopy(this.regionUVs,0,t.regionUVs,0,this.regionUVs.length),t.triangles=new Array(this.triangles.length),k.arrayCopy(this.triangles,0,t.triangles,0,this.triangles.length),t.hullLength=this.hullLength,this.edges!=null&&(t.edges=new Array(this.edges.length),k.arrayCopy(this.edges,0,t.edges,0,this.edges.length)),t.width=this.width,t.height=this.height,t}newLinkedMesh(){const t=new Jn(this.name);return t.region=this.region,t.path=this.path,t.color.setFromColor(this.color),t.deformAttachment=this.deformAttachment,t.setParentMesh(this.parentMesh!=null?this.parentMesh:this),t}},ts=class extends Tn{constructor(t){super(t),this.type=Z.Path,this.closed=!1,this.constantSpeed=!1,this.color=new O(1,1,1,1)}copy(){const t=new ts(this.name);return this.copyTo(t),t.lengths=new Array(this.lengths.length),k.arrayCopy(this.lengths,0,t.lengths,0,this.lengths.length),t.closed=closed,t.constantSpeed=this.constantSpeed,t.color.setFromColor(this.color),t}},si=class extends Tn{constructor(t){super(t),this.type=Z.Point,this.color=new O(.38,.94,0,1)}computeWorldPosition(t,n){const e=t.matrix;return n.x=this.x*e.a+this.y*e.c+t.worldX,n.y=this.x*e.b+this.y*e.d+t.worldY,n}computeWorldRotation(t){const n=t.matrix,e=T.cosDeg(this.rotation),r=T.sinDeg(this.rotation),i=e*n.a+r*n.c,h=e*n.b+r*n.d;return Math.atan2(h,i)*T.radDeg}copy(){const t=new si(this.name);return t.x=this.x,t.y=this.y,t.rotation=this.rotation,t.color.setFromColor(this.color),t}},zr=class{constructor(t){this.atlas=t}newRegionAttachment(t,n,e){const r=this.atlas.findRegion(e);if(r==null)throw new Error(`Region not found in atlas: ${e} (region attachment: ${n})`);const i=new J(n);return i.region=r,i}newMeshAttachment(t,n,e){const r=this.atlas.findRegion(e);if(r==null)throw new Error(`Region not found in atlas: ${e} (mesh attachment: ${n})`);const i=new Jn(n);return i.region=r,i}newBoundingBoxAttachment(t,n){return new ei(n)}newPathAttachment(t,n){return new ts(n)}newPointAttachment(t,n){return new si(n)}newClippingAttachment(t,n){return new ni(n)}},As=class{constructor(t,n,e){this.name=t,this.order=n,this.skinRequired=e}},ii=class extends As{constructor(t){super(t,0,!1),this.bones=new Array}};var qt=(f=>(f[f.Length=0]="Length",f[f.Fixed=1]="Fixed",f[f.Percent=2]="Percent",f))(qt||{});const Xn=class{constructor(t,n){if(this.position=0,this.spacing=0,this.rotateMix=0,this.translateMix=0,this.spaces=new Array,this.positions=new Array,this.world=new Array,this.curves=new Array,this.lengths=new Array,this.segments=new Array,this.active=!1,t==null)throw new Error("data cannot be null.");if(n==null)throw new Error("skeleton cannot be null.");this.data=t,this.bones=new Array;for(let e=0,r=t.bones.length;e<r;e++)this.bones.push(n.findBone(t.bones[e].name));this.target=n.findSlot(t.target.name),this.position=t.position,this.spacing=t.spacing,this.rotateMix=t.rotateMix,this.translateMix=t.translateMix}isActive(){return this.active}apply(){this.update()}update(){const t=this.target.getAttachment();if(!(t instanceof ts))return;const n=this.rotateMix,e=this.translateMix,r=e>0,i=n>0;if(!r&&!i)return;const h=this.data,l=h.spacingMode,s=l==qt.Length,a=h.rotateMode,o=a==ut.Tangent,c=a==ut.ChainScale,d=this.bones.length,u=o?d:d+1,m=this.bones,g=k.setArraySize(this.spaces,u);let x=null;const w=this.spacing;if(c||s){c&&(x=k.setArraySize(this.lengths,d));for(let M=0,C=u-1;M<C;){const I=m[M],R=I.data.length;if(R<Xn.epsilon)c&&(x[M]=0),g[++M]=0;else{const v=R*I.matrix.a,V=R*I.matrix.b,P=Math.sqrt(v*v+V*V);c&&(x[M]=P),g[++M]=(s?R+w:w)*P/R}}}else for(let M=1;M<u;M++)g[M]=w;const b=this.computeWorldPositions(t,u,o,h.positionMode==dt.Percent,l==qt.Percent);let E=b[0],p=b[1],S=h.offsetRotation,y=!1;if(S==0)y=a==ut.Chain;else{y=!1;const M=this.target.bone.matrix;S*=M.a*M.d-M.b*M.c>0?T.degRad:-T.degRad}for(let M=0,C=3;M<d;M++,C+=3){const I=m[M],R=I.matrix;R.tx+=(E-R.tx)*e,R.ty+=(p-R.ty)*e;const v=b[C],V=b[C+1],P=v-E,D=V-p;if(c){const F=x[M];if(F!=0){const B=(Math.sqrt(P*P+D*D)/F-1)*n+1;R.a*=B,R.b*=B}}if(E=v,p=V,i){const F=R.a,B=R.c,H=R.b,U=R.d;let X=0,N=0,_=0;if(o&&(o?X=b[C-1]:g[M+1]==0?X=b[C+2]:X=Math.atan2(D,P)),X-=Math.atan2(H,F),y){N=Math.cos(X),_=Math.sin(X);const $=I.data.length;E+=($*(N*F-_*H)-P)*n,p+=($*(_*F+N*H)-D)*n}else X+=S;X>T.PI?X-=T.PI2:X<-T.PI&&(X+=T.PI2),X*=n,N=Math.cos(X),_=Math.sin(X),R.a=N*F-_*H,R.c=N*B-_*U,R.b=_*F+N*H,R.d=_*B+N*U}I.appliedValid=!1}}computeWorldPositions(t,n,e,r,i){const h=this.target;let l=this.position;const s=this.spaces,a=k.setArraySize(this.positions,n*3+2);let o=null;const c=t.closed;let d=t.worldVerticesLength,u=d/6,m=Xn.NONE;if(!t.constantSpeed){const X=t.lengths;u-=c?1:2;const N=X[u];if(r&&(l*=N),i)for(let _=0;_<n;_++)s[_]*=N;o=k.setArraySize(this.world,8);for(let _=0,$=0,q=0;_<n;_++,$+=3){const W=s[_];l+=W;let L=l;if(c)L%=N,L<0&&(L+=N),q=0;else if(L<0){m!=Xn.BEFORE&&(m=Xn.BEFORE,t.computeWorldVertices(h,2,4,o,0,2)),this.addBeforePosition(L,o,0,a,$);continue}else if(L>N){m!=Xn.AFTER&&(m=Xn.AFTER,t.computeWorldVertices(h,d-6,4,o,0,2)),this.addAfterPosition(L-N,o,0,a,$);continue}for(;;q++){const j=X[q];if(!(L>j)){if(q==0)L/=j;else{const K=X[q-1];L=(L-K)/(j-K)}break}}q!=m&&(m=q,c&&q==u?(t.computeWorldVertices(h,d-4,4,o,0,2),t.computeWorldVertices(h,0,4,o,4,2)):t.computeWorldVertices(h,q*6+2,8,o,0,2)),this.addCurvePosition(L,o[0],o[1],o[2],o[3],o[4],o[5],o[6],o[7],a,$,e||_>0&&W==0)}return a}c?(d+=2,o=k.setArraySize(this.world,d),t.computeWorldVertices(h,2,d-4,o,0,2),t.computeWorldVertices(h,0,2,o,d-4,2),o[d-2]=o[0],o[d-1]=o[1]):(u--,d-=4,o=k.setArraySize(this.world,d),t.computeWorldVertices(h,2,d,o,0,2));const g=k.setArraySize(this.curves,u);let x=0,w=o[0],b=o[1],E=0,p=0,S=0,y=0,M=0,C=0,I=0,R=0,v=0,V=0,P=0,D=0,F=0,B=0;for(let X=0,N=2;X<u;X++,N+=6)E=o[N],p=o[N+1],S=o[N+2],y=o[N+3],M=o[N+4],C=o[N+5],I=(w-E*2+S)*.1875,R=(b-p*2+y)*.1875,v=((E-S)*3-w+M)*.09375,V=((p-y)*3-b+C)*.09375,P=I*2+v,D=R*2+V,F=(E-w)*.75+I+v*.16666667,B=(p-b)*.75+R+V*.16666667,x+=Math.sqrt(F*F+B*B),F+=P,B+=D,P+=v,D+=V,x+=Math.sqrt(F*F+B*B),F+=P,B+=D,x+=Math.sqrt(F*F+B*B),F+=P+v,B+=D+V,x+=Math.sqrt(F*F+B*B),g[X]=x,w=M,b=C;if(r&&(l*=x),i)for(let X=0;X<n;X++)s[X]*=x;const H=this.segments;let U=0;for(let X=0,N=0,_=0,$=0;X<n;X++,N+=3){const q=s[X];l+=q;let W=l;if(c)W%=x,W<0&&(W+=x),_=0;else if(W<0){this.addBeforePosition(W,o,0,a,N);continue}else if(W>x){this.addAfterPosition(W-x,o,d-4,a,N);continue}for(;;_++){const L=g[_];if(!(W>L)){if(_==0)W/=L;else{const j=g[_-1];W=(W-j)/(L-j)}break}}if(_!=m){m=_;let L=_*6;for(w=o[L],b=o[L+1],E=o[L+2],p=o[L+3],S=o[L+4],y=o[L+5],M=o[L+6],C=o[L+7],I=(w-E*2+S)*.03,R=(b-p*2+y)*.03,v=((E-S)*3-w+M)*.006,V=((p-y)*3-b+C)*.006,P=I*2+v,D=R*2+V,F=(E-w)*.3+I+v*.16666667,B=(p-b)*.3+R+V*.16666667,U=Math.sqrt(F*F+B*B),H[0]=U,L=1;L<8;L++)F+=P,B+=D,P+=v,D+=V,U+=Math.sqrt(F*F+B*B),H[L]=U;F+=P,B+=D,U+=Math.sqrt(F*F+B*B),H[8]=U,F+=P+v,B+=D+V,U+=Math.sqrt(F*F+B*B),H[9]=U,$=0}for(W*=U;;$++){const L=H[$];if(!(W>L)){if($==0)W/=L;else{const j=H[$-1];W=$+(W-j)/(L-j)}break}}this.addCurvePosition(W*.1,w,b,E,p,S,y,M,C,a,N,e||X>0&&q==0)}return a}addBeforePosition(t,n,e,r,i){const h=n[e],l=n[e+1],s=n[e+2]-h,a=n[e+3]-l,o=Math.atan2(a,s);r[i]=h+t*Math.cos(o),r[i+1]=l+t*Math.sin(o),r[i+2]=o}addAfterPosition(t,n,e,r,i){const h=n[e+2],l=n[e+3],s=h-n[e],a=l-n[e+1],o=Math.atan2(a,s);r[i]=h+t*Math.cos(o),r[i+1]=l+t*Math.sin(o),r[i+2]=o}addCurvePosition(t,n,e,r,i,h,l,s,a,o,c,d){(t==0||isNaN(t))&&(t=1e-4);const u=t*t,m=u*t,g=1-t,x=g*g,w=x*g,b=g*t,E=b*3,p=g*E,S=E*t,y=n*w+r*p+h*S+s*m,M=e*w+i*p+l*S+a*m;o[c]=y,o[c+1]=M,d&&(o[c+2]=Math.atan2(M-(e*x+i*b*2+l*u),y-(n*x+r*b*2+h*u)))}};let es=Xn;es.NONE=-1,es.BEFORE=-2,es.AFTER=-3,es.epsilon=1e-5;let ri=class{constructor(t,n,e){if(this.matrix=new G.Matrix,this.children=new Array,this.x=0,this.y=0,this.rotation=0,this.scaleX=0,this.scaleY=0,this.shearX=0,this.shearY=0,this.ax=0,this.ay=0,this.arotation=0,this.ascaleX=0,this.ascaleY=0,this.ashearX=0,this.ashearY=0,this.appliedValid=!1,this.sorted=!1,this.active=!1,t==null)throw new Error("data cannot be null.");if(n==null)throw new Error("skeleton cannot be null.");this.data=t,this.skeleton=n,this.parent=e,this.setToSetupPose()}get worldX(){return this.matrix.tx}get worldY(){return this.matrix.ty}isActive(){return this.active}update(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransform(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransformWith(t,n,e,r,i,h,l){this.ax=t,this.ay=n,this.arotation=e,this.ascaleX=r,this.ascaleY=i,this.ashearX=h,this.ashearY=l,this.appliedValid=!0;const s=this.parent,a=this.matrix,o=this.skeleton.scaleX,c=jt.yDown?-this.skeleton.scaleY:this.skeleton.scaleY;if(s==null){const x=this.skeleton,w=e+90+l;a.a=T.cosDeg(e+h)*r*o,a.c=T.cosDeg(w)*i*o,a.b=T.sinDeg(e+h)*r*c,a.d=T.sinDeg(w)*i*c,a.tx=t*o+x.x,a.ty=n*c+x.y;return}let d=s.matrix.a,u=s.matrix.c,m=s.matrix.b,g=s.matrix.d;switch(a.tx=d*t+u*n+s.matrix.tx,a.ty=m*t+g*n+s.matrix.ty,this.data.transformMode){case z.Normal:{const x=e+90+l,w=T.cosDeg(e+h)*r,b=T.cosDeg(x)*i,E=T.sinDeg(e+h)*r,p=T.sinDeg(x)*i;a.a=d*w+u*E,a.c=d*b+u*p,a.b=m*w+g*E,a.d=m*b+g*p;return}case z.OnlyTranslation:{const x=e+90+l;a.a=T.cosDeg(e+h)*r,a.c=T.cosDeg(x)*i,a.b=T.sinDeg(e+h)*r,a.d=T.sinDeg(x)*i;break}case z.NoRotationOrReflection:{let x=d*d+m*m,w=0;x>1e-4?(x=Math.abs(d*g-u*m)/x,d/=this.skeleton.scaleX,m/=this.skeleton.scaleY,u=m*x,g=d*x,w=Math.atan2(m,d)*T.radDeg):(d=0,m=0,w=90-Math.atan2(g,u)*T.radDeg);const b=e+h-w,E=e+l-w+90,p=T.cosDeg(b)*r,S=T.cosDeg(E)*i,y=T.sinDeg(b)*r,M=T.sinDeg(E)*i;a.a=d*p-u*y,a.c=d*S-u*M,a.b=m*p+g*y,a.d=m*S+g*M;break}case z.NoScale:case z.NoScaleOrReflection:{const x=T.cosDeg(e),w=T.sinDeg(e);let b=(d*x+u*w)/o,E=(m*x+g*w)/c,p=Math.sqrt(b*b+E*E);p>1e-5&&(p=1/p),b*=p,E*=p,p=Math.sqrt(b*b+E*E),this.data.transformMode==z.NoScale&&d*g-u*m<0!=(jt.yDown?this.skeleton.scaleX<0!=this.skeleton.scaleY>0:this.skeleton.scaleX<0!=this.skeleton.scaleY<0)&&(p=-p);const S=Math.PI/2+Math.atan2(E,b),y=Math.cos(S)*p,M=Math.sin(S)*p,C=T.cosDeg(h)*r,I=T.cosDeg(90+l)*i,R=T.sinDeg(h)*r,v=T.sinDeg(90+l)*i;a.a=b*C+y*R,a.c=b*I+y*v,a.b=E*C+M*R,a.d=E*I+M*v;break}}a.a*=o,a.c*=o,a.b*=c,a.d*=c}setToSetupPose(){const t=this.data;this.x=t.x,this.y=t.y,this.rotation=t.rotation,this.scaleX=t.scaleX,this.scaleY=t.scaleY,this.shearX=t.shearX,this.shearY=t.shearY}getWorldRotationX(){return Math.atan2(this.matrix.b,this.matrix.a)*T.radDeg}getWorldRotationY(){return Math.atan2(this.matrix.d,this.matrix.c)*T.radDeg}getWorldScaleX(){const t=this.matrix;return Math.sqrt(t.a*t.a+t.c*t.c)}getWorldScaleY(){const t=this.matrix;return Math.sqrt(t.b*t.b+t.d*t.d)}updateAppliedTransform(){this.appliedValid=!0;const t=this.parent,n=this.matrix;if(t==null){this.ax=n.tx,this.ay=n.ty,this.arotation=Math.atan2(n.b,n.a)*T.radDeg,this.ascaleX=Math.sqrt(n.a*n.a+n.b*n.b),this.ascaleY=Math.sqrt(n.c*n.c+n.d*n.d),this.ashearX=0,this.ashearY=Math.atan2(n.a*n.c+n.b*n.d,n.a*n.d-n.b*n.c)*T.radDeg;return}const e=t.matrix,r=1/(e.a*e.d-e.b*e.c),i=n.tx-e.tx,h=n.ty-e.ty;this.ax=i*e.d*r-h*e.c*r,this.ay=h*e.a*r-i*e.b*r;const l=r*e.d,s=r*e.a,a=r*e.c,o=r*e.b,c=l*n.a-a*n.b,d=l*n.c-a*n.d,u=s*n.b-o*n.a,m=s*n.d-o*n.c;if(this.ashearX=0,this.ascaleX=Math.sqrt(c*c+u*u),this.ascaleX>1e-4){const g=c*m-d*u;this.ascaleY=g/this.ascaleX,this.ashearY=Math.atan2(c*d+u*m,g)*T.radDeg,this.arotation=Math.atan2(u,c)*T.radDeg}else this.ascaleX=0,this.ascaleY=Math.sqrt(d*d+m*m),this.ashearY=0,this.arotation=90-Math.atan2(m,d)*T.radDeg}worldToLocal(t){const n=this.matrix,e=n.a,r=n.c,i=n.b,h=n.d,l=1/(e*h-r*i),s=t.x-n.tx,a=t.y-n.ty;return t.x=s*h*l-a*r*l,t.y=a*e*l-s*i*l,t}localToWorld(t){const n=this.matrix,e=t.x,r=t.y;return t.x=e*n.a+r*n.c+n.tx,t.y=e*n.b+r*n.d+n.ty,t}worldToLocalRotation(t){const n=T.sinDeg(t),e=T.cosDeg(t),r=this.matrix;return Math.atan2(r.a*n-r.b*e,r.d*e-r.c*n)*T.radDeg}localToWorldRotation(t){const n=T.sinDeg(t),e=T.cosDeg(t),r=this.matrix;return Math.atan2(e*r.b+n*r.d,e*r.a+n*r.c)*T.radDeg}rotateWorld(t){const n=this.matrix,e=n.a,r=n.c,i=n.b,h=n.d,l=T.cosDeg(t),s=T.sinDeg(t);n.a=l*e-s*i,n.c=l*r-s*h,n.b=s*e+l*i,n.d=s*r+l*h,this.appliedValid=!1}},Gr=class{constructor(t,n){if(this.bendDirection=0,this.compress=!1,this.stretch=!1,this.mix=1,this.softness=0,this.active=!1,t==null)throw new Error("data cannot be null.");if(n==null)throw new Error("skeleton cannot be null.");this.data=t,this.mix=t.mix,this.softness=t.softness,this.bendDirection=t.bendDirection,this.compress=t.compress,this.stretch=t.stretch,this.bones=new Array;for(let e=0;e<t.bones.length;e++)this.bones.push(n.findBone(t.bones[e].name));this.target=n.findBone(t.target.name)}isActive(){return this.active}apply(){this.update()}update(){const t=this.target,n=this.bones;switch(n.length){case 1:this.apply1(n[0],t.worldX,t.worldY,this.compress,this.stretch,this.data.uniform,this.mix);break;case 2:this.apply2(n[0],n[1],t.worldX,t.worldY,this.bendDirection,this.stretch,this.softness,this.mix);break}}apply1(t,n,e,r,i,h,l){t.appliedValid||t.updateAppliedTransform();const s=t.parent.matrix,a=s.a;let o=s.c;const c=s.b;let d=s.d,u=-t.ashearX-t.arotation,m=0,g=0;switch(t.data.transformMode){case z.OnlyTranslation:m=n-t.worldX,g=e-t.worldY;break;case z.NoRotationOrReflection:const b=Math.abs(a*d-o*c)/(a*a+c*c),E=a/t.skeleton.scaleX,p=c/t.skeleton.scaleY;o=-p*b*t.skeleton.scaleX,d=E*b*t.skeleton.scaleY,u+=Math.atan2(p,E)*T.radDeg;default:const S=n-s.tx,y=e-s.ty,M=a*d-o*c;m=(S*d-y*o)/M-t.ax,g=(y*a-S*c)/M-t.ay}u+=Math.atan2(g,m)*T.radDeg,t.ascaleX<0&&(u+=180),u>180?u-=360:u<-180&&(u+=360);let x=t.ascaleX,w=t.ascaleY;if(r||i){switch(t.data.transformMode){case z.NoScale:case z.NoScaleOrReflection:m=n-t.worldX,g=e-t.worldY}const b=t.data.length*x,E=Math.sqrt(m*m+g*g);if(r&&E<b||i&&E>b&&b>1e-4){const p=(E/b-1)*l+1;x*=p,h&&(w*=p)}}t.updateWorldTransformWith(t.ax,t.ay,t.arotation+u*l,x,w,t.ashearX,t.ashearY)}apply2(t,n,e,r,i,h,l,s){if(s==0){n.updateWorldTransform();return}t.appliedValid||t.updateAppliedTransform(),n.appliedValid||n.updateAppliedTransform();const a=t.ax,o=t.ay;let c=t.ascaleX,d=c,u=t.ascaleY,m=n.ascaleX;const g=t.matrix;let x=0,w=0,b=0;c<0?(c=-c,x=180,b=-1):(x=0,b=1),u<0&&(u=-u,b=-b),m<0?(m=-m,w=180):w=0;const E=n.ax;let p=0,S=0,y=0,M=g.a,C=g.c,I=g.b,R=g.d;const v=Math.abs(c-u)<=1e-4;v?(p=n.ay,S=M*E+C*p+g.tx,y=I*E+R*p+g.ty):(p=0,S=M*E+g.tx,y=I*E+g.ty);const V=t.parent.matrix;M=V.a,C=V.c,I=V.b,R=V.d;const P=1/(M*R-C*I);let D=S-V.tx,F=y-V.ty;const B=(D*R-F*C)*P-a,H=(F*M-D*I)*P-o,U=Math.sqrt(B*B+H*H);let X=n.data.length*m,N,_;if(U<1e-4){this.apply1(t,e,r,!1,h,!1,s),n.updateWorldTransformWith(E,p,0,n.ascaleX,n.ascaleY,n.ashearX,n.ashearY);return}D=e-V.tx,F=r-V.ty;let $=(D*R-F*C)*P-a,q=(F*M-D*I)*P-o,W=$*$+q*q;if(l!=0){l*=c*(m+1)/2;const K=Math.sqrt(W),mt=K-U-X*c+l;if(mt>0){let nt=Math.min(1,mt/(l*2))-1;nt=(mt-l*(1-nt*nt))/K,$-=nt*$,q-=nt*q,W=$*$+q*q}}t:if(v){X*=c;let K=(W-U*U-X*X)/(2*U*X);K<-1?K=-1:K>1&&(K=1,h&&(d*=(Math.sqrt(W)/(U+X)-1)*s+1)),_=Math.acos(K)*i,M=U+X*K,C=X*Math.sin(_),N=Math.atan2(q*M-$*C,$*M+q*C)}else{M=c*X,C=u*X;const K=M*M,mt=C*C,nt=Math.atan2(q,$);I=mt*U*U+K*W-K*mt;const It=-2*mt*U,Gt=mt-K;if(R=It*It-4*Gt*I,R>=0){let Bt=Math.sqrt(R);It<0&&(Bt=-Bt),Bt=-(It+Bt)/2;const rn=Bt/Gt,$t=I/Bt,ie=Math.abs(rn)<Math.abs($t)?rn:$t;if(ie*ie<=W){F=Math.sqrt(W-ie*ie)*i,N=nt-Math.atan2(F,ie),_=Math.atan2(F/u,(ie-U)/c);break t}}let pe=T.PI,ne=U-M,_e=ne*ne,Le=0,Ce=0,se=U+M,Oe=se*se,ee=0;I=-M*U/(K-mt),I>=-1&&I<=1&&(I=Math.acos(I),D=M*Math.cos(I)+U,F=C*Math.sin(I),R=D*D+F*F,R<_e&&(pe=I,_e=R,ne=D,Le=F),R>Oe&&(Ce=I,Oe=R,se=D,ee=F)),W<=(_e+Oe)/2?(N=nt-Math.atan2(Le*i,ne),_=pe*i):(N=nt-Math.atan2(ee*i,se),_=Ce*i)}const L=Math.atan2(p,E)*b;let j=t.arotation;N=(N-L)*T.radDeg+x-j,N>180?N-=360:N<-180&&(N+=360),t.updateWorldTransformWith(a,o,j+N*s,d,t.ascaleY,0,0),j=n.arotation,_=((_+L)*T.radDeg-n.ashearX)*b+w-j,_>180?_-=360:_<-180&&(_+=360),n.updateWorldTransformWith(E,p,j+_*s,n.ascaleX,n.ascaleY,n.ashearX,n.ashearY)}},jr=class{constructor(t,n){if(this.rotateMix=0,this.translateMix=0,this.scaleMix=0,this.shearMix=0,this.temp=new Yn,this.active=!1,t==null)throw new Error("data cannot be null.");if(n==null)throw new Error("skeleton cannot be null.");this.data=t,this.rotateMix=t.rotateMix,this.translateMix=t.translateMix,this.scaleMix=t.scaleMix,this.shearMix=t.shearMix,this.bones=new Array;for(let e=0;e<t.bones.length;e++)this.bones.push(n.findBone(t.bones[e].name));this.target=n.findBone(t.target.name)}isActive(){return this.active}apply(){this.update()}update(){this.data.local?this.data.relative?this.applyRelativeLocal():this.applyAbsoluteLocal():this.data.relative?this.applyRelativeWorld():this.applyAbsoluteWorld()}applyAbsoluteWorld(){const t=this.rotateMix,n=this.translateMix,e=this.scaleMix,r=this.shearMix,i=this.target,h=i.matrix,l=h.a,s=h.c,a=h.b,o=h.d,c=l*o-s*a>0?T.degRad:-T.degRad,d=this.data.offsetRotation*c,u=this.data.offsetShearY*c,m=this.bones;for(let g=0,x=m.length;g<x;g++){const w=m[g];let b=!1;const E=w.matrix;if(t!=0){const p=E.a,S=E.c,y=E.b,M=E.d;let C=Math.atan2(a,l)-Math.atan2(y,p)+d;C>T.PI?C-=T.PI2:C<-T.PI&&(C+=T.PI2),C*=t;const I=Math.cos(C),R=Math.sin(C);E.a=I*p-R*y,E.c=I*S-R*M,E.b=R*p+I*y,E.d=R*S+I*M,b=!0}if(n!=0){const p=this.temp;i.localToWorld(p.set(this.data.offsetX,this.data.offsetY)),E.tx+=(p.x-E.tx)*n,E.ty+=(p.y-E.ty)*n,b=!0}if(e>0){let p=Math.sqrt(E.a*E.a+E.b*E.b),S=Math.sqrt(l*l+a*a);p>1e-5&&(p=(p+(S-p+this.data.offsetScaleX)*e)/p),E.a*=p,E.b*=p,p=Math.sqrt(E.c*E.c+E.d*E.d),S=Math.sqrt(s*s+o*o),p>1e-5&&(p=(p+(S-p+this.data.offsetScaleY)*e)/p),E.c*=p,E.d*=p,b=!0}if(r>0){const p=E.c,S=E.d,y=Math.atan2(S,p);let M=Math.atan2(o,s)-Math.atan2(a,l)-(y-Math.atan2(E.b,E.a));M>T.PI?M-=T.PI2:M<-T.PI&&(M+=T.PI2),M=y+(M+u)*r;const C=Math.sqrt(p*p+S*S);E.c=Math.cos(M)*C,E.d=Math.sin(M)*C,b=!0}b&&(w.appliedValid=!1)}}applyRelativeWorld(){const t=this.rotateMix,n=this.translateMix,e=this.scaleMix,r=this.shearMix,i=this.target,h=i.matrix,l=h.a,s=h.c,a=h.b,o=h.d,c=l*o-s*a>0?T.degRad:-T.degRad,d=this.data.offsetRotation*c,u=this.data.offsetShearY*c,m=this.bones;for(let g=0,x=m.length;g<x;g++){const w=m[g];let b=!1;const E=w.matrix;if(t!=0){const p=E.a,S=E.c,y=E.b,M=E.d;let C=Math.atan2(a,l)+d;C>T.PI?C-=T.PI2:C<-T.PI&&(C+=T.PI2),C*=t;const I=Math.cos(C),R=Math.sin(C);E.a=I*p-R*y,E.c=I*S-R*M,E.b=R*p+I*y,E.d=R*S+I*M,b=!0}if(n!=0){const p=this.temp;i.localToWorld(p.set(this.data.offsetX,this.data.offsetY)),E.tx+=p.x*n,E.ty+=p.y*n,b=!0}if(e>0){let p=(Math.sqrt(l*l+a*a)-1+this.data.offsetScaleX)*e+1;E.a*=p,E.b*=p,p=(Math.sqrt(s*s+o*o)-1+this.data.offsetScaleY)*e+1,E.c*=p,E.d*=p,b=!0}if(r>0){let p=Math.atan2(o,s)-Math.atan2(a,l);p>T.PI?p-=T.PI2:p<-T.PI&&(p+=T.PI2);const S=E.c,y=E.d;p=Math.atan2(y,S)+(p-T.PI/2+u)*r;const M=Math.sqrt(S*S+y*y);E.c=Math.cos(p)*M,E.d=Math.sin(p)*M,b=!0}b&&(w.appliedValid=!1)}}applyAbsoluteLocal(){const t=this.rotateMix,n=this.translateMix,e=this.scaleMix,r=this.shearMix,i=this.target;i.appliedValid||i.updateAppliedTransform();const h=this.bones;for(let l=0,s=h.length;l<s;l++){const a=h[l];a.appliedValid||a.updateAppliedTransform();let o=a.arotation;if(t!=0){let x=i.arotation-o+this.data.offsetRotation;x-=(16384-(16384.499999999996-x/360|0))*360,o+=x*t}let c=a.ax,d=a.ay;n!=0&&(c+=(i.ax-c+this.data.offsetX)*n,d+=(i.ay-d+this.data.offsetY)*n);let u=a.ascaleX,m=a.ascaleY;e>0&&(u>1e-5&&(u=(u+(i.ascaleX-u+this.data.offsetScaleX)*e)/u),m>1e-5&&(m=(m+(i.ascaleY-m+this.data.offsetScaleY)*e)/m));const g=a.ashearY;if(r>0){let x=i.ashearY-g+this.data.offsetShearY;x-=(16384-(16384.499999999996-x/360|0))*360,a.shearY+=x*r}a.updateWorldTransformWith(c,d,o,u,m,a.ashearX,g)}}applyRelativeLocal(){const t=this.rotateMix,n=this.translateMix,e=this.scaleMix,r=this.shearMix,i=this.target;i.appliedValid||i.updateAppliedTransform();const h=this.bones;for(let l=0,s=h.length;l<s;l++){const a=h[l];a.appliedValid||a.updateAppliedTransform();let o=a.arotation;t!=0&&(o+=(i.arotation+this.data.offsetRotation)*t);let c=a.ax,d=a.ay;n!=0&&(c+=(i.ax+this.data.offsetX)*n,d+=(i.ay+this.data.offsetY)*n);let u=a.ascaleX,m=a.ascaleY;e>0&&(u>1e-5&&(u*=(i.ascaleX-1+this.data.offsetScaleX)*e+1),m>1e-5&&(m*=(i.ascaleY-1+this.data.offsetScaleY)*e+1));let g=a.ashearY;r>0&&(g+=(i.ashearY+this.data.offsetShearY)*r),a.updateWorldTransformWith(c,d,o,u,m,a.ashearX,g)}}};const ds=class{constructor(t){if(this._updateCache=new Array,this.updateCacheReset=new Array,this.time=0,this.scaleX=1,this.scaleY=1,this.x=0,this.y=0,t==null)throw new Error("data cannot be null.");this.data=t,this.bones=new Array;for(let n=0;n<t.bones.length;n++){const e=t.bones[n];let r;if(e.parent==null)r=new ri(e,this,null);else{const i=this.bones[e.parent.index];r=new ri(e,this,i),i.children.push(r)}this.bones.push(r)}this.slots=new Array,this.drawOrder=new Array;for(let n=0;n<t.slots.length;n++){const e=t.slots[n],r=this.bones[e.boneData.index],i=new js(e,r);this.slots.push(i),this.drawOrder.push(i)}this.ikConstraints=new Array;for(let n=0;n<t.ikConstraints.length;n++){const e=t.ikConstraints[n];this.ikConstraints.push(new Gr(e,this))}this.transformConstraints=new Array;for(let n=0;n<t.transformConstraints.length;n++){const e=t.transformConstraints[n];this.transformConstraints.push(new jr(e,this))}this.pathConstraints=new Array;for(let n=0;n<t.pathConstraints.length;n++){const e=t.pathConstraints[n];this.pathConstraints.push(new es(e,this))}this.color=new O(1,1,1,1),this.updateCache()}updateCache(){const t=this._updateCache;t.length=0,this.updateCacheReset.length=0;const n=this.bones;for(let o=0,c=n.length;o<c;o++){const d=n[o];d.sorted=d.data.skinRequired,d.active=!d.sorted}if(this.skin!=null){const o=this.skin.bones;for(let c=0,d=this.skin.bones.length;c<d;c++){let u=this.bones[o[c].index];do u.sorted=!1,u.active=!0,u=u.parent;while(u!=null)}}const e=this.ikConstraints,r=this.transformConstraints,i=this.pathConstraints,h=e.length,l=r.length,s=i.length,a=h+l+s;t:for(let o=0;o<a;o++){for(let c=0;c<h;c++){const d=e[c];if(d.data.order==o){this.sortIkConstraint(d);continue t}}for(let c=0;c<l;c++){const d=r[c];if(d.data.order==o){this.sortTransformConstraint(d);continue t}}for(let c=0;c<s;c++){const d=i[c];if(d.data.order==o){this.sortPathConstraint(d);continue t}}}for(let o=0,c=n.length;o<c;o++)this.sortBone(n[o])}sortIkConstraint(t){if(t.active=t.target.isActive()&&(!t.data.skinRequired||this.skin!=null&&k.contains(this.skin.constraints,t.data,!0)),!t.active)return;const n=t.target;this.sortBone(n);const e=t.bones,r=e[0];if(this.sortBone(r),e.length>1){const i=e[e.length-1];this._updateCache.indexOf(i)>-1||this.updateCacheReset.push(i)}this._updateCache.push(t),this.sortReset(r.children),e[e.length-1].sorted=!0}sortPathConstraint(t){if(t.active=t.target.bone.isActive()&&(!t.data.skinRequired||this.skin!=null&&k.contains(this.skin.constraints,t.data,!0)),!t.active)return;const n=t.target,e=n.data.index,r=n.bone;this.skin!=null&&this.sortPathConstraintAttachment(this.skin,e,r),this.data.defaultSkin!=null&&this.data.defaultSkin!=this.skin&&this.sortPathConstraintAttachment(this.data.defaultSkin,e,r);for(let s=0,a=this.data.skins.length;s<a;s++)this.sortPathConstraintAttachment(this.data.skins[s],e,r);const i=n.getAttachment();i instanceof ts&&this.sortPathConstraintAttachmentWith(i,r);const h=t.bones,l=h.length;for(let s=0;s<l;s++)this.sortBone(h[s]);this._updateCache.push(t);for(let s=0;s<l;s++)this.sortReset(h[s].children);for(let s=0;s<l;s++)h[s].sorted=!0}sortTransformConstraint(t){if(t.active=t.target.isActive()&&(!t.data.skinRequired||this.skin!=null&&k.contains(this.skin.constraints,t.data,!0)),!t.active)return;this.sortBone(t.target);const n=t.bones,e=n.length;if(t.data.local)for(let r=0;r<e;r++){const i=n[r];this.sortBone(i.parent),this._updateCache.indexOf(i)>-1||this.updateCacheReset.push(i)}else for(let r=0;r<e;r++)this.sortBone(n[r]);this._updateCache.push(t);for(let r=0;r<e;r++)this.sortReset(n[r].children);for(let r=0;r<e;r++)n[r].sorted=!0}sortPathConstraintAttachment(t,n,e){const r=t.attachments[n];if(r)for(const i in r)this.sortPathConstraintAttachmentWith(r[i],e)}sortPathConstraintAttachmentWith(t,n){if(!(t instanceof ts))return;const e=t.bones;if(e==null)this.sortBone(n);else{const r=this.bones;let i=0;for(;i<e.length;){const h=e[i++];for(let l=i+h;i<l;i++){const s=e[i];this.sortBone(r[s])}}}}sortBone(t){if(t.sorted)return;const n=t.parent;n!=null&&this.sortBone(n),t.sorted=!0,this._updateCache.push(t)}sortReset(t){for(let n=0,e=t.length;n<e;n++){const r=t[n];r.active&&(r.sorted&&this.sortReset(r.children),r.sorted=!1)}}updateWorldTransform(){const t=this.updateCacheReset;for(let e=0,r=t.length;e<r;e++){const i=t[e];i.ax=i.x,i.ay=i.y,i.arotation=i.rotation,i.ascaleX=i.scaleX,i.ascaleY=i.scaleY,i.ashearX=i.shearX,i.ashearY=i.shearY,i.appliedValid=!0}const n=this._updateCache;for(let e=0,r=n.length;e<r;e++)n[e].update()}setToSetupPose(){this.setBonesToSetupPose(),this.setSlotsToSetupPose()}setBonesToSetupPose(){const t=this.bones;for(let i=0,h=t.length;i<h;i++)t[i].setToSetupPose();const n=this.ikConstraints;for(let i=0,h=n.length;i<h;i++){const l=n[i];l.mix=l.data.mix,l.softness=l.data.softness,l.bendDirection=l.data.bendDirection,l.compress=l.data.compress,l.stretch=l.data.stretch}const e=this.transformConstraints;for(let i=0,h=e.length;i<h;i++){const l=e[i],s=l.data;l.rotateMix=s.rotateMix,l.translateMix=s.translateMix,l.scaleMix=s.scaleMix,l.shearMix=s.shearMix}const r=this.pathConstraints;for(let i=0,h=r.length;i<h;i++){const l=r[i],s=l.data;l.position=s.position,l.spacing=s.spacing,l.rotateMix=s.rotateMix,l.translateMix=s.translateMix}}setSlotsToSetupPose(){const t=this.slots;k.arrayCopy(t,0,this.drawOrder,0,t.length);for(let n=0,e=t.length;n<e;n++)t[n].setToSetupPose()}getRootBone(){return this.bones.length==0?null:this.bones[0]}findBone(t){if(t==null)throw new Error("boneName cannot be null.");const n=this.bones;for(let e=0,r=n.length;e<r;e++){const i=n[e];if(i.data.name==t)return i}return null}findBoneIndex(t){if(t==null)throw new Error("boneName cannot be null.");const n=this.bones;for(let e=0,r=n.length;e<r;e++)if(n[e].data.name==t)return e;return-1}findSlot(t){if(t==null)throw new Error("slotName cannot be null.");const n=this.slots;for(let e=0,r=n.length;e<r;e++){const i=n[e];if(i.data.name==t)return i}return null}findSlotIndex(t){if(t==null)throw new Error("slotName cannot be null.");const n=this.slots;for(let e=0,r=n.length;e<r;e++)if(n[e].data.name==t)return e;return-1}setSkinByName(t){const n=this.data.findSkin(t);if(n==null)throw new Error(`Skin not found: ${t}`);this.setSkin(n)}setSkin(t){if(t!=this.skin){if(t!=null)if(this.skin!=null)t.attachAll(this,this.skin);else{const n=this.slots;for(let e=0,r=n.length;e<r;e++){const i=n[e],h=i.data.attachmentName;if(h!=null){const l=t.getAttachment(e,h);l!=null&&i.setAttachment(l)}}}this.skin=t,this.updateCache()}}getAttachmentByName(t,n){return this.getAttachment(this.data.findSlotIndex(t),n)}getAttachment(t,n){if(n==null)throw new Error("attachmentName cannot be null.");if(this.skin!=null){const e=this.skin.getAttachment(t,n);if(e!=null)return e}return this.data.defaultSkin!=null?this.data.defaultSkin.getAttachment(t,n):null}setAttachment(t,n){if(t==null)throw new Error("slotName cannot be null.");const e=this.slots;for(let r=0,i=e.length;r<i;r++){const h=e[r];if(h.data.name==t){let l=null;if(n!=null&&(l=this.getAttachment(r,n),l==null))throw new Error(`Attachment not found: ${n}, for slot: ${t}`);h.setAttachment(l);return}}throw new Error(`Slot not found: ${t}`)}findIkConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const n=this.ikConstraints;for(let e=0,r=n.length;e<r;e++){const i=n[e];if(i.data.name==t)return i}return null}findTransformConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const n=this.transformConstraints;for(let e=0,r=n.length;e<r;e++){const i=n[e];if(i.data.name==t)return i}return null}findPathConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const n=this.pathConstraints;for(let e=0,r=n.length;e<r;e++){const i=n[e];if(i.data.name==t)return i}return null}getBounds(t,n,e=new Array(2)){if(t==null)throw new Error("offset cannot be null.");if(n==null)throw new Error("size cannot be null.");const r=this.drawOrder;let i=Number.POSITIVE_INFINITY,h=Number.POSITIVE_INFINITY,l=Number.NEGATIVE_INFINITY,s=Number.NEGATIVE_INFINITY;for(let a=0,o=r.length;a<o;a++){const c=r[a];if(!c.bone.active)continue;let d=0,u=null;const m=c.getAttachment();if(m instanceof J)d=8,u=k.setArraySize(e,d,0),m.computeWorldVertices(c.bone,u,0,2);else if(m instanceof Jn){const g=m;d=g.worldVerticesLength,u=k.setArraySize(e,d,0),g.computeWorldVertices(c,0,d,u,0,2)}if(u!=null)for(let g=0,x=u.length;g<x;g+=2){const w=u[g],b=u[g+1];i=Math.min(i,w),h=Math.min(h,b),l=Math.max(l,w),s=Math.max(s,b)}}t.set(i,h),n.set(l-i,s-h)}update(t){this.time+=t}get flipX(){return this.scaleX==-1}set flipX(t){ds.deprecatedWarning1||(ds.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleX=t?1:-1}get flipY(){return this.scaleY==-1}set flipY(t){ds.deprecatedWarning1||(ds.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleY=t?1:-1}};let ai=ds;ai.deprecatedWarning1=!1;let oi=class{constructor(t,n){if(n==null)throw new Error("data cannot be null.");this.time=t,this.data=n}},li=class{constructor(){this.bones=new Array,this.slots=new Array,this.skins=new Array,this.events=new Array,this.animations=new Array,this.ikConstraints=new Array,this.transformConstraints=new Array,this.pathConstraints=new Array,this.fps=0}findBone(t){if(t==null)throw new Error("boneName cannot be null.");const n=this.bones;for(let e=0,r=n.length;e<r;e++){const i=n[e];if(i.name==t)return i}return null}findBoneIndex(t){if(t==null)throw new Error("boneName cannot be null.");const n=this.bones;for(let e=0,r=n.length;e<r;e++)if(n[e].name==t)return e;return-1}findSlot(t){if(t==null)throw new Error("slotName cannot be null.");const n=this.slots;for(let e=0,r=n.length;e<r;e++){const i=n[e];if(i.name==t)return i}return null}findSlotIndex(t){if(t==null)throw new Error("slotName cannot be null.");const n=this.slots;for(let e=0,r=n.length;e<r;e++)if(n[e].name==t)return e;return-1}findSkin(t){if(t==null)throw new Error("skinName cannot be null.");const n=this.skins;for(let e=0,r=n.length;e<r;e++){const i=n[e];if(i.name==t)return i}return null}findEvent(t){if(t==null)throw new Error("eventDataName cannot be null.");const n=this.events;for(let e=0,r=n.length;e<r;e++){const i=n[e];if(i.name==t)return i}return null}findAnimation(t){if(t==null)throw new Error("animationName cannot be null.");const n=this.animations;for(let e=0,r=n.length;e<r;e++){const i=n[e];if(i.name==t)return i}return null}findIkConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const n=this.ikConstraints;for(let e=0,r=n.length;e<r;e++){const i=n[e];if(i.name==t)return i}return null}findTransformConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const n=this.transformConstraints;for(let e=0,r=n.length;e<r;e++){const i=n[e];if(i.name==t)return i}return null}findPathConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const n=this.pathConstraints;for(let e=0,r=n.length;e<r;e++){const i=n[e];if(i.name==t)return i}return null}findPathConstraintIndex(t){if(t==null)throw new Error("pathConstraintName cannot be null.");const n=this.pathConstraints;for(let e=0,r=n.length;e<r;e++)if(n[e].name==t)return e;return-1}},ci=class{constructor(t,n,e){if(this.color=new O(1,1,1,1),t<0)throw new Error("index must be >= 0.");if(n==null)throw new Error("name cannot be null.");if(e==null)throw new Error("boneData cannot be null.");this.index=t,this.name=n,this.boneData=e}},hi=class{constructor(t,n,e){if(this.x=0,this.y=0,this.rotation=0,this.scaleX=1,this.scaleY=1,this.shearX=0,this.shearY=0,this.transformMode=z.Normal,this.skinRequired=!1,this.inheritRotation=!0,this.inheritScale=!0,this.color=new O,t<0)throw new Error("index must be >= 0.");if(n==null)throw new Error("name cannot be null.");this.index=t,this.name=n,this.parent=e}},di=class extends As{constructor(t){super(t,0,!1),this.bones=new Array,this.bendDirection=1,this.compress=!1,this.stretch=!1,this.uniform=!1,this.mix=1,this.softness=0}},fi=class extends As{constructor(t){super(t,0,!1),this.bones=new Array,this.rotateMix=0,this.translateMix=0,this.scaleMix=0,this.shearMix=0,this.offsetRotation=0,this.offsetX=0,this.offsetY=0,this.offsetScaleX=0,this.offsetScaleY=0,this.offsetShearY=0,this.relative=!1,this.local=!1}},ui=class{constructor(t,n,e){this.slotIndex=t,this.name=n,this.attachment=e}},Ts=class{constructor(t){if(this.attachments=new Array,this.bones=Array(),this.constraints=new Array,t==null)throw new Error("name cannot be null.");this.name=t}setAttachment(t,n,e){if(e==null)throw new Error("attachment cannot be null.");const r=this.attachments;t>=r.length&&(r.length=t+1),r[t]||(r[t]={}),r[t][n]=e}addSkin(t){for(let e=0;e<t.bones.length;e++){const r=t.bones[e];let i=!1;for(let h=0;h<this.bones.length;h++)if(this.bones[h]==r){i=!0;break}i||this.bones.push(r)}for(let e=0;e<t.constraints.length;e++){const r=t.constraints[e];let i=!1;for(let h=0;h<this.constraints.length;h++)if(this.constraints[h]==r){i=!0;break}i||this.constraints.push(r)}const n=t.getAttachments();for(let e=0;e<n.length;e++){const r=n[e];this.setAttachment(r.slotIndex,r.name,r.attachment)}}copySkin(t){for(let e=0;e<t.bones.length;e++){const r=t.bones[e];let i=!1;for(let h=0;h<this.bones.length;h++)if(this.bones[h]==r){i=!0;break}i||this.bones.push(r)}for(let e=0;e<t.constraints.length;e++){const r=t.constraints[e];let i=!1;for(let h=0;h<this.constraints.length;h++)if(this.constraints[h]==r){i=!0;break}i||this.constraints.push(r)}const n=t.getAttachments();for(let e=0;e<n.length;e++){const r=n[e];r.attachment!=null&&(r.attachment instanceof Jn?(r.attachment=r.attachment.newLinkedMesh(),this.setAttachment(r.slotIndex,r.name,r.attachment)):(r.attachment=r.attachment.copy(),this.setAttachment(r.slotIndex,r.name,r.attachment)))}}getAttachment(t,n){const e=this.attachments[t];return e?e[n]:null}removeAttachment(t,n){const e=this.attachments[t];e&&(e[n]=null)}getAttachments(){const t=new Array;for(let n=0;n<this.attachments.length;n++){const e=this.attachments[n];if(e)for(const r in e){const i=e[r];i&&t.push(new ui(n,r,i))}}return t}getAttachmentsForSlot(t,n){const e=this.attachments[t];if(e)for(const r in e){const i=e[r];i&&n.push(new ui(t,r,i))}}clear(){this.attachments.length=0,this.bones.length=0,this.constraints.length=0}attachAll(t,n){let e=0;for(let r=0;r<t.slots.length;r++){const i=t.slots[r],h=i.getAttachment();if(h&&e<n.attachments.length){const l=n.attachments[e];for(const s in l){const a=l[s];if(h==a){const o=this.getAttachment(e,s);o!=null&&i.setAttachment(o);break}}}e++}}},mi=class{constructor(t){this.name=t}};const Xt=class{constructor(t){this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=t}readSkeletonData(t){const n=this.scale,e=new li;e.name="";const r=new Gn(t);e.hash=r.readString(),e.version=r.readString(),e.version==="3.8.75"&&console.error("Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine."),e.width=r.readFloat(),e.height=r.readFloat();const i=r.readBoolean();i&&(e.imagesPath=r.readString());let h=0;h=r.readInt(!0);for(let s=0;s<h;s++){const a=r.readString(),o=s==0?null:e.bones[r.readInt(!0)],c=new hi(s,a,o);c.rotation=r.readFloat(),c.x=r.readFloat()*n,c.y=r.readFloat()*n,c.scaleX=r.readFloat(),c.scaleY=r.readFloat(),c.shearX=r.readFloat(),c.shearY=r.readFloat(),c.length=r.readFloat()*n,c.inheritRotation=r.readBoolean(),c.inheritScale=r.readBoolean(),i&&O.rgba8888ToColor(c.color,r.readInt32()),e.bones.push(c)}h=r.readInt(!0);for(let s=0;s<h;s++){const a=r.readString(),o=e.bones[r.readInt(!0)],c=new ci(s,a,o);O.rgba8888ToColor(c.color,r.readInt32()),c.attachmentName=r.readString(),c.blendMode=Xt.BlendModeValues[r.readInt(!0)],e.slots.push(c)}h=r.readInt(!0);for(let s=0,a;s<h;s++){const o=r.readString(),c=new di(o);a=r.readInt(!0);for(let d=0;d<a;d++)c.bones.push(e.bones[r.readInt(!0)]);c.target=e.bones[r.readInt(!0)],c.mix=r.readFloat(),c.bendDirection=r.readByte(),e.ikConstraints.push(c)}h=r.readInt(!0);for(let s=0,a;s<h;s++){const o=r.readString(),c=new fi(o);a=r.readInt(!0);for(let d=0;d<a;d++)c.bones.push(e.bones[r.readInt(!0)]);c.target=e.bones[r.readInt(!0)],c.offsetRotation=r.readFloat(),c.offsetX=r.readFloat()*n,c.offsetY=r.readFloat()*n,c.offsetScaleX=r.readFloat(),c.offsetScaleY=r.readFloat(),c.offsetShearY=r.readFloat(),c.rotateMix=r.readFloat(),c.translateMix=r.readFloat(),c.scaleMix=r.readFloat(),c.shearMix=r.readFloat(),e.transformConstraints.push(c)}h=r.readInt(!0);for(let s=0,a;s<h;s++){const o=r.readString(),c=new ii(o);a=r.readInt(!0);for(let d=0;d<a;d++)c.bones.push(e.bones[r.readInt(!0)]);c.target=e.slots[r.readInt(!0)],c.positionMode=Xt.PositionModeValues[r.readInt(!0)],c.spacingMode=Xt.SpacingModeValues[r.readInt(!0)],c.rotateMode=Xt.RotateModeValues[r.readInt(!0)],c.offsetRotation=r.readFloat(),c.position=r.readFloat(),c.positionMode==dt.Fixed&&(c.position*=n),c.spacing=r.readFloat(),(c.spacingMode==qt.Length||c.spacingMode==qt.Fixed)&&(c.spacing*=n),c.rotateMix=r.readFloat(),c.translateMix=r.readFloat(),e.pathConstraints.push(c)}const l=this.readSkin(r,e,!0,i);l!=null&&(e.defaultSkin=l,e.skins.push(l));{let s=e.skins.length;for(k.setArraySize(e.skins,h=s+r.readInt(!0));s<h;s++)e.skins[s]=this.readSkin(r,e,!1,i)}h=this.linkedMeshes.length;for(let s=0;s<h;s++){const a=this.linkedMeshes[s],o=a.skin==null?e.defaultSkin:e.findSkin(a.skin);if(o==null)throw new Error(`Skin not found: ${a.skin}`);const c=o.getAttachment(a.slotIndex,a.parent);if(c==null)throw new Error(`Parent mesh not found: ${a.parent}`);a.mesh.deformAttachment=a.inheritDeform?c:a.mesh,a.mesh.setParentMesh(c)}this.linkedMeshes.length=0,h=r.readInt(!0);for(let s=0;s<h;s++){const a=new mi(r.readStringRef());a.intValue=r.readInt(!1),a.floatValue=r.readFloat(),a.stringValue=r.readString(),a.audioPath=r.readString(),a.audioPath!=null&&(a.volume=r.readFloat(),a.balance=r.readFloat()),e.events.push(a)}h=r.readInt(!0);for(let s=0;s<h;s++)e.animations.push(this.readAnimation(r,r.readString(),e));return e}readSkin(t,n,e,r){let i=null,h=0;if(e){if(h=t.readInt(!0),h==0)return null;i=new Ts("default")}else{i=new Ts(t.readString()),i.bones.length=t.readInt(!0);for(let l=0,s=i.bones.length;l<s;l++)i.bones[l]=n.bones[t.readInt(!0)];for(let l=0,s=t.readInt(!0);l<s;l++)i.constraints.push(n.ikConstraints[t.readInt(!0)]);for(let l=0,s=t.readInt(!0);l<s;l++)i.constraints.push(n.transformConstraints[t.readInt(!0)]);for(let l=0,s=t.readInt(!0);l<s;l++)i.constraints.push(n.pathConstraints[t.readInt(!0)]);h=t.readInt(!0)}for(let l=0;l<h;l++){const s=t.readInt(!0);for(let a=0,o=t.readInt(!0);a<o;a++){const c=t.readString(),d=this.readAttachment(t,n,i,s,c,r);d!=null&&i.setAttachment(s,c,d)}}return i}readAttachment(t,n,e,r,i,h){const l=this.scale;let s=t.readStringRef();s==null&&(s=i);const a=t.readByte();switch(Xt.AttachmentTypeValues[a]){case Z.Region:{let c=t.readString();const d=t.readFloat(),u=t.readFloat(),m=t.readFloat(),g=t.readFloat(),x=t.readFloat(),w=t.readFloat(),b=t.readFloat(),E=t.readInt32();c==null&&(c=s);const p=this.attachmentLoader.newRegionAttachment(e,s,c);return p==null?null:(p.path=c,p.x=u*l,p.y=m*l,p.scaleX=g,p.scaleY=x,p.rotation=d,p.width=w*l,p.height=b*l,O.rgba8888ToColor(p.color,E),p)}case Z.BoundingBox:{const c=t.readInt(!0),d=this.readVertices(t,c),u=h?t.readInt32():0,m=this.attachmentLoader.newBoundingBoxAttachment(e,s);return m==null?null:(m.worldVerticesLength=c<<1,m.vertices=d.vertices,m.bones=d.bones,m.cVertices=d.cVertices,h&&O.rgba8888ToColor(m.color,u),m)}case Z.Mesh:{let c=t.readStringRef();const d=t.readInt32(),u=t.readInt(!0),m=this.readFloatArray(t,u<<1,1),g=this.readShortArray(t),x=this.readVertices(t,u),w=t.readInt(!0);let b=null,E=0,p=0;h&&(b=this.readShortArray(t),E=t.readFloat(),p=t.readFloat()),c==null&&(c=s);const S=this.attachmentLoader.newMeshAttachment(e,s,c);return S==null?null:(S.path=c,O.rgba8888ToColor(S.color,d),S.bones=x.bones,S.vertices=x.vertices,S.worldVerticesLength=u<<1,S.triangles=g,S.regionUVs=new Float32Array(m),S.cVertices=x.cVertices,S.hullLength=w<<1,h&&(S.edges=b,S.width=E*l,S.height=p*l),S)}case Z.LinkedMesh:{let c=t.readStringRef();const d=t.readInt32(),u=t.readStringRef(),m=t.readStringRef(),g=t.readBoolean();let x=0,w=0;h&&(x=t.readFloat(),w=t.readFloat()),c==null&&(c=s);const b=this.attachmentLoader.newMeshAttachment(e,s,c);return b==null?null:(b.path=c,O.rgba8888ToColor(b.color,d),h&&(b.width=x*l,b.height=w*l),this.linkedMeshes.push(new eo(b,u,r,m,g)),b)}case Z.Path:{const c=t.readBoolean(),d=t.readBoolean(),u=t.readInt(!0),m=this.readVertices(t,u),g=k.newArray(u/3,0);for(let b=0,E=g.length;b<E;b++)g[b]=t.readFloat()*l;const x=h?t.readInt32():0,w=this.attachmentLoader.newPathAttachment(e,s);return w==null?null:(w.closed=c,w.constantSpeed=d,w.worldVerticesLength=u<<1,w.vertices=m.vertices,w.bones=m.bones,w.lengths=g,w.cVertices=m.cVertices,h&&O.rgba8888ToColor(w.color,x),w)}case Z.Point:{const c=t.readFloat(),d=t.readFloat(),u=t.readFloat(),m=h?t.readInt32():0,g=this.attachmentLoader.newPointAttachment(e,s);return g==null?null:(g.x=d*l,g.y=u*l,g.rotation=c,h&&O.rgba8888ToColor(g.color,m),g)}case Z.Clipping:{const c=t.readInt(!0),d=t.readInt(!0),u=this.readVertices(t,d),m=h?t.readInt32():0,g=this.attachmentLoader.newClippingAttachment(e,s);return g==null?null:(g.endSlot=n.slots[c],g.worldVerticesLength=d<<1,g.vertices=u.vertices,g.bones=u.bones,g.cVertices=u.cVertices,h&&O.rgba8888ToColor(g.color,m),g)}}return null}readVertices(t,n){const e=n<<1,r=new no,i=this.scale;if(!t.readBoolean())return r.vertices=this.readFloatArray(t,e,i),r;const h=new Array,l=new Array,s=new Array;for(let a=0;a<n;a++){const o=t.readInt(!0);s.push(o),h.push(o);for(let c=0;c<o;c++){const d=t.readInt(!0);s.push(d),h.push(d);const u=t.readFloat()*i,m=t.readFloat()*i,g=t.readFloat();l.push(u),l.push(m),l.push(g),h.push(u),h.push(m),h.push(g)}}return r.vertices=k.toFloatArray(l),r.bones=s,r.cVertices=h,r}readFloatArray(t,n,e){const r=new Array(n);if(e==1)for(let i=0;i<n;i++)r[i]=t.readFloat();else for(let i=0;i<n;i++)r[i]=t.readFloat()*e;return r}readShortArray(t){const n=t.readInt(!0),e=new Array(n);for(let r=0;r<n;r++)e[r]=t.readShort();return e}readAnimation(t,n,e){const r=new Array,i=this.scale;let h=0;const l=new O;for(let o=0,c=t.readInt(!0);o<c;o++){const d=t.readInt(!0);for(let u=0,m=t.readInt(!0);u<m;u++){const g=t.readByte(),x=t.readInt(!0);switch(g){case Xt.SLOT_ATTACHMENT:{const w=new Nn(x);w.slotIndex=d;for(let b=0;b<x;b++){const E=t.readFloat(),p=t.readString();w.setFrame(b,E,p)}r.push(w),h=Math.max(h,w.frames[x-1]);break}case Xt.SLOT_COLOR:{const w=new oe(x);w.slotIndex=d;for(let b=0;b<x;b++){const E=t.readFloat();O.rgba8888ToColor(l,t.readInt32()),w.setFrame(b,E,l.r,l.g,l.b,l.a),b<x-1&&this.readCurve(t,b,w)}r.push(w),h=Math.max(h,w.frames[(x-1)*oe.ENTRIES]);break}}}}for(let o=0,c=t.readInt(!0);o<c;o++){const d=t.readInt(!0);for(let u=0,m=t.readInt(!0);u<m;u++){const g=t.readByte(),x=t.readInt(!0);switch(g){case Xt.BONE_ROTATE:{const w=new Zt(x);w.boneIndex=d;for(let b=0;b<x;b++)w.setFrame(b,t.readFloat(),t.readFloat()),b<x-1&&this.readCurve(t,b,w);r.push(w),h=Math.max(h,w.frames[(x-1)*Zt.ENTRIES]);break}case Xt.BONE_TRANSLATE:case Xt.BONE_SCALE:case Xt.BONE_SHEAR:{let w,b=1;g==Xt.BONE_SCALE?w=new ke(x):g==Xt.BONE_SHEAR?w=new ve(x):(w=new Re(x),b=i),w.boneIndex=d;for(let E=0;E<x;E++){const p=t.readFloat(),S=t.readFloat(),y=t.readFloat();w.setFrame(E,p,S*b,y*b),E<x-1&&this.readCurve(t,E,w)}r.push(w),h=Math.max(h,w.frames[(x-1)*Re.ENTRIES]);break}}}}for(let o=0,c=t.readInt(!0);o<c;o++){const d=t.readInt(!0),u=t.readInt(!0),m=new Qt(u);m.ikConstraintIndex=d;for(let g=0;g<u;g++){const x=t.readFloat(),w=t.readFloat(),b=t.readByte();m.setFrame(g,x,w,b),g<u-1&&this.readCurve(t,g,m)}r.push(m),h=Math.max(h,m.frames[(u-1)*Qt.ENTRIES])}for(let o=0,c=t.readInt(!0);o<c;o++){const d=t.readInt(!0),u=t.readInt(!0),m=new le(u);m.transformConstraintIndex=d;for(let g=0;g<u;g++)m.setFrame(g,t.readFloat(),t.readFloat(),t.readFloat(),t.readFloat(),t.readFloat()),g<u-1&&this.readCurve(t,g,m);r.push(m),h=Math.max(h,m.frames[(u-1)*le.ENTRIES])}for(let o=0,c=t.readInt(!0);o<c;o++){const d=t.readInt(!0),u=e.pathConstraints[d];for(let m=0,g=t.readInt(!0);m<g;m++){const x=t.readByte(),w=t.readInt(!0);switch(x){case Xt.PATH_POSITION:case Xt.PATH_SPACING:{let b,E=1;x==Xt.PATH_SPACING?(b=new on(w),(u.spacingMode==qt.Length||u.spacingMode==qt.Fixed)&&(E=i)):(b=new an(w),u.positionMode==dt.Fixed&&(E=i)),b.pathConstraintIndex=d;for(let p=0;p<w;p++){const S=t.readFloat(),y=t.readFloat()*E;b.setFrame(p,S,y),p<w-1&&this.readCurve(t,p,b)}r.push(b),h=Math.max(h,b.frames[(w-1)*an.ENTRIES]);break}case Xt.PATH_MIX:{const b=new ze(w);b.pathConstraintIndex=d;for(let E=0;E<w;E++){const p=t.readFloat(),S=t.readFloat(),y=t.readFloat();b.setFrame(E,p,S,y),E<w-1&&this.readCurve(t,E,b)}r.push(b),h=Math.max(h,b.frames[(w-1)*ze.ENTRIES]);break}}}}for(let o=0,c=t.readInt(!0);o<c;o++){const d=e.skins[t.readInt(!0)];for(let u=0,m=t.readInt(!0);u<m;u++){const g=t.readInt(!0);for(let x=0,w=t.readInt(!0);x<w;x++){const b=d==null?void 0:d.getAttachment(g,t.readString()),E=b.bones!=null,p=b.vertices,S=E?p.length/3*2:p.length,y=t.readInt(!0),M=new Zs(y);M.slotIndex=g,M.attachment=b;for(let C=0;C<y;C++){const I=t.readFloat();let R,v=t.readInt(!0);if(v==0)R=E?k.newFloatArray(S):p;else{R=k.newFloatArray(S);const V=t.readInt(!0);if(v+=V,i==1)for(let P=V;P<v;P++)R[P]=t.readFloat();else for(let P=V;P<v;P++)R[P]=t.readFloat()*i;if(!E)for(let P=0,D=R.length;P<D;P++)R[P]+=p[P]}M.setFrame(C,I,R,d.name),C<y-1&&this.readCurve(t,C,M)}r.push(M),h=Math.max(h,M.frames[y-1])}}}const s=t.readInt(!0);if(s>0){const o=new Kn(s),c=e.slots.length;for(let d=0;d<s;d++){const u=t.readFloat(),m=t.readInt(!0),g=k.newArray(c,0);for(let E=c-1;E>=0;E--)g[E]=-1;const x=k.newArray(c-m,0);let w=0,b=0;for(let E=0;E<m;E++){const p=t.readInt(!0);for(;w!=p;)x[b++]=w++;g[w+t.readInt(!0)]=w++}for(;w<c;)x[b++]=w++;for(let E=c-1;E>=0;E--)g[E]==-1&&(g[E]=x[--b]);o.setFrame(d,u,g)}r.push(o),h=Math.max(h,o.frames[s-1])}const a=t.readInt(!0);if(a>0){const o=new ys(a);for(let c=0;c<a;c++){const d=t.readFloat(),u=e.events[t.readInt(!0)],m=new oi(d,u);m.intValue=t.readInt(!1),m.floatValue=t.readFloat(),m.stringValue=t.readBoolean()?t.readString():u.stringValue,m.data.audioPath!=null&&(m.volume=t.readFloat(),m.balance=t.readFloat()),o.setFrame(c,m)}r.push(o),h=Math.max(h,o.frames[a-1])}return new Rt(n,r,h)}readCurve(t,n,e){switch(t.readByte()){case Xt.CURVE_STEPPED:e.setStepped(n);break;case Xt.CURVE_BEZIER:this.setCurve(e,n,t.readFloat(),t.readFloat(),t.readFloat(),t.readFloat());break}}setCurve(t,n,e,r,i,h){t.setCurve(n,e,r,i,h)}};let vt=Xt;vt.AttachmentTypeValues=[0,1,2,3,4,5,6],vt.TransformModeValues=[z.Normal,z.OnlyTranslation,z.NoRotationOrReflection,z.NoScale,z.NoScaleOrReflection],vt.PositionModeValues=[dt.Fixed,dt.Percent],vt.SpacingModeValues=[qt.Length,qt.Fixed,qt.Percent],vt.RotateModeValues=[ut.Tangent,ut.Chain,ut.ChainScale],vt.BlendModeValues=[G.BLEND_MODES.NORMAL,G.BLEND_MODES.ADD,G.BLEND_MODES.MULTIPLY,G.BLEND_MODES.SCREEN],vt.BONE_ROTATE=0,vt.BONE_TRANSLATE=1,vt.BONE_SCALE=2,vt.BONE_SHEAR=3,vt.SLOT_ATTACHMENT=0,vt.SLOT_COLOR=1,vt.SLOT_TWO_COLOR=2,vt.PATH_POSITION=0,vt.PATH_SPACING=1,vt.PATH_MIX=2,vt.CURVE_LINEAR=0,vt.CURVE_STEPPED=1,vt.CURVE_BEZIER=2;let eo=class{constructor(t,n,e,r,i){this.mesh=t,this.skin=n,this.slotIndex=e,this.parent=r,this.inheritDeform=i}},no=class{constructor(t=null,n=null,e=null){this.bones=t,this.vertices=n,this.cVertices=e}},gi=class{constructor(t){if(t==null)throw new Error("name cannot be null.");this.name=t}};const Zr=class extends gi{constructor(t){super(t),this.id=(Zr.nextID++&65535)<<11,this.worldVerticesLength=0,this.deformAttachment=this}computeWorldVerticesOld(t,n){this.computeWorldVertices(t,0,this.worldVerticesLength,n,0,2)}computeWorldVertices(t,n,e,r,i,h){e=i+(e>>1)*h;const l=t.bone.skeleton,s=t.deform;let a=this.vertices;const o=this.bones;if(o==null){s.length>0&&(a=s);const m=t.bone.matrix,g=m.tx,x=m.ty,w=m.a,b=m.c,E=m.b,p=m.d;for(let S=n,y=i;y<e;S+=2,y+=h){const M=a[S],C=a[S+1];r[y]=M*w+C*b+g,r[y+1]=M*E+C*p+x}return}let c=0,d=0;for(let m=0;m<n;m+=2){const g=o[c];c+=g+1,d+=g}const u=l.bones;if(s.length==0)for(let m=i,g=d*3;m<e;m+=h){let x=0,w=0,b=o[c++];for(b+=c;c<b;c++,g+=3){const E=u[o[c]].matrix,p=a[g],S=a[g+1],y=a[g+2];x+=(p*E.a+S*E.c+E.tx)*y,w+=(p*E.b+S*E.d+E.ty)*y}r[m]=x,r[m+1]=w}else{const m=s;for(let g=i,x=d*3,w=d<<1;g<e;g+=h){let b=0,E=0,p=o[c++];for(p+=c;c<p;c++,x+=3,w+=2){const S=u[o[c]].matrix,y=a[x]+m[w],M=a[x+1]+m[w+1],C=a[x+2];b+=(y*S.a+M*S.c+S.tx)*C,E+=(y*S.b+M*S.d+S.ty)*C}r[g]=b,r[g+1]=E}}}copyTo(t){this.bones!=null?(t.bones=new Array(this.bones.length),k.arrayCopy(this.bones,0,t.bones,0,this.bones.length)):t.bones=null,this.vertices!=null?(t.vertices=k.newFloatArray(this.vertices.length),k.arrayCopy(this.vertices,0,t.vertices,0,this.vertices.length)):t.vertices=null,t.worldVerticesLength=this.worldVerticesLength,t.deformAttachment=this.deformAttachment}};let In=Zr;In.nextID=0;let xi=class extends In{constructor(t){super(t),this.type=Z.BoundingBox,this.color=new O(1,1,1,1)}copy(){const t=new xi(this.name);return this.copyTo(t),t.color.setFromColor(this.color),t}},pi=class extends In{constructor(t){super(t),this.type=Z.Clipping,this.color=new O(.2275,.2275,.8078,1)}copy(){const t=new pi(this.name);return this.copyTo(t),t.endSlot=this.endSlot,t.color.setFromColor(this.color),t}},ns=class extends In{constructor(t){super(t),this.type=Z.Mesh,this.color=new O(1,1,1,1),this.tempColor=new O(0,0,0,0)}getParentMesh(){return this.parentMesh}setParentMesh(t){this.parentMesh=t,t!=null&&(this.bones=t.bones,this.vertices=t.vertices,this.worldVerticesLength=t.worldVerticesLength,this.regionUVs=t.regionUVs,this.triangles=t.triangles,this.hullLength=t.hullLength,this.worldVerticesLength=t.worldVerticesLength)}copy(){if(this.parentMesh!=null)return this.newLinkedMesh();const t=new ns(this.name);return t.region=this.region,t.path=this.path,t.color.setFromColor(this.color),this.copyTo(t),t.regionUVs=new Float32Array(this.regionUVs.length),k.arrayCopy(this.regionUVs,0,t.regionUVs,0,this.regionUVs.length),t.triangles=new Array(this.triangles.length),k.arrayCopy(this.triangles,0,t.triangles,0,this.triangles.length),t.hullLength=this.hullLength,this.edges!=null&&(t.edges=new Array(this.edges.length),k.arrayCopy(this.edges,0,t.edges,0,this.edges.length)),t.width=this.width,t.height=this.height,t}newLinkedMesh(){const t=new ns(this.name);return t.region=this.region,t.path=this.path,t.color.setFromColor(this.color),t.deformAttachment=this.deformAttachment,t.setParentMesh(this.parentMesh!=null?this.parentMesh:this),t}},ss=class extends In{constructor(t){super(t),this.type=Z.Path,this.closed=!1,this.constantSpeed=!1,this.color=new O(1,1,1,1)}copy(){const t=new ss(this.name);return this.copyTo(t),t.lengths=new Array(this.lengths.length),k.arrayCopy(this.lengths,0,t.lengths,0,this.lengths.length),t.closed=closed,t.constantSpeed=this.constantSpeed,t.color.setFromColor(this.color),t}},wi=class extends In{constructor(t){super(t),this.type=Z.Point,this.color=new O(.38,.94,0,1)}computeWorldPosition(t,n){const e=t.matrix;return n.x=this.x*e.a+this.y*e.c+t.worldX,n.y=this.x*e.b+this.y*e.d+t.worldY,n}computeWorldRotation(t){const n=t.matrix,e=T.cosDeg(this.rotation),r=T.sinDeg(this.rotation),i=e*n.a+r*n.c,h=e*n.b+r*n.d;return Math.atan2(h,i)*T.radDeg}copy(){const t=new wi(this.name);return t.x=this.x,t.y=this.y,t.rotation=this.rotation,t.color.setFromColor(this.color),t}},bi=class{constructor(t,n){if(this.deform=new Array,t==null)throw new Error("data cannot be null.");if(n==null)throw new Error("bone cannot be null.");this.data=t,this.bone=n,this.color=new O,this.darkColor=t.darkColor==null?null:new O,this.setToSetupPose(),this.blendMode=this.data.blendMode}getAttachment(){return this.attachment}setAttachment(t){this.attachment!=t&&(this.attachment=t,this.attachmentTime=this.bone.skeleton.time,this.deform.length=0)}setAttachmentTime(t){this.attachmentTime=this.bone.skeleton.time-t}getAttachmentTime(){return this.bone.skeleton.time-this.attachmentTime}setToSetupPose(){this.color.setFromColor(this.data.color),this.darkColor!=null&&this.darkColor.setFromColor(this.data.darkColor),this.data.attachmentName==null?this.attachment=null:(this.attachment=null,this.setAttachment(this.bone.skeleton.getAttachment(this.data.index,this.data.attachmentName)))}};const Ut=class extends gi{constructor(t){super(t),this.type=Z.Region,this.x=0,this.y=0,this.scaleX=1,this.scaleY=1,this.rotation=0,this.width=0,this.height=0,this.color=new O(1,1,1,1),this.offset=k.newFloatArray(8),this.uvs=k.newFloatArray(8),this.tempColor=new O(1,1,1,1)}updateOffset(){const t=this.width/this.region.originalWidth*this.scaleX,n=this.height/this.region.originalHeight*this.scaleY,e=-this.width/2*this.scaleX+this.region.offsetX*t,r=-this.height/2*this.scaleY+this.region.offsetY*n,i=e+this.region.width*t,h=r+this.region.height*n,l=this.rotation*Math.PI/180,s=Math.cos(l),a=Math.sin(l),o=e*s+this.x,c=e*a,d=r*s+this.y,u=r*a,m=i*s+this.x,g=i*a,x=h*s+this.y,w=h*a,b=this.offset;b[Ut.OX1]=o-u,b[Ut.OY1]=d+c,b[Ut.OX2]=o-w,b[Ut.OY2]=x+c,b[Ut.OX3]=m-w,b[Ut.OY3]=x+g,b[Ut.OX4]=m-u,b[Ut.OY4]=d+g}setRegion(t){this.region=t;const n=this.uvs;t.rotate?(n[2]=t.u,n[3]=t.v2,n[4]=t.u,n[5]=t.v,n[6]=t.u2,n[7]=t.v,n[0]=t.u2,n[1]=t.v2):(n[0]=t.u,n[1]=t.v2,n[2]=t.u,n[3]=t.v,n[4]=t.u2,n[5]=t.v,n[6]=t.u2,n[7]=t.v2)}computeWorldVertices(t,n,e,r){const i=this.offset,h=t instanceof bi?t.bone.matrix:t.matrix,l=h.tx,s=h.ty,a=h.a,o=h.c,c=h.b,d=h.d;let u=0,m=0;u=i[Ut.OX1],m=i[Ut.OY1],n[e]=u*a+m*o+l,n[e+1]=u*c+m*d+s,e+=r,u=i[Ut.OX2],m=i[Ut.OY2],n[e]=u*a+m*o+l,n[e+1]=u*c+m*d+s,e+=r,u=i[Ut.OX3],m=i[Ut.OY3],n[e]=u*a+m*o+l,n[e+1]=u*c+m*d+s,e+=r,u=i[Ut.OX4],m=i[Ut.OY4],n[e]=u*a+m*o+l,n[e+1]=u*c+m*d+s}copy(){const t=new Ut(this.name);return t.region=this.region,t.rendererObject=this.rendererObject,t.path=this.path,t.x=this.x,t.y=this.y,t.scaleX=this.scaleX,t.scaleY=this.scaleY,t.rotation=this.rotation,t.width=this.width,t.height=this.height,k.arrayCopy(this.uvs,0,t.uvs,0,8),k.arrayCopy(this.offset,0,t.offset,0,8),t.color.setFromColor(this.color),t}};let tt=Ut;tt.OX1=0,tt.OY1=1,tt.OX2=2,tt.OY2=3,tt.OX3=4,tt.OY3=5,tt.OX4=6,tt.OY4=7,tt.X1=0,tt.Y1=1,tt.C1R=2,tt.C1G=3,tt.C1B=4,tt.C1A=5,tt.U1=6,tt.V1=7,tt.X2=8,tt.Y2=9,tt.C2R=10,tt.C2G=11,tt.C2B=12,tt.C2A=13,tt.U2=14,tt.V2=15,tt.X3=16,tt.Y3=17,tt.C3R=18,tt.C3G=19,tt.C3B=20,tt.C3A=21,tt.U3=22,tt.V3=23,tt.X4=24,tt.Y4=25,tt.C4R=26,tt.C4G=27,tt.C4B=28,tt.C4A=29,tt.U4=30,tt.V4=31;let so=class{constructor(t,n){this.jitterX=0,this.jitterY=0,this.jitterX=t,this.jitterY=n}begin(t){}transform(t,n,e,r){t.x+=T.randomTriangular(-this.jitterX,this.jitterY),t.y+=T.randomTriangular(-this.jitterX,this.jitterY)}end(){}};const Qr=class{constructor(t){this.centerX=0,this.centerY=0,this.radius=0,this.angle=0,this.worldX=0,this.worldY=0,this.radius=t}begin(t){this.worldX=t.x+this.centerX,this.worldY=t.y+this.centerY}transform(t,n,e,r){const i=this.angle*T.degreesToRadians,h=t.x-this.worldX,l=t.y-this.worldY,s=Math.sqrt(h*h+l*l);if(s<this.radius){const a=Qr.interpolation.apply(0,i,(this.radius-s)/this.radius),o=Math.cos(a),c=Math.sin(a);t.x=o*h-c*l+this.worldX,t.y=c*h+o*l+this.worldY}}end(){}};let Kr=Qr;Kr.interpolation=new Ss(2);let Vt=class{constructor(t,n,e){if(t==null)throw new Error("name cannot be null.");if(n==null)throw new Error("timelines cannot be null.");this.name=t,this.timelines=n,this.timelineIds=[];for(let r=0;r<n.length;r++)this.timelineIds[n[r].getPropertyId()]=!0;this.duration=e}hasTimeline(t){return this.timelineIds[t]==!0}apply(t,n,e,r,i,h,l,s){if(t==null)throw new Error("skeleton cannot be null.");r&&this.duration!=0&&(e%=this.duration,n>0&&(n%=this.duration));const a=this.timelines;for(let o=0,c=a.length;o<c;o++)a[o].apply(t,n,e,i,h,l,s)}static binarySearch(t,n,e=1){let r=0,i=t.length/e-2;if(i==0)return e;let h=i>>>1;for(;;){if(t[(h+1)*e]<=n?r=h+1:i=h,r==i)return(r+1)*e;h=r+i>>>1}}static linearSearch(t,n,e){for(let r=0,i=t.length-e;r<=i;r+=e)if(t[r]>n)return r;return-1}};var Jr=(f=>(f[f.rotate=0]="rotate",f[f.translate=1]="translate",f[f.scale=2]="scale",f[f.shear=3]="shear",f[f.attachment=4]="attachment",f[f.color=5]="color",f[f.deform=6]="deform",f[f.event=7]="event",f[f.drawOrder=8]="drawOrder",f[f.ikConstraint=9]="ikConstraint",f[f.transformConstraint=10]="transformConstraint",f[f.pathConstraintPosition=11]="pathConstraintPosition",f[f.pathConstraintSpacing=12]="pathConstraintSpacing",f[f.pathConstraintMix=13]="pathConstraintMix",f[f.twoColor=14]="twoColor",f))(Jr||{});const Pt=class{constructor(t){if(t<=0)throw new Error(`frameCount must be > 0: ${t}`);this.curves=k.newFloatArray((t-1)*Pt.BEZIER_SIZE)}getFrameCount(){return this.curves.length/Pt.BEZIER_SIZE+1}setLinear(t){this.curves[t*Pt.BEZIER_SIZE]=Pt.LINEAR}setStepped(t){this.curves[t*Pt.BEZIER_SIZE]=Pt.STEPPED}getCurveType(t){const n=t*Pt.BEZIER_SIZE;if(n==this.curves.length)return Pt.LINEAR;const e=this.curves[n];return e==Pt.LINEAR?Pt.LINEAR:e==Pt.STEPPED?Pt.STEPPED:Pt.BEZIER}setCurve(t,n,e,r,i){const h=(-n*2+r)*.03,l=(-e*2+i)*.03,s=((n-r)*3+1)*.006,a=((e-i)*3+1)*.006;let o=h*2+s,c=l*2+a,d=n*.3+h+s*.16666667,u=e*.3+l+a*.16666667,m=t*Pt.BEZIER_SIZE;const g=this.curves;g[m++]=Pt.BEZIER;let x=d,w=u;for(let b=m+Pt.BEZIER_SIZE-1;m<b;m+=2)g[m]=x,g[m+1]=w,d+=o,u+=c,o+=s,c+=a,x+=d,w+=u}getCurvePercent(t,n){n=T.clamp(n,0,1);const e=this.curves;let r=t*Pt.BEZIER_SIZE;const i=e[r];if(i==Pt.LINEAR)return n;if(i==Pt.STEPPED)return 0;r++;let h=0;for(let s=r,a=r+Pt.BEZIER_SIZE-1;r<a;r+=2)if(h=e[r],h>=n){let o,c;return r==s?(o=0,c=0):(o=e[r-2],c=e[r-1]),c+(e[r+1]-c)*(n-o)/(h-o)}const l=e[r-1];return l+(1-l)*(n-h)/(1-h)}};let Ee=Pt;Ee.LINEAR=0,Ee.STEPPED=1,Ee.BEZIER=2,Ee.BEZIER_SIZE=10*2-1;const Rn=class extends Ee{constructor(t){super(t),this.frames=k.newFloatArray(t<<1)}getPropertyId(){return(0<<24)+this.boneIndex}setFrame(t,n,e){t<<=1,this.frames[t]=n,this.frames[t+Rn.ROTATION]=e}apply(t,n,e,r,i,h,l){const s=this.frames,a=t.bones[this.boneIndex];if(!a.active)return;if(e<s[0]){switch(h){case A.setup:a.rotation=a.data.rotation;return;case A.first:const g=a.data.rotation-a.rotation;a.rotation+=(g-(16384-(16384.499999999996-g/360|0))*360)*i}return}if(e>=s[s.length-Rn.ENTRIES]){let g=s[s.length+Rn.PREV_ROTATION];switch(h){case A.setup:a.rotation=a.data.rotation+g*i;break;case A.first:case A.replace:g+=a.data.rotation-a.rotation,g-=(16384-(16384.499999999996-g/360|0))*360;case A.add:a.rotation+=g*i}return}const o=Vt.binarySearch(s,e,Rn.ENTRIES),c=s[o+Rn.PREV_ROTATION],d=s[o],u=this.getCurvePercent((o>>1)-1,1-(e-d)/(s[o+Rn.PREV_TIME]-d));let m=s[o+Rn.ROTATION]-c;switch(m=c+(m-(16384-(16384.499999999996-m/360|0))*360)*u,h){case A.setup:a.rotation=a.data.rotation+(m-(16384-(16384.499999999996-m/360|0))*360)*i;break;case A.first:case A.replace:m+=a.data.rotation-a.rotation;case A.add:a.rotation+=(m-(16384-(16384.499999999996-m/360|0))*360)*i}}};let Kt=Rn;Kt.ENTRIES=2,Kt.PREV_TIME=-2,Kt.PREV_ROTATION=-1,Kt.ROTATION=1;const he=class extends Ee{constructor(t){super(t),this.frames=k.newFloatArray(t*he.ENTRIES)}getPropertyId(){return(1<<24)+this.boneIndex}setFrame(t,n,e,r){t*=he.ENTRIES,this.frames[t]=n,this.frames[t+he.X]=e,this.frames[t+he.Y]=r}apply(t,n,e,r,i,h,l){const s=this.frames,a=t.bones[this.boneIndex];if(!a.active)return;if(e<s[0]){switch(h){case A.setup:a.x=a.data.x,a.y=a.data.y;return;case A.first:a.x+=(a.data.x-a.x)*i,a.y+=(a.data.y-a.y)*i}return}let o=0,c=0;if(e>=s[s.length-he.ENTRIES])o=s[s.length+he.PREV_X],c=s[s.length+he.PREV_Y];else{const d=Vt.binarySearch(s,e,he.ENTRIES);o=s[d+he.PREV_X],c=s[d+he.PREV_Y];const u=s[d],m=this.getCurvePercent(d/he.ENTRIES-1,1-(e-u)/(s[d+he.PREV_TIME]-u));o+=(s[d+he.X]-o)*m,c+=(s[d+he.Y]-c)*m}switch(h){case A.setup:a.x=a.data.x+o*i,a.y=a.data.y+c*i;break;case A.first:case A.replace:a.x+=(a.data.x+o-a.x)*i,a.y+=(a.data.y+c-a.y)*i;break;case A.add:a.x+=o*i,a.y+=c*i}}};let Pe=he;Pe.ENTRIES=3,Pe.PREV_TIME=-3,Pe.PREV_X=-2,Pe.PREV_Y=-1,Pe.X=1,Pe.Y=2;let Fe=class extends Pe{constructor(t){super(t)}getPropertyId(){return(2<<24)+this.boneIndex}apply(t,n,e,r,i,h,l){const s=this.frames,a=t.bones[this.boneIndex];if(!a.active)return;if(e<s[0]){switch(h){case A.setup:a.scaleX=a.data.scaleX,a.scaleY=a.data.scaleY;return;case A.first:a.scaleX+=(a.data.scaleX-a.scaleX)*i,a.scaleY+=(a.data.scaleY-a.scaleY)*i}return}let o=0,c=0;if(e>=s[s.length-Fe.ENTRIES])o=s[s.length+Fe.PREV_X]*a.data.scaleX,c=s[s.length+Fe.PREV_Y]*a.data.scaleY;else{const d=Vt.binarySearch(s,e,Fe.ENTRIES);o=s[d+Fe.PREV_X],c=s[d+Fe.PREV_Y];const u=s[d],m=this.getCurvePercent(d/Fe.ENTRIES-1,1-(e-u)/(s[d+Fe.PREV_TIME]-u));o=(o+(s[d+Fe.X]-o)*m)*a.data.scaleX,c=(c+(s[d+Fe.Y]-c)*m)*a.data.scaleY}if(i==1)h==A.add?(a.scaleX+=o-a.data.scaleX,a.scaleY+=c-a.data.scaleY):(a.scaleX=o,a.scaleY=c);else{let d=0,u=0;if(l==Q.mixOut)switch(h){case A.setup:d=a.data.scaleX,u=a.data.scaleY,a.scaleX=d+(Math.abs(o)*T.signum(d)-d)*i,a.scaleY=u+(Math.abs(c)*T.signum(u)-u)*i;break;case A.first:case A.replace:d=a.scaleX,u=a.scaleY,a.scaleX=d+(Math.abs(o)*T.signum(d)-d)*i,a.scaleY=u+(Math.abs(c)*T.signum(u)-u)*i;break;case A.add:d=a.scaleX,u=a.scaleY,a.scaleX=d+(Math.abs(o)*T.signum(d)-a.data.scaleX)*i,a.scaleY=u+(Math.abs(c)*T.signum(u)-a.data.scaleY)*i}else switch(h){case A.setup:d=Math.abs(a.data.scaleX)*T.signum(o),u=Math.abs(a.data.scaleY)*T.signum(c),a.scaleX=d+(o-d)*i,a.scaleY=u+(c-u)*i;break;case A.first:case A.replace:d=Math.abs(a.scaleX)*T.signum(o),u=Math.abs(a.scaleY)*T.signum(c),a.scaleX=d+(o-d)*i,a.scaleY=u+(c-u)*i;break;case A.add:d=T.signum(o),u=T.signum(c),a.scaleX=Math.abs(a.scaleX)*d+(o-Math.abs(a.data.scaleX)*d)*i,a.scaleY=Math.abs(a.scaleY)*u+(c-Math.abs(a.data.scaleY)*u)*i}}}},Ye=class extends Pe{constructor(t){super(t)}getPropertyId(){return(3<<24)+this.boneIndex}apply(t,n,e,r,i,h,l){const s=this.frames,a=t.bones[this.boneIndex];if(!a.active)return;if(e<s[0]){switch(h){case A.setup:a.shearX=a.data.shearX,a.shearY=a.data.shearY;return;case A.first:a.shearX+=(a.data.shearX-a.shearX)*i,a.shearY+=(a.data.shearY-a.shearY)*i}return}let o=0,c=0;if(e>=s[s.length-Ye.ENTRIES])o=s[s.length+Ye.PREV_X],c=s[s.length+Ye.PREV_Y];else{const d=Vt.binarySearch(s,e,Ye.ENTRIES);o=s[d+Ye.PREV_X],c=s[d+Ye.PREV_Y];const u=s[d],m=this.getCurvePercent(d/Ye.ENTRIES-1,1-(e-u)/(s[d+Ye.PREV_TIME]-u));o=o+(s[d+Ye.X]-o)*m,c=c+(s[d+Ye.Y]-c)*m}switch(h){case A.setup:a.shearX=a.data.shearX+o*i,a.shearY=a.data.shearY+c*i;break;case A.first:case A.replace:a.shearX+=(a.data.shearX+o-a.shearX)*i,a.shearY+=(a.data.shearY+c-a.shearY)*i;break;case A.add:a.shearX+=o*i,a.shearY+=c*i}}};const bt=class extends Ee{constructor(t){super(t),this.frames=k.newFloatArray(t*bt.ENTRIES)}getPropertyId(){return(5<<24)+this.slotIndex}setFrame(t,n,e,r,i,h){t*=bt.ENTRIES,this.frames[t]=n,this.frames[t+bt.R]=e,this.frames[t+bt.G]=r,this.frames[t+bt.B]=i,this.frames[t+bt.A]=h}apply(t,n,e,r,i,h,l){const s=t.slots[this.slotIndex];if(!s.bone.active)return;const a=this.frames;if(e<a[0]){switch(h){case A.setup:s.color.setFromColor(s.data.color);return;case A.first:const m=s.color,g=s.data.color;m.add((g.r-m.r)*i,(g.g-m.g)*i,(g.b-m.b)*i,(g.a-m.a)*i)}return}let o=0,c=0,d=0,u=0;if(e>=a[a.length-bt.ENTRIES]){const m=a.length;o=a[m+bt.PREV_R],c=a[m+bt.PREV_G],d=a[m+bt.PREV_B],u=a[m+bt.PREV_A]}else{const m=Vt.binarySearch(a,e,bt.ENTRIES);o=a[m+bt.PREV_R],c=a[m+bt.PREV_G],d=a[m+bt.PREV_B],u=a[m+bt.PREV_A];const g=a[m],x=this.getCurvePercent(m/bt.ENTRIES-1,1-(e-g)/(a[m+bt.PREV_TIME]-g));o+=(a[m+bt.R]-o)*x,c+=(a[m+bt.G]-c)*x,d+=(a[m+bt.B]-d)*x,u+=(a[m+bt.A]-u)*x}if(i==1)s.color.set(o,c,d,u);else{const m=s.color;h==A.setup&&m.setFromColor(s.data.color),m.add((o-m.r)*i,(c-m.g)*i,(d-m.b)*i,(u-m.a)*i)}}};let de=bt;de.ENTRIES=5,de.PREV_TIME=-5,de.PREV_R=-4,de.PREV_G=-3,de.PREV_B=-2,de.PREV_A=-1,de.R=1,de.G=2,de.B=3,de.A=4;const at=class extends Ee{constructor(t){super(t),this.frames=k.newFloatArray(t*at.ENTRIES)}getPropertyId(){return(14<<24)+this.slotIndex}setFrame(t,n,e,r,i,h,l,s,a){t*=at.ENTRIES,this.frames[t]=n,this.frames[t+at.R]=e,this.frames[t+at.G]=r,this.frames[t+at.B]=i,this.frames[t+at.A]=h,this.frames[t+at.R2]=l,this.frames[t+at.G2]=s,this.frames[t+at.B2]=a}apply(t,n,e,r,i,h,l){const s=t.slots[this.slotIndex];if(!s.bone.active)return;const a=this.frames;if(e<a[0]){switch(h){case A.setup:s.color.setFromColor(s.data.color),s.darkColor.setFromColor(s.data.darkColor);return;case A.first:const w=s.color,b=s.darkColor,E=s.data.color,p=s.data.darkColor;w.add((E.r-w.r)*i,(E.g-w.g)*i,(E.b-w.b)*i,(E.a-w.a)*i),b.add((p.r-b.r)*i,(p.g-b.g)*i,(p.b-b.b)*i,0)}return}let o=0,c=0,d=0,u=0,m=0,g=0,x=0;if(e>=a[a.length-at.ENTRIES]){const w=a.length;o=a[w+at.PREV_R],c=a[w+at.PREV_G],d=a[w+at.PREV_B],u=a[w+at.PREV_A],m=a[w+at.PREV_R2],g=a[w+at.PREV_G2],x=a[w+at.PREV_B2]}else{const w=Vt.binarySearch(a,e,at.ENTRIES);o=a[w+at.PREV_R],c=a[w+at.PREV_G],d=a[w+at.PREV_B],u=a[w+at.PREV_A],m=a[w+at.PREV_R2],g=a[w+at.PREV_G2],x=a[w+at.PREV_B2];const b=a[w],E=this.getCurvePercent(w/at.ENTRIES-1,1-(e-b)/(a[w+at.PREV_TIME]-b));o+=(a[w+at.R]-o)*E,c+=(a[w+at.G]-c)*E,d+=(a[w+at.B]-d)*E,u+=(a[w+at.A]-u)*E,m+=(a[w+at.R2]-m)*E,g+=(a[w+at.G2]-g)*E,x+=(a[w+at.B2]-x)*E}if(i==1)s.color.set(o,c,d,u),s.darkColor.set(m,g,x,1);else{const w=s.color,b=s.darkColor;h==A.setup&&(w.setFromColor(s.data.color),b.setFromColor(s.data.darkColor)),w.add((o-w.r)*i,(c-w.g)*i,(d-w.b)*i,(u-w.a)*i),b.add((m-b.r)*i,(g-b.g)*i,(x-b.b)*i,0)}}};let Ft=at;Ft.ENTRIES=8,Ft.PREV_TIME=-8,Ft.PREV_R=-7,Ft.PREV_G=-6,Ft.PREV_B=-5,Ft.PREV_A=-4,Ft.PREV_R2=-3,Ft.PREV_G2=-2,Ft.PREV_B2=-1,Ft.R=1,Ft.G=2,Ft.B=3,Ft.A=4,Ft.R2=5,Ft.G2=6,Ft.B2=7;let Bn=class{constructor(t){this.frames=k.newFloatArray(t),this.attachmentNames=new Array(t)}getPropertyId(){return(4<<24)+this.slotIndex}getFrameCount(){return this.frames.length}setFrame(t,n,e){this.frames[t]=n,this.attachmentNames[t]=e}apply(t,n,e,r,i,h,l){const s=t.slots[this.slotIndex];if(!s.bone.active)return;if(l==Q.mixOut){h==A.setup&&this.setAttachment(t,s,s.data.attachmentName);return}const a=this.frames;if(e<a[0]){(h==A.setup||h==A.first)&&this.setAttachment(t,s,s.data.attachmentName);return}let o=0;e>=a[a.length-1]?o=a.length-1:o=Vt.binarySearch(a,e,1)-1;const c=this.attachmentNames[o];t.slots[this.slotIndex].setAttachment(c==null?null:t.getAttachment(this.slotIndex,c))}setAttachment(t,n,e){n.setAttachment(e==null?null:t.getAttachment(this.slotIndex,e))}},ta=null,Ei=class extends Ee{constructor(t){super(t),this.frames=k.newFloatArray(t),this.frameVertices=new Array(t),ta==null&&(ta=k.newFloatArray(64))}getPropertyId(){return(6<<27)+Number(this.attachment.id)+this.slotIndex}setFrame(t,n,e){this.frames[t]=n,this.frameVertices[t]=e}apply(t,n,e,r,i,h,l){const s=t.slots[this.slotIndex];if(!s.bone.active)return;const a=s.getAttachment();if(!(a instanceof In)||a.deformAttachment!=this.attachment)return;const o=s.deform;o.length==0&&(h=A.setup);const c=this.frameVertices,d=c[0].length,u=this.frames;if(e<u[0]){const p=a;switch(h){case A.setup:o.length=0;return;case A.first:if(i==1){o.length=0;break}const S=k.setArraySize(o,d);if(p.bones==null){const y=p.vertices;for(let M=0;M<d;M++)S[M]+=(y[M]-S[M])*i}else{i=1-i;for(let y=0;y<d;y++)S[y]*=i}}return}const m=k.setArraySize(o,d);if(e>=u[u.length-1]){const p=c[u.length-1];if(i==1)if(h==A.add){const S=a;if(S.bones==null){const y=S.vertices;for(let M=0;M<d;M++)m[M]+=p[M]-y[M]}else for(let y=0;y<d;y++)m[y]+=p[y]}else k.arrayCopy(p,0,m,0,d);else switch(h){case A.setup:{const y=a;if(y.bones==null){const M=y.vertices;for(let C=0;C<d;C++){const I=M[C];m[C]=I+(p[C]-I)*i}}else for(let M=0;M<d;M++)m[M]=p[M]*i;break}case A.first:case A.replace:for(let y=0;y<d;y++)m[y]+=(p[y]-m[y])*i;break;case A.add:const S=a;if(S.bones==null){const y=S.vertices;for(let M=0;M<d;M++)m[M]+=(p[M]-y[M])*i}else for(let y=0;y<d;y++)m[y]+=p[y]*i}return}const g=Vt.binarySearch(u,e),x=c[g-1],w=c[g],b=u[g],E=this.getCurvePercent(g-1,1-(e-b)/(u[g-1]-b));if(i==1)if(h==A.add){const p=a;if(p.bones==null){const S=p.vertices;for(let y=0;y<d;y++){const M=x[y];m[y]+=M+(w[y]-M)*E-S[y]}}else for(let S=0;S<d;S++){const y=x[S];m[S]+=y+(w[S]-y)*E}}else for(let p=0;p<d;p++){const S=x[p];m[p]=S+(w[p]-S)*E}else switch(h){case A.setup:{const S=a;if(S.bones==null){const y=S.vertices;for(let M=0;M<d;M++){const C=x[M],I=y[M];m[M]=I+(C+(w[M]-C)*E-I)*i}}else for(let y=0;y<d;y++){const M=x[y];m[y]=(M+(w[y]-M)*E)*i}break}case A.first:case A.replace:for(let S=0;S<d;S++){const y=x[S];m[S]+=(y+(w[S]-y)*E-m[S])*i}break;case A.add:const p=a;if(p.bones==null){const S=p.vertices;for(let y=0;y<d;y++){const M=x[y];m[y]+=(M+(w[y]-M)*E-S[y])*i}}else for(let S=0;S<d;S++){const y=x[S];m[S]+=(y+(w[S]-y)*E)*i}}}},Cs=class{constructor(t){this.frames=k.newFloatArray(t),this.events=new Array(t)}getPropertyId(){return 7<<24}getFrameCount(){return this.frames.length}setFrame(t,n){this.frames[t]=n.time,this.events[t]=n}apply(t,n,e,r,i,h,l){if(r==null)return;const s=this.frames,a=this.frames.length;if(n>e)this.apply(t,n,Number.MAX_VALUE,r,i,h,l),n=-1;else if(n>=s[a-1])return;if(e<s[0])return;let o=0;if(n<s[0])o=0;else{o=Vt.binarySearch(s,n);const c=s[o];for(;o>0&&s[o-1]==c;)o--}for(;o<a&&e>=s[o];o++)r.push(this.events[o])}},is=class{constructor(t){this.frames=k.newFloatArray(t),this.drawOrders=new Array(t)}getPropertyId(){return 8<<24}getFrameCount(){return this.frames.length}setFrame(t,n,e){this.frames[t]=n,this.drawOrders[t]=e}apply(t,n,e,r,i,h,l){const s=t.drawOrder,a=t.slots;if(l==Q.mixOut&&h==A.setup){k.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}const o=this.frames;if(e<o[0]){(h==A.setup||h==A.first)&&k.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}let c=0;e>=o[o.length-1]?c=o.length-1:c=Vt.binarySearch(o,e)-1;const d=this.drawOrders[c];if(d==null)k.arrayCopy(a,0,s,0,a.length);else for(let u=0,m=d.length;u<m;u++)s[u]=a[d[u]]}};const ht=class extends Ee{constructor(t){super(t),this.frames=k.newFloatArray(t*ht.ENTRIES)}getPropertyId(){return(9<<24)+this.ikConstraintIndex}setFrame(t,n,e,r,i,h,l){t*=ht.ENTRIES,this.frames[t]=n,this.frames[t+ht.MIX]=e,this.frames[t+ht.SOFTNESS]=r,this.frames[t+ht.BEND_DIRECTION]=i,this.frames[t+ht.COMPRESS]=h?1:0,this.frames[t+ht.STRETCH]=l?1:0}apply(t,n,e,r,i,h,l){const s=this.frames,a=t.ikConstraints[this.ikConstraintIndex];if(!a.active)return;if(e<s[0]){switch(h){case A.setup:a.mix=a.data.mix,a.softness=a.data.softness,a.bendDirection=a.data.bendDirection,a.compress=a.data.compress,a.stretch=a.data.stretch;return;case A.first:a.mix+=(a.data.mix-a.mix)*i,a.softness+=(a.data.softness-a.softness)*i,a.bendDirection=a.data.bendDirection,a.compress=a.data.compress,a.stretch=a.data.stretch}return}if(e>=s[s.length-ht.ENTRIES]){h==A.setup?(a.mix=a.data.mix+(s[s.length+ht.PREV_MIX]-a.data.mix)*i,a.softness=a.data.softness+(s[s.length+ht.PREV_SOFTNESS]-a.data.softness)*i,l==Q.mixOut?(a.bendDirection=a.data.bendDirection,a.compress=a.data.compress,a.stretch=a.data.stretch):(a.bendDirection=s[s.length+ht.PREV_BEND_DIRECTION],a.compress=s[s.length+ht.PREV_COMPRESS]!=0,a.stretch=s[s.length+ht.PREV_STRETCH]!=0)):(a.mix+=(s[s.length+ht.PREV_MIX]-a.mix)*i,a.softness+=(s[s.length+ht.PREV_SOFTNESS]-a.softness)*i,l==Q.mixIn&&(a.bendDirection=s[s.length+ht.PREV_BEND_DIRECTION],a.compress=s[s.length+ht.PREV_COMPRESS]!=0,a.stretch=s[s.length+ht.PREV_STRETCH]!=0));return}const o=Vt.binarySearch(s,e,ht.ENTRIES),c=s[o+ht.PREV_MIX],d=s[o+ht.PREV_SOFTNESS],u=s[o],m=this.getCurvePercent(o/ht.ENTRIES-1,1-(e-u)/(s[o+ht.PREV_TIME]-u));h==A.setup?(a.mix=a.data.mix+(c+(s[o+ht.MIX]-c)*m-a.data.mix)*i,a.softness=a.data.softness+(d+(s[o+ht.SOFTNESS]-d)*m-a.data.softness)*i,l==Q.mixOut?(a.bendDirection=a.data.bendDirection,a.compress=a.data.compress,a.stretch=a.data.stretch):(a.bendDirection=s[o+ht.PREV_BEND_DIRECTION],a.compress=s[o+ht.PREV_COMPRESS]!=0,a.stretch=s[o+ht.PREV_STRETCH]!=0)):(a.mix+=(c+(s[o+ht.MIX]-c)*m-a.mix)*i,a.softness+=(d+(s[o+ht.SOFTNESS]-d)*m-a.softness)*i,l==Q.mixIn&&(a.bendDirection=s[o+ht.PREV_BEND_DIRECTION],a.compress=s[o+ht.PREV_COMPRESS]!=0,a.stretch=s[o+ht.PREV_STRETCH]!=0))}};let Jt=ht;Jt.ENTRIES=6,Jt.PREV_TIME=-6,Jt.PREV_MIX=-5,Jt.PREV_SOFTNESS=-4,Jt.PREV_BEND_DIRECTION=-3,Jt.PREV_COMPRESS=-2,Jt.PREV_STRETCH=-1,Jt.MIX=1,Jt.SOFTNESS=2,Jt.BEND_DIRECTION=3,Jt.COMPRESS=4,Jt.STRETCH=5;const Et=class extends Ee{constructor(t){super(t),this.frames=k.newFloatArray(t*Et.ENTRIES)}getPropertyId(){return(10<<24)+this.transformConstraintIndex}setFrame(t,n,e,r,i,h){t*=Et.ENTRIES,this.frames[t]=n,this.frames[t+Et.ROTATE]=e,this.frames[t+Et.TRANSLATE]=r,this.frames[t+Et.SCALE]=i,this.frames[t+Et.SHEAR]=h}apply(t,n,e,r,i,h,l){const s=this.frames,a=t.transformConstraints[this.transformConstraintIndex];if(!a.active)return;if(e<s[0]){const m=a.data;switch(h){case A.setup:a.rotateMix=m.rotateMix,a.translateMix=m.translateMix,a.scaleMix=m.scaleMix,a.shearMix=m.shearMix;return;case A.first:a.rotateMix+=(m.rotateMix-a.rotateMix)*i,a.translateMix+=(m.translateMix-a.translateMix)*i,a.scaleMix+=(m.scaleMix-a.scaleMix)*i,a.shearMix+=(m.shearMix-a.shearMix)*i}return}let o=0,c=0,d=0,u=0;if(e>=s[s.length-Et.ENTRIES]){const m=s.length;o=s[m+Et.PREV_ROTATE],c=s[m+Et.PREV_TRANSLATE],d=s[m+Et.PREV_SCALE],u=s[m+Et.PREV_SHEAR]}else{const m=Vt.binarySearch(s,e,Et.ENTRIES);o=s[m+Et.PREV_ROTATE],c=s[m+Et.PREV_TRANSLATE],d=s[m+Et.PREV_SCALE],u=s[m+Et.PREV_SHEAR];const g=s[m],x=this.getCurvePercent(m/Et.ENTRIES-1,1-(e-g)/(s[m+Et.PREV_TIME]-g));o+=(s[m+Et.ROTATE]-o)*x,c+=(s[m+Et.TRANSLATE]-c)*x,d+=(s[m+Et.SCALE]-d)*x,u+=(s[m+Et.SHEAR]-u)*x}if(h==A.setup){const m=a.data;a.rotateMix=m.rotateMix+(o-m.rotateMix)*i,a.translateMix=m.translateMix+(c-m.translateMix)*i,a.scaleMix=m.scaleMix+(d-m.scaleMix)*i,a.shearMix=m.shearMix+(u-m.shearMix)*i}else a.rotateMix+=(o-a.rotateMix)*i,a.translateMix+=(c-a.translateMix)*i,a.scaleMix+=(d-a.scaleMix)*i,a.shearMix+=(u-a.shearMix)*i}};let fe=Et;fe.ENTRIES=5,fe.PREV_TIME=-5,fe.PREV_ROTATE=-4,fe.PREV_TRANSLATE=-3,fe.PREV_SCALE=-2,fe.PREV_SHEAR=-1,fe.ROTATE=1,fe.TRANSLATE=2,fe.SCALE=3,fe.SHEAR=4;const Ge=class extends Ee{constructor(t){super(t),this.frames=k.newFloatArray(t*Ge.ENTRIES)}getPropertyId(){return(11<<24)+this.pathConstraintIndex}setFrame(t,n,e){t*=Ge.ENTRIES,this.frames[t]=n,this.frames[t+Ge.VALUE]=e}apply(t,n,e,r,i,h,l){const s=this.frames,a=t.pathConstraints[this.pathConstraintIndex];if(!a.active)return;if(e<s[0]){switch(h){case A.setup:a.position=a.data.position;return;case A.first:a.position+=(a.data.position-a.position)*i}return}let o=0;if(e>=s[s.length-Ge.ENTRIES])o=s[s.length+Ge.PREV_VALUE];else{const c=Vt.binarySearch(s,e,Ge.ENTRIES);o=s[c+Ge.PREV_VALUE];const d=s[c],u=this.getCurvePercent(c/Ge.ENTRIES-1,1-(e-d)/(s[c+Ge.PREV_TIME]-d));o+=(s[c+Ge.VALUE]-o)*u}h==A.setup?a.position=a.data.position+(o-a.data.position)*i:a.position+=(o-a.position)*i}};let ln=Ge;ln.ENTRIES=2,ln.PREV_TIME=-2,ln.PREV_VALUE=-1,ln.VALUE=1;let cn=class extends ln{constructor(t){super(t)}getPropertyId(){return(12<<24)+this.pathConstraintIndex}apply(t,n,e,r,i,h,l){const s=this.frames,a=t.pathConstraints[this.pathConstraintIndex];if(!a.active)return;if(e<s[0]){switch(h){case A.setup:a.spacing=a.data.spacing;return;case A.first:a.spacing+=(a.data.spacing-a.spacing)*i}return}let o=0;if(e>=s[s.length-cn.ENTRIES])o=s[s.length+cn.PREV_VALUE];else{const c=Vt.binarySearch(s,e,cn.ENTRIES);o=s[c+cn.PREV_VALUE];const d=s[c],u=this.getCurvePercent(c/cn.ENTRIES-1,1-(e-d)/(s[c+cn.PREV_TIME]-d));o+=(s[c+cn.VALUE]-o)*u}h==A.setup?a.spacing=a.data.spacing+(o-a.data.spacing)*i:a.spacing+=(o-a.spacing)*i}};const ue=class extends Ee{constructor(t){super(t),this.frames=k.newFloatArray(t*ue.ENTRIES)}getPropertyId(){return(13<<24)+this.pathConstraintIndex}setFrame(t,n,e,r){t*=ue.ENTRIES,this.frames[t]=n,this.frames[t+ue.ROTATE]=e,this.frames[t+ue.TRANSLATE]=r}apply(t,n,e,r,i,h,l){const s=this.frames,a=t.pathConstraints[this.pathConstraintIndex];if(!a.active)return;if(e<s[0]){switch(h){case A.setup:a.rotateMix=a.data.rotateMix,a.translateMix=a.data.translateMix;return;case A.first:a.rotateMix+=(a.data.rotateMix-a.rotateMix)*i,a.translateMix+=(a.data.translateMix-a.translateMix)*i}return}let o=0,c=0;if(e>=s[s.length-ue.ENTRIES])o=s[s.length+ue.PREV_ROTATE],c=s[s.length+ue.PREV_TRANSLATE];else{const d=Vt.binarySearch(s,e,ue.ENTRIES);o=s[d+ue.PREV_ROTATE],c=s[d+ue.PREV_TRANSLATE];const u=s[d],m=this.getCurvePercent(d/ue.ENTRIES-1,1-(e-u)/(s[d+ue.PREV_TIME]-u));o+=(s[d+ue.ROTATE]-o)*m,c+=(s[d+ue.TRANSLATE]-c)*m}h==A.setup?(a.rotateMix=a.data.rotateMix+(o-a.data.rotateMix)*i,a.translateMix=a.data.translateMix+(c-a.data.translateMix)*i):(a.rotateMix+=(o-a.rotateMix)*i,a.translateMix+=(c-a.translateMix)*i)}};let je=ue;je.ENTRIES=3,je.PREV_TIME=-3,je.PREV_ROTATE=-2,je.PREV_TRANSLATE=-1,je.ROTATE=1,je.TRANSLATE=2;const St=class{constructor(t){this.tracks=new Array,this.timeScale=1,this.unkeyedState=0,this.events=new Array,this.listeners=new Array,this.queue=new yi(this),this.propertyIDs=new Es,this.animationsChanged=!1,this.trackEntryPool=new Zn(()=>new Is),this.data=t}update(t){t*=this.timeScale;const n=this.tracks;for(let e=0,r=n.length;e<r;e++){const i=n[e];if(i==null)continue;i.animationLast=i.nextAnimationLast,i.trackLast=i.nextTrackLast;let h=t*i.timeScale;if(i.delay>0){if(i.delay-=h,i.delay>0)continue;h=-i.delay,i.delay=0}let l=i.next;if(l!=null){const s=i.trackLast-l.delay;if(s>=0){for(l.delay=0,l.trackTime+=i.timeScale==0?0:(s/i.timeScale+t)*l.timeScale,i.trackTime+=h,this.setCurrent(e,l,!0);l.mixingFrom!=null;)l.mixTime+=t,l=l.mixingFrom;continue}}else if(i.trackLast>=i.trackEnd&&i.mixingFrom==null){n[e]=null,this.queue.end(i),this.disposeNext(i);continue}if(i.mixingFrom!=null&&this.updateMixingFrom(i,t)){let s=i.mixingFrom;for(i.mixingFrom=null,s!=null&&(s.mixingTo=null);s!=null;)this.queue.end(s),s=s.mixingFrom}i.trackTime+=h}this.queue.drain()}updateMixingFrom(t,n){const e=t.mixingFrom;if(e==null)return!0;const r=this.updateMixingFrom(e,n);return e.animationLast=e.nextAnimationLast,e.trackLast=e.nextTrackLast,t.mixTime>0&&t.mixTime>=t.mixDuration?((e.totalAlpha==0||t.mixDuration==0)&&(t.mixingFrom=e.mixingFrom,e.mixingFrom!=null&&(e.mixingFrom.mixingTo=t),t.interruptAlpha=e.interruptAlpha,this.queue.end(e)),r):(e.trackTime+=n*e.timeScale,t.mixTime+=n,!1)}apply(t){if(t==null)throw new Error("skeleton cannot be null.");this.animationsChanged&&this._animationsChanged();const n=this.events,e=this.tracks;let r=!1;for(let l=0,s=e.length;l<s;l++){const a=e[l];if(a==null||a.delay>0)continue;r=!0;const o=l==0?A.first:a.mixBlend;let c=a.alpha;a.mixingFrom!=null?c*=this.applyMixingFrom(a,t,o):a.trackTime>=a.trackEnd&&a.next==null&&(c=0);const d=a.animationLast,u=a.getAnimationTime(),m=a.animation.timelines.length,g=a.animation.timelines;if(l==0&&c==1||o==A.add)for(let x=0;x<m;x++){k.webkit602BugfixHelper(c,o);const w=g[x];w instanceof Bn?this.applyAttachmentTimeline(w,t,u,o,!0):w.apply(t,d,u,n,c,o,Q.mixIn)}else{const x=a.timelineMode,w=a.timelinesRotation.length==0;w&&k.setArraySize(a.timelinesRotation,m<<1,null);const b=a.timelinesRotation;for(let E=0;E<m;E++){const p=g[E],S=x[E]==St.SUBSEQUENT?o:A.setup;p instanceof Kt?this.applyRotateTimeline(p,t,u,c,S,b,E<<1,w):p instanceof Bn?this.applyAttachmentTimeline(p,t,u,o,!0):(k.webkit602BugfixHelper(c,o),p.apply(t,d,u,n,c,S,Q.mixIn))}}this.queueEvents(a,u),n.length=0,a.nextAnimationLast=u,a.nextTrackLast=a.trackTime}const i=this.unkeyedState+St.SETUP,h=t.slots;for(let l=0,s=t.slots.length;l<s;l++){const a=h[l];if(a.attachmentState==i){const o=a.data.attachmentName;a.setAttachment(o==null?null:t.getAttachment(a.data.index,o))}}return this.unkeyedState+=2,this.queue.drain(),r}applyMixingFrom(t,n,e){const r=t.mixingFrom;r.mixingFrom!=null&&this.applyMixingFrom(r,n,e);let i=0;t.mixDuration==0?(i=1,e==A.first&&(e=A.setup)):(i=t.mixTime/t.mixDuration,i>1&&(i=1),e!=A.first&&(e=r.mixBlend));const h=i<r.eventThreshold?this.events:null,l=i<r.attachmentThreshold,s=i<r.drawOrderThreshold,a=r.animationLast,o=r.getAnimationTime(),c=r.animation.timelines.length,d=r.animation.timelines,u=r.alpha*t.interruptAlpha,m=u*(1-i);if(e==A.add)for(let g=0;g<c;g++)d[g].apply(n,a,o,h,m,e,Q.mixOut);else{const g=r.timelineMode,x=r.timelineHoldMix,w=r.timelinesRotation.length==0;w&&k.setArraySize(r.timelinesRotation,c<<1,null);const b=r.timelinesRotation;r.totalAlpha=0;for(let E=0;E<c;E++){const p=d[E];let S=Q.mixOut,y,M=0;switch(g[E]){case St.SUBSEQUENT:if(!s&&p instanceof is)continue;y=e,M=m;break;case St.FIRST:y=A.setup,M=m;break;case St.HOLD_SUBSEQUENT:y=e,M=u;break;case St.HOLD_FIRST:y=A.setup,M=u;break;default:y=A.setup;const C=x[E];M=u*Math.max(0,1-C.mixTime/C.mixDuration);break}r.totalAlpha+=M,p instanceof Kt?this.applyRotateTimeline(p,n,o,M,y,b,E<<1,w):p instanceof Bn?this.applyAttachmentTimeline(p,n,o,y,l):(k.webkit602BugfixHelper(M,e),s&&p instanceof is&&y==A.setup&&(S=Q.mixIn),p.apply(n,a,o,h,M,y,S))}}return t.mixDuration>0&&this.queueEvents(r,o),this.events.length=0,r.nextAnimationLast=o,r.nextTrackLast=r.trackTime,i}applyAttachmentTimeline(t,n,e,r,i){const h=n.slots[t.slotIndex];if(!h.bone.active)return;const l=t.frames;if(e<l[0])(r==A.setup||r==A.first)&&this.setAttachment(n,h,h.data.attachmentName,i);else{let s;e>=l[l.length-1]?s=l.length-1:s=Vt.binarySearch(l,e)-1,this.setAttachment(n,h,t.attachmentNames[s],i)}h.attachmentState<=this.unkeyedState&&(h.attachmentState=this.unkeyedState+St.SETUP)}setAttachment(t,n,e,r){n.setAttachment(e==null?null:t.getAttachment(n.data.index,e)),r&&(n.attachmentState=this.unkeyedState+St.CURRENT)}applyRotateTimeline(t,n,e,r,i,h,l,s){if(s&&(h[l]=0),r==1){t.apply(n,0,e,null,1,i,Q.mixIn);return}const a=t,o=a.frames,c=n.bones[a.boneIndex];if(!c.active)return;let d=0,u=0;if(e<o[0])switch(i){case A.setup:c.rotation=c.data.rotation;default:return;case A.first:d=c.rotation,u=c.data.rotation}else if(d=i==A.setup?c.data.rotation:c.rotation,e>=o[o.length-Kt.ENTRIES])u=c.data.rotation+o[o.length+Kt.PREV_ROTATION];else{const x=Vt.binarySearch(o,e,Kt.ENTRIES),w=o[x+Kt.PREV_ROTATION],b=o[x],E=a.getCurvePercent((x>>1)-1,1-(e-b)/(o[x+Kt.PREV_TIME]-b));u=o[x+Kt.ROTATION]-w,u-=(16384-(16384.499999999996-u/360|0))*360,u=w+u*E+c.data.rotation,u-=(16384-(16384.499999999996-u/360|0))*360}let m=0,g=u-d;if(g-=(16384-(16384.499999999996-g/360|0))*360,g==0)m=h[l];else{let x=0,w=0;s?(x=0,w=g):(x=h[l],w=h[l+1]);const b=g>0;let E=x>=0;T.signum(w)!=T.signum(g)&&Math.abs(w)<=90&&(Math.abs(x)>180&&(x+=360*T.signum(x)),E=b),m=g+x-x%360,E!=b&&(m+=360*T.signum(x)),h[l]=m}h[l+1]=g,d+=m*r,c.rotation=d-(16384-(16384.499999999996-d/360|0))*360}queueEvents(t,n){const e=t.animationStart,r=t.animationEnd,i=r-e,h=t.trackLast%i,l=this.events;let s=0;const a=l.length;for(;s<a;s++){const c=l[s];if(c.time<h)break;c.time>r||this.queue.event(t,c)}let o=!1;for(t.loop?o=i==0||h>t.trackTime%i:o=n>=r&&t.animationLast<r,o&&this.queue.complete(t);s<a;s++)l[s].time<e||this.queue.event(t,l[s])}clearTracks(){const t=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let n=0,e=this.tracks.length;n<e;n++)this.clearTrack(n);this.tracks.length=0,this.queue.drainDisabled=t,this.queue.drain()}clearTrack(t){if(t>=this.tracks.length)return;const n=this.tracks[t];if(n==null)return;this.queue.end(n),this.disposeNext(n);let e=n;for(;;){const r=e.mixingFrom;if(r==null)break;this.queue.end(r),e.mixingFrom=null,e.mixingTo=null,e=r}this.tracks[n.trackIndex]=null,this.queue.drain()}setCurrent(t,n,e){const r=this.expandToIndex(t);this.tracks[t]=n,r!=null&&(e&&this.queue.interrupt(r),n.mixingFrom=r,r.mixingTo=n,n.mixTime=0,r.mixingFrom!=null&&r.mixDuration>0&&(n.interruptAlpha*=Math.min(1,r.mixTime/r.mixDuration)),r.timelinesRotation.length=0),this.queue.start(n)}setAnimation(t,n,e){const r=this.data.skeletonData.findAnimation(n);if(r==null)throw new Error(`Animation not found: ${n}`);return this.setAnimationWith(t,r,e)}setAnimationWith(t,n,e){if(n==null)throw new Error("animation cannot be null.");let r=!0,i=this.expandToIndex(t);i!=null&&(i.nextTrackLast==-1?(this.tracks[t]=i.mixingFrom,this.queue.interrupt(i),this.queue.end(i),this.disposeNext(i),i=i.mixingFrom,r=!1):this.disposeNext(i));const h=this.trackEntry(t,n,e,i);return this.setCurrent(t,h,r),this.queue.drain(),h}addAnimation(t,n,e,r){const i=this.data.skeletonData.findAnimation(n);if(i==null)throw new Error(`Animation not found: ${n}`);return this.addAnimationWith(t,i,e,r)}addAnimationWith(t,n,e,r){if(n==null)throw new Error("animation cannot be null.");let i=this.expandToIndex(t);if(i!=null)for(;i.next!=null;)i=i.next;const h=this.trackEntry(t,n,e,i);if(i==null)this.setCurrent(t,h,!0),this.queue.drain();else if(i.next=h,r<=0){const l=i.animationEnd-i.animationStart;l!=0?(i.loop?r+=l*(1+(i.trackTime/l|0)):r+=Math.max(l,i.trackTime),r-=this.data.getMix(i.animation,n)):r=i.trackTime}return h.delay=r,h}setEmptyAnimation(t,n){const e=this.setAnimationWith(t,St.emptyAnimation,!1);return e.mixDuration=n,e.trackEnd=n,e}addEmptyAnimation(t,n,e){e<=0&&(e-=n);const r=this.addAnimationWith(t,St.emptyAnimation,!1,e);return r.mixDuration=n,r.trackEnd=n,r}setEmptyAnimations(t){const n=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let e=0,r=this.tracks.length;e<r;e++){const i=this.tracks[e];i!=null&&this.setEmptyAnimation(i.trackIndex,t)}this.queue.drainDisabled=n,this.queue.drain()}expandToIndex(t){return t<this.tracks.length?this.tracks[t]:(k.ensureArrayCapacity(this.tracks,t+1,null),this.tracks.length=t+1,null)}trackEntry(t,n,e,r){const i=this.trackEntryPool.obtain();return i.trackIndex=t,i.animation=n,i.loop=e,i.holdPrevious=!1,i.eventThreshold=0,i.attachmentThreshold=0,i.drawOrderThreshold=0,i.animationStart=0,i.animationEnd=n.duration,i.animationLast=-1,i.nextAnimationLast=-1,i.delay=0,i.trackTime=0,i.trackLast=-1,i.nextTrackLast=-1,i.trackEnd=Number.MAX_VALUE,i.timeScale=1,i.alpha=1,i.interruptAlpha=1,i.mixTime=0,i.mixDuration=r==null?0:this.data.getMix(r.animation,n),i.mixBlend=A.replace,i}disposeNext(t){let n=t.next;for(;n!=null;)this.queue.dispose(n),n=n.next;t.next=null}_animationsChanged(){this.animationsChanged=!1,this.propertyIDs.clear();for(let t=0,n=this.tracks.length;t<n;t++){let e=this.tracks[t];if(e!=null){for(;e.mixingFrom!=null;)e=e.mixingFrom;do(e.mixingFrom==null||e.mixBlend!=A.add)&&this.computeHold(e),e=e.mixingTo;while(e!=null)}}}computeHold(t){const n=t.mixingTo,e=t.animation.timelines,r=t.animation.timelines.length,i=k.setArraySize(t.timelineMode,r);t.timelineHoldMix.length=0;const h=k.setArraySize(t.timelineHoldMix,r),l=this.propertyIDs;if(n!=null&&n.holdPrevious){for(let s=0;s<r;s++)i[s]=l.add(e[s].getPropertyId())?St.HOLD_FIRST:St.HOLD_SUBSEQUENT;return}t:for(let s=0;s<r;s++){const a=e[s],o=a.getPropertyId();if(!l.add(o))i[s]=St.SUBSEQUENT;else if(n==null||a instanceof Bn||a instanceof is||a instanceof Cs||!n.animation.hasTimeline(o))i[s]=St.FIRST;else{for(let c=n.mixingTo;c!=null;c=c.mixingTo)if(!c.animation.hasTimeline(o)){if(t.mixDuration>0){i[s]=St.HOLD_MIX,h[s]=c;continue t}break}i[s]=St.HOLD_FIRST}}}getCurrent(t){return t>=this.tracks.length?null:this.tracks[t]}addListener(t){if(t==null)throw new Error("listener cannot be null.");this.listeners.push(t)}removeListener(t){const n=this.listeners.indexOf(t);n>=0&&this.listeners.splice(n,1)}clearListeners(){this.listeners.length=0}clearListenerNotifications(){this.queue.clear()}setAnimationByName(t,n,e){St.deprecatedWarning1||(St.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.")),this.setAnimation(t,n,e)}addAnimationByName(t,n,e,r){St.deprecatedWarning2||(St.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.")),this.addAnimation(t,n,e,r)}hasAnimation(t){return this.data.skeletonData.findAnimation(t)!==null}hasAnimationByName(t){return St.deprecatedWarning3||(St.deprecatedWarning3=!0,console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.")),this.hasAnimation(t)}};let Ne=St;Ne.emptyAnimation=new Vt("<empty>",[],0),Ne.SUBSEQUENT=0,Ne.FIRST=1,Ne.HOLD_SUBSEQUENT=2,Ne.HOLD_FIRST=3,Ne.HOLD_MIX=4,Ne.SETUP=1,Ne.CURRENT=2,Ne.deprecatedWarning1=!1,Ne.deprecatedWarning2=!1,Ne.deprecatedWarning3=!1;const xn=class{constructor(){this.mixBlend=A.replace,this.timelineMode=new Array,this.timelineHoldMix=new Array,this.timelinesRotation=new Array}reset(){this.next=null,this.mixingFrom=null,this.mixingTo=null,this.animation=null,this.listener=null,this.timelineMode.length=0,this.timelineHoldMix.length=0,this.timelinesRotation.length=0}getAnimationTime(){if(this.loop){const t=this.animationEnd-this.animationStart;return t==0?this.animationStart:this.trackTime%t+this.animationStart}return Math.min(this.trackTime+this.animationStart,this.animationEnd)}setAnimationLast(t){this.animationLast=t,this.nextAnimationLast=t}isComplete(){return this.trackTime>=this.animationEnd-this.animationStart}resetRotationDirections(){this.timelinesRotation.length=0}get time(){return xn.deprecatedWarning1||(xn.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime}set time(t){xn.deprecatedWarning1||(xn.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime=t}get endTime(){return xn.deprecatedWarning2||(xn.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime}set endTime(t){xn.deprecatedWarning2||(xn.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime=t}loopsCount(){return Math.floor(this.trackTime/this.trackEnd)}};let Is=xn;Is.deprecatedWarning1=!1,Is.deprecatedWarning2=!1;const Si=class{constructor(t){this.objects=[],this.drainDisabled=!1,this.animState=t}start(t){this.objects.push(Se.start),this.objects.push(t),this.animState.animationsChanged=!0}interrupt(t){this.objects.push(Se.interrupt),this.objects.push(t)}end(t){this.objects.push(Se.end),this.objects.push(t),this.animState.animationsChanged=!0}dispose(t){this.objects.push(Se.dispose),this.objects.push(t)}complete(t){this.objects.push(Se.complete),this.objects.push(t)}event(t,n){this.objects.push(Se.event),this.objects.push(t),this.objects.push(n)}deprecateStuff(){return Si.deprecatedWarning1||(Si.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'")),!0}drain(){if(this.drainDisabled)return;this.drainDisabled=!0;const t=this.objects,n=this.animState.listeners;for(let e=0;e<t.length;e+=2){const r=t[e],i=t[e+1];switch(r){case Se.start:i.listener!=null&&i.listener.start&&i.listener.start(i);for(let s=0;s<n.length;s++)n[s].start&&n[s].start(i);i.onStart&&this.deprecateStuff()&&i.onStart(i.trackIndex),this.animState.onStart&&this.deprecateStuff()&&this.deprecateStuff&&this.animState.onStart(i.trackIndex);break;case Se.interrupt:i.listener!=null&&i.listener.interrupt&&i.listener.interrupt(i);for(let s=0;s<n.length;s++)n[s].interrupt&&n[s].interrupt(i);break;case Se.end:i.listener!=null&&i.listener.end&&i.listener.end(i);for(let s=0;s<n.length;s++)n[s].end&&n[s].end(i);i.onEnd&&this.deprecateStuff()&&i.onEnd(i.trackIndex),this.animState.onEnd&&this.deprecateStuff()&&this.animState.onEnd(i.trackIndex);case Se.dispose:i.listener!=null&&i.listener.dispose&&i.listener.dispose(i);for(let s=0;s<n.length;s++)n[s].dispose&&n[s].dispose(i);this.animState.trackEntryPool.free(i);break;case Se.complete:i.listener!=null&&i.listener.complete&&i.listener.complete(i);for(let s=0;s<n.length;s++)n[s].complete&&n[s].complete(i);const h=T.toInt(i.loopsCount());i.onComplete&&this.deprecateStuff()&&i.onComplete(i.trackIndex,h),this.animState.onComplete&&this.deprecateStuff()&&this.animState.onComplete(i.trackIndex,h);break;case Se.event:const l=t[e+++2];i.listener!=null&&i.listener.event&&i.listener.event(i,l);for(let s=0;s<n.length;s++)n[s].event&&n[s].event(i,l);i.onEvent&&this.deprecateStuff()&&i.onEvent(i.trackIndex,l),this.animState.onEvent&&this.deprecateStuff()&&this.animState.onEvent(i.trackIndex,l);break}}this.clear(),this.drainDisabled=!1}clear(){this.objects.length=0}};let yi=Si;yi.deprecatedWarning1=!1;var Se=(f=>(f[f.start=0]="start",f[f.interrupt=1]="interrupt",f[f.end=2]="end",f[f.dispose=3]="dispose",f[f.complete=4]="complete",f[f.event=5]="event",f))(Se||{});let io=class{start(t){}interrupt(t){}end(t){}dispose(t){}complete(t){}event(t,n){}};const Mi=class{constructor(t){if(this.animationToMixTime={},this.defaultMix=0,t==null)throw new Error("skeletonData cannot be null.");this.skeletonData=t}setMix(t,n,e){const r=this.skeletonData.findAnimation(t);if(r==null)throw new Error(`Animation not found: ${t}`);const i=this.skeletonData.findAnimation(n);if(i==null)throw new Error(`Animation not found: ${n}`);this.setMixWith(r,i,e)}setMixByName(t,n,e){Mi.deprecatedWarning1||(Mi.deprecatedWarning1=!0,console.warn("Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.")),this.setMix(t,n,e)}setMixWith(t,n,e){if(t==null)throw new Error("from cannot be null.");if(n==null)throw new Error("to cannot be null.");const r=`${t.name}.${n.name}`;this.animationToMixTime[r]=e}getMix(t,n){const e=`${t.name}.${n.name}`,r=this.animationToMixTime[e];return r===void 0?this.defaultMix:r}};let Ai=Mi;Ai.deprecatedWarning1=!1;let Ti=class{constructor(t){this.atlas=t}newRegionAttachment(t,n,e){const r=this.atlas.findRegion(e);if(r==null)throw new Error(`Region not found in atlas: ${e} (region attachment: ${n})`);const i=new tt(n);return i.region=r,i}newMeshAttachment(t,n,e){const r=this.atlas.findRegion(e);if(r==null)throw new Error(`Region not found in atlas: ${e} (mesh attachment: ${n})`);const i=new ns(n);return i.region=r,i}newBoundingBoxAttachment(t,n){return new xi(n)}newPathAttachment(t,n){return new ss(n)}newPointAttachment(t,n){return new wi(n)}newClippingAttachment(t,n){return new pi(n)}},Ci=class{constructor(t,n,e){if(this.matrix=new G.Matrix,this.children=new Array,this.x=0,this.y=0,this.rotation=0,this.scaleX=0,this.scaleY=0,this.shearX=0,this.shearY=0,this.ax=0,this.ay=0,this.arotation=0,this.ascaleX=0,this.ascaleY=0,this.ashearX=0,this.ashearY=0,this.appliedValid=!1,this.sorted=!1,this.active=!1,t==null)throw new Error("data cannot be null.");if(n==null)throw new Error("skeleton cannot be null.");this.data=t,this.skeleton=n,this.parent=e,this.setToSetupPose()}get worldX(){return this.matrix.tx}get worldY(){return this.matrix.ty}isActive(){return this.active}update(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransform(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransformWith(t,n,e,r,i,h,l){this.ax=t,this.ay=n,this.arotation=e,this.ascaleX=r,this.ascaleY=i,this.ashearX=h,this.ashearY=l,this.appliedValid=!0;const s=this.parent,a=this.matrix,o=this.skeleton.scaleX,c=jt.yDown?-this.skeleton.scaleY:this.skeleton.scaleY;if(s==null){const x=this.skeleton,w=e+90+l;a.a=T.cosDeg(e+h)*r*o,a.c=T.cosDeg(w)*i*o,a.b=T.sinDeg(e+h)*r*c,a.d=T.sinDeg(w)*i*c,a.tx=t*o+x.x,a.ty=n*c+x.y;return}let d=s.matrix.a,u=s.matrix.c,m=s.matrix.b,g=s.matrix.d;switch(a.tx=d*t+u*n+s.matrix.tx,a.ty=m*t+g*n+s.matrix.ty,this.data.transformMode){case z.Normal:{const x=e+90+l,w=T.cosDeg(e+h)*r,b=T.cosDeg(x)*i,E=T.sinDeg(e+h)*r,p=T.sinDeg(x)*i;a.a=d*w+u*E,a.c=d*b+u*p,a.b=m*w+g*E,a.d=m*b+g*p;return}case z.OnlyTranslation:{const x=e+90+l;a.a=T.cosDeg(e+h)*r,a.c=T.cosDeg(x)*i,a.b=T.sinDeg(e+h)*r,a.d=T.sinDeg(x)*i;break}case z.NoRotationOrReflection:{let x=d*d+m*m,w=0;x>1e-4?(x=Math.abs(d*g-u*m)/x,d/=this.skeleton.scaleX,m/=this.skeleton.scaleY,u=m*x,g=d*x,w=Math.atan2(m,d)*T.radDeg):(d=0,m=0,w=90-Math.atan2(g,u)*T.radDeg);const b=e+h-w,E=e+l-w+90,p=T.cosDeg(b)*r,S=T.cosDeg(E)*i,y=T.sinDeg(b)*r,M=T.sinDeg(E)*i;a.a=d*p-u*y,a.c=d*S-u*M,a.b=m*p+g*y,a.d=m*S+g*M;break}case z.NoScale:case z.NoScaleOrReflection:{const x=T.cosDeg(e),w=T.sinDeg(e);let b=(d*x+u*w)/o,E=(m*x+g*w)/c,p=Math.sqrt(b*b+E*E);p>1e-5&&(p=1/p),b*=p,E*=p,p=Math.sqrt(b*b+E*E),this.data.transformMode==z.NoScale&&d*g-u*m<0!=(jt.yDown?this.skeleton.scaleX<0!=this.skeleton.scaleY>0:this.skeleton.scaleX<0!=this.skeleton.scaleY<0)&&(p=-p);const S=Math.PI/2+Math.atan2(E,b),y=Math.cos(S)*p,M=Math.sin(S)*p,C=T.cosDeg(h)*r,I=T.cosDeg(90+l)*i,R=T.sinDeg(h)*r,v=T.sinDeg(90+l)*i;a.a=b*C+y*R,a.c=b*I+y*v,a.b=E*C+M*R,a.d=E*I+M*v;break}}a.a*=o,a.c*=o,a.b*=c,a.d*=c}setToSetupPose(){const t=this.data;this.x=t.x,this.y=t.y,this.rotation=t.rotation,this.scaleX=t.scaleX,this.scaleY=t.scaleY,this.shearX=t.shearX,this.shearY=t.shearY}getWorldRotationX(){return Math.atan2(this.matrix.b,this.matrix.a)*T.radDeg}getWorldRotationY(){return Math.atan2(this.matrix.d,this.matrix.c)*T.radDeg}getWorldScaleX(){const t=this.matrix;return Math.sqrt(t.a*t.a+t.c*t.c)}getWorldScaleY(){const t=this.matrix;return Math.sqrt(t.b*t.b+t.d*t.d)}updateAppliedTransform(){this.appliedValid=!0;const t=this.parent,n=this.matrix;if(t==null){this.ax=n.tx,this.ay=n.ty,this.arotation=Math.atan2(n.b,n.a)*T.radDeg,this.ascaleX=Math.sqrt(n.a*n.a+n.b*n.b),this.ascaleY=Math.sqrt(n.c*n.c+n.d*n.d),this.ashearX=0,this.ashearY=Math.atan2(n.a*n.c+n.b*n.d,n.a*n.d-n.b*n.c)*T.radDeg;return}const e=t.matrix,r=1/(e.a*e.d-e.b*e.c),i=n.tx-e.tx,h=n.ty-e.ty;this.ax=i*e.d*r-h*e.c*r,this.ay=h*e.a*r-i*e.b*r;const l=r*e.d,s=r*e.a,a=r*e.c,o=r*e.b,c=l*n.a-a*n.b,d=l*n.c-a*n.d,u=s*n.b-o*n.a,m=s*n.d-o*n.c;if(this.ashearX=0,this.ascaleX=Math.sqrt(c*c+u*u),this.ascaleX>1e-4){const g=c*m-d*u;this.ascaleY=g/this.ascaleX,this.ashearY=Math.atan2(c*d+u*m,g)*T.radDeg,this.arotation=Math.atan2(u,c)*T.radDeg}else this.ascaleX=0,this.ascaleY=Math.sqrt(d*d+m*m),this.ashearY=0,this.arotation=90-Math.atan2(m,d)*T.radDeg}worldToLocal(t){const n=this.matrix,e=n.a,r=n.c,i=n.b,h=n.d,l=1/(e*h-r*i),s=t.x-n.tx,a=t.y-n.ty;return t.x=s*h*l-a*r*l,t.y=a*e*l-s*i*l,t}localToWorld(t){const n=this.matrix,e=t.x,r=t.y;return t.x=e*n.a+r*n.c+n.tx,t.y=e*n.b+r*n.d+n.ty,t}worldToLocalRotation(t){const n=T.sinDeg(t),e=T.cosDeg(t),r=this.matrix;return Math.atan2(r.a*n-r.b*e,r.d*e-r.c*n)*T.radDeg}localToWorldRotation(t){const n=T.sinDeg(t),e=T.cosDeg(t),r=this.matrix;return Math.atan2(e*r.b+n*r.d,e*r.a+n*r.c)*T.radDeg}rotateWorld(t){const n=this.matrix,e=n.a,r=n.c,i=n.b,h=n.d,l=T.cosDeg(t),s=T.sinDeg(t);n.a=l*e-s*i,n.c=l*r-s*h,n.b=s*e+l*i,n.d=s*r+l*h,this.appliedValid=!1}},Ii=class{constructor(t,n,e){if(this.x=0,this.y=0,this.rotation=0,this.scaleX=1,this.scaleY=1,this.shearX=0,this.shearY=0,this.transformMode=z.Normal,this.skinRequired=!1,this.color=new O,t<0)throw new Error("index must be >= 0.");if(n==null)throw new Error("name cannot be null.");this.index=t,this.name=n,this.parent=e}},Rs=class{constructor(t,n,e){this.name=t,this.order=n,this.skinRequired=e}},Ri=class{constructor(t,n){if(n==null)throw new Error("data cannot be null.");this.time=t,this.data=n}},ki=class{constructor(t){this.name=t}},ea=class{constructor(t,n){if(this.bendDirection=0,this.compress=!1,this.stretch=!1,this.mix=1,this.softness=0,this.active=!1,t==null)throw new Error("data cannot be null.");if(n==null)throw new Error("skeleton cannot be null.");this.data=t,this.mix=t.mix,this.softness=t.softness,this.bendDirection=t.bendDirection,this.compress=t.compress,this.stretch=t.stretch,this.bones=new Array;for(let e=0;e<t.bones.length;e++)this.bones.push(n.findBone(t.bones[e].name));this.target=n.findBone(t.target.name)}isActive(){return this.active}apply(){this.update()}update(){const t=this.target,n=this.bones;switch(n.length){case 1:this.apply1(n[0],t.worldX,t.worldY,this.compress,this.stretch,this.data.uniform,this.mix);break;case 2:this.apply2(n[0],n[1],t.worldX,t.worldY,this.bendDirection,this.stretch,this.softness,this.mix);break}}apply1(t,n,e,r,i,h,l){t.appliedValid||t.updateAppliedTransform();const s=t.parent.matrix,a=s.a;let o=s.c;const c=s.b;let d=s.d,u=-t.ashearX-t.arotation,m=0,g=0;switch(t.data.transformMode){case z.OnlyTranslation:m=n-t.worldX,g=e-t.worldY;break;case z.NoRotationOrReflection:const b=Math.abs(a*d-o*c)/(a*a+c*c),E=a/t.skeleton.scaleX,p=c/t.skeleton.scaleY;o=-p*b*t.skeleton.scaleX,d=E*b*t.skeleton.scaleY,u+=Math.atan2(p,E)*T.radDeg;default:const S=n-s.tx,y=e-s.ty,M=a*d-o*c;m=(S*d-y*o)/M-t.ax,g=(y*a-S*c)/M-t.ay}u+=Math.atan2(g,m)*T.radDeg,t.ascaleX<0&&(u+=180),u>180?u-=360:u<-180&&(u+=360);let x=t.ascaleX,w=t.ascaleY;if(r||i){switch(t.data.transformMode){case z.NoScale:case z.NoScaleOrReflection:m=n-t.worldX,g=e-t.worldY}const b=t.data.length*x,E=Math.sqrt(m*m+g*g);if(r&&E<b||i&&E>b&&b>1e-4){const p=(E/b-1)*l+1;x*=p,h&&(w*=p)}}t.updateWorldTransformWith(t.ax,t.ay,t.arotation+u*l,x,w,t.ashearX,t.ashearY)}apply2(t,n,e,r,i,h,l,s){if(s==0){n.updateWorldTransform();return}t.appliedValid||t.updateAppliedTransform(),n.appliedValid||n.updateAppliedTransform();const a=t.ax,o=t.ay;let c=t.ascaleX,d=c,u=t.ascaleY,m=n.ascaleX;const g=t.matrix;let x=0,w=0,b=0;c<0?(c=-c,x=180,b=-1):(x=0,b=1),u<0&&(u=-u,b=-b),m<0?(m=-m,w=180):w=0;const E=n.ax;let p=0,S=0,y=0,M=g.a,C=g.c,I=g.b,R=g.d;const v=Math.abs(c-u)<=1e-4;v?(p=n.ay,S=M*E+C*p+g.tx,y=I*E+R*p+g.ty):(p=0,S=M*E+g.tx,y=I*E+g.ty);const V=t.parent.matrix;M=V.a,C=V.c,I=V.b,R=V.d;const P=1/(M*R-C*I);let D=S-V.tx,F=y-V.ty;const B=(D*R-F*C)*P-a,H=(F*M-D*I)*P-o,U=Math.sqrt(B*B+H*H);let X=n.data.length*m,N,_;if(U<1e-4){this.apply1(t,e,r,!1,h,!1,s),n.updateWorldTransformWith(E,p,0,n.ascaleX,n.ascaleY,n.ashearX,n.ashearY);return}D=e-V.tx,F=r-V.ty;let $=(D*R-F*C)*P-a,q=(F*M-D*I)*P-o,W=$*$+q*q;if(l!=0){l*=c*(m+1)/2;const K=Math.sqrt(W),mt=K-U-X*c+l;if(mt>0){let nt=Math.min(1,mt/(l*2))-1;nt=(mt-l*(1-nt*nt))/K,$-=nt*$,q-=nt*q,W=$*$+q*q}}t:if(v){X*=c;let K=(W-U*U-X*X)/(2*U*X);K<-1?K=-1:K>1&&(K=1,h&&(d*=(Math.sqrt(W)/(U+X)-1)*s+1)),_=Math.acos(K)*i,M=U+X*K,C=X*Math.sin(_),N=Math.atan2(q*M-$*C,$*M+q*C)}else{M=c*X,C=u*X;const K=M*M,mt=C*C,nt=Math.atan2(q,$);I=mt*U*U+K*W-K*mt;const It=-2*mt*U,Gt=mt-K;if(R=It*It-4*Gt*I,R>=0){let Bt=Math.sqrt(R);It<0&&(Bt=-Bt),Bt=-(It+Bt)/2;const rn=Bt/Gt,$t=I/Bt,ie=Math.abs(rn)<Math.abs($t)?rn:$t;if(ie*ie<=W){F=Math.sqrt(W-ie*ie)*i,N=nt-Math.atan2(F,ie),_=Math.atan2(F/u,(ie-U)/c);break t}}let pe=T.PI,ne=U-M,_e=ne*ne,Le=0,Ce=0,se=U+M,Oe=se*se,ee=0;I=-M*U/(K-mt),I>=-1&&I<=1&&(I=Math.acos(I),D=M*Math.cos(I)+U,F=C*Math.sin(I),R=D*D+F*F,R<_e&&(pe=I,_e=R,ne=D,Le=F),R>Oe&&(Ce=I,Oe=R,se=D,ee=F)),W<=(_e+Oe)/2?(N=nt-Math.atan2(Le*i,ne),_=pe*i):(N=nt-Math.atan2(ee*i,se),_=Ce*i)}const L=Math.atan2(p,E)*b;let j=t.arotation;N=(N-L)*T.radDeg+x-j,N>180?N-=360:N<-180&&(N+=360),t.updateWorldTransformWith(a,o,j+N*s,d,t.ascaleY,0,0),j=n.arotation,_=((_+L)*T.radDeg-n.ashearX)*b+w-j,_>180?_-=360:_<-180&&(_+=360),n.updateWorldTransformWith(E,p,j+_*s,n.ascaleX,n.ascaleY,n.ashearX,n.ashearY)}},vi=class extends Rs{constructor(t){super(t,0,!1),this.bones=new Array,this.bendDirection=1,this.compress=!1,this.stretch=!1,this.uniform=!1,this.mix=1,this.softness=0}},Vi=class extends Rs{constructor(t){super(t,0,!1),this.bones=new Array}};var Ht=(f=>(f[f.Length=0]="Length",f[f.Fixed=1]="Fixed",f[f.Percent=2]="Percent",f))(Ht||{});const Dn=class{constructor(t,n){if(this.position=0,this.spacing=0,this.rotateMix=0,this.translateMix=0,this.spaces=new Array,this.positions=new Array,this.world=new Array,this.curves=new Array,this.lengths=new Array,this.segments=new Array,this.active=!1,t==null)throw new Error("data cannot be null.");if(n==null)throw new Error("skeleton cannot be null.");this.data=t,this.bones=new Array;for(let e=0,r=t.bones.length;e<r;e++)this.bones.push(n.findBone(t.bones[e].name));this.target=n.findSlot(t.target.name),this.position=t.position,this.spacing=t.spacing,this.rotateMix=t.rotateMix,this.translateMix=t.translateMix}isActive(){return this.active}apply(){this.update()}update(){const t=this.target.getAttachment();if(!(t instanceof ss))return;const n=this.rotateMix,e=this.translateMix,r=e>0,i=n>0;if(!r&&!i)return;const h=this.data,l=h.spacingMode,s=l==Ht.Length,a=h.rotateMode,o=a==ut.Tangent,c=a==ut.ChainScale,d=this.bones.length,u=o?d:d+1,m=this.bones,g=k.setArraySize(this.spaces,u);let x=null;const w=this.spacing;if(c||s){c&&(x=k.setArraySize(this.lengths,d));for(let M=0,C=u-1;M<C;){const I=m[M],R=I.data.length;if(R<Dn.epsilon)c&&(x[M]=0),g[++M]=0;else{const v=R*I.matrix.a,V=R*I.matrix.b,P=Math.sqrt(v*v+V*V);c&&(x[M]=P),g[++M]=(s?R+w:w)*P/R}}}else for(let M=1;M<u;M++)g[M]=w;const b=this.computeWorldPositions(t,u,o,h.positionMode==dt.Percent,l==Ht.Percent);let E=b[0],p=b[1],S=h.offsetRotation,y=!1;if(S==0)y=a==ut.Chain;else{y=!1;const M=this.target.bone.matrix;S*=M.a*M.d-M.b*M.c>0?T.degRad:-T.degRad}for(let M=0,C=3;M<d;M++,C+=3){const I=m[M],R=I.matrix;R.tx+=(E-R.tx)*e,R.ty+=(p-R.ty)*e;const v=b[C],V=b[C+1],P=v-E,D=V-p;if(c){const F=x[M];if(F!=0){const B=(Math.sqrt(P*P+D*D)/F-1)*n+1;R.a*=B,R.b*=B}}if(E=v,p=V,i){const F=R.a,B=R.c,H=R.b,U=R.d;let X=0,N=0,_=0;if(o&&(o?X=b[C-1]:g[M+1]==0?X=b[C+2]:X=Math.atan2(D,P)),X-=Math.atan2(H,F),y){N=Math.cos(X),_=Math.sin(X);const $=I.data.length;E+=($*(N*F-_*H)-P)*n,p+=($*(_*F+N*H)-D)*n}else X+=S;X>T.PI?X-=T.PI2:X<-T.PI&&(X+=T.PI2),X*=n,N=Math.cos(X),_=Math.sin(X),R.a=N*F-_*H,R.c=N*B-_*U,R.b=_*F+N*H,R.d=_*B+N*U}I.appliedValid=!1}}computeWorldPositions(t,n,e,r,i){const h=this.target;let l=this.position;const s=this.spaces,a=k.setArraySize(this.positions,n*3+2);let o=null;const c=t.closed;let d=t.worldVerticesLength,u=d/6,m=Dn.NONE;if(!t.constantSpeed){const X=t.lengths;u-=c?1:2;const N=X[u];if(r&&(l*=N),i)for(let _=0;_<n;_++)s[_]*=N;o=k.setArraySize(this.world,8);for(let _=0,$=0,q=0;_<n;_++,$+=3){const W=s[_];l+=W;let L=l;if(c)L%=N,L<0&&(L+=N),q=0;else if(L<0){m!=Dn.BEFORE&&(m=Dn.BEFORE,t.computeWorldVertices(h,2,4,o,0,2)),this.addBeforePosition(L,o,0,a,$);continue}else if(L>N){m!=Dn.AFTER&&(m=Dn.AFTER,t.computeWorldVertices(h,d-6,4,o,0,2)),this.addAfterPosition(L-N,o,0,a,$);continue}for(;;q++){const j=X[q];if(!(L>j)){if(q==0)L/=j;else{const K=X[q-1];L=(L-K)/(j-K)}break}}q!=m&&(m=q,c&&q==u?(t.computeWorldVertices(h,d-4,4,o,0,2),t.computeWorldVertices(h,0,4,o,4,2)):t.computeWorldVertices(h,q*6+2,8,o,0,2)),this.addCurvePosition(L,o[0],o[1],o[2],o[3],o[4],o[5],o[6],o[7],a,$,e||_>0&&W==0)}return a}c?(d+=2,o=k.setArraySize(this.world,d),t.computeWorldVertices(h,2,d-4,o,0,2),t.computeWorldVertices(h,0,2,o,d-4,2),o[d-2]=o[0],o[d-1]=o[1]):(u--,d-=4,o=k.setArraySize(this.world,d),t.computeWorldVertices(h,2,d,o,0,2));const g=k.setArraySize(this.curves,u);let x=0,w=o[0],b=o[1],E=0,p=0,S=0,y=0,M=0,C=0,I=0,R=0,v=0,V=0,P=0,D=0,F=0,B=0;for(let X=0,N=2;X<u;X++,N+=6)E=o[N],p=o[N+1],S=o[N+2],y=o[N+3],M=o[N+4],C=o[N+5],I=(w-E*2+S)*.1875,R=(b-p*2+y)*.1875,v=((E-S)*3-w+M)*.09375,V=((p-y)*3-b+C)*.09375,P=I*2+v,D=R*2+V,F=(E-w)*.75+I+v*.16666667,B=(p-b)*.75+R+V*.16666667,x+=Math.sqrt(F*F+B*B),F+=P,B+=D,P+=v,D+=V,x+=Math.sqrt(F*F+B*B),F+=P,B+=D,x+=Math.sqrt(F*F+B*B),F+=P+v,B+=D+V,x+=Math.sqrt(F*F+B*B),g[X]=x,w=M,b=C;if(r&&(l*=x),i)for(let X=0;X<n;X++)s[X]*=x;const H=this.segments;let U=0;for(let X=0,N=0,_=0,$=0;X<n;X++,N+=3){const q=s[X];l+=q;let W=l;if(c)W%=x,W<0&&(W+=x),_=0;else if(W<0){this.addBeforePosition(W,o,0,a,N);continue}else if(W>x){this.addAfterPosition(W-x,o,d-4,a,N);continue}for(;;_++){const L=g[_];if(!(W>L)){if(_==0)W/=L;else{const j=g[_-1];W=(W-j)/(L-j)}break}}if(_!=m){m=_;let L=_*6;for(w=o[L],b=o[L+1],E=o[L+2],p=o[L+3],S=o[L+4],y=o[L+5],M=o[L+6],C=o[L+7],I=(w-E*2+S)*.03,R=(b-p*2+y)*.03,v=((E-S)*3-w+M)*.006,V=((p-y)*3-b+C)*.006,P=I*2+v,D=R*2+V,F=(E-w)*.3+I+v*.16666667,B=(p-b)*.3+R+V*.16666667,U=Math.sqrt(F*F+B*B),H[0]=U,L=1;L<8;L++)F+=P,B+=D,P+=v,D+=V,U+=Math.sqrt(F*F+B*B),H[L]=U;F+=P,B+=D,U+=Math.sqrt(F*F+B*B),H[8]=U,F+=P+v,B+=D+V,U+=Math.sqrt(F*F+B*B),H[9]=U,$=0}for(W*=U;;$++){const L=H[$];if(!(W>L)){if($==0)W/=L;else{const j=H[$-1];W=$+(W-j)/(L-j)}break}}this.addCurvePosition(W*.1,w,b,E,p,S,y,M,C,a,N,e||X>0&&q==0)}return a}addBeforePosition(t,n,e,r,i){const h=n[e],l=n[e+1],s=n[e+2]-h,a=n[e+3]-l,o=Math.atan2(a,s);r[i]=h+t*Math.cos(o),r[i+1]=l+t*Math.sin(o),r[i+2]=o}addAfterPosition(t,n,e,r,i){const h=n[e+2],l=n[e+3],s=h-n[e],a=l-n[e+1],o=Math.atan2(a,s);r[i]=h+t*Math.cos(o),r[i+1]=l+t*Math.sin(o),r[i+2]=o}addCurvePosition(t,n,e,r,i,h,l,s,a,o,c,d){(t==0||isNaN(t))&&(t=1e-4);const u=t*t,m=u*t,g=1-t,x=g*g,w=x*g,b=g*t,E=b*3,p=g*E,S=E*t,y=n*w+r*p+h*S+s*m,M=e*w+i*p+l*S+a*m;o[c]=y,o[c+1]=M,d&&(o[c+2]=Math.atan2(M-(e*x+i*b*2+l*u),y-(n*x+r*b*2+h*u)))}};let rs=Dn;rs.NONE=-1,rs.BEFORE=-2,rs.AFTER=-3,rs.epsilon=1e-5;let na=class{constructor(t,n){if(this.rotateMix=0,this.translateMix=0,this.scaleMix=0,this.shearMix=0,this.temp=new Yn,this.active=!1,t==null)throw new Error("data cannot be null.");if(n==null)throw new Error("skeleton cannot be null.");this.data=t,this.rotateMix=t.rotateMix,this.translateMix=t.translateMix,this.scaleMix=t.scaleMix,this.shearMix=t.shearMix,this.bones=new Array;for(let e=0;e<t.bones.length;e++)this.bones.push(n.findBone(t.bones[e].name));this.target=n.findBone(t.target.name)}isActive(){return this.active}apply(){this.update()}update(){this.data.local?this.data.relative?this.applyRelativeLocal():this.applyAbsoluteLocal():this.data.relative?this.applyRelativeWorld():this.applyAbsoluteWorld()}applyAbsoluteWorld(){const t=this.rotateMix,n=this.translateMix,e=this.scaleMix,r=this.shearMix,i=this.target,h=i.matrix,l=h.a,s=h.c,a=h.b,o=h.d,c=l*o-s*a>0?T.degRad:-T.degRad,d=this.data.offsetRotation*c,u=this.data.offsetShearY*c,m=this.bones;for(let g=0,x=m.length;g<x;g++){const w=m[g];let b=!1;const E=w.matrix;if(t!=0){const p=E.a,S=E.c,y=E.b,M=E.d;let C=Math.atan2(a,l)-Math.atan2(y,p)+d;C>T.PI?C-=T.PI2:C<-T.PI&&(C+=T.PI2),C*=t;const I=Math.cos(C),R=Math.sin(C);E.a=I*p-R*y,E.c=I*S-R*M,E.b=R*p+I*y,E.d=R*S+I*M,b=!0}if(n!=0){const p=this.temp;i.localToWorld(p.set(this.data.offsetX,this.data.offsetY)),E.tx+=(p.x-E.tx)*n,E.ty+=(p.y-E.ty)*n,b=!0}if(e>0){let p=Math.sqrt(E.a*E.a+E.b*E.b),S=Math.sqrt(l*l+a*a);p>1e-5&&(p=(p+(S-p+this.data.offsetScaleX)*e)/p),E.a*=p,E.b*=p,p=Math.sqrt(E.c*E.c+E.d*E.d),S=Math.sqrt(s*s+o*o),p>1e-5&&(p=(p+(S-p+this.data.offsetScaleY)*e)/p),E.c*=p,E.d*=p,b=!0}if(r>0){const p=E.c,S=E.d,y=Math.atan2(S,p);let M=Math.atan2(o,s)-Math.atan2(a,l)-(y-Math.atan2(E.b,E.a));M>T.PI?M-=T.PI2:M<-T.PI&&(M+=T.PI2),M=y+(M+u)*r;const C=Math.sqrt(p*p+S*S);E.c=Math.cos(M)*C,E.d=Math.sin(M)*C,b=!0}b&&(w.appliedValid=!1)}}applyRelativeWorld(){const t=this.rotateMix,n=this.translateMix,e=this.scaleMix,r=this.shearMix,i=this.target,h=i.matrix,l=h.a,s=h.c,a=h.b,o=h.d,c=l*o-s*a>0?T.degRad:-T.degRad,d=this.data.offsetRotation*c,u=this.data.offsetShearY*c,m=this.bones;for(let g=0,x=m.length;g<x;g++){const w=m[g];let b=!1;const E=w.matrix;if(t!=0){const p=E.a,S=E.c,y=E.b,M=E.d;let C=Math.atan2(a,l)+d;C>T.PI?C-=T.PI2:C<-T.PI&&(C+=T.PI2),C*=t;const I=Math.cos(C),R=Math.sin(C);E.a=I*p-R*y,E.c=I*S-R*M,E.b=R*p+I*y,E.d=R*S+I*M,b=!0}if(n!=0){const p=this.temp;i.localToWorld(p.set(this.data.offsetX,this.data.offsetY)),E.tx+=p.x*n,E.ty+=p.y*n,b=!0}if(e>0){let p=(Math.sqrt(l*l+a*a)-1+this.data.offsetScaleX)*e+1;E.a*=p,E.b*=p,p=(Math.sqrt(s*s+o*o)-1+this.data.offsetScaleY)*e+1,E.c*=p,E.d*=p,b=!0}if(r>0){let p=Math.atan2(o,s)-Math.atan2(a,l);p>T.PI?p-=T.PI2:p<-T.PI&&(p+=T.PI2);const S=E.c,y=E.d;p=Math.atan2(y,S)+(p-T.PI/2+u)*r;const M=Math.sqrt(S*S+y*y);E.c=Math.cos(p)*M,E.d=Math.sin(p)*M,b=!0}b&&(w.appliedValid=!1)}}applyAbsoluteLocal(){const t=this.rotateMix,n=this.translateMix,e=this.scaleMix,r=this.shearMix,i=this.target;i.appliedValid||i.updateAppliedTransform();const h=this.bones;for(let l=0,s=h.length;l<s;l++){const a=h[l];a.appliedValid||a.updateAppliedTransform();let o=a.arotation;if(t!=0){let x=i.arotation-o+this.data.offsetRotation;x-=(16384-(16384.499999999996-x/360|0))*360,o+=x*t}let c=a.ax,d=a.ay;n!=0&&(c+=(i.ax-c+this.data.offsetX)*n,d+=(i.ay-d+this.data.offsetY)*n);let u=a.ascaleX,m=a.ascaleY;e>0&&(u>1e-5&&(u=(u+(i.ascaleX-u+this.data.offsetScaleX)*e)/u),m>1e-5&&(m=(m+(i.ascaleY-m+this.data.offsetScaleY)*e)/m));const g=a.ashearY;if(r>0){let x=i.ashearY-g+this.data.offsetShearY;x-=(16384-(16384.499999999996-x/360|0))*360,a.shearY+=x*r}a.updateWorldTransformWith(c,d,o,u,m,a.ashearX,g)}}applyRelativeLocal(){const t=this.rotateMix,n=this.translateMix,e=this.scaleMix,r=this.shearMix,i=this.target;i.appliedValid||i.updateAppliedTransform();const h=this.bones;for(let l=0,s=h.length;l<s;l++){const a=h[l];a.appliedValid||a.updateAppliedTransform();let o=a.arotation;t!=0&&(o+=(i.arotation+this.data.offsetRotation)*t);let c=a.ax,d=a.ay;n!=0&&(c+=(i.ax+this.data.offsetX)*n,d+=(i.ay+this.data.offsetY)*n);let u=a.ascaleX,m=a.ascaleY;e>0&&(u>1e-5&&(u*=(i.ascaleX-1+this.data.offsetScaleX)*e+1),m>1e-5&&(m*=(i.ascaleY-1+this.data.offsetScaleY)*e+1));let g=a.ashearY;r>0&&(g+=(i.ashearY+this.data.offsetShearY)*r),a.updateWorldTransformWith(c,d,o,u,m,a.ashearX,g)}}};const fs=class{constructor(t){if(this._updateCache=new Array,this.updateCacheReset=new Array,this.time=0,this.scaleX=1,this.scaleY=1,this.x=0,this.y=0,t==null)throw new Error("data cannot be null.");this.data=t,this.bones=new Array;for(let n=0;n<t.bones.length;n++){const e=t.bones[n];let r;if(e.parent==null)r=new Ci(e,this,null);else{const i=this.bones[e.parent.index];r=new Ci(e,this,i),i.children.push(r)}this.bones.push(r)}this.slots=new Array,this.drawOrder=new Array;for(let n=0;n<t.slots.length;n++){const e=t.slots[n],r=this.bones[e.boneData.index],i=new bi(e,r);this.slots.push(i),this.drawOrder.push(i)}this.ikConstraints=new Array;for(let n=0;n<t.ikConstraints.length;n++){const e=t.ikConstraints[n];this.ikConstraints.push(new ea(e,this))}this.transformConstraints=new Array;for(let n=0;n<t.transformConstraints.length;n++){const e=t.transformConstraints[n];this.transformConstraints.push(new na(e,this))}this.pathConstraints=new Array;for(let n=0;n<t.pathConstraints.length;n++){const e=t.pathConstraints[n];this.pathConstraints.push(new rs(e,this))}this.color=new O(1,1,1,1),this.updateCache()}updateCache(){const t=this._updateCache;t.length=0,this.updateCacheReset.length=0;const n=this.bones;for(let o=0,c=n.length;o<c;o++){const d=n[o];d.sorted=d.data.skinRequired,d.active=!d.sorted}if(this.skin!=null){const o=this.skin.bones;for(let c=0,d=this.skin.bones.length;c<d;c++){let u=this.bones[o[c].index];do u.sorted=!1,u.active=!0,u=u.parent;while(u!=null)}}const e=this.ikConstraints,r=this.transformConstraints,i=this.pathConstraints,h=e.length,l=r.length,s=i.length,a=h+l+s;t:for(let o=0;o<a;o++){for(let c=0;c<h;c++){const d=e[c];if(d.data.order==o){this.sortIkConstraint(d);continue t}}for(let c=0;c<l;c++){const d=r[c];if(d.data.order==o){this.sortTransformConstraint(d);continue t}}for(let c=0;c<s;c++){const d=i[c];if(d.data.order==o){this.sortPathConstraint(d);continue t}}}for(let o=0,c=n.length;o<c;o++)this.sortBone(n[o])}sortIkConstraint(t){if(t.active=t.target.isActive()&&(!t.data.skinRequired||this.skin!=null&&k.contains(this.skin.constraints,t.data,!0)),!t.active)return;const n=t.target;this.sortBone(n);const e=t.bones,r=e[0];if(this.sortBone(r),e.length>1){const i=e[e.length-1];this._updateCache.indexOf(i)>-1||this.updateCacheReset.push(i)}this._updateCache.push(t),this.sortReset(r.children),e[e.length-1].sorted=!0}sortPathConstraint(t){if(t.active=t.target.bone.isActive()&&(!t.data.skinRequired||this.skin!=null&&k.contains(this.skin.constraints,t.data,!0)),!t.active)return;const n=t.target,e=n.data.index,r=n.bone;this.skin!=null&&this.sortPathConstraintAttachment(this.skin,e,r),this.data.defaultSkin!=null&&this.data.defaultSkin!=this.skin&&this.sortPathConstraintAttachment(this.data.defaultSkin,e,r);for(let s=0,a=this.data.skins.length;s<a;s++)this.sortPathConstraintAttachment(this.data.skins[s],e,r);const i=n.getAttachment();i instanceof ss&&this.sortPathConstraintAttachmentWith(i,r);const h=t.bones,l=h.length;for(let s=0;s<l;s++)this.sortBone(h[s]);this._updateCache.push(t);for(let s=0;s<l;s++)this.sortReset(h[s].children);for(let s=0;s<l;s++)h[s].sorted=!0}sortTransformConstraint(t){if(t.active=t.target.isActive()&&(!t.data.skinRequired||this.skin!=null&&k.contains(this.skin.constraints,t.data,!0)),!t.active)return;this.sortBone(t.target);const n=t.bones,e=n.length;if(t.data.local)for(let r=0;r<e;r++){const i=n[r];this.sortBone(i.parent),this._updateCache.indexOf(i)>-1||this.updateCacheReset.push(i)}else for(let r=0;r<e;r++)this.sortBone(n[r]);this._updateCache.push(t);for(let r=0;r<e;r++)this.sortReset(n[r].children);for(let r=0;r<e;r++)n[r].sorted=!0}sortPathConstraintAttachment(t,n,e){const r=t.attachments[n];if(r)for(const i in r)this.sortPathConstraintAttachmentWith(r[i],e)}sortPathConstraintAttachmentWith(t,n){if(!(t instanceof ss))return;const e=t.bones;if(e==null)this.sortBone(n);else{const r=this.bones;let i=0;for(;i<e.length;){const h=e[i++];for(let l=i+h;i<l;i++){const s=e[i];this.sortBone(r[s])}}}}sortBone(t){if(t.sorted)return;const n=t.parent;n!=null&&this.sortBone(n),t.sorted=!0,this._updateCache.push(t)}sortReset(t){for(let n=0,e=t.length;n<e;n++){const r=t[n];r.active&&(r.sorted&&this.sortReset(r.children),r.sorted=!1)}}updateWorldTransform(){const t=this.updateCacheReset;for(let e=0,r=t.length;e<r;e++){const i=t[e];i.ax=i.x,i.ay=i.y,i.arotation=i.rotation,i.ascaleX=i.scaleX,i.ascaleY=i.scaleY,i.ashearX=i.shearX,i.ashearY=i.shearY,i.appliedValid=!0}const n=this._updateCache;for(let e=0,r=n.length;e<r;e++)n[e].update()}setToSetupPose(){this.setBonesToSetupPose(),this.setSlotsToSetupPose()}setBonesToSetupPose(){const t=this.bones;for(let i=0,h=t.length;i<h;i++)t[i].setToSetupPose();const n=this.ikConstraints;for(let i=0,h=n.length;i<h;i++){const l=n[i];l.mix=l.data.mix,l.softness=l.data.softness,l.bendDirection=l.data.bendDirection,l.compress=l.data.compress,l.stretch=l.data.stretch}const e=this.transformConstraints;for(let i=0,h=e.length;i<h;i++){const l=e[i],s=l.data;l.rotateMix=s.rotateMix,l.translateMix=s.translateMix,l.scaleMix=s.scaleMix,l.shearMix=s.shearMix}const r=this.pathConstraints;for(let i=0,h=r.length;i<h;i++){const l=r[i],s=l.data;l.position=s.position,l.spacing=s.spacing,l.rotateMix=s.rotateMix,l.translateMix=s.translateMix}}setSlotsToSetupPose(){const t=this.slots;k.arrayCopy(t,0,this.drawOrder,0,t.length);for(let n=0,e=t.length;n<e;n++)t[n].setToSetupPose()}getRootBone(){return this.bones.length==0?null:this.bones[0]}findBone(t){if(t==null)throw new Error("boneName cannot be null.");const n=this.bones;for(let e=0,r=n.length;e<r;e++){const i=n[e];if(i.data.name==t)return i}return null}findBoneIndex(t){if(t==null)throw new Error("boneName cannot be null.");const n=this.bones;for(let e=0,r=n.length;e<r;e++)if(n[e].data.name==t)return e;return-1}findSlot(t){if(t==null)throw new Error("slotName cannot be null.");const n=this.slots;for(let e=0,r=n.length;e<r;e++){const i=n[e];if(i.data.name==t)return i}return null}findSlotIndex(t){if(t==null)throw new Error("slotName cannot be null.");const n=this.slots;for(let e=0,r=n.length;e<r;e++)if(n[e].data.name==t)return e;return-1}setSkinByName(t){const n=this.data.findSkin(t);if(n==null)throw new Error(`Skin not found: ${t}`);this.setSkin(n)}setSkin(t){if(t!=this.skin){if(t!=null)if(this.skin!=null)t.attachAll(this,this.skin);else{const n=this.slots;for(let e=0,r=n.length;e<r;e++){const i=n[e],h=i.data.attachmentName;if(h!=null){const l=t.getAttachment(e,h);l!=null&&i.setAttachment(l)}}}this.skin=t,this.updateCache()}}getAttachmentByName(t,n){return this.getAttachment(this.data.findSlotIndex(t),n)}getAttachment(t,n){if(n==null)throw new Error("attachmentName cannot be null.");if(this.skin!=null){const e=this.skin.getAttachment(t,n);if(e!=null)return e}return this.data.defaultSkin!=null?this.data.defaultSkin.getAttachment(t,n):null}setAttachment(t,n){if(t==null)throw new Error("slotName cannot be null.");const e=this.slots;for(let r=0,i=e.length;r<i;r++){const h=e[r];if(h.data.name==t){let l=null;if(n!=null&&(l=this.getAttachment(r,n),l==null))throw new Error(`Attachment not found: ${n}, for slot: ${t}`);h.setAttachment(l);return}}throw new Error(`Slot not found: ${t}`)}findIkConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const n=this.ikConstraints;for(let e=0,r=n.length;e<r;e++){const i=n[e];if(i.data.name==t)return i}return null}findTransformConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const n=this.transformConstraints;for(let e=0,r=n.length;e<r;e++){const i=n[e];if(i.data.name==t)return i}return null}findPathConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const n=this.pathConstraints;for(let e=0,r=n.length;e<r;e++){const i=n[e];if(i.data.name==t)return i}return null}getBounds(t,n,e=new Array(2)){if(t==null)throw new Error("offset cannot be null.");if(n==null)throw new Error("size cannot be null.");const r=this.drawOrder;let i=Number.POSITIVE_INFINITY,h=Number.POSITIVE_INFINITY,l=Number.NEGATIVE_INFINITY,s=Number.NEGATIVE_INFINITY;for(let a=0,o=r.length;a<o;a++){const c=r[a];if(!c.bone.active)continue;let d=0,u=null;const m=c.getAttachment();if(m instanceof tt)d=8,u=k.setArraySize(e,d,0),m.computeWorldVertices(c.bone,u,0,2);else if(m instanceof ns){const g=m;d=g.worldVerticesLength,u=k.setArraySize(e,d,0),g.computeWorldVertices(c,0,d,u,0,2)}if(u!=null)for(let g=0,x=u.length;g<x;g+=2){const w=u[g],b=u[g+1];i=Math.min(i,w),h=Math.min(h,b),l=Math.max(l,w),s=Math.max(s,b)}}t.set(i,h),n.set(l-i,s-h)}update(t){this.time+=t}get flipX(){return this.scaleX==-1}set flipX(t){fs.deprecatedWarning1||(fs.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleX=t?1:-1}get flipY(){return this.scaleY==-1}set flipY(t){fs.deprecatedWarning1||(fs.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleY=t?1:-1}};let Pi=fs;Pi.deprecatedWarning1=!1;let Fi=class{constructor(){this.bones=new Array,this.slots=new Array,this.skins=new Array,this.events=new Array,this.animations=new Array,this.ikConstraints=new Array,this.transformConstraints=new Array,this.pathConstraints=new Array,this.fps=0}findBone(t){if(t==null)throw new Error("boneName cannot be null.");const n=this.bones;for(let e=0,r=n.length;e<r;e++){const i=n[e];if(i.name==t)return i}return null}findBoneIndex(t){if(t==null)throw new Error("boneName cannot be null.");const n=this.bones;for(let e=0,r=n.length;e<r;e++)if(n[e].name==t)return e;return-1}findSlot(t){if(t==null)throw new Error("slotName cannot be null.");const n=this.slots;for(let e=0,r=n.length;e<r;e++){const i=n[e];if(i.name==t)return i}return null}findSlotIndex(t){if(t==null)throw new Error("slotName cannot be null.");const n=this.slots;for(let e=0,r=n.length;e<r;e++)if(n[e].name==t)return e;return-1}findSkin(t){if(t==null)throw new Error("skinName cannot be null.");const n=this.skins;for(let e=0,r=n.length;e<r;e++){const i=n[e];if(i.name==t)return i}return null}findEvent(t){if(t==null)throw new Error("eventDataName cannot be null.");const n=this.events;for(let e=0,r=n.length;e<r;e++){const i=n[e];if(i.name==t)return i}return null}findAnimation(t){if(t==null)throw new Error("animationName cannot be null.");const n=this.animations;for(let e=0,r=n.length;e<r;e++){const i=n[e];if(i.name==t)return i}return null}findIkConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const n=this.ikConstraints;for(let e=0,r=n.length;e<r;e++){const i=n[e];if(i.name==t)return i}return null}findTransformConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const n=this.transformConstraints;for(let e=0,r=n.length;e<r;e++){const i=n[e];if(i.name==t)return i}return null}findPathConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const n=this.pathConstraints;for(let e=0,r=n.length;e<r;e++){const i=n[e];if(i.name==t)return i}return null}findPathConstraintIndex(t){if(t==null)throw new Error("pathConstraintName cannot be null.");const n=this.pathConstraints;for(let e=0,r=n.length;e<r;e++)if(n[e].name==t)return e;return-1}},Yi=class{constructor(t,n,e){if(this.color=new O(1,1,1,1),t<0)throw new Error("index must be >= 0.");if(n==null)throw new Error("name cannot be null.");if(e==null)throw new Error("boneData cannot be null.");this.index=t,this.name=n,this.boneData=e}},Ni=class extends Rs{constructor(t){super(t,0,!1),this.bones=new Array,this.rotateMix=0,this.translateMix=0,this.scaleMix=0,this.shearMix=0,this.offsetRotation=0,this.offsetX=0,this.offsetY=0,this.offsetScaleX=0,this.offsetScaleY=0,this.offsetShearY=0,this.relative=!1,this.local=!1}},Xi=class{constructor(t,n,e){this.slotIndex=t,this.name=n,this.attachment=e}},ks=class{constructor(t){if(this.attachments=new Array,this.bones=Array(),this.constraints=new Array,t==null)throw new Error("name cannot be null.");this.name=t}setAttachment(t,n,e){if(e==null)throw new Error("attachment cannot be null.");const r=this.attachments;t>=r.length&&(r.length=t+1),r[t]||(r[t]={}),r[t][n]=e}addSkin(t){for(let e=0;e<t.bones.length;e++){const r=t.bones[e];let i=!1;for(let h=0;h<this.bones.length;h++)if(this.bones[h]==r){i=!0;break}i||this.bones.push(r)}for(let e=0;e<t.constraints.length;e++){const r=t.constraints[e];let i=!1;for(let h=0;h<this.constraints.length;h++)if(this.constraints[h]==r){i=!0;break}i||this.constraints.push(r)}const n=t.getAttachments();for(let e=0;e<n.length;e++){const r=n[e];this.setAttachment(r.slotIndex,r.name,r.attachment)}}copySkin(t){for(let e=0;e<t.bones.length;e++){const r=t.bones[e];let i=!1;for(let h=0;h<this.bones.length;h++)if(this.bones[h]==r){i=!0;break}i||this.bones.push(r)}for(let e=0;e<t.constraints.length;e++){const r=t.constraints[e];let i=!1;for(let h=0;h<this.constraints.length;h++)if(this.constraints[h]==r){i=!0;break}i||this.constraints.push(r)}const n=t.getAttachments();for(let e=0;e<n.length;e++){const r=n[e];r.attachment!=null&&(r.attachment instanceof ns?(r.attachment=r.attachment.newLinkedMesh(),this.setAttachment(r.slotIndex,r.name,r.attachment)):(r.attachment=r.attachment.copy(),this.setAttachment(r.slotIndex,r.name,r.attachment)))}}getAttachment(t,n){const e=this.attachments[t];return e?e[n]:null}removeAttachment(t,n){const e=this.attachments[t];e&&(e[n]=null)}getAttachments(){const t=new Array;for(let n=0;n<this.attachments.length;n++){const e=this.attachments[n];if(e)for(const r in e){const i=e[r];i&&t.push(new Xi(n,r,i))}}return t}getAttachmentsForSlot(t,n){const e=this.attachments[t];if(e)for(const r in e){const i=e[r];i&&n.push(new Xi(t,r,i))}}clear(){this.attachments.length=0,this.bones.length=0,this.constraints.length=0}attachAll(t,n){let e=0;for(let r=0;r<t.slots.length;r++){const i=t.slots[r],h=i.getAttachment();if(h&&e<n.attachments.length){const l=n.attachments[e];for(const s in l){const a=l[s];if(h==a){const o=this.getAttachment(e,s);o!=null&&i.setAttachment(o);break}}}e++}}};const Tt=class{constructor(f){this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=f}readSkeletonData(f){const t=this.scale,n=new Fi;n.name="";const e=new Gn(f);n.hash=e.readString(),n.version=e.readString(),n.version==="3.8.75"&&console.error("Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine."),n.x=e.readFloat(),n.y=e.readFloat(),n.width=e.readFloat(),n.height=e.readFloat();const r=e.readBoolean();r&&(n.fps=e.readFloat(),n.imagesPath=e.readString(),n.audioPath=e.readString());let i=0;i=e.readInt(!0);for(let l=0;l<i;l++)e.strings.push(e.readString());i=e.readInt(!0);for(let l=0;l<i;l++){const s=e.readString(),a=l==0?null:n.bones[e.readInt(!0)],o=new Ii(l,s,a);o.rotation=e.readFloat(),o.x=e.readFloat()*t,o.y=e.readFloat()*t,o.scaleX=e.readFloat(),o.scaleY=e.readFloat(),o.shearX=e.readFloat(),o.shearY=e.readFloat(),o.length=e.readFloat()*t,o.transformMode=Tt.TransformModeValues[e.readInt(!0)],o.skinRequired=e.readBoolean(),r&&O.rgba8888ToColor(o.color,e.readInt32()),n.bones.push(o)}i=e.readInt(!0);for(let l=0;l<i;l++){const s=e.readString(),a=n.bones[e.readInt(!0)],o=new Yi(l,s,a);O.rgba8888ToColor(o.color,e.readInt32());const c=e.readInt32();c!=-1&&O.rgb888ToColor(o.darkColor=new O,c),o.attachmentName=e.readStringRef(),o.blendMode=Tt.BlendModeValues[e.readInt(!0)],n.slots.push(o)}i=e.readInt(!0);for(let l=0,s;l<i;l++){const a=new vi(e.readString());a.order=e.readInt(!0),a.skinRequired=e.readBoolean(),s=e.readInt(!0);for(let o=0;o<s;o++)a.bones.push(n.bones[e.readInt(!0)]);a.target=n.bones[e.readInt(!0)],a.mix=e.readFloat(),a.softness=e.readFloat()*t,a.bendDirection=e.readByte(),a.compress=e.readBoolean(),a.stretch=e.readBoolean(),a.uniform=e.readBoolean(),n.ikConstraints.push(a)}i=e.readInt(!0);for(let l=0,s;l<i;l++){const a=new Ni(e.readString());a.order=e.readInt(!0),a.skinRequired=e.readBoolean(),s=e.readInt(!0);for(let o=0;o<s;o++)a.bones.push(n.bones[e.readInt(!0)]);a.target=n.bones[e.readInt(!0)],a.local=e.readBoolean(),a.relative=e.readBoolean(),a.offsetRotation=e.readFloat(),a.offsetX=e.readFloat()*t,a.offsetY=e.readFloat()*t,a.offsetScaleX=e.readFloat(),a.offsetScaleY=e.readFloat(),a.offsetShearY=e.readFloat(),a.rotateMix=e.readFloat(),a.translateMix=e.readFloat(),a.scaleMix=e.readFloat(),a.shearMix=e.readFloat(),n.transformConstraints.push(a)}i=e.readInt(!0);for(let l=0,s;l<i;l++){const a=new Vi(e.readString());a.order=e.readInt(!0),a.skinRequired=e.readBoolean(),s=e.readInt(!0);for(let o=0;o<s;o++)a.bones.push(n.bones[e.readInt(!0)]);a.target=n.slots[e.readInt(!0)],a.positionMode=Tt.PositionModeValues[e.readInt(!0)],a.spacingMode=Tt.SpacingModeValues[e.readInt(!0)],a.rotateMode=Tt.RotateModeValues[e.readInt(!0)],a.offsetRotation=e.readFloat(),a.position=e.readFloat(),a.positionMode==dt.Fixed&&(a.position*=t),a.spacing=e.readFloat(),(a.spacingMode==Ht.Length||a.spacingMode==Ht.Fixed)&&(a.spacing*=t),a.rotateMix=e.readFloat(),a.translateMix=e.readFloat(),n.pathConstraints.push(a)}const h=this.readSkin(e,n,!0,r);h!=null&&(n.defaultSkin=h,n.skins.push(h));{let l=n.skins.length;for(k.setArraySize(n.skins,i=l+e.readInt(!0));l<i;l++)n.skins[l]=this.readSkin(e,n,!1,r)}i=this.linkedMeshes.length;for(let l=0;l<i;l++){const s=this.linkedMeshes[l],a=s.skin==null?n.defaultSkin:n.findSkin(s.skin);if(a==null)throw new Error(`Skin not found: ${s.skin}`);const o=a.getAttachment(s.slotIndex,s.parent);if(o==null)throw new Error(`Parent mesh not found: ${s.parent}`);s.mesh.deformAttachment=s.inheritDeform?o:s.mesh,s.mesh.setParentMesh(o)}this.linkedMeshes.length=0,i=e.readInt(!0);for(let l=0;l<i;l++){const s=new ki(e.readStringRef());s.intValue=e.readInt(!1),s.floatValue=e.readFloat(),s.stringValue=e.readString(),s.audioPath=e.readString(),s.audioPath!=null&&(s.volume=e.readFloat(),s.balance=e.readFloat()),n.events.push(s)}i=e.readInt(!0);for(let l=0;l<i;l++)n.animations.push(this.readAnimation(e,e.readString(),n));return n}readSkin(f,t,n,e){let r=null,i=0;if(n){if(i=f.readInt(!0),i==0)return null;r=new ks("default")}else{r=new ks(f.readStringRef()),r.bones.length=f.readInt(!0);for(let h=0,l=r.bones.length;h<l;h++)r.bones[h]=t.bones[f.readInt(!0)];for(let h=0,l=f.readInt(!0);h<l;h++)r.constraints.push(t.ikConstraints[f.readInt(!0)]);for(let h=0,l=f.readInt(!0);h<l;h++)r.constraints.push(t.transformConstraints[f.readInt(!0)]);for(let h=0,l=f.readInt(!0);h<l;h++)r.constraints.push(t.pathConstraints[f.readInt(!0)]);i=f.readInt(!0)}for(let h=0;h<i;h++){const l=f.readInt(!0);for(let s=0,a=f.readInt(!0);s<a;s++){const o=f.readStringRef(),c=this.readAttachment(f,t,r,l,o,e);c!=null&&r.setAttachment(l,o,c)}}return r}readAttachment(f,t,n,e,r,i){const h=this.scale;let l=f.readStringRef();l==null&&(l=r);const s=f.readByte();switch(Tt.AttachmentTypeValues[s]){case Z.Region:{let o=f.readStringRef();const c=f.readFloat(),d=f.readFloat(),u=f.readFloat(),m=f.readFloat(),g=f.readFloat(),x=f.readFloat(),w=f.readFloat(),b=f.readInt32();o==null&&(o=l);const E=this.attachmentLoader.newRegionAttachment(n,l,o);return E==null?null:(E.path=o,E.x=d*h,E.y=u*h,E.scaleX=m,E.scaleY=g,E.rotation=c,E.width=x*h,E.height=w*h,O.rgba8888ToColor(E.color,b),E)}case Z.BoundingBox:{const o=f.readInt(!0),c=this.readVertices(f,o),d=i?f.readInt32():0,u=this.attachmentLoader.newBoundingBoxAttachment(n,l);return u==null?null:(u.worldVerticesLength=o<<1,u.vertices=c.vertices,u.bones=c.bones,i&&O.rgba8888ToColor(u.color,d),u)}case Z.Mesh:{let o=f.readStringRef();const c=f.readInt32(),d=f.readInt(!0),u=this.readFloatArray(f,d<<1,1),m=this.readShortArray(f),g=this.readVertices(f,d),x=f.readInt(!0);let w=null,b=0,E=0;i&&(w=this.readShortArray(f),b=f.readFloat(),E=f.readFloat()),o==null&&(o=l);const p=this.attachmentLoader.newMeshAttachment(n,l,o);return p==null?null:(p.path=o,O.rgba8888ToColor(p.color,c),p.bones=g.bones,p.vertices=g.vertices,p.worldVerticesLength=d<<1,p.triangles=m,p.regionUVs=new Float32Array(u),p.hullLength=x<<1,i&&(p.edges=w,p.width=b*h,p.height=E*h),p)}case Z.LinkedMesh:{let o=f.readStringRef();const c=f.readInt32(),d=f.readStringRef(),u=f.readStringRef(),m=f.readBoolean();let g=0,x=0;i&&(g=f.readFloat(),x=f.readFloat()),o==null&&(o=l);const w=this.attachmentLoader.newMeshAttachment(n,l,o);return w==null?null:(w.path=o,O.rgba8888ToColor(w.color,c),i&&(w.width=g*h,w.height=x*h),this.linkedMeshes.push(new ro(w,d,e,u,m)),w)}case Z.Path:{const o=f.readBoolean(),c=f.readBoolean(),d=f.readInt(!0),u=this.readVertices(f,d),m=k.newArray(d/3,0);for(let w=0,b=m.length;w<b;w++)m[w]=f.readFloat()*h;const g=i?f.readInt32():0,x=this.attachmentLoader.newPathAttachment(n,l);return x==null?null:(x.closed=o,x.constantSpeed=c,x.worldVerticesLength=d<<1,x.vertices=u.vertices,x.bones=u.bones,x.lengths=m,i&&O.rgba8888ToColor(x.color,g),x)}case Z.Point:{const o=f.readFloat(),c=f.readFloat(),d=f.readFloat(),u=i?f.readInt32():0,m=this.attachmentLoader.newPointAttachment(n,l);return m==null?null:(m.x=c*h,m.y=d*h,m.rotation=o,i&&O.rgba8888ToColor(m.color,u),m)}case Z.Clipping:{const o=f.readInt(!0),c=f.readInt(!0),d=this.readVertices(f,c),u=i?f.readInt32():0,m=this.attachmentLoader.newClippingAttachment(n,l);return m==null?null:(m.endSlot=t.slots[o],m.worldVerticesLength=c<<1,m.vertices=d.vertices,m.bones=d.bones,i&&O.rgba8888ToColor(m.color,u),m)}}return null}readVertices(f,t){const n=t<<1,e=new ao,r=this.scale;if(!f.readBoolean())return e.vertices=this.readFloatArray(f,n,r),e;const i=new Array,h=new Array;for(let l=0;l<t;l++){const s=f.readInt(!0);h.push(s);for(let a=0;a<s;a++)h.push(f.readInt(!0)),i.push(f.readFloat()*r),i.push(f.readFloat()*r),i.push(f.readFloat())}return e.vertices=k.toFloatArray(i),e.bones=h,e}readFloatArray(f,t,n){const e=new Array(t);if(n==1)for(let r=0;r<t;r++)e[r]=f.readFloat();else for(let r=0;r<t;r++)e[r]=f.readFloat()*n;return e}readShortArray(f){const t=f.readInt(!0),n=new Array(t);for(let e=0;e<t;e++)n[e]=f.readShort();return n}readAnimation(f,t,n){const e=new Array,r=this.scale;let i=0;const h=new O,l=new O;for(let o=0,c=f.readInt(!0);o<c;o++){const d=f.readInt(!0);for(let u=0,m=f.readInt(!0);u<m;u++){const g=f.readByte(),x=f.readInt(!0);switch(g){case Tt.SLOT_ATTACHMENT:{const w=new Bn(x);w.slotIndex=d;for(let b=0;b<x;b++)w.setFrame(b,f.readFloat(),f.readStringRef());e.push(w),i=Math.max(i,w.frames[x-1]);break}case Tt.SLOT_COLOR:{const w=new de(x);w.slotIndex=d;for(let b=0;b<x;b++){const E=f.readFloat();O.rgba8888ToColor(h,f.readInt32()),w.setFrame(b,E,h.r,h.g,h.b,h.a),b<x-1&&this.readCurve(f,b,w)}e.push(w),i=Math.max(i,w.frames[(x-1)*de.ENTRIES]);break}case Tt.SLOT_TWO_COLOR:{const w=new Ft(x);w.slotIndex=d;for(let b=0;b<x;b++){const E=f.readFloat();O.rgba8888ToColor(h,f.readInt32()),O.rgb888ToColor(l,f.readInt32()),w.setFrame(b,E,h.r,h.g,h.b,h.a,l.r,l.g,l.b),b<x-1&&this.readCurve(f,b,w)}e.push(w),i=Math.max(i,w.frames[(x-1)*Ft.ENTRIES]);break}}}}for(let o=0,c=f.readInt(!0);o<c;o++){const d=f.readInt(!0);for(let u=0,m=f.readInt(!0);u<m;u++){const g=f.readByte(),x=f.readInt(!0);switch(g){case Tt.BONE_ROTATE:{const w=new Kt(x);w.boneIndex=d;for(let b=0;b<x;b++)w.setFrame(b,f.readFloat(),f.readFloat()),b<x-1&&this.readCurve(f,b,w);e.push(w),i=Math.max(i,w.frames[(x-1)*Kt.ENTRIES]);break}case Tt.BONE_TRANSLATE:case Tt.BONE_SCALE:case Tt.BONE_SHEAR:{let w,b=1;g==Tt.BONE_SCALE?w=new Fe(x):g==Tt.BONE_SHEAR?w=new Ye(x):(w=new Pe(x),b=r),w.boneIndex=d;for(let E=0;E<x;E++)w.setFrame(E,f.readFloat(),f.readFloat()*b,f.readFloat()*b),E<x-1&&this.readCurve(f,E,w);e.push(w),i=Math.max(i,w.frames[(x-1)*Pe.ENTRIES]);break}}}}for(let o=0,c=f.readInt(!0);o<c;o++){const d=f.readInt(!0),u=f.readInt(!0),m=new Jt(u);m.ikConstraintIndex=d;for(let g=0;g<u;g++)m.setFrame(g,f.readFloat(),f.readFloat(),f.readFloat()*r,f.readByte(),f.readBoolean(),f.readBoolean()),g<u-1&&this.readCurve(f,g,m);e.push(m),i=Math.max(i,m.frames[(u-1)*Jt.ENTRIES])}for(let o=0,c=f.readInt(!0);o<c;o++){const d=f.readInt(!0),u=f.readInt(!0),m=new fe(u);m.transformConstraintIndex=d;for(let g=0;g<u;g++)m.setFrame(g,f.readFloat(),f.readFloat(),f.readFloat(),f.readFloat(),f.readFloat()),g<u-1&&this.readCurve(f,g,m);e.push(m),i=Math.max(i,m.frames[(u-1)*fe.ENTRIES])}for(let o=0,c=f.readInt(!0);o<c;o++){const d=f.readInt(!0),u=n.pathConstraints[d];for(let m=0,g=f.readInt(!0);m<g;m++){const x=f.readByte(),w=f.readInt(!0);switch(x){case Tt.PATH_POSITION:case Tt.PATH_SPACING:{let b,E=1;x==Tt.PATH_SPACING?(b=new cn(w),(u.spacingMode==Ht.Length||u.spacingMode==Ht.Fixed)&&(E=r)):(b=new ln(w),u.positionMode==dt.Fixed&&(E=r)),b.pathConstraintIndex=d;for(let p=0;p<w;p++)b.setFrame(p,f.readFloat(),f.readFloat()*E),p<w-1&&this.readCurve(f,p,b);e.push(b),i=Math.max(i,b.frames[(w-1)*ln.ENTRIES]);break}case Tt.PATH_MIX:{const b=new je(w);b.pathConstraintIndex=d;for(let E=0;E<w;E++)b.setFrame(E,f.readFloat(),f.readFloat(),f.readFloat()),E<w-1&&this.readCurve(f,E,b);e.push(b),i=Math.max(i,b.frames[(w-1)*je.ENTRIES]);break}}}}for(let o=0,c=f.readInt(!0);o<c;o++){const d=n.skins[f.readInt(!0)];for(let u=0,m=f.readInt(!0);u<m;u++){const g=f.readInt(!0);for(let x=0,w=f.readInt(!0);x<w;x++){const b=d.getAttachment(g,f.readStringRef()),E=b.bones!=null,p=b.vertices,S=E?p.length/3*2:p.length,y=f.readInt(!0),M=new Ei(y);M.slotIndex=g,M.attachment=b;for(let C=0;C<y;C++){const I=f.readFloat();let R,v=f.readInt(!0);if(v==0)R=E?k.newFloatArray(S):p;else{R=k.newFloatArray(S);const V=f.readInt(!0);if(v+=V,r==1)for(let P=V;P<v;P++)R[P]=f.readFloat();else for(let P=V;P<v;P++)R[P]=f.readFloat()*r;if(!E)for(let P=0,D=R.length;P<D;P++)R[P]+=p[P]}M.setFrame(C,I,R),C<y-1&&this.readCurve(f,C,M)}e.push(M),i=Math.max(i,M.frames[y-1])}}}const s=f.readInt(!0);if(s>0){const o=new is(s),c=n.slots.length;for(let d=0;d<s;d++){const u=f.readFloat(),m=f.readInt(!0),g=k.newArray(c,0);for(let E=c-1;E>=0;E--)g[E]=-1;const x=k.newArray(c-m,0);let w=0,b=0;for(let E=0;E<m;E++){const p=f.readInt(!0);for(;w!=p;)x[b++]=w++;g[w+f.readInt(!0)]=w++}for(;w<c;)x[b++]=w++;for(let E=c-1;E>=0;E--)g[E]==-1&&(g[E]=x[--b]);o.setFrame(d,u,g)}e.push(o),i=Math.max(i,o.frames[s-1])}const a=f.readInt(!0);if(a>0){const o=new Cs(a);for(let c=0;c<a;c++){const d=f.readFloat(),u=n.events[f.readInt(!0)],m=new Ri(d,u);m.intValue=f.readInt(!1),m.floatValue=f.readFloat(),m.stringValue=f.readBoolean()?f.readString():u.stringValue,m.data.audioPath!=null&&(m.volume=f.readFloat(),m.balance=f.readFloat()),o.setFrame(c,m)}e.push(o),i=Math.max(i,o.frames[a-1])}return new Vt(t,e,i)}readCurve(f,t,n){switch(f.readByte()){case Tt.CURVE_STEPPED:n.setStepped(t);break;case Tt.CURVE_BEZIER:this.setCurve(n,t,f.readFloat(),f.readFloat(),f.readFloat(),f.readFloat());break}}setCurve(f,t,n,e,r,i){f.setCurve(t,n,e,r,i)}};let Yt=Tt;Yt.AttachmentTypeValues=[0,1,2,3,4,5,6],Yt.TransformModeValues=[z.Normal,z.OnlyTranslation,z.NoRotationOrReflection,z.NoScale,z.NoScaleOrReflection],Yt.PositionModeValues=[dt.Fixed,dt.Percent],Yt.SpacingModeValues=[Ht.Length,Ht.Fixed,Ht.Percent],Yt.RotateModeValues=[ut.Tangent,ut.Chain,ut.ChainScale],Yt.BlendModeValues=[G.BLEND_MODES.NORMAL,G.BLEND_MODES.ADD,G.BLEND_MODES.MULTIPLY,G.BLEND_MODES.SCREEN],Yt.BONE_ROTATE=0,Yt.BONE_TRANSLATE=1,Yt.BONE_SCALE=2,Yt.BONE_SHEAR=3,Yt.SLOT_ATTACHMENT=0,Yt.SLOT_COLOR=1,Yt.SLOT_TWO_COLOR=2,Yt.PATH_POSITION=0,Yt.PATH_SPACING=1,Yt.PATH_MIX=2,Yt.CURVE_LINEAR=0,Yt.CURVE_STEPPED=1,Yt.CURVE_BEZIER=2;let ro=class{constructor(t,n,e,r,i){this.mesh=t,this.skin=n,this.slotIndex=e,this.parent=r,this.inheritDeform=i}},ao=class{constructor(t=null,n=null){this.bones=t,this.vertices=n}},oo=class extends Qn{},_n=class{constructor(t){this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=t}readSkeletonData(t){const n=this.scale,e=new Fi,r=typeof t=="string"?JSON.parse(t):t,i=r.skeleton;if(i!=null){if(e.hash=i.hash,e.version=i.spine,e.version.substr(0,3)!=="3.8"){const h=`Spine 3.8 loader cant load version ${i.spine}. Please configure your pixi-spine bundle`;console.error(h)}e.version==="3.8.75"&&console.error("Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine."),e.x=i.x,e.y=i.y,e.width=i.width,e.height=i.height,e.fps=i.fps,e.imagesPath=i.images}if(r.bones)for(let h=0;h<r.bones.length;h++){const l=r.bones[h];let s=null;const a=this.getValue(l,"parent",null);if(a!=null&&(s=e.findBone(a),s==null))throw new Error(`Parent bone not found: ${a}`);const o=new Ii(e.bones.length,l.name,s);o.length=this.getValue(l,"length",0)*n,o.x=this.getValue(l,"x",0)*n,o.y=this.getValue(l,"y",0)*n,o.rotation=this.getValue(l,"rotation",0),o.scaleX=this.getValue(l,"scaleX",1),o.scaleY=this.getValue(l,"scaleY",1),o.shearX=this.getValue(l,"shearX",0),o.shearY=this.getValue(l,"shearY",0),o.transformMode=_n.transformModeFromString(this.getValue(l,"transform","normal")),o.skinRequired=this.getValue(l,"skin",!1),e.bones.push(o)}if(r.slots)for(let h=0;h<r.slots.length;h++){const l=r.slots[h],s=l.name,a=l.bone,o=e.findBone(a);if(o==null)throw new Error(`Slot bone not found: ${a}`);const c=new Yi(e.slots.length,s,o),d=this.getValue(l,"color",null);d!=null&&c.color.setFromString(d);const u=this.getValue(l,"dark",null);u!=null&&(c.darkColor=new O(1,1,1,1),c.darkColor.setFromString(u)),c.attachmentName=this.getValue(l,"attachment",null),c.blendMode=_n.blendModeFromString(this.getValue(l,"blend","normal")),e.slots.push(c)}if(r.ik)for(let h=0;h<r.ik.length;h++){const l=r.ik[h],s=new vi(l.name);s.order=this.getValue(l,"order",0),s.skinRequired=this.getValue(l,"skin",!1);for(let o=0;o<l.bones.length;o++){const c=l.bones[o],d=e.findBone(c);if(d==null)throw new Error(`IK bone not found: ${c}`);s.bones.push(d)}const a=l.target;if(s.target=e.findBone(a),s.target==null)throw new Error(`IK target bone not found: ${a}`);s.mix=this.getValue(l,"mix",1),s.softness=this.getValue(l,"softness",0)*n,s.bendDirection=this.getValue(l,"bendPositive",!0)?1:-1,s.compress=this.getValue(l,"compress",!1),s.stretch=this.getValue(l,"stretch",!1),s.uniform=this.getValue(l,"uniform",!1),e.ikConstraints.push(s)}if(r.transform)for(let h=0;h<r.transform.length;h++){const l=r.transform[h],s=new Ni(l.name);s.order=this.getValue(l,"order",0),s.skinRequired=this.getValue(l,"skin",!1);for(let o=0;o<l.bones.length;o++){const c=l.bones[o],d=e.findBone(c);if(d==null)throw new Error(`Transform constraint bone not found: ${c}`);s.bones.push(d)}const a=l.target;if(s.target=e.findBone(a),s.target==null)throw new Error(`Transform constraint target bone not found: ${a}`);s.local=this.getValue(l,"local",!1),s.relative=this.getValue(l,"relative",!1),s.offsetRotation=this.getValue(l,"rotation",0),s.offsetX=this.getValue(l,"x",0)*n,s.offsetY=this.getValue(l,"y",0)*n,s.offsetScaleX=this.getValue(l,"scaleX",0),s.offsetScaleY=this.getValue(l,"scaleY",0),s.offsetShearY=this.getValue(l,"shearY",0),s.rotateMix=this.getValue(l,"rotateMix",1),s.translateMix=this.getValue(l,"translateMix",1),s.scaleMix=this.getValue(l,"scaleMix",1),s.shearMix=this.getValue(l,"shearMix",1),e.transformConstraints.push(s)}if(r.path)for(let h=0;h<r.path.length;h++){const l=r.path[h],s=new Vi(l.name);s.order=this.getValue(l,"order",0),s.skinRequired=this.getValue(l,"skin",!1);for(let o=0;o<l.bones.length;o++){const c=l.bones[o],d=e.findBone(c);if(d==null)throw new Error(`Transform constraint bone not found: ${c}`);s.bones.push(d)}const a=l.target;if(s.target=e.findSlot(a),s.target==null)throw new Error(`Path target slot not found: ${a}`);s.positionMode=_n.positionModeFromString(this.getValue(l,"positionMode","percent")),s.spacingMode=_n.spacingModeFromString(this.getValue(l,"spacingMode","length")),s.rotateMode=_n.rotateModeFromString(this.getValue(l,"rotateMode","tangent")),s.offsetRotation=this.getValue(l,"rotation",0),s.position=this.getValue(l,"position",0),s.positionMode==dt.Fixed&&(s.position*=n),s.spacing=this.getValue(l,"spacing",0),(s.spacingMode==Ht.Length||s.spacingMode==Ht.Fixed)&&(s.spacing*=n),s.rotateMix=this.getValue(l,"rotateMix",1),s.translateMix=this.getValue(l,"translateMix",1),e.pathConstraints.push(s)}if(r.skins)for(let h=0;h<r.skins.length;h++){const l=r.skins[h],s=new ks(l.name);if(l.bones)for(let a=0;a<l.bones.length;a++){const o=e.findBone(l.bones[a]);if(o==null)throw new Error(`Skin bone not found: ${l.bones[h]}`);s.bones.push(o)}if(l.ik)for(let a=0;a<l.ik.length;a++){const o=e.findIkConstraint(l.ik[a]);if(o==null)throw new Error(`Skin IK constraint not found: ${l.ik[h]}`);s.constraints.push(o)}if(l.transform)for(let a=0;a<l.transform.length;a++){const o=e.findTransformConstraint(l.transform[a]);if(o==null)throw new Error(`Skin transform constraint not found: ${l.transform[h]}`);s.constraints.push(o)}if(l.path)for(let a=0;a<l.path.length;a++){const o=e.findPathConstraint(l.path[a]);if(o==null)throw new Error(`Skin path constraint not found: ${l.path[h]}`);s.constraints.push(o)}for(const a in l.attachments){const o=e.findSlot(a);if(o==null)throw new Error(`Slot not found: ${a}`);const c=l.attachments[a];for(const d in c){const u=this.readAttachment(c[d],s,o.index,d,e);u!=null&&s.setAttachment(o.index,d,u)}}e.skins.push(s),s.name=="default"&&(e.defaultSkin=s)}for(let h=0,l=this.linkedMeshes.length;h<l;h++){const s=this.linkedMeshes[h],a=s.skin==null?e.defaultSkin:e.findSkin(s.skin);if(a==null)throw new Error(`Skin not found: ${s.skin}`);const o=a.getAttachment(s.slotIndex,s.parent);if(o==null)throw new Error(`Parent mesh not found: ${s.parent}`);s.mesh.deformAttachment=s.inheritDeform?o:s.mesh,s.mesh.setParentMesh(o)}if(this.linkedMeshes.length=0,r.events)for(const h in r.events){const l=r.events[h],s=new ki(h);s.intValue=this.getValue(l,"int",0),s.floatValue=this.getValue(l,"float",0),s.stringValue=this.getValue(l,"string",""),s.audioPath=this.getValue(l,"audio",null),s.audioPath!=null&&(s.volume=this.getValue(l,"volume",1),s.balance=this.getValue(l,"balance",0)),e.events.push(s)}if(r.animations)for(const h in r.animations){const l=r.animations[h];this.readAnimation(l,h,e)}return e}readAttachment(t,n,e,r,i){const h=this.scale;switch(r=this.getValue(t,"name",r),this.getValue(t,"type","region")){case"region":{const s=this.getValue(t,"path",r),a=this.attachmentLoader.newRegionAttachment(n,r,s);if(a==null)return null;a.path=s,a.x=this.getValue(t,"x",0)*h,a.y=this.getValue(t,"y",0)*h,a.scaleX=this.getValue(t,"scaleX",1),a.scaleY=this.getValue(t,"scaleY",1),a.rotation=this.getValue(t,"rotation",0),a.width=t.width*h,a.height=t.height*h;const o=this.getValue(t,"color",null);return o!=null&&a.color.setFromString(o),a}case"boundingbox":{const s=this.attachmentLoader.newBoundingBoxAttachment(n,r);if(s==null)return null;this.readVertices(t,s,t.vertexCount<<1);const a=this.getValue(t,"color",null);return a!=null&&s.color.setFromString(a),s}case"mesh":case"linkedmesh":{const s=this.getValue(t,"path",r),a=this.attachmentLoader.newMeshAttachment(n,r,s);if(a==null)return null;a.path=s;const o=this.getValue(t,"color",null);o!=null&&a.color.setFromString(o),a.width=this.getValue(t,"width",0)*h,a.height=this.getValue(t,"height",0)*h;const c=this.getValue(t,"parent",null);if(c!=null)return this.linkedMeshes.push(new lo(a,this.getValue(t,"skin",null),e,c,this.getValue(t,"deform",!0))),a;const d=t.uvs;return this.readVertices(t,a,d.length),a.triangles=t.triangles,a.regionUVs=new Float32Array(d),a.edges=this.getValue(t,"edges",null),a.hullLength=this.getValue(t,"hull",0)*2,a}case"path":{const s=this.attachmentLoader.newPathAttachment(n,r);if(s==null)return null;s.closed=this.getValue(t,"closed",!1),s.constantSpeed=this.getValue(t,"constantSpeed",!0);const a=t.vertexCount;this.readVertices(t,s,a<<1);const o=k.newArray(a/3,0);for(let d=0;d<t.lengths.length;d++)o[d]=t.lengths[d]*h;s.lengths=o;const c=this.getValue(t,"color",null);return c!=null&&s.color.setFromString(c),s}case"point":{const s=this.attachmentLoader.newPointAttachment(n,r);if(s==null)return null;s.x=this.getValue(t,"x",0)*h,s.y=this.getValue(t,"y",0)*h,s.rotation=this.getValue(t,"rotation",0);const a=this.getValue(t,"color",null);return a!=null&&s.color.setFromString(a),s}case"clipping":{const s=this.attachmentLoader.newClippingAttachment(n,r);if(s==null)return null;const a=this.getValue(t,"end",null);if(a!=null){const d=i.findSlot(a);if(d==null)throw new Error(`Clipping end slot not found: ${a}`);s.endSlot=d}const o=t.vertexCount;this.readVertices(t,s,o<<1);const c=this.getValue(t,"color",null);return c!=null&&s.color.setFromString(c),s}}return null}readVertices(t,n,e){const r=this.scale;n.worldVerticesLength=e;const i=t.vertices;if(e==i.length){const s=k.toFloatArray(i);if(r!=1)for(let a=0,o=i.length;a<o;a++)s[a]*=r;n.vertices=s;return}const h=new Array,l=new Array;for(let s=0,a=i.length;s<a;){const o=i[s++];l.push(o);for(let c=s+o*4;s<c;s+=4)l.push(i[s]),h.push(i[s+1]*r),h.push(i[s+2]*r),h.push(i[s+3])}n.bones=l,n.vertices=k.toFloatArray(h)}readAnimation(t,n,e){const r=this.scale,i=new Array;let h=0;if(t.slots)for(const s in t.slots){const a=t.slots[s],o=e.findSlotIndex(s);if(o==-1)throw new Error(`Slot not found: ${s}`);for(const c in a){const d=a[c];if(c=="attachment"){const u=new Bn(d.length);u.slotIndex=o;let m=0;for(let g=0;g<d.length;g++){const x=d[g];u.setFrame(m++,this.getValue(x,"time",0),x.name)}i.push(u),h=Math.max(h,u.frames[u.getFrameCount()-1])}else if(c=="color"){const u=new de(d.length);u.slotIndex=o;let m=0;for(let g=0;g<d.length;g++){const x=d[g],w=new O;w.setFromString(x.color||"ffffffff"),u.setFrame(m,this.getValue(x,"time",0),w.r,w.g,w.b,w.a),this.readCurve(x,u,m),m++}i.push(u),h=Math.max(h,u.frames[(u.getFrameCount()-1)*de.ENTRIES])}else if(c=="twoColor"){const u=new Ft(d.length);u.slotIndex=o;let m=0;for(let g=0;g<d.length;g++){const x=d[g],w=new O,b=new O;w.setFromString(x.light),b.setFromString(x.dark),u.setFrame(m,this.getValue(x,"time",0),w.r,w.g,w.b,w.a,b.r,b.g,b.b),this.readCurve(x,u,m),m++}i.push(u),h=Math.max(h,u.frames[(u.getFrameCount()-1)*Ft.ENTRIES])}else throw new Error(`Invalid timeline type for a slot: ${c} (${s})`)}}if(t.bones)for(const s in t.bones){const a=t.bones[s],o=e.findBoneIndex(s);if(o==-1)throw new Error(`Bone not found: ${s}`);for(const c in a){const d=a[c];if(c==="rotate"){const u=new Kt(d.length);u.boneIndex=o;let m=0;for(let g=0;g<d.length;g++){const x=d[g];u.setFrame(m,this.getValue(x,"time",0),this.getValue(x,"angle",0)),this.readCurve(x,u,m),m++}i.push(u),h=Math.max(h,u.frames[(u.getFrameCount()-1)*Kt.ENTRIES])}else if(c==="translate"||c==="scale"||c==="shear"){let u=null,m=1,g=0;c==="scale"?(u=new Fe(d.length),g=1):c==="shear"?u=new Ye(d.length):(u=new Pe(d.length),m=r),u.boneIndex=o;let x=0;for(let w=0;w<d.length;w++){const b=d[w],E=this.getValue(b,"x",g),p=this.getValue(b,"y",g);u.setFrame(x,this.getValue(b,"time",0),E*m,p*m),this.readCurve(b,u,x),x++}i.push(u),h=Math.max(h,u.frames[(u.getFrameCount()-1)*Pe.ENTRIES])}else throw new Error(`Invalid timeline type for a bone: ${c} (${s})`)}}if(t.ik)for(const s in t.ik){const a=t.ik[s],o=e.findIkConstraint(s),c=new Jt(a.length);c.ikConstraintIndex=e.ikConstraints.indexOf(o);let d=0;for(let u=0;u<a.length;u++){const m=a[u];c.setFrame(d,this.getValue(m,"time",0),this.getValue(m,"mix",1),this.getValue(m,"softness",0)*r,this.getValue(m,"bendPositive",!0)?1:-1,this.getValue(m,"compress",!1),this.getValue(m,"stretch",!1)),this.readCurve(m,c,d),d++}i.push(c),h=Math.max(h,c.frames[(c.getFrameCount()-1)*Jt.ENTRIES])}if(t.transform)for(const s in t.transform){const a=t.transform[s],o=e.findTransformConstraint(s),c=new fe(a.length);c.transformConstraintIndex=e.transformConstraints.indexOf(o);let d=0;for(let u=0;u<a.length;u++){const m=a[u];c.setFrame(d,this.getValue(m,"time",0),this.getValue(m,"rotateMix",1),this.getValue(m,"translateMix",1),this.getValue(m,"scaleMix",1),this.getValue(m,"shearMix",1)),this.readCurve(m,c,d),d++}i.push(c),h=Math.max(h,c.frames[(c.getFrameCount()-1)*fe.ENTRIES])}if(t.path)for(const s in t.path){const a=t.path[s],o=e.findPathConstraintIndex(s);if(o==-1)throw new Error(`Path constraint not found: ${s}`);const c=e.pathConstraints[o];for(const d in a){const u=a[d];if(d==="position"||d==="spacing"){let m=null,g=1;d==="spacing"?(m=new cn(u.length),(c.spacingMode==Ht.Length||c.spacingMode==Ht.Fixed)&&(g=r)):(m=new ln(u.length),c.positionMode==dt.Fixed&&(g=r)),m.pathConstraintIndex=o;let x=0;for(let w=0;w<u.length;w++){const b=u[w];m.setFrame(x,this.getValue(b,"time",0),this.getValue(b,d,0)*g),this.readCurve(b,m,x),x++}i.push(m),h=Math.max(h,m.frames[(m.getFrameCount()-1)*ln.ENTRIES])}else if(d==="mix"){const m=new je(u.length);m.pathConstraintIndex=o;let g=0;for(let x=0;x<u.length;x++){const w=u[x];m.setFrame(g,this.getValue(w,"time",0),this.getValue(w,"rotateMix",1),this.getValue(w,"translateMix",1)),this.readCurve(w,m,g),g++}i.push(m),h=Math.max(h,m.frames[(m.getFrameCount()-1)*je.ENTRIES])}}}if(t.deform)for(const s in t.deform){const a=t.deform[s],o=e.findSkin(s);if(o==null){if(jt.FAIL_ON_NON_EXISTING_SKIN)throw new Error(`Skin not found: ${s}`);continue}for(const c in a){const d=a[c],u=e.findSlotIndex(c);if(u==-1)throw new Error(`Slot not found: ${d.name}`);for(const m in d){const g=d[m],x=o.getAttachment(u,m);if(x==null)throw new Error(`Deform attachment not found: ${g.name}`);const w=x.bones!=null,b=x.vertices,E=w?b.length/3*2:b.length,p=new Ei(g.length);p.slotIndex=u,p.attachment=x;let S=0;for(let y=0;y<g.length;y++){const M=g[y];let C;const I=this.getValue(M,"vertices",null);if(I==null)C=w?k.newFloatArray(E):b;else{C=k.newFloatArray(E);const R=this.getValue(M,"offset",0);if(k.arrayCopy(I,0,C,R,I.length),r!=1)for(let v=R,V=v+I.length;v<V;v++)C[v]*=r;if(!w)for(let v=0;v<E;v++)C[v]+=b[v]}p.setFrame(S,this.getValue(M,"time",0),C),this.readCurve(M,p,S),S++}i.push(p),h=Math.max(h,p.frames[p.getFrameCount()-1])}}}let l=t.drawOrder;if(l==null&&(l=t.draworder),l!=null){const s=new is(l.length),a=e.slots.length;let o=0;for(let c=0;c<l.length;c++){const d=l[c];let u=null;const m=this.getValue(d,"offsets",null);if(m!=null){u=k.newArray(a,-1);const g=k.newArray(a-m.length,0);let x=0,w=0;for(let b=0;b<m.length;b++){const E=m[b],p=e.findSlotIndex(E.slot);if(p==-1)throw new Error(`Slot not found: ${E.slot}`);for(;x!=p;)g[w++]=x++;u[x+E.offset]=x++}for(;x<a;)g[w++]=x++;for(let b=a-1;b>=0;b--)u[b]==-1&&(u[b]=g[--w])}s.setFrame(o++,this.getValue(d,"time",0),u)}i.push(s),h=Math.max(h,s.frames[s.getFrameCount()-1])}if(t.events){const s=new Cs(t.events.length);let a=0;for(let o=0;o<t.events.length;o++){const c=t.events[o],d=e.findEvent(c.name);if(d==null)throw new Error(`Event not found: ${c.name}`);const u=new Ri(k.toSinglePrecision(this.getValue(c,"time",0)),d);u.intValue=this.getValue(c,"int",d.intValue),u.floatValue=this.getValue(c,"float",d.floatValue),u.stringValue=this.getValue(c,"string",d.stringValue),u.data.audioPath!=null&&(u.volume=this.getValue(c,"volume",1),u.balance=this.getValue(c,"balance",0)),s.setFrame(a++,u)}i.push(s),h=Math.max(h,s.frames[s.getFrameCount()-1])}if(isNaN(h))throw new Error("Error while parsing animation, duration is NaN");e.animations.push(new Vt(n,i,h))}readCurve(t,n,e){if(t.hasOwnProperty("curve"))if(t.curve==="stepped")n.setStepped(e);else{const r=t.curve;n.setCurve(e,r,this.getValue(t,"c2",0),this.getValue(t,"c3",1),this.getValue(t,"c4",1))}}getValue(t,n,e){return t[n]!==void 0?t[n]:e}static blendModeFromString(t){if(t=t.toLowerCase(),t=="normal")return G.BLEND_MODES.NORMAL;if(t=="additive")return G.BLEND_MODES.ADD;if(t=="multiply")return G.BLEND_MODES.MULTIPLY;if(t=="screen")return G.BLEND_MODES.SCREEN;throw new Error(`Unknown blend mode: ${t}`)}static positionModeFromString(t){if(t=t.toLowerCase(),t=="fixed")return dt.Fixed;if(t=="percent")return dt.Percent;throw new Error(`Unknown position mode: ${t}`)}static spacingModeFromString(t){if(t=t.toLowerCase(),t=="length")return Ht.Length;if(t=="fixed")return Ht.Fixed;if(t=="percent")return Ht.Percent;throw new Error(`Unknown position mode: ${t}`)}static rotateModeFromString(t){if(t=t.toLowerCase(),t=="tangent")return ut.Tangent;if(t=="chain")return ut.Chain;if(t=="chainscale")return ut.ChainScale;throw new Error(`Unknown rotate mode: ${t}`)}static transformModeFromString(t){if(t=t.toLowerCase(),t=="normal")return z.Normal;if(t=="onlytranslation")return z.OnlyTranslation;if(t=="norotationorreflection")return z.NoRotationOrReflection;if(t=="noscale")return z.NoScale;if(t=="noscaleorreflection")return z.NoScaleOrReflection;throw new Error(`Unknown transform mode: ${t}`)}},lo=class{constructor(t,n,e,r,i){this.mesh=t,this.skin=n,this.slotIndex=e,this.parent=r,this.inheritDeform=i}};var co=Object.freeze({__proto__:null,Animation:Vt,AnimationState:Ne,AnimationStateAdapter:io,AnimationStateData:Ai,AtlasAttachmentLoader:Ti,Attachment:gi,AttachmentTimeline:Bn,Bone:Ci,BoneData:Ii,BoundingBoxAttachment:xi,ClippingAttachment:pi,ColorTimeline:de,ConstraintData:Rs,CurveTimeline:Ee,DeformTimeline:Ei,DrawOrderTimeline:is,Event:Ri,EventData:ki,EventQueue:yi,EventTimeline:Cs,EventType:Se,IkConstraint:ea,IkConstraintData:vi,IkConstraintTimeline:Jt,JitterEffect:so,MeshAttachment:ns,PathAttachment:ss,PathConstraint:rs,PathConstraintData:Vi,PathConstraintMixTimeline:je,PathConstraintPositionTimeline:ln,PathConstraintSpacingTimeline:cn,PointAttachment:wi,RegionAttachment:tt,RotateTimeline:Kt,ScaleTimeline:Fe,ShearTimeline:Ye,Skeleton:Pi,SkeletonBinary:Yt,SkeletonBounds:oo,SkeletonData:Fi,SkeletonJson:_n,Skin:ks,SkinEntry:Xi,Slot:bi,SlotData:Yi,SpacingMode:Ht,Spine:class extends An{createSkeleton(t){this.skeleton=new Pi(t),this.skeleton.updateWorldTransform(),this.stateData=new Ai(t),this.state=new Ne(this.stateData)}},SwirlEffect:Kr,TimelineType:Jr,TrackEntry:Is,TransformConstraint:na,TransformConstraintData:Ni,TransformConstraintTimeline:fe,TranslateTimeline:Pe,TwoColorTimeline:Ft,VertexAttachment:In});let Bi=class{constructor(t){if(t==null)throw new Error("name cannot be null.");this.name=t}};const sa=class extends Bi{constructor(t){super(t),this.id=(sa.nextID++&65535)<<11,this.worldVerticesLength=0}computeWorldVerticesOld(t,n){this.computeWorldVertices(t,0,this.worldVerticesLength,n,0,2)}computeWorldVertices(t,n,e,r,i,h){e=i+(e>>1)*h;const l=t.bone.skeleton,s=t.attachmentVertices;let a=this.vertices;const o=this.bones;if(o==null){s.length>0&&(a=s);const m=t.bone.matrix,g=m.tx,x=m.ty,w=m.a,b=m.c,E=m.b,p=m.d;for(let S=n,y=i;y<e;S+=2,y+=h){const M=a[S],C=a[S+1];r[y]=M*w+C*b+g,r[y+1]=M*E+C*p+x}return}let c=0,d=0;for(let m=0;m<n;m+=2){const g=o[c];c+=g+1,d+=g}const u=l.bones;if(s.length==0)for(let m=i,g=d*3;m<e;m+=h){let x=0,w=0,b=o[c++];for(b+=c;c<b;c++,g+=3){const E=u[o[c]].matrix,p=a[g],S=a[g+1],y=a[g+2];x+=(p*E.a+S*E.c+E.tx)*y,w+=(p*E.b+S*E.d+E.ty)*y}r[m]=x,r[m+1]=w}else{const m=s;for(let g=i,x=d*3,w=d<<1;g<e;g+=h){let b=0,E=0,p=o[c++];for(p+=c;c<p;c++,x+=3,w+=2){const S=u[o[c]].matrix,y=a[x]+m[w],M=a[x+1]+m[w+1],C=a[x+2];b+=(y*S.a+M*S.c+S.tx)*C,E+=(y*S.b+M*S.d+S.ty)*C}r[g]=b,r[g+1]=E}}}applyDeform(t){return this==t}};let kn=sa;kn.nextID=0;let ia=class extends kn{constructor(t){super(t),this.type=Z.BoundingBox,this.color=new O(1,1,1,1)}},ra=class extends kn{constructor(t){super(t),this.type=Z.Clipping,this.color=new O(.2275,.2275,.8078,1)}},Di=class extends kn{constructor(t){super(t),this.type=Z.Mesh,this.color=new O(1,1,1,1),this.inheritDeform=!1,this.tempColor=new O(0,0,0,0)}applyDeform(t){return this==t||this.inheritDeform&&this.parentMesh==t}getParentMesh(){return this.parentMesh}setParentMesh(t){this.parentMesh=t,t!=null&&(this.bones=t.bones,this.vertices=t.vertices,this.worldVerticesLength=t.worldVerticesLength,this.regionUVs=t.regionUVs,this.triangles=t.triangles,this.hullLength=t.hullLength,this.worldVerticesLength=t.worldVerticesLength)}},us=class extends kn{constructor(t){super(t),this.type=Z.Path,this.closed=!1,this.constantSpeed=!1,this.color=new O(1,1,1,1)}},aa=class extends kn{constructor(t){super(t),this.type=Z.Point,this.color=new O(.38,.94,0,1)}computeWorldPosition(t,n){const e=t.matrix;return n.x=this.x*e.a+this.y*e.c+t.worldX,n.y=this.x*e.b+this.y*e.d+t.worldY,n}computeWorldRotation(t){const n=t.matrix,e=T.cosDeg(this.rotation),r=T.sinDeg(this.rotation),i=e*n.a+r*n.c,h=e*n.b+r*n.d;return Math.atan2(h,i)*T.radDeg}},_i=class{constructor(t,n){if(this.attachmentVertices=new Array,t==null)throw new Error("data cannot be null.");if(n==null)throw new Error("bone cannot be null.");this.data=t,this.bone=n,this.color=new O,this.darkColor=t.darkColor==null?null:new O,this.setToSetupPose(),this.blendMode=this.data.blendMode}getAttachment(){return this.attachment}setAttachment(t){this.attachment!=t&&(this.attachment=t,this.attachmentTime=this.bone.skeleton.time,this.attachmentVertices.length=0)}setAttachmentTime(t){this.attachmentTime=this.bone.skeleton.time-t}getAttachmentTime(){return this.bone.skeleton.time-this.attachmentTime}setToSetupPose(){this.color.setFromColor(this.data.color),this.darkColor!=null&&this.darkColor.setFromColor(this.data.darkColor),this.data.attachmentName==null?this.attachment=null:(this.attachment=null,this.setAttachment(this.bone.skeleton.getAttachment(this.data.index,this.data.attachmentName)))}};const te=class extends Bi{constructor(t){super(t),this.type=Z.Region,this.x=0,this.y=0,this.scaleX=1,this.scaleY=1,this.rotation=0,this.width=0,this.height=0,this.color=new O(1,1,1,1),this.offset=k.newFloatArray(8),this.uvs=k.newFloatArray(8),this.tempColor=new O(1,1,1,1)}updateOffset(){const t=this.width/this.region.originalWidth*this.scaleX,n=this.height/this.region.originalHeight*this.scaleY,e=-this.width/2*this.scaleX+this.region.offsetX*t,r=-this.height/2*this.scaleY+this.region.offsetY*n,i=e+this.region.width*t,h=r+this.region.height*n,l=this.rotation*Math.PI/180,s=Math.cos(l),a=Math.sin(l),o=e*s+this.x,c=e*a,d=r*s+this.y,u=r*a,m=i*s+this.x,g=i*a,x=h*s+this.y,w=h*a,b=this.offset;b[te.OX1]=o-u,b[te.OY1]=d+c,b[te.OX2]=o-w,b[te.OY2]=x+c,b[te.OX3]=m-w,b[te.OY3]=x+g,b[te.OX4]=m-u,b[te.OY4]=d+g}setRegion(t){this.region=t;const n=this.uvs;t.rotate?(n[2]=t.u,n[3]=t.v2,n[4]=t.u,n[5]=t.v,n[6]=t.u2,n[7]=t.v,n[0]=t.u2,n[1]=t.v2):(n[0]=t.u,n[1]=t.v2,n[2]=t.u,n[3]=t.v,n[4]=t.u2,n[5]=t.v,n[6]=t.u2,n[7]=t.v2)}computeWorldVertices(t,n,e,r){const i=this.offset,h=t instanceof _i?t.bone.matrix:t.matrix,l=h.tx,s=h.ty,a=h.a,o=h.c,c=h.b,d=h.d;let u=0,m=0;u=i[te.OX1],m=i[te.OY1],n[e]=u*a+m*o+l,n[e+1]=u*c+m*d+s,e+=r,u=i[te.OX2],m=i[te.OY2],n[e]=u*a+m*o+l,n[e+1]=u*c+m*d+s,e+=r,u=i[te.OX3],m=i[te.OY3],n[e]=u*a+m*o+l,n[e+1]=u*c+m*d+s,e+=r,u=i[te.OX4],m=i[te.OY4],n[e]=u*a+m*o+l,n[e+1]=u*c+m*d+s}};let et=te;et.OX1=0,et.OY1=1,et.OX2=2,et.OY2=3,et.OX3=4,et.OY3=5,et.OX4=6,et.OY4=7,et.X1=0,et.Y1=1,et.C1R=2,et.C1G=3,et.C1B=4,et.C1A=5,et.U1=6,et.V1=7,et.X2=8,et.Y2=9,et.C2R=10,et.C2G=11,et.C2B=12,et.C2A=13,et.U2=14,et.V2=15,et.X3=16,et.Y3=17,et.C3R=18,et.C3G=19,et.C3B=20,et.C3A=21,et.U3=22,et.V3=23,et.X4=24,et.Y4=25,et.C4R=26,et.C4G=27,et.C4B=28,et.C4A=29,et.U4=30,et.V4=31;let ho=class{constructor(t,n){this.jitterX=0,this.jitterY=0,this.jitterX=t,this.jitterY=n}begin(t){}transform(t,n,e,r){t.x+=T.randomTriangular(-this.jitterX,this.jitterY),t.y+=T.randomTriangular(-this.jitterX,this.jitterY)}end(){}};const oa=class{constructor(f){this.centerX=0,this.centerY=0,this.radius=0,this.angle=0,this.worldX=0,this.worldY=0,this.radius=f}begin(f){this.worldX=f.x+this.centerX,this.worldY=f.y+this.centerY}transform(f,t,n,e){const r=this.angle*T.degreesToRadians,i=f.x-this.worldX,h=f.y-this.worldY,l=Math.sqrt(i*i+h*h);if(l<this.radius){const s=oa.interpolation.apply(0,r,(this.radius-l)/this.radius),a=Math.cos(s),o=Math.sin(s);f.x=a*i-o*h+this.worldX,f.y=o*i+a*h+this.worldY}}end(){}};let la=oa;la.interpolation=new Ss(2);let _t=class{constructor(t,n,e){if(t==null)throw new Error("name cannot be null.");if(n==null)throw new Error("timelines cannot be null.");this.name=t,this.timelines=n,this.duration=e}apply(t,n,e,r,i,h,l,s){if(t==null)throw new Error("skeleton cannot be null.");r&&this.duration!=0&&(e%=this.duration,n>0&&(n%=this.duration));const a=this.timelines;for(let o=0,c=a.length;o<c;o++)a[o].apply(t,n,e,i,h,l,s)}static binarySearch(t,n,e=1){let r=0,i=t.length/e-2;if(i==0)return e;let h=i>>>1;for(;;){if(t[(h+1)*e]<=n?r=h+1:i=h,r==i)return(r+1)*e;h=r+i>>>1}}static linearSearch(t,n,e){for(let r=0,i=t.length-e;r<=i;r+=e)if(t[r]>n)return r;return-1}};var ca=(f=>(f[f.rotate=0]="rotate",f[f.translate=1]="translate",f[f.scale=2]="scale",f[f.shear=3]="shear",f[f.attachment=4]="attachment",f[f.color=5]="color",f[f.deform=6]="deform",f[f.event=7]="event",f[f.drawOrder=8]="drawOrder",f[f.ikConstraint=9]="ikConstraint",f[f.transformConstraint=10]="transformConstraint",f[f.pathConstraintPosition=11]="pathConstraintPosition",f[f.pathConstraintSpacing=12]="pathConstraintSpacing",f[f.pathConstraintMix=13]="pathConstraintMix",f[f.twoColor=14]="twoColor",f))(ca||{});const Nt=class{constructor(f){if(f<=0)throw new Error(`frameCount must be > 0: ${f}`);this.curves=k.newFloatArray((f-1)*Nt.BEZIER_SIZE)}getFrameCount(){return this.curves.length/Nt.BEZIER_SIZE+1}setLinear(f){this.curves[f*Nt.BEZIER_SIZE]=Nt.LINEAR}setStepped(f){this.curves[f*Nt.BEZIER_SIZE]=Nt.STEPPED}getCurveType(f){const t=f*Nt.BEZIER_SIZE;if(t==this.curves.length)return Nt.LINEAR;const n=this.curves[t];return n==Nt.LINEAR?Nt.LINEAR:n==Nt.STEPPED?Nt.STEPPED:Nt.BEZIER}setCurve(f,t,n,e,r){const i=(-t*2+e)*.03,h=(-n*2+r)*.03,l=((t-e)*3+1)*.006,s=((n-r)*3+1)*.006;let a=i*2+l,o=h*2+s,c=t*.3+i+l*.16666667,d=n*.3+h+s*.16666667,u=f*Nt.BEZIER_SIZE;const m=this.curves;m[u++]=Nt.BEZIER;let g=c,x=d;for(let w=u+Nt.BEZIER_SIZE-1;u<w;u+=2)m[u]=g,m[u+1]=x,c+=a,d+=o,a+=l,o+=s,g+=c,x+=d}getCurvePercent(f,t){t=T.clamp(t,0,1);const n=this.curves;let e=f*Nt.BEZIER_SIZE;const r=n[e];if(r==Nt.LINEAR)return t;if(r==Nt.STEPPED)return 0;e++;let i=0;for(let l=e,s=e+Nt.BEZIER_SIZE-1;e<s;e+=2)if(i=n[e],i>=t){let a,o;return e==l?(a=0,o=0):(a=n[e-2],o=n[e-1]),o+(n[e+1]-o)*(t-a)/(i-a)}const h=n[e-1];return h+(1-h)*(t-i)/(1-i)}};let ye=Nt;ye.LINEAR=0,ye.STEPPED=1,ye.BEZIER=2,ye.BEZIER_SIZE=10*2-1;const vn=class extends ye{constructor(f){super(f),this.frames=k.newFloatArray(f<<1)}getPropertyId(){return(0<<24)+this.boneIndex}setFrame(f,t,n){f<<=1,this.frames[f]=t,this.frames[f+vn.ROTATION]=n}apply(f,t,n,e,r,i,h){const l=this.frames,s=f.bones[this.boneIndex];if(n<l[0]){switch(i){case A.setup:s.rotation=s.data.rotation;return;case A.first:const m=s.data.rotation-s.rotation;s.rotation+=(m-(16384-(16384.499999999996-m/360|0))*360)*r}return}if(n>=l[l.length-vn.ENTRIES]){let m=l[l.length+vn.PREV_ROTATION];switch(i){case A.setup:s.rotation=s.data.rotation+m*r;break;case A.first:case A.replace:m+=s.data.rotation-s.rotation,m-=(16384-(16384.499999999996-m/360|0))*360;case A.add:s.rotation+=m*r}return}const a=_t.binarySearch(l,n,vn.ENTRIES),o=l[a+vn.PREV_ROTATION],c=l[a],d=this.getCurvePercent((a>>1)-1,1-(n-c)/(l[a+vn.PREV_TIME]-c));let u=l[a+vn.ROTATION]-o;switch(u=o+(u-(16384-(16384.499999999996-u/360|0))*360)*d,i){case A.setup:s.rotation=s.data.rotation+(u-(16384-(16384.499999999996-u/360|0))*360)*r;break;case A.first:case A.replace:u+=s.data.rotation-s.rotation;case A.add:s.rotation+=(u-(16384-(16384.499999999996-u/360|0))*360)*r}}};let me=vn;me.ENTRIES=2,me.PREV_TIME=-2,me.PREV_ROTATION=-1,me.ROTATION=1;const ge=class extends ye{constructor(f){super(f),this.frames=k.newFloatArray(f*ge.ENTRIES)}getPropertyId(){return(1<<24)+this.boneIndex}setFrame(f,t,n,e){f*=ge.ENTRIES,this.frames[f]=t,this.frames[f+ge.X]=n,this.frames[f+ge.Y]=e}apply(f,t,n,e,r,i,h){const l=this.frames,s=f.bones[this.boneIndex];if(n<l[0]){switch(i){case A.setup:s.x=s.data.x,s.y=s.data.y;return;case A.first:s.x+=(s.data.x-s.x)*r,s.y+=(s.data.y-s.y)*r}return}let a=0,o=0;if(n>=l[l.length-ge.ENTRIES])a=l[l.length+ge.PREV_X],o=l[l.length+ge.PREV_Y];else{const c=_t.binarySearch(l,n,ge.ENTRIES);a=l[c+ge.PREV_X],o=l[c+ge.PREV_Y];const d=l[c],u=this.getCurvePercent(c/ge.ENTRIES-1,1-(n-d)/(l[c+ge.PREV_TIME]-d));a+=(l[c+ge.X]-a)*u,o+=(l[c+ge.Y]-o)*u}switch(i){case A.setup:s.x=s.data.x+a*r,s.y=s.data.y+o*r;break;case A.first:case A.replace:s.x+=(s.data.x+a-s.x)*r,s.y+=(s.data.y+o-s.y)*r;break;case A.add:s.x+=a*r,s.y+=o*r}}};let Ze=ge;Ze.ENTRIES=3,Ze.PREV_TIME=-3,Ze.PREV_X=-2,Ze.PREV_Y=-1,Ze.X=1,Ze.Y=2;let We=class extends Ze{constructor(t){super(t)}getPropertyId(){return(2<<24)+this.boneIndex}apply(t,n,e,r,i,h,l){const s=this.frames,a=t.bones[this.boneIndex];if(e<s[0]){switch(h){case A.setup:a.scaleX=a.data.scaleX,a.scaleY=a.data.scaleY;return;case A.first:a.scaleX+=(a.data.scaleX-a.scaleX)*i,a.scaleY+=(a.data.scaleY-a.scaleY)*i}return}let o=0,c=0;if(e>=s[s.length-We.ENTRIES])o=s[s.length+We.PREV_X]*a.data.scaleX,c=s[s.length+We.PREV_Y]*a.data.scaleY;else{const d=_t.binarySearch(s,e,We.ENTRIES);o=s[d+We.PREV_X],c=s[d+We.PREV_Y];const u=s[d],m=this.getCurvePercent(d/We.ENTRIES-1,1-(e-u)/(s[d+We.PREV_TIME]-u));o=(o+(s[d+We.X]-o)*m)*a.data.scaleX,c=(c+(s[d+We.Y]-c)*m)*a.data.scaleY}if(i==1)h==A.add?(a.scaleX+=o-a.data.scaleX,a.scaleY+=c-a.data.scaleY):(a.scaleX=o,a.scaleY=c);else{let d=0,u=0;if(l==Q.mixOut)switch(h){case A.setup:d=a.data.scaleX,u=a.data.scaleY,a.scaleX=d+(Math.abs(o)*T.signum(d)-d)*i,a.scaleY=u+(Math.abs(c)*T.signum(u)-u)*i;break;case A.first:case A.replace:d=a.scaleX,u=a.scaleY,a.scaleX=d+(Math.abs(o)*T.signum(d)-d)*i,a.scaleY=u+(Math.abs(c)*T.signum(u)-u)*i;break;case A.add:d=a.scaleX,u=a.scaleY,a.scaleX=d+(Math.abs(o)*T.signum(d)-a.data.scaleX)*i,a.scaleY=u+(Math.abs(c)*T.signum(u)-a.data.scaleY)*i}else switch(h){case A.setup:d=Math.abs(a.data.scaleX)*T.signum(o),u=Math.abs(a.data.scaleY)*T.signum(c),a.scaleX=d+(o-d)*i,a.scaleY=u+(c-u)*i;break;case A.first:case A.replace:d=Math.abs(a.scaleX)*T.signum(o),u=Math.abs(a.scaleY)*T.signum(c),a.scaleX=d+(o-d)*i,a.scaleY=u+(c-u)*i;break;case A.add:d=T.signum(o),u=T.signum(c),a.scaleX=Math.abs(a.scaleX)*d+(o-Math.abs(a.data.scaleX)*d)*i,a.scaleY=Math.abs(a.scaleY)*u+(c-Math.abs(a.data.scaleY)*u)*i}}}},qe=class extends Ze{constructor(t){super(t)}getPropertyId(){return(3<<24)+this.boneIndex}apply(t,n,e,r,i,h,l){const s=this.frames,a=t.bones[this.boneIndex];if(e<s[0]){switch(h){case A.setup:a.shearX=a.data.shearX,a.shearY=a.data.shearY;return;case A.first:a.shearX+=(a.data.shearX-a.shearX)*i,a.shearY+=(a.data.shearY-a.shearY)*i}return}let o=0,c=0;if(e>=s[s.length-qe.ENTRIES])o=s[s.length+qe.PREV_X],c=s[s.length+qe.PREV_Y];else{const d=_t.binarySearch(s,e,qe.ENTRIES);o=s[d+qe.PREV_X],c=s[d+qe.PREV_Y];const u=s[d],m=this.getCurvePercent(d/qe.ENTRIES-1,1-(e-u)/(s[d+qe.PREV_TIME]-u));o=o+(s[d+qe.X]-o)*m,c=c+(s[d+qe.Y]-c)*m}switch(h){case A.setup:a.shearX=a.data.shearX+o*i,a.shearY=a.data.shearY+c*i;break;case A.first:case A.replace:a.shearX+=(a.data.shearX+o-a.shearX)*i,a.shearY+=(a.data.shearY+c-a.shearY)*i;break;case A.add:a.shearX+=o*i,a.shearY+=c*i}}};const yt=class extends ye{constructor(f){super(f),this.frames=k.newFloatArray(f*yt.ENTRIES)}getPropertyId(){return(5<<24)+this.slotIndex}setFrame(f,t,n,e,r,i){f*=yt.ENTRIES,this.frames[f]=t,this.frames[f+yt.R]=n,this.frames[f+yt.G]=e,this.frames[f+yt.B]=r,this.frames[f+yt.A]=i}apply(f,t,n,e,r,i,h){const l=f.slots[this.slotIndex],s=this.frames;if(n<s[0]){switch(i){case A.setup:l.color.setFromColor(l.data.color);return;case A.first:const u=l.color,m=l.data.color;u.add((m.r-u.r)*r,(m.g-u.g)*r,(m.b-u.b)*r,(m.a-u.a)*r)}return}let a=0,o=0,c=0,d=0;if(n>=s[s.length-yt.ENTRIES]){const u=s.length;a=s[u+yt.PREV_R],o=s[u+yt.PREV_G],c=s[u+yt.PREV_B],d=s[u+yt.PREV_A]}else{const u=_t.binarySearch(s,n,yt.ENTRIES);a=s[u+yt.PREV_R],o=s[u+yt.PREV_G],c=s[u+yt.PREV_B],d=s[u+yt.PREV_A];const m=s[u],g=this.getCurvePercent(u/yt.ENTRIES-1,1-(n-m)/(s[u+yt.PREV_TIME]-m));a+=(s[u+yt.R]-a)*g,o+=(s[u+yt.G]-o)*g,c+=(s[u+yt.B]-c)*g,d+=(s[u+yt.A]-d)*g}if(r==1)l.color.set(a,o,c,d);else{const u=l.color;i==A.setup&&u.setFromColor(l.data.color),u.add((a-u.r)*r,(o-u.g)*r,(c-u.b)*r,(d-u.a)*r)}}};let Xe=yt;Xe.ENTRIES=5,Xe.PREV_TIME=-5,Xe.PREV_R=-4,Xe.PREV_G=-3,Xe.PREV_B=-2,Xe.PREV_A=-1,Xe.R=1,Xe.G=2,Xe.B=3,Xe.A=4;const ot=class extends ye{constructor(f){super(f),this.frames=k.newFloatArray(f*ot.ENTRIES)}getPropertyId(){return(14<<24)+this.slotIndex}setFrame(f,t,n,e,r,i,h,l,s){f*=ot.ENTRIES,this.frames[f]=t,this.frames[f+ot.R]=n,this.frames[f+ot.G]=e,this.frames[f+ot.B]=r,this.frames[f+ot.A]=i,this.frames[f+ot.R2]=h,this.frames[f+ot.G2]=l,this.frames[f+ot.B2]=s}apply(f,t,n,e,r,i,h){const l=f.slots[this.slotIndex],s=this.frames;if(n<s[0]){switch(i){case A.setup:l.color.setFromColor(l.data.color),l.darkColor.setFromColor(l.data.darkColor);return;case A.first:const x=l.color,w=l.darkColor,b=l.data.color,E=l.data.darkColor;x.add((b.r-x.r)*r,(b.g-x.g)*r,(b.b-x.b)*r,(b.a-x.a)*r),w.add((E.r-w.r)*r,(E.g-w.g)*r,(E.b-w.b)*r,0)}return}let a=0,o=0,c=0,d=0,u=0,m=0,g=0;if(n>=s[s.length-ot.ENTRIES]){const x=s.length;a=s[x+ot.PREV_R],o=s[x+ot.PREV_G],c=s[x+ot.PREV_B],d=s[x+ot.PREV_A],u=s[x+ot.PREV_R2],m=s[x+ot.PREV_G2],g=s[x+ot.PREV_B2]}else{const x=_t.binarySearch(s,n,ot.ENTRIES);a=s[x+ot.PREV_R],o=s[x+ot.PREV_G],c=s[x+ot.PREV_B],d=s[x+ot.PREV_A],u=s[x+ot.PREV_R2],m=s[x+ot.PREV_G2],g=s[x+ot.PREV_B2];const w=s[x],b=this.getCurvePercent(x/ot.ENTRIES-1,1-(n-w)/(s[x+ot.PREV_TIME]-w));a+=(s[x+ot.R]-a)*b,o+=(s[x+ot.G]-o)*b,c+=(s[x+ot.B]-c)*b,d+=(s[x+ot.A]-d)*b,u+=(s[x+ot.R2]-u)*b,m+=(s[x+ot.G2]-m)*b,g+=(s[x+ot.B2]-g)*b}if(r==1)l.color.set(a,o,c,d),l.darkColor.set(u,m,g,1);else{const x=l.color,w=l.darkColor;i==A.setup&&(x.setFromColor(l.data.color),w.setFromColor(l.data.darkColor)),x.add((a-x.r)*r,(o-x.g)*r,(c-x.b)*r,(d-x.a)*r),w.add((u-w.r)*r,(m-w.g)*r,(g-w.b)*r,0)}}};let Lt=ot;Lt.ENTRIES=8,Lt.PREV_TIME=-8,Lt.PREV_R=-7,Lt.PREV_G=-6,Lt.PREV_B=-5,Lt.PREV_A=-4,Lt.PREV_R2=-3,Lt.PREV_G2=-2,Lt.PREV_B2=-1,Lt.R=1,Lt.G=2,Lt.B=3,Lt.A=4,Lt.R2=5,Lt.G2=6,Lt.B2=7;let vs=class{constructor(t){this.frames=k.newFloatArray(t),this.attachmentNames=new Array(t)}getPropertyId(){return(4<<24)+this.slotIndex}getFrameCount(){return this.frames.length}setFrame(t,n,e){this.frames[t]=n,this.attachmentNames[t]=e}apply(t,n,e,r,i,h,l){const s=t.slots[this.slotIndex];if(l==Q.mixOut&&h==A.setup){const d=s.data.attachmentName;s.setAttachment(d==null?null:t.getAttachment(this.slotIndex,d));return}const a=this.frames;if(e<a[0]){if(h==A.setup||h==A.first){const d=s.data.attachmentName;s.setAttachment(d==null?null:t.getAttachment(this.slotIndex,d))}return}let o=0;e>=a[a.length-1]?o=a.length-1:o=_t.binarySearch(a,e,1)-1;const c=this.attachmentNames[o];t.slots[this.slotIndex].setAttachment(c==null?null:t.getAttachment(this.slotIndex,c))}},ha=null,da=class extends ye{constructor(t){super(t),this.frames=k.newFloatArray(t),this.frameVertices=new Array(t),ha==null&&(ha=k.newFloatArray(64))}getPropertyId(){return(6<<27)+Number(this.attachment.id)+this.slotIndex}setFrame(t,n,e){this.frames[t]=n,this.frameVertices[t]=e}apply(t,n,e,r,i,h,l){const s=t.slots[this.slotIndex],a=s.getAttachment();if(!(a instanceof kn)||!a.applyDeform(this.attachment))return;const o=s.attachmentVertices;o.length==0&&(h=A.setup);const c=this.frameVertices,d=c[0].length,u=this.frames;if(e<u[0]){const p=a;switch(h){case A.setup:o.length=0;return;case A.first:if(i==1){o.length=0;break}const S=k.setArraySize(o,d);if(p.bones==null){const y=p.vertices;for(let M=0;M<d;M++)S[M]+=(y[M]-S[M])*i}else{i=1-i;for(let y=0;y<d;y++)S[y]*=i}}return}const m=k.setArraySize(o,d);if(e>=u[u.length-1]){const p=c[u.length-1];if(i==1)if(h==A.add){const S=a;if(S.bones==null){const y=S.vertices;for(let M=0;M<d;M++)m[M]+=p[M]-y[M]}else for(let y=0;y<d;y++)m[y]+=p[y]}else k.arrayCopy(p,0,m,0,d);else switch(h){case A.setup:{const y=a;if(y.bones==null){const M=y.vertices;for(let C=0;C<d;C++){const I=M[C];m[C]=I+(p[C]-I)*i}}else for(let M=0;M<d;M++)m[M]=p[M]*i;break}case A.first:case A.replace:for(let y=0;y<d;y++)m[y]+=(p[y]-m[y])*i;case A.add:const S=a;if(S.bones==null){const y=S.vertices;for(let M=0;M<d;M++)m[M]+=(p[M]-y[M])*i}else for(let y=0;y<d;y++)m[y]+=p[y]*i}return}const g=_t.binarySearch(u,e),x=c[g-1],w=c[g],b=u[g],E=this.getCurvePercent(g-1,1-(e-b)/(u[g-1]-b));if(i==1)if(h==A.add){const p=a;if(p.bones==null){const S=p.vertices;for(let y=0;y<d;y++){const M=x[y];m[y]+=M+(w[y]-M)*E-S[y]}}else for(let S=0;S<d;S++){const y=x[S];m[S]+=y+(w[S]-y)*E}}else for(let p=0;p<d;p++){const S=x[p];m[p]=S+(w[p]-S)*E}else switch(h){case A.setup:{const S=a;if(S.bones==null){const y=S.vertices;for(let M=0;M<d;M++){const C=x[M],I=y[M];m[M]=I+(C+(w[M]-C)*E-I)*i}}else for(let y=0;y<d;y++){const M=x[y];m[y]=(M+(w[y]-M)*E)*i}break}case A.first:case A.replace:for(let S=0;S<d;S++){const y=x[S];m[S]+=(y+(w[S]-y)*E-m[S])*i}break;case A.add:const p=a;if(p.bones==null){const S=p.vertices;for(let y=0;y<d;y++){const M=x[y];m[y]+=(M+(w[y]-M)*E-S[y])*i}}else for(let S=0;S<d;S++){const y=x[S];m[S]+=(y+(w[S]-y)*E)*i}}}},fa=class{constructor(t){this.frames=k.newFloatArray(t),this.events=new Array(t)}getPropertyId(){return 7<<24}getFrameCount(){return this.frames.length}setFrame(t,n){this.frames[t]=n.time,this.events[t]=n}apply(t,n,e,r,i,h,l){if(r==null)return;const s=this.frames,a=this.frames.length;if(n>e)this.apply(t,n,Number.MAX_VALUE,r,i,h,l),n=-1;else if(n>=s[a-1])return;if(e<s[0])return;let o=0;if(n<s[0])o=0;else{o=_t.binarySearch(s,n);const c=s[o];for(;o>0&&s[o-1]==c;)o--}for(;o<a&&e>=s[o];o++)r.push(this.events[o])}},Vs=class{constructor(t){this.frames=k.newFloatArray(t),this.drawOrders=new Array(t)}getPropertyId(){return 8<<24}getFrameCount(){return this.frames.length}setFrame(t,n,e){this.frames[t]=n,this.drawOrders[t]=e}apply(t,n,e,r,i,h,l){const s=t.drawOrder,a=t.slots;if(l==Q.mixOut&&h==A.setup){k.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}const o=this.frames;if(e<o[0]){(h==A.setup||h==A.first)&&k.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}let c=0;e>=o[o.length-1]?c=o.length-1:c=_t.binarySearch(o,e)-1;const d=this.drawOrders[c];if(d==null)k.arrayCopy(a,0,s,0,a.length);else for(let u=0,m=d.length;u<m;u++)s[u]=a[d[u]]}};const gt=class extends ye{constructor(f){super(f),this.frames=k.newFloatArray(f*gt.ENTRIES)}getPropertyId(){return(9<<24)+this.ikConstraintIndex}setFrame(f,t,n,e,r,i){f*=gt.ENTRIES,this.frames[f]=t,this.frames[f+gt.MIX]=n,this.frames[f+gt.BEND_DIRECTION]=e,this.frames[f+gt.COMPRESS]=r?1:0,this.frames[f+gt.STRETCH]=i?1:0}apply(f,t,n,e,r,i,h){const l=this.frames,s=f.ikConstraints[this.ikConstraintIndex];if(n<l[0]){switch(i){case A.setup:s.mix=s.data.mix,s.bendDirection=s.data.bendDirection,s.compress=s.data.compress,s.stretch=s.data.stretch;return;case A.first:s.mix+=(s.data.mix-s.mix)*r,s.bendDirection=s.data.bendDirection,s.compress=s.data.compress,s.stretch=s.data.stretch}return}if(n>=l[l.length-gt.ENTRIES]){i==A.setup?(s.mix=s.data.mix+(l[l.length+gt.PREV_MIX]-s.data.mix)*r,h==Q.mixOut?(s.bendDirection=s.data.bendDirection,s.compress=s.data.compress,s.stretch=s.data.stretch):(s.bendDirection=l[l.length+gt.PREV_BEND_DIRECTION],s.compress=l[l.length+gt.PREV_COMPRESS]!=0,s.stretch=l[l.length+gt.PREV_STRETCH]!=0)):(s.mix+=(l[l.length+gt.PREV_MIX]-s.mix)*r,h==Q.mixIn&&(s.bendDirection=l[l.length+gt.PREV_BEND_DIRECTION],s.compress=l[l.length+gt.PREV_COMPRESS]!=0,s.stretch=l[l.length+gt.PREV_STRETCH]!=0));return}const a=_t.binarySearch(l,n,gt.ENTRIES),o=l[a+gt.PREV_MIX],c=l[a],d=this.getCurvePercent(a/gt.ENTRIES-1,1-(n-c)/(l[a+gt.PREV_TIME]-c));i==A.setup?(s.mix=s.data.mix+(o+(l[a+gt.MIX]-o)*d-s.data.mix)*r,h==Q.mixOut?(s.bendDirection=s.data.bendDirection,s.compress=s.data.compress,s.stretch=s.data.stretch):(s.bendDirection=l[a+gt.PREV_BEND_DIRECTION],s.compress=l[a+gt.PREV_COMPRESS]!=0,s.stretch=l[a+gt.PREV_STRETCH]!=0)):(s.mix+=(o+(l[a+gt.MIX]-o)*d-s.mix)*r,h==Q.mixIn&&(s.bendDirection=l[a+gt.PREV_BEND_DIRECTION],s.compress=l[a+gt.PREV_COMPRESS]!=0,s.stretch=l[a+gt.PREV_STRETCH]!=0))}};let Be=gt;Be.ENTRIES=5,Be.PREV_TIME=-5,Be.PREV_MIX=-4,Be.PREV_BEND_DIRECTION=-3,Be.PREV_COMPRESS=-2,Be.PREV_STRETCH=-1,Be.MIX=1,Be.BEND_DIRECTION=2,Be.COMPRESS=3,Be.STRETCH=4;const Mt=class extends ye{constructor(f){super(f),this.frames=k.newFloatArray(f*Mt.ENTRIES)}getPropertyId(){return(10<<24)+this.transformConstraintIndex}setFrame(f,t,n,e,r,i){f*=Mt.ENTRIES,this.frames[f]=t,this.frames[f+Mt.ROTATE]=n,this.frames[f+Mt.TRANSLATE]=e,this.frames[f+Mt.SCALE]=r,this.frames[f+Mt.SHEAR]=i}apply(f,t,n,e,r,i,h){const l=this.frames,s=f.transformConstraints[this.transformConstraintIndex];if(n<l[0]){const u=s.data;switch(i){case A.setup:s.rotateMix=u.rotateMix,s.translateMix=u.translateMix,s.scaleMix=u.scaleMix,s.shearMix=u.shearMix;return;case A.first:s.rotateMix+=(u.rotateMix-s.rotateMix)*r,s.translateMix+=(u.translateMix-s.translateMix)*r,s.scaleMix+=(u.scaleMix-s.scaleMix)*r,s.shearMix+=(u.shearMix-s.shearMix)*r}return}let a=0,o=0,c=0,d=0;if(n>=l[l.length-Mt.ENTRIES]){const u=l.length;a=l[u+Mt.PREV_ROTATE],o=l[u+Mt.PREV_TRANSLATE],c=l[u+Mt.PREV_SCALE],d=l[u+Mt.PREV_SHEAR]}else{const u=_t.binarySearch(l,n,Mt.ENTRIES);a=l[u+Mt.PREV_ROTATE],o=l[u+Mt.PREV_TRANSLATE],c=l[u+Mt.PREV_SCALE],d=l[u+Mt.PREV_SHEAR];const m=l[u],g=this.getCurvePercent(u/Mt.ENTRIES-1,1-(n-m)/(l[u+Mt.PREV_TIME]-m));a+=(l[u+Mt.ROTATE]-a)*g,o+=(l[u+Mt.TRANSLATE]-o)*g,c+=(l[u+Mt.SCALE]-c)*g,d+=(l[u+Mt.SHEAR]-d)*g}if(i==A.setup){const u=s.data;s.rotateMix=u.rotateMix+(a-u.rotateMix)*r,s.translateMix=u.translateMix+(o-u.translateMix)*r,s.scaleMix=u.scaleMix+(c-u.scaleMix)*r,s.shearMix=u.shearMix+(d-u.shearMix)*r}else s.rotateMix+=(a-s.rotateMix)*r,s.translateMix+=(o-s.translateMix)*r,s.scaleMix+=(c-s.scaleMix)*r,s.shearMix+=(d-s.shearMix)*r}};let De=Mt;De.ENTRIES=5,De.PREV_TIME=-5,De.PREV_ROTATE=-4,De.PREV_TRANSLATE=-3,De.PREV_SCALE=-2,De.PREV_SHEAR=-1,De.ROTATE=1,De.TRANSLATE=2,De.SCALE=3,De.SHEAR=4;const Qe=class extends ye{constructor(f){super(f),this.frames=k.newFloatArray(f*Qe.ENTRIES)}getPropertyId(){return(11<<24)+this.pathConstraintIndex}setFrame(f,t,n){f*=Qe.ENTRIES,this.frames[f]=t,this.frames[f+Qe.VALUE]=n}apply(f,t,n,e,r,i,h){const l=this.frames,s=f.pathConstraints[this.pathConstraintIndex];if(n<l[0]){switch(i){case A.setup:s.position=s.data.position;return;case A.first:s.position+=(s.data.position-s.position)*r}return}let a=0;if(n>=l[l.length-Qe.ENTRIES])a=l[l.length+Qe.PREV_VALUE];else{const o=_t.binarySearch(l,n,Qe.ENTRIES);a=l[o+Qe.PREV_VALUE];const c=l[o],d=this.getCurvePercent(o/Qe.ENTRIES-1,1-(n-c)/(l[o+Qe.PREV_TIME]-c));a+=(l[o+Qe.VALUE]-a)*d}i==A.setup?s.position=s.data.position+(a-s.data.position)*r:s.position+=(a-s.position)*r}};let Vn=Qe;Vn.ENTRIES=2,Vn.PREV_TIME=-2,Vn.PREV_VALUE=-1,Vn.VALUE=1;let pn=class extends Vn{constructor(t){super(t)}getPropertyId(){return(12<<24)+this.pathConstraintIndex}apply(t,n,e,r,i,h,l){const s=this.frames,a=t.pathConstraints[this.pathConstraintIndex];if(e<s[0]){switch(h){case A.setup:a.spacing=a.data.spacing;return;case A.first:a.spacing+=(a.data.spacing-a.spacing)*i}return}let o=0;if(e>=s[s.length-pn.ENTRIES])o=s[s.length+pn.PREV_VALUE];else{const c=_t.binarySearch(s,e,pn.ENTRIES);o=s[c+pn.PREV_VALUE];const d=s[c],u=this.getCurvePercent(c/pn.ENTRIES-1,1-(e-d)/(s[c+pn.PREV_TIME]-d));o+=(s[c+pn.VALUE]-o)*u}h==A.setup?a.spacing=a.data.spacing+(o-a.data.spacing)*i:a.spacing+=(o-a.spacing)*i}};const xe=class extends ye{constructor(f){super(f),this.frames=k.newFloatArray(f*xe.ENTRIES)}getPropertyId(){return(13<<24)+this.pathConstraintIndex}setFrame(f,t,n,e){f*=xe.ENTRIES,this.frames[f]=t,this.frames[f+xe.ROTATE]=n,this.frames[f+xe.TRANSLATE]=e}apply(f,t,n,e,r,i,h){const l=this.frames,s=f.pathConstraints[this.pathConstraintIndex];if(n<l[0]){switch(i){case A.setup:s.rotateMix=s.data.rotateMix,s.translateMix=s.data.translateMix;return;case A.first:s.rotateMix+=(s.data.rotateMix-s.rotateMix)*r,s.translateMix+=(s.data.translateMix-s.translateMix)*r}return}let a=0,o=0;if(n>=l[l.length-xe.ENTRIES])a=l[l.length+xe.PREV_ROTATE],o=l[l.length+xe.PREV_TRANSLATE];else{const c=_t.binarySearch(l,n,xe.ENTRIES);a=l[c+xe.PREV_ROTATE],o=l[c+xe.PREV_TRANSLATE];const d=l[c],u=this.getCurvePercent(c/xe.ENTRIES-1,1-(n-d)/(l[c+xe.PREV_TIME]-d));a+=(l[c+xe.ROTATE]-a)*u,o+=(l[c+xe.TRANSLATE]-o)*u}i==A.setup?(s.rotateMix=s.data.rotateMix+(a-s.data.rotateMix)*r,s.translateMix=s.data.translateMix+(o-s.data.translateMix)*r):(s.rotateMix+=(a-s.rotateMix)*r,s.translateMix+=(o-s.translateMix)*r)}};let wn=xe;wn.ENTRIES=3,wn.PREV_TIME=-3,wn.PREV_ROTATE=-2,wn.PREV_TRANSLATE=-1,wn.ROTATE=1,wn.TRANSLATE=2;const zt=class{constructor(t){this.tracks=new Array,this.events=new Array,this.listeners=new Array,this.queue=new Oi(this),this.propertyIDs=new Es,this.animationsChanged=!1,this.timeScale=1,this.trackEntryPool=new Zn(()=>new Ps),this.data=t}update(t){t*=this.timeScale;const n=this.tracks;for(let e=0,r=n.length;e<r;e++){const i=n[e];if(i==null)continue;i.animationLast=i.nextAnimationLast,i.trackLast=i.nextTrackLast;let h=t*i.timeScale;if(i.delay>0){if(i.delay-=h,i.delay>0)continue;h=-i.delay,i.delay=0}let l=i.next;if(l!=null){const s=i.trackLast-l.delay;if(s>=0){for(l.delay=0,l.trackTime=i.timeScale==0?0:(s/i.timeScale+t)*l.timeScale,i.trackTime+=h,this.setCurrent(e,l,!0);l.mixingFrom!=null;)l.mixTime+=t,l=l.mixingFrom;continue}}else if(i.trackLast>=i.trackEnd&&i.mixingFrom==null){n[e]=null,this.queue.end(i),this.disposeNext(i);continue}if(i.mixingFrom!=null&&this.updateMixingFrom(i,t)){let s=i.mixingFrom;for(i.mixingFrom=null,s!=null&&(s.mixingTo=null);s!=null;)this.queue.end(s),s=s.mixingFrom}i.trackTime+=h}this.queue.drain()}updateMixingFrom(t,n){const e=t.mixingFrom;if(e==null)return!0;const r=this.updateMixingFrom(e,n);return e.animationLast=e.nextAnimationLast,e.trackLast=e.nextTrackLast,t.mixTime>0&&t.mixTime>=t.mixDuration?((e.totalAlpha==0||t.mixDuration==0)&&(t.mixingFrom=e.mixingFrom,e.mixingFrom!=null&&(e.mixingFrom.mixingTo=t),t.interruptAlpha=e.interruptAlpha,this.queue.end(e)),r):(e.trackTime+=n*e.timeScale,t.mixTime+=n,!1)}apply(t){if(t==null)throw new Error("skeleton cannot be null.");this.animationsChanged&&this._animationsChanged();const n=this.events,e=this.tracks;let r=!1;for(let i=0,h=e.length;i<h;i++){const l=e[i];if(l==null||l.delay>0)continue;r=!0;const s=i==0?A.first:l.mixBlend;let a=l.alpha;l.mixingFrom!=null?a*=this.applyMixingFrom(l,t,s):l.trackTime>=l.trackEnd&&l.next==null&&(a=0);const o=l.animationLast,c=l.getAnimationTime(),d=l.animation.timelines.length,u=l.animation.timelines;if(i==0&&a==1||s==A.add)for(let m=0;m<d;m++)k.webkit602BugfixHelper(a,s),u[m].apply(t,o,c,n,a,s,Q.mixIn);else{const m=l.timelineMode,g=l.timelinesRotation.length==0;g&&k.setArraySize(l.timelinesRotation,d<<1,null);const x=l.timelinesRotation;for(let w=0;w<d;w++){const b=u[w],E=m[w]==zt.SUBSEQUENT?s:A.setup;b instanceof me?this.applyRotateTimeline(b,t,c,a,E,x,w<<1,g):(k.webkit602BugfixHelper(a,s),b.apply(t,o,c,n,a,E,Q.mixIn))}}this.queueEvents(l,c),n.length=0,l.nextAnimationLast=c,l.nextTrackLast=l.trackTime}return this.queue.drain(),r}applyMixingFrom(t,n,e){const r=t.mixingFrom;r.mixingFrom!=null&&this.applyMixingFrom(r,n,e);let i=0;t.mixDuration==0?(i=1,e==A.first&&(e=A.setup)):(i=t.mixTime/t.mixDuration,i>1&&(i=1),e!=A.first&&(e=r.mixBlend));const h=i<r.eventThreshold?this.events:null,l=i<r.attachmentThreshold,s=i<r.drawOrderThreshold,a=r.animationLast,o=r.getAnimationTime(),c=r.animation.timelines.length,d=r.animation.timelines,u=r.alpha*t.interruptAlpha,m=u*(1-i);if(e==A.add)for(let g=0;g<c;g++)d[g].apply(n,a,o,h,m,e,Q.mixOut);else{const g=r.timelineMode,x=r.timelineHoldMix,w=r.timelinesRotation.length==0;w&&k.setArraySize(r.timelinesRotation,c<<1,null);const b=r.timelinesRotation;r.totalAlpha=0;for(let E=0;E<c;E++){const p=d[E];let S=Q.mixOut,y,M=0;switch(g[E]){case zt.SUBSEQUENT:if(!l&&p instanceof vs||!s&&p instanceof Vs)continue;y=e,M=m;break;case zt.FIRST:y=A.setup,M=m;break;case zt.HOLD:y=A.setup,M=u;break;default:y=A.setup;const C=x[E];M=u*Math.max(0,1-C.mixTime/C.mixDuration);break}r.totalAlpha+=M,p instanceof me?this.applyRotateTimeline(p,n,o,M,y,b,E<<1,w):(k.webkit602BugfixHelper(M,e),y==A.setup&&(p instanceof vs?l&&(S=Q.mixOut):p instanceof Vs&&s&&(S=Q.mixOut)),p.apply(n,a,o,h,M,y,S))}}return t.mixDuration>0&&this.queueEvents(r,o),this.events.length=0,r.nextAnimationLast=o,r.nextTrackLast=r.trackTime,i}applyRotateTimeline(t,n,e,r,i,h,l,s){if(s&&(h[l]=0),r==1){t.apply(n,0,e,null,1,i,Q.mixIn);return}const a=t,o=a.frames,c=n.bones[a.boneIndex];let d=0,u=0;if(e<o[0])switch(i){case A.setup:c.rotation=c.data.rotation;default:return;case A.first:d=c.rotation,u=c.data.rotation}else if(d=i==A.setup?c.data.rotation:c.rotation,e>=o[o.length-me.ENTRIES])u=c.data.rotation+o[o.length+me.PREV_ROTATION];else{const x=_t.binarySearch(o,e,me.ENTRIES),w=o[x+me.PREV_ROTATION],b=o[x],E=a.getCurvePercent((x>>1)-1,1-(e-b)/(o[x+me.PREV_TIME]-b));u=o[x+me.ROTATION]-w,u-=(16384-(16384.499999999996-u/360|0))*360,u=w+u*E+c.data.rotation,u-=(16384-(16384.499999999996-u/360|0))*360}let m=0,g=u-d;if(g-=(16384-(16384.499999999996-g/360|0))*360,g==0)m=h[l];else{let x=0,w=0;s?(x=0,w=g):(x=h[l],w=h[l+1]);const b=g>0;let E=x>=0;T.signum(w)!=T.signum(g)&&Math.abs(w)<=90&&(Math.abs(x)>180&&(x+=360*T.signum(x)),E=b),m=g+x-x%360,E!=b&&(m+=360*T.signum(x)),h[l]=m}h[l+1]=g,d+=m*r,c.rotation=d-(16384-(16384.499999999996-d/360|0))*360}queueEvents(t,n){const e=t.animationStart,r=t.animationEnd,i=r-e,h=t.trackLast%i,l=this.events;let s=0;const a=l.length;for(;s<a;s++){const c=l[s];if(c.time<h)break;c.time>r||this.queue.event(t,c)}let o=!1;for(t.loop?o=i==0||h>t.trackTime%i:o=n>=r&&t.animationLast<r,o&&this.queue.complete(t);s<a;s++)l[s].time<e||this.queue.event(t,l[s])}clearTracks(){const t=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let n=0,e=this.tracks.length;n<e;n++)this.clearTrack(n);this.tracks.length=0,this.queue.drainDisabled=t,this.queue.drain()}clearTrack(t){if(t>=this.tracks.length)return;const n=this.tracks[t];if(n==null)return;this.queue.end(n),this.disposeNext(n);let e=n;for(;;){const r=e.mixingFrom;if(r==null)break;this.queue.end(r),e.mixingFrom=null,e.mixingTo=null,e=r}this.tracks[n.trackIndex]=null,this.queue.drain()}setCurrent(t,n,e){const r=this.expandToIndex(t);this.tracks[t]=n,r!=null&&(e&&this.queue.interrupt(r),n.mixingFrom=r,r.mixingTo=n,n.mixTime=0,r.mixingFrom!=null&&r.mixDuration>0&&(n.interruptAlpha*=Math.min(1,r.mixTime/r.mixDuration)),r.timelinesRotation.length=0),this.queue.start(n)}setAnimation(t,n,e){const r=this.data.skeletonData.findAnimation(n);if(r==null)throw new Error(`Animation not found: ${n}`);return this.setAnimationWith(t,r,e)}setAnimationWith(t,n,e){if(n==null)throw new Error("animation cannot be null.");let r=!0,i=this.expandToIndex(t);i!=null&&(i.nextTrackLast==-1?(this.tracks[t]=i.mixingFrom,this.queue.interrupt(i),this.queue.end(i),this.disposeNext(i),i=i.mixingFrom,r=!1):this.disposeNext(i));const h=this.trackEntry(t,n,e,i);return this.setCurrent(t,h,r),this.queue.drain(),h}addAnimation(t,n,e,r){const i=this.data.skeletonData.findAnimation(n);if(i==null)throw new Error(`Animation not found: ${n}`);return this.addAnimationWith(t,i,e,r)}addAnimationWith(t,n,e,r){if(n==null)throw new Error("animation cannot be null.");let i=this.expandToIndex(t);if(i!=null)for(;i.next!=null;)i=i.next;const h=this.trackEntry(t,n,e,i);if(i==null)this.setCurrent(t,h,!0),this.queue.drain();else if(i.next=h,r<=0){const l=i.animationEnd-i.animationStart;l!=0?(i.loop?r+=l*(1+(i.trackTime/l|0)):r+=Math.max(l,i.trackTime),r-=this.data.getMix(i.animation,n)):r=i.trackTime}return h.delay=r,h}setEmptyAnimation(t,n){const e=this.setAnimationWith(t,zt.emptyAnimation,!1);return e.mixDuration=n,e.trackEnd=n,e}addEmptyAnimation(t,n,e){e<=0&&(e-=n);const r=this.addAnimationWith(t,zt.emptyAnimation,!1,e);return r.mixDuration=n,r.trackEnd=n,r}setEmptyAnimations(t){const n=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let e=0,r=this.tracks.length;e<r;e++){const i=this.tracks[e];i!=null&&this.setEmptyAnimation(i.trackIndex,t)}this.queue.drainDisabled=n,this.queue.drain()}expandToIndex(t){return t<this.tracks.length?this.tracks[t]:(k.ensureArrayCapacity(this.tracks,t-this.tracks.length+1,null),this.tracks.length=t+1,null)}trackEntry(t,n,e,r){const i=this.trackEntryPool.obtain();return i.trackIndex=t,i.animation=n,i.loop=e,i.holdPrevious=!1,i.eventThreshold=0,i.attachmentThreshold=0,i.drawOrderThreshold=0,i.animationStart=0,i.animationEnd=n.duration,i.animationLast=-1,i.nextAnimationLast=-1,i.delay=0,i.trackTime=0,i.trackLast=-1,i.nextTrackLast=-1,i.trackEnd=Number.MAX_VALUE,i.timeScale=1,i.alpha=1,i.interruptAlpha=1,i.mixTime=0,i.mixDuration=r==null?0:this.data.getMix(r.animation,n),i}disposeNext(t){let n=t.next;for(;n!=null;)this.queue.dispose(n),n=n.next;t.next=null}_animationsChanged(){this.animationsChanged=!1,this.propertyIDs.clear();for(let t=0,n=this.tracks.length;t<n;t++){let e=this.tracks[t];if(e!=null){for(;e.mixingFrom!=null;)e=e.mixingFrom;do(e.mixingFrom==null||e.mixBlend!=A.add)&&this.setTimelineModes(e),e=e.mixingTo;while(e!=null)}}}setTimelineModes(t){const n=t.mixingTo,e=t.animation.timelines,r=t.animation.timelines.length,i=k.setArraySize(t.timelineMode,r);t.timelineHoldMix.length=0;const h=k.setArraySize(t.timelineHoldMix,r),l=this.propertyIDs;if(n!=null&&n.holdPrevious){for(let s=0;s<r;s++)l.add(e[s].getPropertyId()),i[s]=zt.HOLD;return}t:for(let s=0;s<r;s++){const a=e[s].getPropertyId();if(!l.add(a))i[s]=zt.SUBSEQUENT;else if(n==null||!this.hasTimeline(n,a))i[s]=zt.FIRST;else{for(let o=n.mixingTo;o!=null;o=o.mixingTo)if(!this.hasTimeline(o,a)){if(t.mixDuration>0){i[s]=zt.HOLD_MIX,h[s]=o;continue t}break}i[s]=zt.HOLD}}}hasTimeline(t,n){const e=t.animation.timelines;for(let r=0,i=e.length;r<i;r++)if(e[r].getPropertyId()==n)return!0;return!1}getCurrent(t){return t>=this.tracks.length?null:this.tracks[t]}addListener(t){if(t==null)throw new Error("listener cannot be null.");this.listeners.push(t)}removeListener(t){const n=this.listeners.indexOf(t);n>=0&&this.listeners.splice(n,1)}clearListeners(){this.listeners.length=0}clearListenerNotifications(){this.queue.clear()}setAnimationByName(t,n,e){zt.deprecatedWarning1||(zt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.")),this.setAnimation(t,n,e)}addAnimationByName(t,n,e,r){zt.deprecatedWarning2||(zt.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.")),this.addAnimation(t,n,e,r)}hasAnimation(t){return this.data.skeletonData.findAnimation(t)!==null}hasAnimationByName(t){return zt.deprecatedWarning3||(zt.deprecatedWarning3=!0,console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.")),this.hasAnimation(t)}};let hn=zt;hn.emptyAnimation=new _t("<empty>",[],0),hn.SUBSEQUENT=0,hn.FIRST=1,hn.HOLD=2,hn.HOLD_MIX=3,hn.deprecatedWarning1=!1,hn.deprecatedWarning2=!1,hn.deprecatedWarning3=!1;const bn=class{constructor(){this.mixBlend=A.replace,this.timelineMode=new Array,this.timelineHoldMix=new Array,this.timelinesRotation=new Array}reset(){this.next=null,this.mixingFrom=null,this.mixingTo=null,this.animation=null,this.listener=null,this.timelineMode.length=0,this.timelineHoldMix.length=0,this.timelinesRotation.length=0}getAnimationTime(){if(this.loop){const t=this.animationEnd-this.animationStart;return t==0?this.animationStart:this.trackTime%t+this.animationStart}return Math.min(this.trackTime+this.animationStart,this.animationEnd)}setAnimationLast(t){this.animationLast=t,this.nextAnimationLast=t}isComplete(){return this.trackTime>=this.animationEnd-this.animationStart}resetRotationDirections(){this.timelinesRotation.length=0}get time(){return bn.deprecatedWarning1||(bn.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime}set time(t){bn.deprecatedWarning1||(bn.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime=t}get endTime(){return bn.deprecatedWarning2||(bn.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime}set endTime(t){bn.deprecatedWarning2||(bn.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime=t}loopsCount(){return Math.floor(this.trackTime/this.trackEnd)}};let Ps=bn;Ps.deprecatedWarning1=!1,Ps.deprecatedWarning2=!1;const Li=class{constructor(f){this.objects=[],this.drainDisabled=!1,this.animState=f}start(f){this.objects.push(Me.start),this.objects.push(f),this.animState.animationsChanged=!0}interrupt(f){this.objects.push(Me.interrupt),this.objects.push(f)}end(f){this.objects.push(Me.end),this.objects.push(f),this.animState.animationsChanged=!0}dispose(f){this.objects.push(Me.dispose),this.objects.push(f)}complete(f){this.objects.push(Me.complete),this.objects.push(f)}event(f,t){this.objects.push(Me.event),this.objects.push(f),this.objects.push(t)}deprecateStuff(){return Li.deprecatedWarning1||(Li.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'")),!0}drain(){if(this.drainDisabled)return;this.drainDisabled=!0;const f=this.objects,t=this.animState.listeners;for(let n=0;n<f.length;n+=2){const e=f[n],r=f[n+1];switch(e){case Me.start:r.listener!=null&&r.listener.start&&r.listener.start(r);for(let l=0;l<t.length;l++)t[l].start&&t[l].start(r);r.onStart&&this.deprecateStuff()&&r.onStart(r.trackIndex),this.animState.onStart&&this.deprecateStuff()&&this.deprecateStuff&&this.animState.onStart(r.trackIndex);break;case Me.interrupt:r.listener!=null&&r.listener.interrupt&&r.listener.interrupt(r);for(let l=0;l<t.length;l++)t[l].interrupt&&t[l].interrupt(r);break;case Me.end:r.listener!=null&&r.listener.end&&r.listener.end(r);for(let l=0;l<t.length;l++)t[l].end&&t[l].end(r);r.onEnd&&this.deprecateStuff()&&r.onEnd(r.trackIndex),this.animState.onEnd&&this.deprecateStuff()&&this.animState.onEnd(r.trackIndex);case Me.dispose:r.listener!=null&&r.listener.dispose&&r.listener.dispose(r);for(let l=0;l<t.length;l++)t[l].dispose&&t[l].dispose(r);this.animState.trackEntryPool.free(r);break;case Me.complete:r.listener!=null&&r.listener.complete&&r.listener.complete(r);for(let l=0;l<t.length;l++)t[l].complete&&t[l].complete(r);const i=T.toInt(r.loopsCount());r.onComplete&&this.deprecateStuff()&&r.onComplete(r.trackIndex,i),this.animState.onComplete&&this.deprecateStuff()&&this.animState.onComplete(r.trackIndex,i);break;case Me.event:const h=f[n+++2];r.listener!=null&&r.listener.event&&r.listener.event(r,h);for(let l=0;l<t.length;l++)t[l].event&&t[l].event(r,h);r.onEvent&&this.deprecateStuff()&&r.onEvent(r.trackIndex,h),this.animState.onEvent&&this.deprecateStuff()&&this.animState.onEvent(r.trackIndex,h);break}}this.clear(),this.drainDisabled=!1}clear(){this.objects.length=0}};let Oi=Li;Oi.deprecatedWarning1=!1;var Me=(f=>(f[f.start=0]="start",f[f.interrupt=1]="interrupt",f[f.end=2]="end",f[f.dispose=3]="dispose",f[f.complete=4]="complete",f[f.event=5]="event",f))(Me||{});class fo{start(t){}interrupt(t){}end(t){}dispose(t){}complete(t){}event(t,n){}}const $i=class{constructor(f){if(this.animationToMixTime={},this.defaultMix=0,f==null)throw new Error("skeletonData cannot be null.");this.skeletonData=f}setMix(f,t,n){const e=this.skeletonData.findAnimation(f);if(e==null)throw new Error(`Animation not found: ${f}`);const r=this.skeletonData.findAnimation(t);if(r==null)throw new Error(`Animation not found: ${t}`);this.setMixWith(e,r,n)}setMixByName(f,t,n){$i.deprecatedWarning1||($i.deprecatedWarning1=!0,console.warn("Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.")),this.setMix(f,t,n)}setMixWith(f,t,n){if(f==null)throw new Error("from cannot be null.");if(t==null)throw new Error("to cannot be null.");const e=`${f.name}.${t.name}`;this.animationToMixTime[e]=n}getMix(f,t){const n=`${f.name}.${t.name}`,e=this.animationToMixTime[n];return e===void 0?this.defaultMix:e}};let Wi=$i;Wi.deprecatedWarning1=!1;let ua=class{constructor(t){this.atlas=t}newRegionAttachment(t,n,e){const r=this.atlas.findRegion(e);if(r==null)throw new Error(`Region not found in atlas: ${e} (region attachment: ${n})`);const i=new et(n);return i.region=r,i}newMeshAttachment(t,n,e){const r=this.atlas.findRegion(e);if(r==null)throw new Error(`Region not found in atlas: ${e} (mesh attachment: ${n})`);const i=new Di(n);return i.region=r,i}newBoundingBoxAttachment(t,n){return new ia(n)}newPathAttachment(t,n){return new us(n)}newPointAttachment(t,n){return new aa(n)}newClippingAttachment(t,n){return new ra(n)}},qi=class{constructor(t,n,e){if(this.matrix=new G.Matrix,this.children=new Array,this.x=0,this.y=0,this.rotation=0,this.scaleX=0,this.scaleY=0,this.shearX=0,this.shearY=0,this.ax=0,this.ay=0,this.arotation=0,this.ascaleX=0,this.ascaleY=0,this.ashearX=0,this.ashearY=0,this.appliedValid=!1,this.sorted=!1,this.active=!0,t==null)throw new Error("data cannot be null.");if(n==null)throw new Error("skeleton cannot be null.");this.data=t,this.skeleton=n,this.parent=e,this.setToSetupPose()}get worldX(){return this.matrix.tx}get worldY(){return this.matrix.ty}update(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransform(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransformWith(t,n,e,r,i,h,l){this.ax=t,this.ay=n,this.arotation=e,this.ascaleX=r,this.ascaleY=i,this.ashearX=h,this.ashearY=l,this.appliedValid=!0;const s=this.parent,a=this.matrix,o=this.skeleton.scaleX,c=jt.yDown?-this.skeleton.scaleY:this.skeleton.scaleY;if(s==null){const x=this.skeleton,w=e+90+l;a.a=T.cosDeg(e+h)*r*o,a.c=T.cosDeg(w)*i*o,a.b=T.sinDeg(e+h)*r*c,a.d=T.sinDeg(w)*i*c,a.tx=t*o+x.x,a.ty=n*c+x.y;return}let d=s.matrix.a,u=s.matrix.c,m=s.matrix.b,g=s.matrix.d;switch(a.tx=d*t+u*n+s.matrix.tx,a.ty=m*t+g*n+s.matrix.ty,this.data.transformMode){case z.Normal:{const x=e+90+l,w=T.cosDeg(e+h)*r,b=T.cosDeg(x)*i,E=T.sinDeg(e+h)*r,p=T.sinDeg(x)*i;a.a=d*w+u*E,a.c=d*b+u*p,a.b=m*w+g*E,a.d=m*b+g*p;return}case z.OnlyTranslation:{const x=e+90+l;a.a=T.cosDeg(e+h)*r,a.c=T.cosDeg(x)*i,a.b=T.sinDeg(e+h)*r,a.d=T.sinDeg(x)*i;break}case z.NoRotationOrReflection:{let x=d*d+m*m,w=0;x>1e-4?(x=Math.abs(d*g-u*m)/x,u=m*x,g=d*x,w=Math.atan2(m,d)*T.radDeg):(d=0,m=0,w=90-Math.atan2(g,u)*T.radDeg);const b=e+h-w,E=e+l-w+90,p=T.cosDeg(b)*r,S=T.cosDeg(E)*i,y=T.sinDeg(b)*r,M=T.sinDeg(E)*i;a.a=d*p-u*y,a.c=d*S-u*M,a.b=m*p+g*y,a.d=m*S+g*M;break}case z.NoScale:case z.NoScaleOrReflection:{const x=T.cosDeg(e),w=T.sinDeg(e);let b=(d*x+u*w)/o,E=(m*x+g*w)/c,p=Math.sqrt(b*b+E*E);p>1e-5&&(p=1/p),b*=p,E*=p,p=Math.sqrt(b*b+E*E),this.data.transformMode==z.NoScale&&d*g-u*m<0!=(jt.yDown?this.skeleton.scaleX<0!=this.skeleton.scaleY>0:this.skeleton.scaleX<0!=this.skeleton.scaleY<0)&&(p=-p);const S=Math.PI/2+Math.atan2(E,b),y=Math.cos(S)*p,M=Math.sin(S)*p,C=T.cosDeg(h)*r,I=T.cosDeg(90+l)*i,R=T.sinDeg(h)*r,v=T.sinDeg(90+l)*i;a.a=b*C+y*R,a.c=b*I+y*v,a.b=E*C+M*R,a.d=E*I+M*v;break}}a.a*=o,a.c*=o,a.b*=c,a.d*=c}setToSetupPose(){const t=this.data;this.x=t.x,this.y=t.y,this.rotation=t.rotation,this.scaleX=t.scaleX,this.scaleY=t.scaleY,this.shearX=t.shearX,this.shearY=t.shearY}getWorldRotationX(){return Math.atan2(this.matrix.b,this.matrix.a)*T.radDeg}getWorldRotationY(){return Math.atan2(this.matrix.d,this.matrix.c)*T.radDeg}getWorldScaleX(){const t=this.matrix;return Math.sqrt(t.a*t.a+t.c*t.c)}getWorldScaleY(){const t=this.matrix;return Math.sqrt(t.b*t.b+t.d*t.d)}updateAppliedTransform(){this.appliedValid=!0;const t=this.parent,n=this.matrix;if(t==null){this.ax=n.tx,this.ay=n.ty,this.arotation=Math.atan2(n.b,n.a)*T.radDeg,this.ascaleX=Math.sqrt(n.a*n.a+n.b*n.b),this.ascaleY=Math.sqrt(n.c*n.c+n.d*n.d),this.ashearX=0,this.ashearY=Math.atan2(n.a*n.c+n.b*n.d,n.a*n.d-n.b*n.c)*T.radDeg;return}const e=t.matrix,r=1/(e.a*e.d-e.b*e.c),i=n.tx-e.tx,h=n.ty-e.ty;this.ax=i*e.d*r-h*e.c*r,this.ay=h*e.a*r-i*e.b*r;const l=r*e.d,s=r*e.a,a=r*e.c,o=r*e.b,c=l*n.a-a*n.b,d=l*n.c-a*n.d,u=s*n.b-o*n.a,m=s*n.d-o*n.c;if(this.ashearX=0,this.ascaleX=Math.sqrt(c*c+u*u),this.ascaleX>1e-4){const g=c*m-d*u;this.ascaleY=g/this.ascaleX,this.ashearY=Math.atan2(c*d+u*m,g)*T.radDeg,this.arotation=Math.atan2(u,c)*T.radDeg}else this.ascaleX=0,this.ascaleY=Math.sqrt(d*d+m*m),this.ashearY=0,this.arotation=90-Math.atan2(m,d)*T.radDeg}worldToLocal(t){const n=this.matrix,e=n.a,r=n.c,i=n.b,h=n.d,l=1/(e*h-r*i),s=t.x-n.tx,a=t.y-n.ty;return t.x=s*h*l-a*r*l,t.y=a*e*l-s*i*l,t}localToWorld(t){const n=this.matrix,e=t.x,r=t.y;return t.x=e*n.a+r*n.c+n.tx,t.y=e*n.b+r*n.d+n.ty,t}worldToLocalRotation(t){const n=T.sinDeg(t),e=T.cosDeg(t),r=this.matrix;return Math.atan2(r.a*n-r.b*e,r.d*e-r.c*n)*T.radDeg}localToWorldRotation(t){const n=T.sinDeg(t),e=T.cosDeg(t),r=this.matrix;return Math.atan2(e*r.b+n*r.d,e*r.a+n*r.c)*T.radDeg}rotateWorld(t){const n=this.matrix,e=n.a,r=n.c,i=n.b,h=n.d,l=T.cosDeg(t),s=T.sinDeg(t);n.a=l*e-s*i,n.c=l*r-s*h,n.b=s*e+l*i,n.d=s*r+l*h,this.appliedValid=!1}},ma=class{constructor(t,n,e){if(this.x=0,this.y=0,this.rotation=0,this.scaleX=1,this.scaleY=1,this.shearX=0,this.shearY=0,this.transformMode=z.Normal,t<0)throw new Error("index must be >= 0.");if(n==null)throw new Error("name cannot be null.");this.index=t,this.name=n,this.parent=e}},ga=class{constructor(t,n){if(n==null)throw new Error("data cannot be null.");this.time=t,this.data=n}},xa=class{constructor(t){this.name=t}},pa=class{constructor(t,n){if(this.bendDirection=0,this.compress=!1,this.stretch=!1,this.mix=1,t==null)throw new Error("data cannot be null.");if(n==null)throw new Error("skeleton cannot be null.");this.data=t,this.mix=t.mix,this.bendDirection=t.bendDirection,this.compress=t.compress,this.stretch=t.stretch,this.bones=new Array;for(let e=0;e<t.bones.length;e++)this.bones.push(n.findBone(t.bones[e].name));this.target=n.findBone(t.target.name)}getOrder(){return this.data.order}apply(){this.update()}update(){const t=this.target,n=this.bones;switch(n.length){case 1:this.apply1(n[0],t.worldX,t.worldY,this.compress,this.stretch,this.data.uniform,this.mix);break;case 2:this.apply2(n[0],n[1],t.worldX,t.worldY,this.bendDirection,this.stretch,this.mix);break}}apply1(t,n,e,r,i,h,l){t.appliedValid||t.updateAppliedTransform();const s=t.parent.matrix,a=1/(s.a*s.d-s.b*s.c),o=n-s.tx,c=e-s.ty,d=(o*s.d-c*s.c)*a-t.ax,u=(c*s.a-o*s.b)*a-t.ay;let m=Math.atan2(u,d)*T.radDeg-t.ashearX-t.arotation;t.ascaleX<0&&(m+=180),m>180?m-=360:m<-180&&(m+=360);let g=t.ascaleX,x=t.ascaleY;if(r||i){const w=t.data.length*g,b=Math.sqrt(d*d+u*u);if(r&&b<w||i&&b>w&&w>1e-4){const E=(b/w-1)*l+1;g*=E,h&&(x*=E)}}t.updateWorldTransformWith(t.ax,t.ay,t.arotation+m*l,g,x,t.ashearX,t.ashearY)}apply2(t,n,e,r,i,h,l){if(l==0){n.updateWorldTransform();return}t.appliedValid||t.updateAppliedTransform(),n.appliedValid||n.updateAppliedTransform();const s=t.ax,a=t.ay;let o=t.ascaleX,c=o,d=t.ascaleY,u=n.ascaleX;const m=t.matrix;let g=0,x=0,w=0;o<0?(o=-o,g=180,w=-1):(g=0,w=1),d<0&&(d=-d,w=-w),u<0?(u=-u,x=180):x=0;const b=n.ax;let E=0,p=0,S=0,y=m.a,M=m.c,C=m.b,I=m.d;const R=Math.abs(o-d)<=1e-4;R?(E=n.ay,p=y*b+M*E+m.tx,S=C*b+I*E+m.ty):(E=0,p=y*b+m.tx,S=C*b+m.ty);const v=t.parent.matrix;y=v.a,M=v.c,C=v.b,I=v.d;const V=1/(y*I-M*C);let P=e-v.tx,D=r-v.ty;const F=(P*I-D*M)*V-s,B=(D*y-P*C)*V-a,H=F*F+B*B;P=p-v.tx,D=S-v.ty;const U=(P*I-D*M)*V-s,X=(D*y-P*C)*V-a,N=Math.sqrt(U*U+X*X);let _=n.data.length*u,$=0,q=0;t:if(R){_*=o;let j=(H-N*N-_*_)/(2*N*_);j<-1?j=-1:j>1&&(j=1,h&&N+_>1e-4&&(c*=(Math.sqrt(H)/(N+_)-1)*l+1)),q=Math.acos(j)*i,y=N+_*j,M=_*Math.sin(q),$=Math.atan2(B*y-F*M,F*y+B*M)}else{y=o*_,M=d*_;const j=y*y,K=M*M,mt=Math.atan2(B,F);C=K*N*N+j*H-j*K;const nt=-2*K*N,It=K-j;if(I=nt*nt-4*It*C,I>=0){let ee=Math.sqrt(I);nt<0&&(ee=-ee),ee=-(nt+ee)/2;const Bt=ee/It,rn=C/ee,$t=Math.abs(Bt)<Math.abs(rn)?Bt:rn;if($t*$t<=H){D=Math.sqrt(H-$t*$t)*i,$=mt-Math.atan2(D,$t),q=Math.atan2(D/d,($t-N)/o);break t}}let Gt=T.PI,pe=N-y,ne=pe*pe,_e=0,Le=0,Ce=N+y,se=Ce*Ce,Oe=0;C=-y*N/(j-K),C>=-1&&C<=1&&(C=Math.acos(C),P=y*Math.cos(C)+N,D=M*Math.sin(C),I=P*P+D*D,I<ne&&(Gt=C,ne=I,pe=P,_e=D),I>se&&(Le=C,se=I,Ce=P,Oe=D)),H<=(ne+se)/2?($=mt-Math.atan2(_e*i,pe),q=Gt*i):($=mt-Math.atan2(Oe*i,Ce),q=Le*i)}const W=Math.atan2(E,b)*w;let L=t.arotation;$=($-W)*T.radDeg+g-L,$>180?$-=360:$<-180&&($+=360),t.updateWorldTransformWith(s,a,L+$*l,c,t.ascaleY,0,0),L=n.arotation,q=((q+W)*T.radDeg-n.ashearX)*w+x-L,q>180?q-=360:q<-180&&(q+=360),n.updateWorldTransformWith(b,E,L+q*l,n.ascaleX,n.ascaleY,n.ashearX,n.ashearY)}},wa=class{constructor(t){this.order=0,this.bones=new Array,this.bendDirection=1,this.compress=!1,this.stretch=!1,this.uniform=!1,this.mix=1,this.name=t}},ba=class{constructor(t){this.order=0,this.bones=new Array,this.name=t}};var Ke=(f=>(f[f.Length=0]="Length",f[f.Fixed=1]="Fixed",f[f.Percent=2]="Percent",f))(Ke||{});const Ln=class{constructor(t,n){if(this.position=0,this.spacing=0,this.rotateMix=0,this.translateMix=0,this.spaces=new Array,this.positions=new Array,this.world=new Array,this.curves=new Array,this.lengths=new Array,this.segments=new Array,t==null)throw new Error("data cannot be null.");if(n==null)throw new Error("skeleton cannot be null.");this.data=t,this.bones=new Array;for(let e=0,r=t.bones.length;e<r;e++)this.bones.push(n.findBone(t.bones[e].name));this.target=n.findSlot(t.target.name),this.position=t.position,this.spacing=t.spacing,this.rotateMix=t.rotateMix,this.translateMix=t.translateMix}apply(){this.update()}update(){const t=this.target.getAttachment();if(!(t instanceof us))return;const n=this.rotateMix,e=this.translateMix,r=e>0,i=n>0;if(!r&&!i)return;const h=this.data,l=h.spacingMode,s=l==Ke.Length,a=h.rotateMode,o=a==ut.Tangent,c=a==ut.ChainScale,d=this.bones.length,u=o?d:d+1,m=this.bones,g=k.setArraySize(this.spaces,u);let x=null;const w=this.spacing;if(c||s){c&&(x=k.setArraySize(this.lengths,d));for(let M=0,C=u-1;M<C;){const I=m[M],R=I.data.length;if(R<Ln.epsilon)c&&(x[M]=0),g[++M]=0;else{const v=R*I.matrix.a,V=R*I.matrix.b,P=Math.sqrt(v*v+V*V);c&&(x[M]=P),g[++M]=(s?R+w:w)*P/R}}}else for(let M=1;M<u;M++)g[M]=w;const b=this.computeWorldPositions(t,u,o,h.positionMode==dt.Percent,l==Ke.Percent);let E=b[0],p=b[1],S=h.offsetRotation,y=!1;if(S==0)y=a==ut.Chain;else{y=!1;const M=this.target.bone.matrix;S*=M.a*M.d-M.b*M.c>0?T.degRad:-T.degRad}for(let M=0,C=3;M<d;M++,C+=3){const I=m[M],R=I.matrix;R.tx+=(E-R.tx)*e,R.ty+=(p-R.ty)*e;const v=b[C],V=b[C+1],P=v-E,D=V-p;if(c){const F=x[M];if(F!=0){const B=(Math.sqrt(P*P+D*D)/F-1)*n+1;R.a*=B,R.b*=B}}if(E=v,p=V,i){const F=R.a,B=R.c,H=R.b,U=R.d;let X=0,N=0,_=0;if(o&&(o?X=b[C-1]:g[M+1]==0?X=b[C+2]:X=Math.atan2(D,P)),X-=Math.atan2(H,F),y){N=Math.cos(X),_=Math.sin(X);const $=I.data.length;E+=($*(N*F-_*H)-P)*n,p+=($*(_*F+N*H)-D)*n}else X+=S;X>T.PI?X-=T.PI2:X<-T.PI&&(X+=T.PI2),X*=n,N=Math.cos(X),_=Math.sin(X),R.a=N*F-_*H,R.c=N*B-_*U,R.b=_*F+N*H,R.d=_*B+N*U}I.appliedValid=!1}}computeWorldPositions(t,n,e,r,i){const h=this.target;let l=this.position;const s=this.spaces,a=k.setArraySize(this.positions,n*3+2);let o=null;const c=t.closed;let d=t.worldVerticesLength,u=d/6,m=Ln.NONE;if(!t.constantSpeed){const X=t.lengths;u-=c?1:2;const N=X[u];if(r&&(l*=N),i)for(let _=0;_<n;_++)s[_]*=N;o=k.setArraySize(this.world,8);for(let _=0,$=0,q=0;_<n;_++,$+=3){const W=s[_];l+=W;let L=l;if(c)L%=N,L<0&&(L+=N),q=0;else if(L<0){m!=Ln.BEFORE&&(m=Ln.BEFORE,t.computeWorldVertices(h,2,4,o,0,2)),this.addBeforePosition(L,o,0,a,$);continue}else if(L>N){m!=Ln.AFTER&&(m=Ln.AFTER,t.computeWorldVertices(h,d-6,4,o,0,2)),this.addAfterPosition(L-N,o,0,a,$);continue}for(;;q++){const j=X[q];if(!(L>j)){if(q==0)L/=j;else{const K=X[q-1];L=(L-K)/(j-K)}break}}q!=m&&(m=q,c&&q==u?(t.computeWorldVertices(h,d-4,4,o,0,2),t.computeWorldVertices(h,0,4,o,4,2)):t.computeWorldVertices(h,q*6+2,8,o,0,2)),this.addCurvePosition(L,o[0],o[1],o[2],o[3],o[4],o[5],o[6],o[7],a,$,e||_>0&&W==0)}return a}c?(d+=2,o=k.setArraySize(this.world,d),t.computeWorldVertices(h,2,d-4,o,0,2),t.computeWorldVertices(h,0,2,o,d-4,2),o[d-2]=o[0],o[d-1]=o[1]):(u--,d-=4,o=k.setArraySize(this.world,d),t.computeWorldVertices(h,2,d,o,0,2));const g=k.setArraySize(this.curves,u);let x=0,w=o[0],b=o[1],E=0,p=0,S=0,y=0,M=0,C=0,I=0,R=0,v=0,V=0,P=0,D=0,F=0,B=0;for(let X=0,N=2;X<u;X++,N+=6)E=o[N],p=o[N+1],S=o[N+2],y=o[N+3],M=o[N+4],C=o[N+5],I=(w-E*2+S)*.1875,R=(b-p*2+y)*.1875,v=((E-S)*3-w+M)*.09375,V=((p-y)*3-b+C)*.09375,P=I*2+v,D=R*2+V,F=(E-w)*.75+I+v*.16666667,B=(p-b)*.75+R+V*.16666667,x+=Math.sqrt(F*F+B*B),F+=P,B+=D,P+=v,D+=V,x+=Math.sqrt(F*F+B*B),F+=P,B+=D,x+=Math.sqrt(F*F+B*B),F+=P+v,B+=D+V,x+=Math.sqrt(F*F+B*B),g[X]=x,w=M,b=C;if(r&&(l*=x),i)for(let X=0;X<n;X++)s[X]*=x;const H=this.segments;let U=0;for(let X=0,N=0,_=0,$=0;X<n;X++,N+=3){const q=s[X];l+=q;let W=l;if(c)W%=x,W<0&&(W+=x),_=0;else if(W<0){this.addBeforePosition(W,o,0,a,N);continue}else if(W>x){this.addAfterPosition(W-x,o,d-4,a,N);continue}for(;;_++){const L=g[_];if(!(W>L)){if(_==0)W/=L;else{const j=g[_-1];W=(W-j)/(L-j)}break}}if(_!=m){m=_;let L=_*6;for(w=o[L],b=o[L+1],E=o[L+2],p=o[L+3],S=o[L+4],y=o[L+5],M=o[L+6],C=o[L+7],I=(w-E*2+S)*.03,R=(b-p*2+y)*.03,v=((E-S)*3-w+M)*.006,V=((p-y)*3-b+C)*.006,P=I*2+v,D=R*2+V,F=(E-w)*.3+I+v*.16666667,B=(p-b)*.3+R+V*.16666667,U=Math.sqrt(F*F+B*B),H[0]=U,L=1;L<8;L++)F+=P,B+=D,P+=v,D+=V,U+=Math.sqrt(F*F+B*B),H[L]=U;F+=P,B+=D,U+=Math.sqrt(F*F+B*B),H[8]=U,F+=P+v,B+=D+V,U+=Math.sqrt(F*F+B*B),H[9]=U,$=0}for(W*=U;;$++){const L=H[$];if(!(W>L)){if($==0)W/=L;else{const j=H[$-1];W=$+(W-j)/(L-j)}break}}this.addCurvePosition(W*.1,w,b,E,p,S,y,M,C,a,N,e||X>0&&q==0)}return a}addBeforePosition(t,n,e,r,i){const h=n[e],l=n[e+1],s=n[e+2]-h,a=n[e+3]-l,o=Math.atan2(a,s);r[i]=h+t*Math.cos(o),r[i+1]=l+t*Math.sin(o),r[i+2]=o}addAfterPosition(t,n,e,r,i){const h=n[e+2],l=n[e+3],s=h-n[e],a=l-n[e+1],o=Math.atan2(a,s);r[i]=h+t*Math.cos(o),r[i+1]=l+t*Math.sin(o),r[i+2]=o}addCurvePosition(t,n,e,r,i,h,l,s,a,o,c,d){(t==0||isNaN(t))&&(t=1e-4);const u=t*t,m=u*t,g=1-t,x=g*g,w=x*g,b=g*t,E=b*3,p=g*E,S=E*t,y=n*w+r*p+h*S+s*m,M=e*w+i*p+l*S+a*m;o[c]=y,o[c+1]=M,d&&(o[c+2]=Math.atan2(M-(e*x+i*b*2+l*u),y-(n*x+r*b*2+h*u)))}getOrder(){return this.data.order}};let as=Ln;as.NONE=-1,as.BEFORE=-2,as.AFTER=-3,as.epsilon=1e-5;let Ea=class{constructor(t,n){if(this.rotateMix=0,this.translateMix=0,this.scaleMix=0,this.shearMix=0,this.temp=new Yn,t==null)throw new Error("data cannot be null.");if(n==null)throw new Error("skeleton cannot be null.");this.data=t,this.rotateMix=t.rotateMix,this.translateMix=t.translateMix,this.scaleMix=t.scaleMix,this.shearMix=t.shearMix,this.bones=new Array;for(let e=0;e<t.bones.length;e++)this.bones.push(n.findBone(t.bones[e].name));this.target=n.findBone(t.target.name)}apply(){this.update()}update(){this.data.local?this.data.relative?this.applyRelativeLocal():this.applyAbsoluteLocal():this.data.relative?this.applyRelativeWorld():this.applyAbsoluteWorld()}applyAbsoluteWorld(){const t=this.rotateMix,n=this.translateMix,e=this.scaleMix,r=this.shearMix,i=this.target,h=i.matrix,l=h.a,s=h.c,a=h.b,o=h.d,c=l*o-s*a>0?T.degRad:-T.degRad,d=this.data.offsetRotation*c,u=this.data.offsetShearY*c,m=this.bones;for(let g=0,x=m.length;g<x;g++){const w=m[g];let b=!1;const E=w.matrix;if(t!=0){const p=E.a,S=E.c,y=E.b,M=E.d;let C=Math.atan2(a,l)-Math.atan2(y,p)+d;C>T.PI?C-=T.PI2:C<-T.PI&&(C+=T.PI2),C*=t;const I=Math.cos(C),R=Math.sin(C);E.a=I*p-R*y,E.c=I*S-R*M,E.b=R*p+I*y,E.d=R*S+I*M,b=!0}if(n!=0){const p=this.temp;i.localToWorld(p.set(this.data.offsetX,this.data.offsetY)),E.tx+=(p.x-E.tx)*n,E.ty+=(p.y-E.ty)*n,b=!0}if(e>0){let p=Math.sqrt(E.a*E.a+E.b*E.b),S=Math.sqrt(l*l+a*a);p>1e-5&&(p=(p+(S-p+this.data.offsetScaleX)*e)/p),E.a*=p,E.b*=p,p=Math.sqrt(E.c*E.c+E.d*E.d),S=Math.sqrt(s*s+o*o),p>1e-5&&(p=(p+(S-p+this.data.offsetScaleY)*e)/p),E.c*=p,E.d*=p,b=!0}if(r>0){const p=E.c,S=E.d,y=Math.atan2(S,p);let M=Math.atan2(o,s)-Math.atan2(a,l)-(y-Math.atan2(E.b,E.a));M>T.PI?M-=T.PI2:M<-T.PI&&(M+=T.PI2),M=y+(M+u)*r;const C=Math.sqrt(p*p+S*S);E.c=Math.cos(M)*C,E.d=Math.sin(M)*C,b=!0}b&&(w.appliedValid=!1)}}applyRelativeWorld(){const t=this.rotateMix,n=this.translateMix,e=this.scaleMix,r=this.shearMix,i=this.target,h=i.matrix,l=h.a,s=h.c,a=h.b,o=h.d,c=l*o-s*a>0?T.degRad:-T.degRad,d=this.data.offsetRotation*c,u=this.data.offsetShearY*c,m=this.bones;for(let g=0,x=m.length;g<x;g++){const w=m[g];let b=!1;const E=w.matrix;if(t!=0){const p=E.a,S=E.c,y=E.b,M=E.d;let C=Math.atan2(a,l)+d;C>T.PI?C-=T.PI2:C<-T.PI&&(C+=T.PI2),C*=t;const I=Math.cos(C),R=Math.sin(C);E.a=I*p-R*y,E.c=I*S-R*M,E.b=R*p+I*y,E.d=R*S+I*M,b=!0}if(n!=0){const p=this.temp;i.localToWorld(p.set(this.data.offsetX,this.data.offsetY)),E.tx+=p.x*n,E.ty+=p.y*n,b=!0}if(e>0){let p=(Math.sqrt(l*l+a*a)-1+this.data.offsetScaleX)*e+1;E.a*=p,E.b*=p,p=(Math.sqrt(s*s+o*o)-1+this.data.offsetScaleY)*e+1,E.c*=p,E.d*=p,b=!0}if(r>0){let p=Math.atan2(o,s)-Math.atan2(a,l);p>T.PI?p-=T.PI2:p<-T.PI&&(p+=T.PI2);const S=E.c,y=E.d;p=Math.atan2(y,S)+(p-T.PI/2+u)*r;const M=Math.sqrt(S*S+y*y);E.c=Math.cos(p)*M,E.d=Math.sin(p)*M,b=!0}b&&(w.appliedValid=!1)}}applyAbsoluteLocal(){const t=this.rotateMix,n=this.translateMix,e=this.scaleMix,r=this.shearMix,i=this.target;i.appliedValid||i.updateAppliedTransform();const h=this.bones;for(let l=0,s=h.length;l<s;l++){const a=h[l];a.appliedValid||a.updateAppliedTransform();let o=a.arotation;if(t!=0){let x=i.arotation-o+this.data.offsetRotation;x-=(16384-(16384.499999999996-x/360|0))*360,o+=x*t}let c=a.ax,d=a.ay;n!=0&&(c+=(i.ax-c+this.data.offsetX)*n,d+=(i.ay-d+this.data.offsetY)*n);let u=a.ascaleX,m=a.ascaleY;e>0&&(u>1e-5&&(u=(u+(i.ascaleX-u+this.data.offsetScaleX)*e)/u),m>1e-5&&(m=(m+(i.ascaleY-m+this.data.offsetScaleY)*e)/m));const g=a.ashearY;if(r>0){let x=i.ashearY-g+this.data.offsetShearY;x-=(16384-(16384.499999999996-x/360|0))*360,a.shearY+=x*r}a.updateWorldTransformWith(c,d,o,u,m,a.ashearX,g)}}applyRelativeLocal(){const t=this.rotateMix,n=this.translateMix,e=this.scaleMix,r=this.shearMix,i=this.target;i.appliedValid||i.updateAppliedTransform();const h=this.bones;for(let l=0,s=h.length;l<s;l++){const a=h[l];a.appliedValid||a.updateAppliedTransform();let o=a.arotation;t!=0&&(o+=(i.arotation+this.data.offsetRotation)*t);let c=a.ax,d=a.ay;n!=0&&(c+=(i.ax+this.data.offsetX)*n,d+=(i.ay+this.data.offsetY)*n);let u=a.ascaleX,m=a.ascaleY;e>0&&(u>1e-5&&(u*=(i.ascaleX-1+this.data.offsetScaleX)*e+1),m>1e-5&&(m*=(i.ascaleY-1+this.data.offsetScaleY)*e+1));let g=a.ashearY;r>0&&(g+=(i.ashearY+this.data.offsetShearY)*r),a.updateWorldTransformWith(c,d,o,u,m,a.ashearX,g)}}getOrder(){return this.data.order}};const ms=class{constructor(t){if(this._updateCache=new Array,this.updateCacheReset=new Array,this.time=0,this.scaleX=1,this.scaleY=1,this.x=0,this.y=0,t==null)throw new Error("data cannot be null.");this.data=t,this.bones=new Array;for(let n=0;n<t.bones.length;n++){const e=t.bones[n];let r;if(e.parent==null)r=new qi(e,this,null);else{const i=this.bones[e.parent.index];r=new qi(e,this,i),i.children.push(r)}this.bones.push(r)}this.slots=new Array,this.drawOrder=new Array;for(let n=0;n<t.slots.length;n++){const e=t.slots[n],r=this.bones[e.boneData.index],i=new _i(e,r);this.slots.push(i),this.drawOrder.push(i)}this.ikConstraints=new Array;for(let n=0;n<t.ikConstraints.length;n++){const e=t.ikConstraints[n];this.ikConstraints.push(new pa(e,this))}this.transformConstraints=new Array;for(let n=0;n<t.transformConstraints.length;n++){const e=t.transformConstraints[n];this.transformConstraints.push(new Ea(e,this))}this.pathConstraints=new Array;for(let n=0;n<t.pathConstraints.length;n++){const e=t.pathConstraints[n];this.pathConstraints.push(new as(e,this))}this.color=new O(1,1,1,1),this.updateCache()}updateCache(){const t=this._updateCache;t.length=0,this.updateCacheReset.length=0;const n=this.bones;for(let o=0,c=n.length;o<c;o++)n[o].sorted=!1;const e=this.ikConstraints,r=this.transformConstraints,i=this.pathConstraints,h=e.length,l=r.length,s=i.length,a=h+l+s;t:for(let o=0;o<a;o++){for(let c=0;c<h;c++){const d=e[c];if(d.data.order==o){this.sortIkConstraint(d);continue t}}for(let c=0;c<l;c++){const d=r[c];if(d.data.order==o){this.sortTransformConstraint(d);continue t}}for(let c=0;c<s;c++){const d=i[c];if(d.data.order==o){this.sortPathConstraint(d);continue t}}}for(let o=0,c=n.length;o<c;o++)this.sortBone(n[o])}sortIkConstraint(t){const n=t.target;this.sortBone(n);const e=t.bones,r=e[0];if(this.sortBone(r),e.length>1){const i=e[e.length-1];this._updateCache.indexOf(i)>-1||this.updateCacheReset.push(i)}this._updateCache.push(t),this.sortReset(r.children),e[e.length-1].sorted=!0}sortPathConstraint(t){const n=t.target,e=n.data.index,r=n.bone;this.skin!=null&&this.sortPathConstraintAttachment(this.skin,e,r),this.data.defaultSkin!=null&&this.data.defaultSkin!=this.skin&&this.sortPathConstraintAttachment(this.data.defaultSkin,e,r);for(let s=0,a=this.data.skins.length;s<a;s++)this.sortPathConstraintAttachment(this.data.skins[s],e,r);const i=n.getAttachment();i instanceof us&&this.sortPathConstraintAttachmentWith(i,r);const h=t.bones,l=h.length;for(let s=0;s<l;s++)this.sortBone(h[s]);this._updateCache.push(t);for(let s=0;s<l;s++)this.sortReset(h[s].children);for(let s=0;s<l;s++)h[s].sorted=!0}sortTransformConstraint(t){this.sortBone(t.target);const n=t.bones,e=n.length;if(t.data.local)for(let r=0;r<e;r++){const i=n[r];this.sortBone(i.parent),this._updateCache.indexOf(i)>-1||this.updateCacheReset.push(i)}else for(let r=0;r<e;r++)this.sortBone(n[r]);this._updateCache.push(t);for(let r=0;r<e;r++)this.sortReset(n[r].children);for(let r=0;r<e;r++)n[r].sorted=!0}sortPathConstraintAttachment(t,n,e){const r=t.attachments[n];if(r)for(const i in r)this.sortPathConstraintAttachmentWith(r[i],e)}sortPathConstraintAttachmentWith(t,n){if(!(t instanceof us))return;const e=t.bones;if(e==null)this.sortBone(n);else{const r=this.bones;let i=0;for(;i<e.length;){const h=e[i++];for(let l=i+h;i<l;i++){const s=e[i];this.sortBone(r[s])}}}}sortBone(t){if(t.sorted)return;const n=t.parent;n!=null&&this.sortBone(n),t.sorted=!0,this._updateCache.push(t)}sortReset(t){for(let n=0,e=t.length;n<e;n++){const r=t[n];r.sorted&&this.sortReset(r.children),r.sorted=!1}}updateWorldTransform(){const t=this.updateCacheReset;for(let e=0,r=t.length;e<r;e++){const i=t[e];i.ax=i.x,i.ay=i.y,i.arotation=i.rotation,i.ascaleX=i.scaleX,i.ascaleY=i.scaleY,i.ashearX=i.shearX,i.ashearY=i.shearY,i.appliedValid=!0}const n=this._updateCache;for(let e=0,r=n.length;e<r;e++)n[e].update()}setToSetupPose(){this.setBonesToSetupPose(),this.setSlotsToSetupPose()}setBonesToSetupPose(){const t=this.bones;for(let i=0,h=t.length;i<h;i++)t[i].setToSetupPose();const n=this.ikConstraints;for(let i=0,h=n.length;i<h;i++){const l=n[i];l.bendDirection=l.data.bendDirection,l.mix=l.data.mix}const e=this.transformConstraints;for(let i=0,h=e.length;i<h;i++){const l=e[i],s=l.data;l.rotateMix=s.rotateMix,l.translateMix=s.translateMix,l.scaleMix=s.scaleMix,l.shearMix=s.shearMix}const r=this.pathConstraints;for(let i=0,h=r.length;i<h;i++){const l=r[i],s=l.data;l.position=s.position,l.spacing=s.spacing,l.rotateMix=s.rotateMix,l.translateMix=s.translateMix}}setSlotsToSetupPose(){const t=this.slots;k.arrayCopy(t,0,this.drawOrder,0,t.length);for(let n=0,e=t.length;n<e;n++)t[n].setToSetupPose()}getRootBone(){return this.bones.length==0?null:this.bones[0]}findBone(t){if(t==null)throw new Error("boneName cannot be null.");const n=this.bones;for(let e=0,r=n.length;e<r;e++){const i=n[e];if(i.data.name==t)return i}return null}findBoneIndex(t){if(t==null)throw new Error("boneName cannot be null.");const n=this.bones;for(let e=0,r=n.length;e<r;e++)if(n[e].data.name==t)return e;return-1}findSlot(t){if(t==null)throw new Error("slotName cannot be null.");const n=this.slots;for(let e=0,r=n.length;e<r;e++){const i=n[e];if(i.data.name==t)return i}return null}findSlotIndex(t){if(t==null)throw new Error("slotName cannot be null.");const n=this.slots;for(let e=0,r=n.length;e<r;e++)if(n[e].data.name==t)return e;return-1}setSkinByName(t){const n=this.data.findSkin(t);if(n==null)throw new Error(`Skin not found: ${t}`);this.setSkin(n)}setSkin(t){if(t!=null)if(this.skin!=null)t.attachAll(this,this.skin);else{const n=this.slots;for(let e=0,r=n.length;e<r;e++){const i=n[e],h=i.data.attachmentName;if(h!=null){const l=t.getAttachment(e,h);l!=null&&i.setAttachment(l)}}}this.skin=t}getAttachmentByName(t,n){return this.getAttachment(this.data.findSlotIndex(t),n)}getAttachment(t,n){if(n==null)throw new Error("attachmentName cannot be null.");if(this.skin!=null){const e=this.skin.getAttachment(t,n);if(e!=null)return e}return this.data.defaultSkin!=null?this.data.defaultSkin.getAttachment(t,n):null}setAttachment(t,n){if(t==null)throw new Error("slotName cannot be null.");const e=this.slots;for(let r=0,i=e.length;r<i;r++){const h=e[r];if(h.data.name==t){let l=null;if(n!=null&&(l=this.getAttachment(r,n),l==null))throw new Error(`Attachment not found: ${n}, for slot: ${t}`);h.setAttachment(l);return}}throw new Error(`Slot not found: ${t}`)}findIkConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const n=this.ikConstraints;for(let e=0,r=n.length;e<r;e++){const i=n[e];if(i.data.name==t)return i}return null}findTransformConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const n=this.transformConstraints;for(let e=0,r=n.length;e<r;e++){const i=n[e];if(i.data.name==t)return i}return null}findPathConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const n=this.pathConstraints;for(let e=0,r=n.length;e<r;e++){const i=n[e];if(i.data.name==t)return i}return null}getBounds(t,n,e){if(t==null)throw new Error("offset cannot be null.");if(n==null)throw new Error("size cannot be null.");const r=this.drawOrder;let i=Number.POSITIVE_INFINITY,h=Number.POSITIVE_INFINITY,l=Number.NEGATIVE_INFINITY,s=Number.NEGATIVE_INFINITY;for(let a=0,o=r.length;a<o;a++){const c=r[a];let d=0,u=null;const m=c.getAttachment();if(m instanceof et)d=8,u=k.setArraySize(e,d,0),m.computeWorldVertices(c.bone,u,0,2);else if(m instanceof Di){const g=m;d=g.worldVerticesLength,u=k.setArraySize(e,d,0),g.computeWorldVertices(c,0,d,u,0,2)}if(u!=null)for(let g=0,x=u.length;g<x;g+=2){const w=u[g],b=u[g+1];i=Math.min(i,w),h=Math.min(h,b),l=Math.max(l,w),s=Math.max(s,b)}}t.set(i,h),n.set(l-i,s-h)}update(t){this.time+=t}get flipX(){return this.scaleX==-1}set flipX(t){ms.deprecatedWarning1||(ms.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleX=t?1:-1}get flipY(){return this.scaleY==-1}set flipY(t){ms.deprecatedWarning1||(ms.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleY=t?1:-1}};let Ui=ms;Ui.deprecatedWarning1=!1;let uo=class extends Qn{},Sa=class{constructor(){this.bones=new Array,this.slots=new Array,this.skins=new Array,this.events=new Array,this.animations=new Array,this.ikConstraints=new Array,this.transformConstraints=new Array,this.pathConstraints=new Array,this.fps=0}findBone(t){if(t==null)throw new Error("boneName cannot be null.");const n=this.bones;for(let e=0,r=n.length;e<r;e++){const i=n[e];if(i.name==t)return i}return null}findBoneIndex(t){if(t==null)throw new Error("boneName cannot be null.");const n=this.bones;for(let e=0,r=n.length;e<r;e++)if(n[e].name==t)return e;return-1}findSlot(t){if(t==null)throw new Error("slotName cannot be null.");const n=this.slots;for(let e=0,r=n.length;e<r;e++){const i=n[e];if(i.name==t)return i}return null}findSlotIndex(t){if(t==null)throw new Error("slotName cannot be null.");const n=this.slots;for(let e=0,r=n.length;e<r;e++)if(n[e].name==t)return e;return-1}findSkin(t){if(t==null)throw new Error("skinName cannot be null.");const n=this.skins;for(let e=0,r=n.length;e<r;e++){const i=n[e];if(i.name==t)return i}return null}findEvent(t){if(t==null)throw new Error("eventDataName cannot be null.");const n=this.events;for(let e=0,r=n.length;e<r;e++){const i=n[e];if(i.name==t)return i}return null}findAnimation(t){if(t==null)throw new Error("animationName cannot be null.");const n=this.animations;for(let e=0,r=n.length;e<r;e++){const i=n[e];if(i.name==t)return i}return null}findIkConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const n=this.ikConstraints;for(let e=0,r=n.length;e<r;e++){const i=n[e];if(i.name==t)return i}return null}findTransformConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const n=this.transformConstraints;for(let e=0,r=n.length;e<r;e++){const i=n[e];if(i.name==t)return i}return null}findPathConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const n=this.pathConstraints;for(let e=0,r=n.length;e<r;e++){const i=n[e];if(i.name==t)return i}return null}findPathConstraintIndex(t){if(t==null)throw new Error("pathConstraintName cannot be null.");const n=this.pathConstraints;for(let e=0,r=n.length;e<r;e++)if(n[e].name==t)return e;return-1}},ya=class{constructor(t,n,e){if(this.color=new O(1,1,1,1),t<0)throw new Error("index must be >= 0.");if(n==null)throw new Error("name cannot be null.");if(e==null)throw new Error("boneData cannot be null.");this.index=t,this.name=n,this.boneData=e}},Ma=class{constructor(t){if(this.order=0,this.bones=new Array,this.rotateMix=0,this.translateMix=0,this.scaleMix=0,this.shearMix=0,this.offsetRotation=0,this.offsetX=0,this.offsetY=0,this.offsetScaleX=0,this.offsetScaleY=0,this.offsetShearY=0,this.relative=!1,this.local=!1,t==null)throw new Error("name cannot be null.");this.name=t}},Aa=class{constructor(t){if(this.attachments=new Array,t==null)throw new Error("name cannot be null.");this.name=t}addAttachment(t,n,e){if(e==null)throw new Error("attachment cannot be null.");const r=this.attachments;t>=r.length&&(r.length=t+1),r[t]||(r[t]={}),r[t][n]=e}getAttachment(t,n){const e=this.attachments[t];return e?e[n]:null}attachAll(t,n){let e=0;for(let r=0;r<t.slots.length;r++){const i=t.slots[r],h=i.getAttachment();if(h&&e<n.attachments.length){const l=n.attachments[e];for(const s in l){const a=l[s];if(h==a){const o=this.getAttachment(e,s);o!=null&&i.setAttachment(o);break}}}e++}}},On=class{constructor(t){this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=t}readSkeletonData(t){const n=this.scale,e=new Sa,r=typeof t=="string"?JSON.parse(t):t,i=r.skeleton;if(i!=null&&(e.hash=i.hash,e.version=i.spine,e.width=i.width,e.height=i.height,e.fps=i.fps,e.imagesPath=i.images),r.bones)for(let h=0;h<r.bones.length;h++){const l=r.bones[h];let s=null;const a=this.getValue(l,"parent",null);if(a!=null&&(s=e.findBone(a),s==null))throw new Error(`Parent bone not found: ${a}`);const o=new ma(e.bones.length,l.name,s);o.length=this.getValue(l,"length",0)*n,o.x=this.getValue(l,"x",0)*n,o.y=this.getValue(l,"y",0)*n,o.rotation=this.getValue(l,"rotation",0),o.scaleX=this.getValue(l,"scaleX",1),o.scaleY=this.getValue(l,"scaleY",1),o.shearX=this.getValue(l,"shearX",0),o.shearY=this.getValue(l,"shearY",0),o.transformMode=On.transformModeFromString(this.getValue(l,"transform","normal")),e.bones.push(o)}if(r.slots)for(let h=0;h<r.slots.length;h++){const l=r.slots[h],s=l.name,a=l.bone,o=e.findBone(a);if(o==null)throw new Error(`Slot bone not found: ${a}`);const c=new ya(e.slots.length,s,o),d=this.getValue(l,"color",null);d!=null&&c.color.setFromString(d);const u=this.getValue(l,"dark",null);u!=null&&(c.darkColor=new O(1,1,1,1),c.darkColor.setFromString(u)),c.attachmentName=this.getValue(l,"attachment",null),c.blendMode=On.blendModeFromString(this.getValue(l,"blend","normal")),e.slots.push(c)}if(r.ik)for(let h=0;h<r.ik.length;h++){const l=r.ik[h],s=new wa(l.name);s.order=this.getValue(l,"order",0);for(let o=0;o<l.bones.length;o++){const c=l.bones[o],d=e.findBone(c);if(d==null)throw new Error(`IK bone not found: ${c}`);s.bones.push(d)}const a=l.target;if(s.target=e.findBone(a),s.target==null)throw new Error(`IK target bone not found: ${a}`);s.bendDirection=this.getValue(l,"bendPositive",!0)?1:-1,s.mix=this.getValue(l,"mix",1),e.ikConstraints.push(s)}if(r.transform)for(let h=0;h<r.transform.length;h++){const l=r.transform[h],s=new Ma(l.name);s.order=this.getValue(l,"order",0);for(let o=0;o<l.bones.length;o++){const c=l.bones[o],d=e.findBone(c);if(d==null)throw new Error(`Transform constraint bone not found: ${c}`);s.bones.push(d)}const a=l.target;if(s.target=e.findBone(a),s.target==null)throw new Error(`Transform constraint target bone not found: ${a}`);s.local=this.getValue(l,"local",!1),s.relative=this.getValue(l,"relative",!1),s.offsetRotation=this.getValue(l,"rotation",0),s.offsetX=this.getValue(l,"x",0)*n,s.offsetY=this.getValue(l,"y",0)*n,s.offsetScaleX=this.getValue(l,"scaleX",0),s.offsetScaleY=this.getValue(l,"scaleY",0),s.offsetShearY=this.getValue(l,"shearY",0),s.rotateMix=this.getValue(l,"rotateMix",1),s.translateMix=this.getValue(l,"translateMix",1),s.scaleMix=this.getValue(l,"scaleMix",1),s.shearMix=this.getValue(l,"shearMix",1),e.transformConstraints.push(s)}if(r.path)for(let h=0;h<r.path.length;h++){const l=r.path[h],s=new ba(l.name);s.order=this.getValue(l,"order",0);for(let o=0;o<l.bones.length;o++){const c=l.bones[o],d=e.findBone(c);if(d==null)throw new Error(`Transform constraint bone not found: ${c}`);s.bones.push(d)}const a=l.target;if(s.target=e.findSlot(a),s.target==null)throw new Error(`Path target slot not found: ${a}`);s.positionMode=On.positionModeFromString(this.getValue(l,"positionMode","percent")),s.spacingMode=On.spacingModeFromString(this.getValue(l,"spacingMode","length")),s.rotateMode=On.rotateModeFromString(this.getValue(l,"rotateMode","tangent")),s.offsetRotation=this.getValue(l,"rotation",0),s.position=this.getValue(l,"position",0),s.positionMode==dt.Fixed&&(s.position*=n),s.spacing=this.getValue(l,"spacing",0),(s.spacingMode==Ke.Length||s.spacingMode==Ke.Fixed)&&(s.spacing*=n),s.rotateMix=this.getValue(l,"rotateMix",1),s.translateMix=this.getValue(l,"translateMix",1),e.pathConstraints.push(s)}if(r.skins)for(const h in r.skins){const l=r.skins[h],s=new Aa(h);for(const a in l){const o=e.findSlotIndex(a);if(o==-1)throw new Error(`Slot not found: ${a}`);const c=l[a];for(const d in c){const u=this.readAttachment(c[d],s,o,d,e);u!=null&&s.addAttachment(o,d,u)}}e.skins.push(s),s.name=="default"&&(e.defaultSkin=s)}for(let h=0,l=this.linkedMeshes.length;h<l;h++){const s=this.linkedMeshes[h],a=s.skin==null?e.defaultSkin:e.findSkin(s.skin);if(a==null)throw new Error(`Skin not found: ${s.skin}`);const o=a.getAttachment(s.slotIndex,s.parent);if(o==null)throw new Error(`Parent mesh not found: ${s.parent}`);s.mesh.setParentMesh(o)}if(this.linkedMeshes.length=0,r.events)for(const h in r.events){const l=r.events[h],s=new xa(h);s.intValue=this.getValue(l,"int",0),s.floatValue=this.getValue(l,"float",0),s.stringValue=this.getValue(l,"string",""),s.audioPath=this.getValue(l,"audio",null),s.audioPath!=null&&(s.volume=this.getValue(l,"volume",1),s.balance=this.getValue(l,"balance",0)),e.events.push(s)}if(r.animations)for(const h in r.animations){const l=r.animations[h];this.readAnimation(l,h,e)}return e}readAttachment(t,n,e,r,i){const h=this.scale;switch(r=this.getValue(t,"name",r),this.getValue(t,"type","region")){case"region":{const s=this.getValue(t,"path",r),a=this.attachmentLoader.newRegionAttachment(n,r,s);if(a==null)return null;a.path=s,a.x=this.getValue(t,"x",0)*h,a.y=this.getValue(t,"y",0)*h,a.scaleX=this.getValue(t,"scaleX",1),a.scaleY=this.getValue(t,"scaleY",1),a.rotation=this.getValue(t,"rotation",0),a.width=t.width*h,a.height=t.height*h;const o=this.getValue(t,"color",null);return o!=null&&a.color.setFromString(o),a}case"boundingbox":{const s=this.attachmentLoader.newBoundingBoxAttachment(n,r);if(s==null)return null;this.readVertices(t,s,t.vertexCount<<1);const a=this.getValue(t,"color",null);return a!=null&&s.color.setFromString(a),s}case"mesh":case"linkedmesh":{const s=this.getValue(t,"path",r),a=this.attachmentLoader.newMeshAttachment(n,r,s);if(a==null)return null;a.path=s;const o=this.getValue(t,"color",null);o!=null&&a.color.setFromString(o);const c=this.getValue(t,"parent",null);if(c!=null)return a.inheritDeform=this.getValue(t,"deform",!0),this.linkedMeshes.push(new mo(a,this.getValue(t,"skin",null),e,c)),a;const d=t.uvs;return this.readVertices(t,a,d.length),a.triangles=t.triangles,a.regionUVs=new Float32Array(d),a.hullLength=this.getValue(t,"hull",0)*2,a}case"path":{const s=this.attachmentLoader.newPathAttachment(n,r);if(s==null)return null;s.closed=this.getValue(t,"closed",!1),s.constantSpeed=this.getValue(t,"constantSpeed",!0);const a=t.vertexCount;this.readVertices(t,s,a<<1);const o=k.newArray(a/3,0);for(let d=0;d<t.lengths.length;d++)o[d]=t.lengths[d]*h;s.lengths=o;const c=this.getValue(t,"color",null);return c!=null&&s.color.setFromString(c),s}case"point":{const s=this.attachmentLoader.newPointAttachment(n,r);if(s==null)return null;s.x=this.getValue(t,"x",0)*h,s.y=this.getValue(t,"y",0)*h,s.rotation=this.getValue(t,"rotation",0);const a=this.getValue(t,"color",null);return a!=null&&s.color.setFromString(a),s}case"clipping":{const s=this.attachmentLoader.newClippingAttachment(n,r);if(s==null)return null;const a=this.getValue(t,"end",null);if(a!=null){const d=i.findSlot(a);if(d==null)throw new Error(`Clipping end slot not found: ${a}`);s.endSlot=d}const o=t.vertexCount;this.readVertices(t,s,o<<1);const c=this.getValue(t,"color",null);return c!=null&&s.color.setFromString(c),s}}return null}readVertices(t,n,e){const r=this.scale;n.worldVerticesLength=e;const i=t.vertices;if(e==i.length){const s=k.toFloatArray(i);if(r!=1)for(let a=0,o=i.length;a<o;a++)s[a]*=r;n.vertices=s;return}const h=new Array,l=new Array;for(let s=0,a=i.length;s<a;){const o=i[s++];l.push(o);for(let c=s+o*4;s<c;s+=4)l.push(i[s]),h.push(i[s+1]*r),h.push(i[s+2]*r),h.push(i[s+3])}n.bones=l,n.vertices=k.toFloatArray(h)}readAnimation(t,n,e){const r=this.scale,i=new Array;let h=0;if(t.slots)for(const s in t.slots){const a=t.slots[s],o=e.findSlotIndex(s);if(o==-1)throw new Error(`Slot not found: ${s}`);for(const c in a){const d=a[c];if(c=="attachment"){const u=new vs(d.length);u.slotIndex=o;let m=0;for(let g=0;g<d.length;g++){const x=d[g];u.setFrame(m++,x.time,x.name)}i.push(u),h=Math.max(h,u.frames[u.getFrameCount()-1])}else if(c=="color"){const u=new Xe(d.length);u.slotIndex=o;let m=0;for(let g=0;g<d.length;g++){const x=d[g],w=new O;w.setFromString(x.color||"ffffffff"),u.setFrame(m,x.time,w.r,w.g,w.b,w.a),this.readCurve(x,u,m),m++}i.push(u),h=Math.max(h,u.frames[(u.getFrameCount()-1)*Xe.ENTRIES])}else if(c=="twoColor"){const u=new Lt(d.length);u.slotIndex=o;let m=0;for(let g=0;g<d.length;g++){const x=d[g],w=new O,b=new O;w.setFromString(x.light),b.setFromString(x.dark),u.setFrame(m,x.time,w.r,w.g,w.b,w.a,b.r,b.g,b.b),this.readCurve(x,u,m),m++}i.push(u),h=Math.max(h,u.frames[(u.getFrameCount()-1)*Lt.ENTRIES])}else throw new Error(`Invalid timeline type for a slot: ${c} (${s})`)}}if(t.bones)for(const s in t.bones){const a=t.bones[s],o=e.findBoneIndex(s);if(o==-1)throw new Error(`Bone not found: ${s}`);for(const c in a){const d=a[c];if(c==="rotate"){const u=new me(d.length);u.boneIndex=o;let m=0;for(let g=0;g<d.length;g++){const x=d[g];u.setFrame(m,x.time,x.angle),this.readCurve(x,u,m),m++}i.push(u),h=Math.max(h,u.frames[(u.getFrameCount()-1)*me.ENTRIES])}else if(c==="translate"||c==="scale"||c==="shear"){let u=null,m=1;c==="scale"?u=new We(d.length):c==="shear"?u=new qe(d.length):(u=new Ze(d.length),m=r),u.boneIndex=o;let g=0;for(let x=0;x<d.length;x++){const w=d[x],b=this.getValue(w,"x",0),E=this.getValue(w,"y",0);u.setFrame(g,w.time,b*m,E*m),this.readCurve(w,u,g),g++}i.push(u),h=Math.max(h,u.frames[(u.getFrameCount()-1)*Ze.ENTRIES])}else throw new Error(`Invalid timeline type for a bone: ${c} (${s})`)}}if(t.ik)for(const s in t.ik){const a=t.ik[s],o=e.findIkConstraint(s),c=new Be(a.length);c.ikConstraintIndex=e.ikConstraints.indexOf(o);let d=0;for(let u=0;u<a.length;u++){const m=a[u];c.setFrame(d,m.time,this.getValue(m,"mix",1),this.getValue(m,"bendPositive",!0)?1:-1,this.getValue(m,"compress",!1),this.getValue(m,"stretch",!1)),this.readCurve(m,c,d),d++}i.push(c),h=Math.max(h,c.frames[(c.getFrameCount()-1)*Be.ENTRIES])}if(t.transform)for(const s in t.transform){const a=t.transform[s],o=e.findTransformConstraint(s),c=new De(a.length);c.transformConstraintIndex=e.transformConstraints.indexOf(o);let d=0;for(let u=0;u<a.length;u++){const m=a[u];c.setFrame(d,m.time,this.getValue(m,"rotateMix",1),this.getValue(m,"translateMix",1),this.getValue(m,"scaleMix",1),this.getValue(m,"shearMix",1)),this.readCurve(m,c,d),d++}i.push(c),h=Math.max(h,c.frames[(c.getFrameCount()-1)*De.ENTRIES])}if(t.paths)for(const s in t.paths){const a=t.paths[s],o=e.findPathConstraintIndex(s);if(o==-1)throw new Error(`Path constraint not found: ${s}`);const c=e.pathConstraints[o];for(const d in a){const u=a[d];if(d==="position"||d==="spacing"){let m=null,g=1;d==="spacing"?(m=new pn(u.length),(c.spacingMode==Ke.Length||c.spacingMode==Ke.Fixed)&&(g=r)):(m=new Vn(u.length),c.positionMode==dt.Fixed&&(g=r)),m.pathConstraintIndex=o;let x=0;for(let w=0;w<u.length;w++){const b=u[w];m.setFrame(x,b.time,this.getValue(b,d,0)*g),this.readCurve(b,m,x),x++}i.push(m),h=Math.max(h,m.frames[(m.getFrameCount()-1)*Vn.ENTRIES])}else if(d==="mix"){const m=new wn(u.length);m.pathConstraintIndex=o;let g=0;for(let x=0;x<u.length;x++){const w=u[x];m.setFrame(g,w.time,this.getValue(w,"rotateMix",1),this.getValue(w,"translateMix",1)),this.readCurve(w,m,g),g++}i.push(m),h=Math.max(h,m.frames[(m.getFrameCount()-1)*wn.ENTRIES])}}}if(t.deform)for(const s in t.deform){const a=t.deform[s],o=e.findSkin(s);if(o==null){if(jt.FAIL_ON_NON_EXISTING_SKIN)throw new Error(`Skin not found: ${s}`);continue}for(const c in a){const d=a[c],u=e.findSlotIndex(c);if(u==-1)throw new Error(`Slot not found: ${d.name}`);for(const m in d){const g=d[m],x=o.getAttachment(u,m);if(x==null)throw new Error(`Deform attachment not found: ${g.name}`);const w=x.bones!=null,b=x.vertices,E=w?b.length/3*2:b.length,p=new da(g.length);p.slotIndex=u,p.attachment=x;let S=0;for(let y=0;y<g.length;y++){const M=g[y];let C;const I=this.getValue(M,"vertices",null);if(I==null)C=w?k.newFloatArray(E):b;else{C=k.newFloatArray(E);const R=this.getValue(M,"offset",0);if(k.arrayCopy(I,0,C,R,I.length),r!=1)for(let v=R,V=v+I.length;v<V;v++)C[v]*=r;if(!w)for(let v=0;v<E;v++)C[v]+=b[v]}p.setFrame(S,M.time,C),this.readCurve(M,p,S),S++}i.push(p),h=Math.max(h,p.frames[p.getFrameCount()-1])}}}let l=t.drawOrder;if(l==null&&(l=t.draworder),l!=null){const s=new Vs(l.length),a=e.slots.length;let o=0;for(let c=0;c<l.length;c++){const d=l[c];let u=null;const m=this.getValue(d,"offsets",null);if(m!=null){u=k.newArray(a,-1);const g=k.newArray(a-m.length,0);let x=0,w=0;for(let b=0;b<m.length;b++){const E=m[b],p=e.findSlotIndex(E.slot);if(p==-1)throw new Error(`Slot not found: ${E.slot}`);for(;x!=p;)g[w++]=x++;u[x+E.offset]=x++}for(;x<a;)g[w++]=x++;for(let b=a-1;b>=0;b--)u[b]==-1&&(u[b]=g[--w])}s.setFrame(o++,d.time,u)}i.push(s),h=Math.max(h,s.frames[s.getFrameCount()-1])}if(t.events){const s=new fa(t.events.length);let a=0;for(let o=0;o<t.events.length;o++){const c=t.events[o],d=e.findEvent(c.name);if(d==null)throw new Error(`Event not found: ${c.name}`);const u=new ga(k.toSinglePrecision(c.time),d);u.intValue=this.getValue(c,"int",d.intValue),u.floatValue=this.getValue(c,"float",d.floatValue),u.stringValue=this.getValue(c,"string",d.stringValue),u.data.audioPath!=null&&(u.volume=this.getValue(c,"volume",1),u.balance=this.getValue(c,"balance",0)),s.setFrame(a++,u)}i.push(s),h=Math.max(h,s.frames[s.getFrameCount()-1])}if(isNaN(h))throw new Error("Error while parsing animation, duration is NaN");e.animations.push(new _t(n,i,h))}readCurve(t,n,e){if(t.curve){if(t.curve==="stepped")n.setStepped(e);else if(Object.prototype.toString.call(t.curve)==="[object Array]"){const r=t.curve;n.setCurve(e,r[0],r[1],r[2],r[3])}}}getValue(t,n,e){return t[n]!==void 0?t[n]:e}static blendModeFromString(t){if(t=t.toLowerCase(),t=="normal")return G.BLEND_MODES.NORMAL;if(t=="additive")return G.BLEND_MODES.ADD;if(t=="multiply")return G.BLEND_MODES.MULTIPLY;if(t=="screen")return G.BLEND_MODES.SCREEN;throw new Error(`Unknown blend mode: ${t}`)}static positionModeFromString(t){if(t=t.toLowerCase(),t=="fixed")return dt.Fixed;if(t=="percent")return dt.Percent;throw new Error(`Unknown position mode: ${t}`)}static spacingModeFromString(t){if(t=t.toLowerCase(),t=="length")return Ke.Length;if(t=="fixed")return Ke.Fixed;if(t=="percent")return Ke.Percent;throw new Error(`Unknown position mode: ${t}`)}static rotateModeFromString(t){if(t=t.toLowerCase(),t=="tangent")return ut.Tangent;if(t=="chain")return ut.Chain;if(t=="chainscale")return ut.ChainScale;throw new Error(`Unknown rotate mode: ${t}`)}static transformModeFromString(t){if(t=t.toLowerCase(),t=="normal")return z.Normal;if(t=="onlytranslation")return z.OnlyTranslation;if(t=="norotationorreflection")return z.NoRotationOrReflection;if(t=="noscale")return z.NoScale;if(t=="noscaleorreflection")return z.NoScaleOrReflection;throw new Error(`Unknown transform mode: ${t}`)}},mo=class{constructor(t,n,e,r){this.mesh=t,this.skin=n,this.slotIndex=e,this.parent=r}};var go=Object.freeze({__proto__:null,Animation:_t,AnimationState:hn,AnimationStateAdapter2:fo,AnimationStateData:Wi,AtlasAttachmentLoader:ua,Attachment:Bi,AttachmentTimeline:vs,Bone:qi,BoneData:ma,BoundingBoxAttachment:ia,ClippingAttachment:ra,ColorTimeline:Xe,CurveTimeline:ye,DeformTimeline:da,DrawOrderTimeline:Vs,Event:ga,EventData:xa,EventQueue:Oi,EventTimeline:fa,EventType:Me,IkConstraint:pa,IkConstraintData:wa,IkConstraintTimeline:Be,JitterEffect:ho,MeshAttachment:Di,PathAttachment:us,PathConstraint:as,PathConstraintData:ba,PathConstraintMixTimeline:wn,PathConstraintPositionTimeline:Vn,PathConstraintSpacingTimeline:pn,PointAttachment:aa,RegionAttachment:et,RotateTimeline:me,ScaleTimeline:We,ShearTimeline:qe,Skeleton:Ui,SkeletonBounds:uo,SkeletonData:Sa,SkeletonJson:On,Skin:Aa,Slot:_i,SlotData:ya,SpacingMode:Ke,Spine:class extends An{createSkeleton(t){this.skeleton=new Ui(t),this.skeleton.updateWorldTransform(),this.stateData=new Wi(t),this.state=new hn(this.stateData)}},SwirlEffect:la,TimelineType:ca,TrackEntry:Ps,TransformConstraint:Ea,TransformConstraintData:Ma,TransformConstraintTimeline:De,TranslateTimeline:Ze,TwoColorTimeline:Lt,VertexAttachment:kn});class Hi{constructor(t){if(!t)throw new Error("name cannot be null.");this.name=t}}const Ta=class extends Hi{constructor(f){super(f),this.id=Ta.nextID++,this.bones=null,this.vertices=[],this.worldVerticesLength=0,this.timelineAttachment=this}computeWorldVerticesOld(f,t){this.computeWorldVertices(f,0,this.worldVerticesLength,t,0,2)}computeWorldVertices(f,t,n,e,r,i){n=r+(n>>1)*i;const h=f.bone.skeleton,l=f.deform;let s=this.vertices;const a=this.bones;if(!a){l.length>0&&(s=l);const u=f.bone.matrix,m=u.tx,g=u.ty,x=u.a,w=u.c,b=u.b,E=u.d;for(let p=t,S=r;S<n;p+=2,S+=i){const y=s[p],M=s[p+1];e[S]=y*x+M*w+m,e[S+1]=y*b+M*E+g}return}let o=0,c=0;for(let u=0;u<t;u+=2){const m=a[o];o+=m+1,c+=m}const d=h.bones;if(l.length==0)for(let u=r,m=c*3;u<n;u+=i){let g=0,x=0,w=a[o++];for(w+=o;o<w;o++,m+=3){const b=d[a[o]].matrix,E=s[m],p=s[m+1],S=s[m+2];g+=(E*b.a+p*b.c+b.tx)*S,x+=(E*b.b+p*b.d+b.ty)*S}e[u]=g,e[u+1]=x}else{const u=l;for(let m=r,g=c*3,x=c<<1;m<n;m+=i){let w=0,b=0,E=a[o++];for(E+=o;o<E;o++,g+=3,x+=2){const p=d[a[o]].matrix,S=s[g]+u[x],y=s[g+1]+u[x+1],M=s[g+2];w+=(S*p.a+y*p.c+p.tx)*M,b+=(S*p.b+y*p.d+p.ty)*M}e[m]=w,e[m+1]=b}}}copyTo(f){this.bones?(f.bones=new Array(this.bones.length),k.arrayCopy(this.bones,0,f.bones,0,this.bones.length)):f.bones=null,this.vertices&&(f.vertices=k.newFloatArray(this.vertices.length),k.arrayCopy(this.vertices,0,f.vertices,0,this.vertices.length)),f.worldVerticesLength=this.worldVerticesLength,f.timelineAttachment=this.timelineAttachment}};let Je=Ta;Je.nextID=0;class Fs extends Je{constructor(t){super(t),this.type=Z.BoundingBox,this.color=new O(1,1,1,1)}copy(){const t=new Fs(this.name);return this.copyTo(t),t.color.setFromColor(this.color),t}}class Ys extends Je{constructor(t){super(t),this.type=Z.Clipping,this.endSlot=null,this.color=new O(.2275,.2275,.8078,1)}copy(){const t=new Ys(this.name);return this.copyTo(t),t.endSlot=this.endSlot,t.color.setFromColor(this.color),t}}class $n extends Je{constructor(t,n){super(t),this.type=Z.Mesh,this.region=null,this.triangles=[],this.color=new O(1,1,1,1),this.width=0,this.height=0,this.hullLength=0,this.edges=[],this.parentMesh=null,this.sequence=null,this.tempColor=new O(0,0,0,0),this.path=n}getParentMesh(){return this.parentMesh}setParentMesh(t){this.parentMesh=t,t&&(this.bones=t.bones,this.vertices=t.vertices,this.worldVerticesLength=t.worldVerticesLength,this.regionUVs=t.regionUVs,this.triangles=t.triangles,this.hullLength=t.hullLength,this.worldVerticesLength=t.worldVerticesLength)}copy(){if(this.parentMesh)return this.newLinkedMesh();const t=new $n(this.name,this.path);return t.region=this.region,t.color.setFromColor(this.color),this.copyTo(t),t.regionUVs=new Float32Array(this.regionUVs.length),k.arrayCopy(this.regionUVs,0,t.regionUVs,0,this.regionUVs.length),t.triangles=new Array(this.triangles.length),k.arrayCopy(this.triangles,0,t.triangles,0,this.triangles.length),t.hullLength=this.hullLength,t.sequence=this.sequence!=null?this.sequence.copy():null,this.edges&&(t.edges=new Array(this.edges.length),k.arrayCopy(this.edges,0,t.edges,0,this.edges.length)),t.width=this.width,t.height=this.height,t}computeWorldVertices(t,n,e,r,i,h){this.sequence!=null&&this.sequence.apply(t,this),super.computeWorldVertices(t,n,e,r,i,h)}newLinkedMesh(){const t=new $n(this.name,this.path);return t.region=this.region,t.color.setFromColor(this.color),t.timelineAttachment=this.timelineAttachment,t.setParentMesh(this.parentMesh?this.parentMesh:this),t}}class Wn extends Je{constructor(t){super(t),this.type=Z.Path,this.lengths=[],this.closed=!1,this.constantSpeed=!1,this.color=new O(1,1,1,1)}copy(){const t=new Wn(this.name);return this.copyTo(t),t.lengths=new Array(this.lengths.length),k.arrayCopy(this.lengths,0,t.lengths,0,this.lengths.length),t.closed=closed,t.constantSpeed=this.constantSpeed,t.color.setFromColor(this.color),t}}class Ns extends Je{constructor(t){super(t),this.type=Z.Point,this.x=0,this.y=0,this.rotation=0,this.color=new O(.38,.94,0,1)}computeWorldPosition(t,n){const e=t.matrix;return n.x=this.x*e.a+this.y*e.c+t.worldX,n.y=this.x*e.b+this.y*e.d+t.worldY,n}computeWorldRotation(t){const n=t.matrix,e=T.cosDeg(this.rotation),r=T.sinDeg(this.rotation),i=e*n.a+r*n.c,h=e*n.b+r*n.d;return Math.atan2(h,i)*T.radDeg}copy(){const t=new Ns(this.name);return t.x=this.x,t.y=this.y,t.rotation=this.rotation,t.color.setFromColor(this.color),t}}const Ca=class extends Hi{constructor(f,t){super(f),this.type=Z.Region,this.x=0,this.y=0,this.scaleX=1,this.scaleY=1,this.rotation=0,this.width=0,this.height=0,this.color=new O(1,1,1,1),this.rendererObject=null,this.region=null,this.sequence=null,this.offset=k.newFloatArray(8),this.uvs=k.newFloatArray(8),this.tempColor=new O(1,1,1,1),this.path=t}updateRegion(){if(!this.region)throw new Error("Region not set.");const f=this.region,t=this.width/this.region.originalWidth*this.scaleX,n=this.height/this.region.originalHeight*this.scaleY,e=-this.width/2*this.scaleX+this.region.offsetX*t,r=-this.height/2*this.scaleY+this.region.offsetY*n,i=e+this.region.width*t,h=r+this.region.height*n,l=this.rotation*Math.PI/180,s=Math.cos(l),a=Math.sin(l),o=this.x,c=this.y,d=e*s+o,u=e*a,m=r*s+c,g=r*a,x=i*s+o,w=i*a,b=h*s+c,E=h*a,p=this.offset;p[0]=d-g,p[1]=m+u,p[2]=d-E,p[3]=b+u,p[4]=x-E,p[5]=b+w,p[6]=x-g,p[7]=m+w;const S=this.uvs;f.degrees==90?(S[2]=f.u,S[3]=f.v2,S[4]=f.u,S[5]=f.v,S[6]=f.u2,S[7]=f.v,S[0]=f.u2,S[1]=f.v2):(S[0]=f.u,S[1]=f.v2,S[2]=f.u,S[3]=f.v,S[4]=f.u2,S[5]=f.v,S[6]=f.u2,S[7]=f.v2)}computeWorldVertices(f,t,n,e){this.sequence!=null&&this.sequence.apply(f,this);const r=f.bone,i=this.offset,h=r.matrix,l=h.tx,s=h.ty,a=h.a,o=h.c,c=h.b,d=h.d;let u=0,m=0;u=i[0],m=i[1],t[n]=u*a+m*o+l,t[n+1]=u*c+m*d+s,n+=e,u=i[2],m=i[3],t[n]=u*a+m*o+l,t[n+1]=u*c+m*d+s,n+=e,u=i[4],m=i[5],t[n]=u*a+m*o+l,t[n+1]=u*c+m*d+s,n+=e,u=i[6],m=i[7],t[n]=u*a+m*o+l,t[n+1]=u*c+m*d+s}copy(){const f=new Ca(this.name,this.path);return f.region=this.region,f.rendererObject=this.rendererObject,f.x=this.x,f.y=this.y,f.scaleX=this.scaleX,f.scaleY=this.scaleY,f.rotation=this.rotation,f.width=this.width,f.height=this.height,k.arrayCopy(this.uvs,0,f.uvs,0,8),k.arrayCopy(this.offset,0,f.offset,0,8),f.color.setFromColor(this.color),f.sequence=this.sequence!=null?this.sequence.copy():null,f}};let lt=Ca;lt.X1=0,lt.Y1=1,lt.C1R=2,lt.C1G=3,lt.C1B=4,lt.C1A=5,lt.U1=6,lt.V1=7,lt.X2=8,lt.Y2=9,lt.C2R=10,lt.C2G=11,lt.C2B=12,lt.C2A=13,lt.U2=14,lt.V2=15,lt.X3=16,lt.Y3=17,lt.C3R=18,lt.C3G=19,lt.C3B=20,lt.C3A=21,lt.U3=22,lt.V3=23,lt.X4=24,lt.Y4=25,lt.C4R=26,lt.C4G=27,lt.C4B=28,lt.C4A=29,lt.U4=30,lt.V4=31;const Xs=class{constructor(f){this.id=Xs.nextID(),this.start=0,this.digits=0,this.setupIndex=0,this.regions=new Array(f)}copy(){const f=new Xs(this.regions.length);return k.arrayCopy(this.regions,0,f.regions,0,this.regions.length),f.start=this.start,f.digits=this.digits,f.setupIndex=this.setupIndex,f}apply(f,t){let n=f.sequenceIndex;n==-1&&(n=this.setupIndex),n>=this.regions.length&&(n=this.regions.length-1);const e=this.regions[n];t.region!=e&&(t.region=e)}getPath(f,t){let n=f;const e=(this.start+t).toString();for(let r=this.digits-e.length;r>0;r--)n+="0";return n+=e,n}static nextID(){return Xs._nextID++}};let Bs=Xs;Bs._nextID=0;var dn=(f=>(f[f.hold=0]="hold",f[f.once=1]="once",f[f.loop=2]="loop",f[f.pingpong=3]="pingpong",f[f.onceReverse=4]="onceReverse",f[f.loopReverse=5]="loopReverse",f[f.pingpongReverse=6]="pingpongReverse",f))(dn||{});const zi=[0,1,2,3,4,5,6];class Ds{constructor(t,n,e){if(this.timelines=[],this.timelineIds=new zs,!t)throw new Error("name cannot be null.");this.name=t,this.setTimelines(n),this.duration=e}setTimelines(t){if(!t)throw new Error("timelines cannot be null.");this.timelines=t,this.timelineIds.clear();for(let n=0;n<t.length;n++)this.timelineIds.addAll(t[n].getPropertyIds())}hasTimeline(t){for(let n=0;n<t.length;n++)if(this.timelineIds.contains(t[n]))return!0;return!1}apply(t,n,e,r,i,h,l,s){if(!t)throw new Error("skeleton cannot be null.");r&&this.duration!=0&&(e%=this.duration,n>0&&(n%=this.duration));const a=this.timelines;for(let o=0,c=a.length;o<c;o++)a[o].apply(t,n,e,i,h,l,s)}}const ft={rotate:0,x:1,y:2,scaleX:3,scaleY:4,shearX:5,shearY:6,rgb:7,alpha:8,rgb2:9,attachment:10,deform:11,event:12,drawOrder:13,ikConstraint:14,transformConstraint:15,pathConstraintPosition:16,pathConstraintSpacing:17,pathConstraintMix:18,sequence:19};class Ct{constructor(t,n){this.propertyIds=n,this.frames=k.newFloatArray(t*this.getFrameEntries())}getPropertyIds(){return this.propertyIds}getFrameEntries(){return 1}getFrameCount(){return this.frames.length/this.getFrameEntries()}getDuration(){return this.frames[this.frames.length-this.getFrameEntries()]}static search1(t,n){const e=t.length;for(let r=1;r<e;r++)if(t[r]>n)return r-1;return e-1}static search(t,n,e){const r=t.length;for(let i=e;i<r;i+=e)if(t[i]>n)return i-e;return r-e}}class tn extends Ct{constructor(t,n,e){super(t,e),this.curves=k.newFloatArray(t+n*18),this.curves[t-1]=1}setLinear(t){this.curves[t]=0}setStepped(t){this.curves[t]=1}shrink(t){const n=this.getFrameCount()+t*18;if(this.curves.length>n){const e=k.newFloatArray(n);k.arrayCopy(this.curves,0,e,0,n),this.curves=e}}setBezier(t,n,e,r,i,h,l,s,a,o,c){const d=this.curves;let u=this.getFrameCount()+t*18;e==0&&(d[n]=2+u);const m=(r-h*2+s)*.03,g=(i-l*2+a)*.03,x=((h-s)*3-r+o)*.006,w=((l-a)*3-i+c)*.006;let b=m*2+x,E=g*2+w,p=(h-r)*.3+m+x*.16666667,S=(l-i)*.3+g+w*.16666667,y=r+p,M=i+S;for(let C=u+18;u<C;u+=2)d[u]=y,d[u+1]=M,p+=b,S+=E,b+=x,E+=w,y+=p,M+=S}getBezierValue(t,n,e,r){const i=this.curves;if(i[r]>t){const a=this.frames[n],o=this.frames[n+e];return o+(t-a)/(i[r]-a)*(i[r+1]-o)}const h=r+18;for(r+=2;r<h;r+=2)if(i[r]>=t){const a=i[r-2],o=i[r-1];return o+(t-a)/(i[r]-a)*(i[r+1]-o)}n+=this.getFrameEntries();const l=i[h-2],s=i[h-1];return s+(t-l)/(this.frames[n]-l)*(this.frames[n+e]-s)}}class en extends tn{constructor(t,n,e){super(t,n,[e])}getFrameEntries(){return 2}setFrame(t,n,e){t<<=1,this.frames[t]=n,this.frames[t+1]=e}getCurveValue(t){const n=this.frames;let e=n.length-2;for(let i=2;i<=e;i+=2)if(n[i]>t){e=i-2;break}const r=this.curves[e>>1];switch(r){case 0:const i=n[e],h=n[e+1];return h+(t-i)/(n[e+2]-i)*(n[e+2+1]-h);case 1:return n[e+1]}return this.getBezierValue(t,e,1,r-2)}}class _s extends tn{constructor(t,n,e,r){super(t,n,[e,r])}getFrameEntries(){return 3}setFrame(t,n,e,r){t*=3,this.frames[t]=n,this.frames[t+1]=e,this.frames[t+2]=r}}class gs extends en{constructor(t,n,e){super(t,n,`${ft.rotate}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,n,e,r,i,h,l){const s=t.bones[this.boneIndex];if(!s.active)return;const a=this.frames;if(e<a[0]){switch(h){case A.setup:s.rotation=s.data.rotation;return;case A.first:s.rotation+=(s.data.rotation-s.rotation)*i}return}let o=this.getCurveValue(e);switch(h){case A.setup:s.rotation=s.data.rotation+o*i;break;case A.first:case A.replace:o+=s.data.rotation-s.rotation;case A.add:s.rotation+=o*i}}}class Gi extends _s{constructor(t,n,e){super(t,n,`${ft.x}|${e}`,`${ft.y}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,n,e,r,i,h,l){const s=t.bones[this.boneIndex];if(!s.active)return;const a=this.frames;if(e<a[0]){switch(h){case A.setup:s.x=s.data.x,s.y=s.data.y;return;case A.first:s.x+=(s.data.x-s.x)*i,s.y+=(s.data.y-s.y)*i}return}let o=0,c=0;const d=Ct.search(a,e,3),u=this.curves[d/3];switch(u){case 0:const m=a[d];o=a[d+1],c=a[d+2];const g=(e-m)/(a[d+3]-m);o+=(a[d+3+1]-o)*g,c+=(a[d+3+2]-c)*g;break;case 1:o=a[d+1],c=a[d+2];break;default:o=this.getBezierValue(e,d,1,u-2),c=this.getBezierValue(e,d,2,u+18-2)}switch(h){case A.setup:s.x=s.data.x+o*i,s.y=s.data.y+c*i;break;case A.first:case A.replace:s.x+=(s.data.x+o-s.x)*i,s.y+=(s.data.y+c-s.y)*i;break;case A.add:s.x+=o*i,s.y+=c*i}}}class ji extends en{constructor(t,n,e){super(t,n,`${ft.x}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,n,e,r,i,h,l){const s=t.bones[this.boneIndex];if(!s.active)return;const a=this.frames;if(e<a[0]){switch(h){case A.setup:s.x=s.data.x;return;case A.first:s.x+=(s.data.x-s.x)*i}return}const o=this.getCurveValue(e);switch(h){case A.setup:s.x=s.data.x+o*i;break;case A.first:case A.replace:s.x+=(s.data.x+o-s.x)*i;break;case A.add:s.x+=o*i}}}class Zi extends en{constructor(t,n,e){super(t,n,`${ft.y}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,n,e,r,i,h,l){const s=t.bones[this.boneIndex];if(!s.active)return;const a=this.frames;if(e<a[0]){switch(h){case A.setup:s.y=s.data.y;return;case A.first:s.y+=(s.data.y-s.y)*i}return}const o=this.getCurveValue(e);switch(h){case A.setup:s.y=s.data.y+o*i;break;case A.first:case A.replace:s.y+=(s.data.y+o-s.y)*i;break;case A.add:s.y+=o*i}}}class Qi extends _s{constructor(t,n,e){super(t,n,`${ft.scaleX}|${e}`,`${ft.scaleY}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,n,e,r,i,h,l){const s=t.bones[this.boneIndex];if(!s.active)return;const a=this.frames;if(e<a[0]){switch(h){case A.setup:s.scaleX=s.data.scaleX,s.scaleY=s.data.scaleY;return;case A.first:s.scaleX+=(s.data.scaleX-s.scaleX)*i,s.scaleY+=(s.data.scaleY-s.scaleY)*i}return}let o,c;const d=Ct.search(a,e,3),u=this.curves[d/3];switch(u){case 0:const m=a[d];o=a[d+1],c=a[d+2];const g=(e-m)/(a[d+3]-m);o+=(a[d+3+1]-o)*g,c+=(a[d+3+2]-c)*g;break;case 1:o=a[d+1],c=a[d+2];break;default:o=this.getBezierValue(e,d,1,u-2),c=this.getBezierValue(e,d,2,u+18-2)}if(o*=s.data.scaleX,c*=s.data.scaleY,i==1)h==A.add?(s.scaleX+=o-s.data.scaleX,s.scaleY+=c-s.data.scaleY):(s.scaleX=o,s.scaleY=c);else{let m=0,g=0;if(l==Q.mixOut)switch(h){case A.setup:m=s.data.scaleX,g=s.data.scaleY,s.scaleX=m+(Math.abs(o)*T.signum(m)-m)*i,s.scaleY=g+(Math.abs(c)*T.signum(g)-g)*i;break;case A.first:case A.replace:m=s.scaleX,g=s.scaleY,s.scaleX=m+(Math.abs(o)*T.signum(m)-m)*i,s.scaleY=g+(Math.abs(c)*T.signum(g)-g)*i;break;case A.add:s.scaleX+=(o-s.data.scaleX)*i,s.scaleY+=(c-s.data.scaleY)*i}else switch(h){case A.setup:m=Math.abs(s.data.scaleX)*T.signum(o),g=Math.abs(s.data.scaleY)*T.signum(c),s.scaleX=m+(o-m)*i,s.scaleY=g+(c-g)*i;break;case A.first:case A.replace:m=Math.abs(s.scaleX)*T.signum(o),g=Math.abs(s.scaleY)*T.signum(c),s.scaleX=m+(o-m)*i,s.scaleY=g+(c-g)*i;break;case A.add:s.scaleX+=(o-s.data.scaleX)*i,s.scaleY+=(c-s.data.scaleY)*i}}}}class Ki extends en{constructor(t,n,e){super(t,n,`${ft.scaleX}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,n,e,r,i,h,l){const s=t.bones[this.boneIndex];if(!s.active)return;const a=this.frames;if(e<a[0]){switch(h){case A.setup:s.scaleX=s.data.scaleX;return;case A.first:s.scaleX+=(s.data.scaleX-s.scaleX)*i}return}const o=this.getCurveValue(e)*s.data.scaleX;if(i==1)h==A.add?s.scaleX+=o-s.data.scaleX:s.scaleX=o;else{let c=0;if(l==Q.mixOut)switch(h){case A.setup:c=s.data.scaleX,s.scaleX=c+(Math.abs(o)*T.signum(c)-c)*i;break;case A.first:case A.replace:c=s.scaleX,s.scaleX=c+(Math.abs(o)*T.signum(c)-c)*i;break;case A.add:s.scaleX+=(o-s.data.scaleX)*i}else switch(h){case A.setup:c=Math.abs(s.data.scaleX)*T.signum(o),s.scaleX=c+(o-c)*i;break;case A.first:case A.replace:c=Math.abs(s.scaleX)*T.signum(o),s.scaleX=c+(o-c)*i;break;case A.add:s.scaleX+=(o-s.data.scaleX)*i}}}}class Ji extends en{constructor(t,n,e){super(t,n,`${ft.scaleY}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,n,e,r,i,h,l){const s=t.bones[this.boneIndex];if(!s.active)return;const a=this.frames;if(e<a[0]){switch(h){case A.setup:s.scaleY=s.data.scaleY;return;case A.first:s.scaleY+=(s.data.scaleY-s.scaleY)*i}return}const o=this.getCurveValue(e)*s.data.scaleY;if(i==1)h==A.add?s.scaleY+=o-s.data.scaleY:s.scaleY=o;else{let c=0;if(l==Q.mixOut)switch(h){case A.setup:c=s.data.scaleY,s.scaleY=c+(Math.abs(o)*T.signum(c)-c)*i;break;case A.first:case A.replace:c=s.scaleY,s.scaleY=c+(Math.abs(o)*T.signum(c)-c)*i;break;case A.add:s.scaleY+=(o-s.data.scaleY)*i}else switch(h){case A.setup:c=Math.abs(s.data.scaleY)*T.signum(o),s.scaleY=c+(o-c)*i;break;case A.first:case A.replace:c=Math.abs(s.scaleY)*T.signum(o),s.scaleY=c+(o-c)*i;break;case A.add:s.scaleY+=(o-s.data.scaleY)*i}}}}class tr extends _s{constructor(t,n,e){super(t,n,`${ft.shearX}|${e}`,`${ft.shearY}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,n,e,r,i,h,l){const s=t.bones[this.boneIndex];if(!s.active)return;const a=this.frames;if(e<a[0]){switch(h){case A.setup:s.shearX=s.data.shearX,s.shearY=s.data.shearY;return;case A.first:s.shearX+=(s.data.shearX-s.shearX)*i,s.shearY+=(s.data.shearY-s.shearY)*i}return}let o=0,c=0;const d=Ct.search(a,e,3),u=this.curves[d/3];switch(u){case 0:const m=a[d];o=a[d+1],c=a[d+2];const g=(e-m)/(a[d+3]-m);o+=(a[d+3+1]-o)*g,c+=(a[d+3+2]-c)*g;break;case 1:o=a[d+1],c=a[d+2];break;default:o=this.getBezierValue(e,d,1,u-2),c=this.getBezierValue(e,d,2,u+18-2)}switch(h){case A.setup:s.shearX=s.data.shearX+o*i,s.shearY=s.data.shearY+c*i;break;case A.first:case A.replace:s.shearX+=(s.data.shearX+o-s.shearX)*i,s.shearY+=(s.data.shearY+c-s.shearY)*i;break;case A.add:s.shearX+=o*i,s.shearY+=c*i}}}class er extends en{constructor(t,n,e){super(t,n,`${ft.shearX}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,n,e,r,i,h,l){const s=t.bones[this.boneIndex];if(!s.active)return;const a=this.frames;if(e<a[0]){switch(h){case A.setup:s.shearX=s.data.shearX;return;case A.first:s.shearX+=(s.data.shearX-s.shearX)*i}return}const o=this.getCurveValue(e);switch(h){case A.setup:s.shearX=s.data.shearX+o*i;break;case A.first:case A.replace:s.shearX+=(s.data.shearX+o-s.shearX)*i;break;case A.add:s.shearX+=o*i}}}class nr extends en{constructor(t,n,e){super(t,n,`${ft.shearY}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,n,e,r,i,h,l){const s=t.bones[this.boneIndex];if(!s.active)return;const a=this.frames;if(e<a[0]){switch(h){case A.setup:s.shearY=s.data.shearY;return;case A.first:s.shearY+=(s.data.shearY-s.shearY)*i}return}const o=this.getCurveValue(e);switch(h){case A.setup:s.shearY=s.data.shearY+o*i;break;case A.first:case A.replace:s.shearY+=(s.data.shearY+o-s.shearY)*i;break;case A.add:s.shearY+=o*i}}}class sr extends tn{constructor(t,n,e){super(t,n,[`${ft.rgb}|${e}`,`${ft.alpha}|${e}`]),this.slotIndex=0,this.slotIndex=e}getFrameEntries(){return 5}setFrame(t,n,e,r,i,h){t*=5,this.frames[t]=n,this.frames[t+1]=e,this.frames[t+2]=r,this.frames[t+3]=i,this.frames[t+4]=h}apply(t,n,e,r,i,h,l){const s=t.slots[this.slotIndex];if(!s.bone.active)return;const a=this.frames,o=s.color;if(e<a[0]){const w=s.data.color;switch(h){case A.setup:o.setFromColor(w);return;case A.first:o.add((w.r-o.r)*i,(w.g-o.g)*i,(w.b-o.b)*i,(w.a-o.a)*i)}return}let c=0,d=0,u=0,m=0;const g=Ct.search(a,e,5),x=this.curves[g/5];switch(x){case 0:const w=a[g];c=a[g+1],d=a[g+2],u=a[g+3],m=a[g+4];const b=(e-w)/(a[g+5]-w);c+=(a[g+5+1]-c)*b,d+=(a[g+5+2]-d)*b,u+=(a[g+5+3]-u)*b,m+=(a[g+5+4]-m)*b;break;case 1:c=a[g+1],d=a[g+2],u=a[g+3],m=a[g+4];break;default:c=this.getBezierValue(e,g,1,x-2),d=this.getBezierValue(e,g,2,x+18-2),u=this.getBezierValue(e,g,3,x+18*2-2),m=this.getBezierValue(e,g,4,x+18*3-2)}i==1?o.set(c,d,u,m):(h==A.setup&&o.setFromColor(s.data.color),o.add((c-o.r)*i,(d-o.g)*i,(u-o.b)*i,(m-o.a)*i))}}class ir extends tn{constructor(t,n,e){super(t,n,[`${ft.rgb}|${e}`]),this.slotIndex=0,this.slotIndex=e}getFrameEntries(){return 4}setFrame(t,n,e,r,i){t<<=2,this.frames[t]=n,this.frames[t+1]=e,this.frames[t+2]=r,this.frames[t+3]=i}apply(t,n,e,r,i,h,l){const s=t.slots[this.slotIndex];if(!s.bone.active)return;const a=this.frames,o=s.color;if(e<a[0]){const x=s.data.color;switch(h){case A.setup:o.r=x.r,o.g=x.g,o.b=x.b;return;case A.first:o.r+=(x.r-o.r)*i,o.g+=(x.g-o.g)*i,o.b+=(x.b-o.b)*i}return}let c=0,d=0,u=0;const m=Ct.search(a,e,4),g=this.curves[m>>2];switch(g){case 0:const x=a[m];c=a[m+1],d=a[m+2],u=a[m+3];const w=(e-x)/(a[m+4]-x);c+=(a[m+4+1]-c)*w,d+=(a[m+4+2]-d)*w,u+=(a[m+4+3]-u)*w;break;case 1:c=a[m+1],d=a[m+2],u=a[m+3];break;default:c=this.getBezierValue(e,m,1,g-2),d=this.getBezierValue(e,m,2,g+18-2),u=this.getBezierValue(e,m,3,g+18*2-2)}if(i==1)o.r=c,o.g=d,o.b=u;else{if(h==A.setup){const x=s.data.color;o.r=x.r,o.g=x.g,o.b=x.b}o.r+=(c-o.r)*i,o.g+=(d-o.g)*i,o.b+=(u-o.b)*i}}}class rr extends en{constructor(t,n,e){super(t,n,`${ft.alpha}|${e}`),this.slotIndex=0,this.slotIndex=e}apply(t,n,e,r,i,h,l){const s=t.slots[this.slotIndex];if(!s.bone.active)return;const a=s.color;if(e<this.frames[0]){const c=s.data.color;switch(h){case A.setup:a.a=c.a;return;case A.first:a.a+=(c.a-a.a)*i}return}const o=this.getCurveValue(e);i==1?a.a=o:(h==A.setup&&(a.a=s.data.color.a),a.a+=(o-a.a)*i)}}class ar extends tn{constructor(t,n,e){super(t,n,[`${ft.rgb}|${e}`,`${ft.alpha}|${e}`,`${ft.rgb2}|${e}`]),this.slotIndex=0,this.slotIndex=e}getFrameEntries(){return 8}setFrame(t,n,e,r,i,h,l,s,a){t<<=3,this.frames[t]=n,this.frames[t+1]=e,this.frames[t+2]=r,this.frames[t+3]=i,this.frames[t+4]=h,this.frames[t+5]=l,this.frames[t+6]=s,this.frames[t+7]=a}apply(t,n,e,r,i,h,l){const s=t.slots[this.slotIndex];if(!s.bone.active)return;const a=this.frames,o=s.color,c=s.darkColor;if(e<a[0]){const S=s.data.color,y=s.data.darkColor;switch(h){case A.setup:o.setFromColor(S),c.r=y.r,c.g=y.g,c.b=y.b;return;case A.first:o.add((S.r-o.r)*i,(S.g-o.g)*i,(S.b-o.b)*i,(S.a-o.a)*i),c.r+=(y.r-c.r)*i,c.g+=(y.g-c.g)*i,c.b+=(y.b-c.b)*i}return}let d=0,u=0,m=0,g=0,x=0,w=0,b=0;const E=Ct.search(a,e,8),p=this.curves[E>>3];switch(p){case 0:const S=a[E];d=a[E+1],u=a[E+2],m=a[E+3],g=a[E+4],x=a[E+5],w=a[E+6],b=a[E+7];const y=(e-S)/(a[E+8]-S);d+=(a[E+8+1]-d)*y,u+=(a[E+8+2]-u)*y,m+=(a[E+8+3]-m)*y,g+=(a[E+8+4]-g)*y,x+=(a[E+8+5]-x)*y,w+=(a[E+8+6]-w)*y,b+=(a[E+8+7]-b)*y;break;case 1:d=a[E+1],u=a[E+2],m=a[E+3],g=a[E+4],x=a[E+5],w=a[E+6],b=a[E+7];break;default:d=this.getBezierValue(e,E,1,p-2),u=this.getBezierValue(e,E,2,p+18-2),m=this.getBezierValue(e,E,3,p+18*2-2),g=this.getBezierValue(e,E,4,p+18*3-2),x=this.getBezierValue(e,E,5,p+18*4-2),w=this.getBezierValue(e,E,6,p+18*5-2),b=this.getBezierValue(e,E,7,p+18*6-2)}if(i==1)o.set(d,u,m,g),c.r=x,c.g=w,c.b=b;else{if(h==A.setup){o.setFromColor(s.data.color);const S=s.data.darkColor;c.r=S.r,c.g=S.g,c.b=S.b}o.add((d-o.r)*i,(u-o.g)*i,(m-o.b)*i,(g-o.a)*i),c.r+=(x-c.r)*i,c.g+=(w-c.g)*i,c.b+=(b-c.b)*i}}}class or extends tn{constructor(t,n,e){super(t,n,[`${ft.rgb}|${e}`,`${ft.rgb2}|${e}`]),this.slotIndex=0,this.slotIndex=e}getFrameEntries(){return 7}setFrame(t,n,e,r,i,h,l,s){t*=7,this.frames[t]=n,this.frames[t+1]=e,this.frames[t+2]=r,this.frames[t+3]=i,this.frames[t+4]=h,this.frames[t+5]=l,this.frames[t+6]=s}apply(t,n,e,r,i,h,l){const s=t.slots[this.slotIndex];if(!s.bone.active)return;const a=this.frames,o=s.color,c=s.darkColor;if(e<a[0]){const p=s.data.color,S=s.data.darkColor;switch(h){case A.setup:o.r=p.r,o.g=p.g,o.b=p.b,c.r=S.r,c.g=S.g,c.b=S.b;return;case A.first:o.r+=(p.r-o.r)*i,o.g+=(p.g-o.g)*i,o.b+=(p.b-o.b)*i,c.r+=(S.r-c.r)*i,c.g+=(S.g-c.g)*i,c.b+=(S.b-c.b)*i}return}let d=0,u=0,m=0,g=0,x=0,w=0;const b=Ct.search(a,e,7),E=this.curves[b/7];switch(E){case 0:const p=a[b];d=a[b+1],u=a[b+2],m=a[b+3],g=a[b+4],x=a[b+5],w=a[b+6];const S=(e-p)/(a[b+7]-p);d+=(a[b+7+1]-d)*S,u+=(a[b+7+2]-u)*S,m+=(a[b+7+3]-m)*S,g+=(a[b+7+4]-g)*S,x+=(a[b+7+5]-x)*S,w+=(a[b+7+6]-w)*S;break;case 1:d=a[b+1],u=a[b+2],m=a[b+3],g=a[b+4],x=a[b+5],w=a[b+6];break;default:d=this.getBezierValue(e,b,1,E-2),u=this.getBezierValue(e,b,2,E+18-2),m=this.getBezierValue(e,b,3,E+18*2-2),g=this.getBezierValue(e,b,4,E+18*3-2),x=this.getBezierValue(e,b,5,E+18*4-2),w=this.getBezierValue(e,b,6,E+18*5-2)}if(i==1)o.r=d,o.g=u,o.b=m,c.r=g,c.g=x,c.b=w;else{if(h==A.setup){const p=s.data.color,S=s.data.darkColor;o.r=p.r,o.g=p.g,o.b=p.b,c.r=S.r,c.g=S.g,c.b=S.b}o.r+=(d-o.r)*i,o.g+=(u-o.g)*i,o.b+=(m-o.b)*i,c.r+=(g-c.r)*i,c.g+=(x-c.g)*i,c.b+=(w-c.b)*i}}}class qn extends Ct{constructor(t,n){super(t,[`${ft.attachment}|${n}`]),this.slotIndex=0,this.slotIndex=n,this.attachmentNames=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,n,e){this.frames[t]=n,this.attachmentNames[t]=e}apply(t,n,e,r,i,h,l){const s=t.slots[this.slotIndex];if(s.bone.active){if(l==Q.mixOut){h==A.setup&&this.setAttachment(t,s,s.data.attachmentName);return}if(e<this.frames[0]){(h==A.setup||h==A.first)&&this.setAttachment(t,s,s.data.attachmentName);return}this.setAttachment(t,s,this.attachmentNames[Ct.search1(this.frames,e)])}}setAttachment(t,n,e){n.setAttachment(e?t.getAttachment(this.slotIndex,e):null)}}class lr extends tn{constructor(t,n,e,r){super(t,n,[`${ft.deform}|${e}|${r.id}`]),this.slotIndex=0,this.slotIndex=e,this.attachment=r,this.vertices=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,n,e){this.frames[t]=n,this.vertices[t]=e}setBezier(t,n,e,r,i,h,l,s,a,o,c){const d=this.curves;let u=this.getFrameCount()+t*18;e==0&&(d[n]=2+u);const m=(r-h*2+s)*.03,g=a*.03-l*.06,x=((h-s)*3-r+o)*.006,w=(l-a+.33333333)*.018;let b=m*2+x,E=g*2+w,p=(h-r)*.3+m+x*.16666667,S=l*.3+g+w*.16666667,y=r+p,M=S;for(let C=u+18;u<C;u+=2)d[u]=y,d[u+1]=M,p+=b,S+=E,b+=x,E+=w,y+=p,M+=S}getCurvePercent(t,n){const e=this.curves;let r=e[n];switch(r){case 0:const s=this.frames[n];return(t-s)/(this.frames[n+this.getFrameEntries()]-s);case 1:return 0}if(r-=2,e[r]>t){const s=this.frames[n];return e[r+1]*(t-s)/(e[r]-s)}const i=r+18;for(r+=2;r<i;r+=2)if(e[r]>=t){const s=e[r-2],a=e[r-1];return a+(t-s)/(e[r]-s)*(e[r+1]-a)}const h=e[i-2],l=e[i-1];return l+(1-l)*(t-h)/(this.frames[n+this.getFrameEntries()]-h)}apply(t,n,e,r,i,h,l){const s=t.slots[this.slotIndex];if(!s.bone.active)return;const a=s.getAttachment();if(!a||!(a instanceof Je)||a.timelineAttachment!=this.attachment)return;const o=s.deform;o.length==0&&(h=A.setup);const c=this.vertices,d=c[0].length,u=this.frames;if(e<u[0]){switch(h){case A.setup:o.length=0;return;case A.first:if(i==1){o.length=0;return}o.length=d;const b=a;if(b.bones){i=1-i;for(let E=0;E<d;E++)o[E]*=i}else{const E=b.vertices;for(let p=0;p<d;p++)o[p]+=(E[p]-o[p])*i}}return}if(o.length=d,e>=u[u.length-1]){const b=c[u.length-1];if(i==1)if(h==A.add){const E=a;if(E.bones)for(let p=0;p<d;p++)o[p]+=b[p];else{const p=E.vertices;for(let S=0;S<d;S++)o[S]+=b[S]-p[S]}}else k.arrayCopy(b,0,o,0,d);else switch(h){case A.setup:{const p=a;if(p.bones)for(let S=0;S<d;S++)o[S]=b[S]*i;else{const S=p.vertices;for(let y=0;y<d;y++){const M=S[y];o[y]=M+(b[y]-M)*i}}break}case A.first:case A.replace:for(let p=0;p<d;p++)o[p]+=(b[p]-o[p])*i;break;case A.add:const E=a;if(E.bones)for(let p=0;p<d;p++)o[p]+=b[p]*i;else{const p=E.vertices;for(let S=0;S<d;S++)o[S]+=(b[S]-p[S])*i}}return}const m=Ct.search1(u,e),g=this.getCurvePercent(e,m),x=c[m],w=c[m+1];if(i==1)if(h==A.add){const b=a;if(b.bones)for(let E=0;E<d;E++){const p=x[E];o[E]+=p+(w[E]-p)*g}else{const E=b.vertices;for(let p=0;p<d;p++){const S=x[p];o[p]+=S+(w[p]-S)*g-E[p]}}}else for(let b=0;b<d;b++){const E=x[b];o[b]=E+(w[b]-E)*g}else switch(h){case A.setup:{const E=a;if(E.bones)for(let p=0;p<d;p++){const S=x[p];o[p]=(S+(w[p]-S)*g)*i}else{const p=E.vertices;for(let S=0;S<d;S++){const y=x[S],M=p[S];o[S]=M+(y+(w[S]-y)*g-M)*i}}break}case A.first:case A.replace:for(let E=0;E<d;E++){const p=x[E];o[E]+=(p+(w[E]-p)*g-o[E])*i}break;case A.add:const b=a;if(b.bones)for(let E=0;E<d;E++){const p=x[E];o[E]+=(p+(w[E]-p)*g)*i}else{const E=b.vertices;for(let p=0;p<d;p++){const S=x[p];o[p]+=(S+(w[p]-S)*g-E[p])*i}}}}}const Ia=class extends Ct{constructor(f){super(f,Ia.propertyIds),this.events=new Array(f)}getFrameCount(){return this.frames.length}setFrame(f,t){this.frames[f]=t.time,this.events[f]=t}apply(f,t,n,e,r,i,h){if(!e)return;const l=this.frames,s=this.frames.length;if(t>n)this.apply(f,t,Number.MAX_VALUE,e,r,i,h),t=-1;else if(t>=l[s-1])return;if(n<l[0])return;let a=0;if(t<l[0])a=0;else{a=Ct.search1(l,t)+1;const o=l[a];for(;a>0&&l[a-1]==o;)a--}for(;a<s&&n>=l[a];a++)e.push(this.events[a])}};let xs=Ia;xs.propertyIds=[`${ft.event}`];const Ra=class extends Ct{constructor(f){super(f,Ra.propertyIds),this.drawOrders=new Array(f)}getFrameCount(){return this.frames.length}setFrame(f,t,n){this.frames[f]=t,this.drawOrders[f]=n}apply(f,t,n,e,r,i,h){if(h==Q.mixOut){i==A.setup&&k.arrayCopy(f.slots,0,f.drawOrder,0,f.slots.length);return}if(n<this.frames[0]){(i==A.setup||i==A.first)&&k.arrayCopy(f.slots,0,f.drawOrder,0,f.slots.length);return}const l=Ct.search1(this.frames,n),s=this.drawOrders[l];if(!s)k.arrayCopy(f.slots,0,f.drawOrder,0,f.slots.length);else{const a=f.drawOrder,o=f.slots;for(let c=0,d=s.length;c<d;c++)a[c]=o[s[c]]}}};let Un=Ra;Un.propertyIds=[`${ft.drawOrder}`];class cr extends tn{constructor(t,n,e){super(t,n,[`${ft.ikConstraint}|${e}`]),this.ikConstraintIndex=0,this.ikConstraintIndex=e}getFrameEntries(){return 6}setFrame(t,n,e,r,i,h,l){t*=6,this.frames[t]=n,this.frames[t+1]=e,this.frames[t+2]=r,this.frames[t+3]=i,this.frames[t+4]=h?1:0,this.frames[t+5]=l?1:0}apply(t,n,e,r,i,h,l){const s=t.ikConstraints[this.ikConstraintIndex];if(!s.active)return;const a=this.frames;if(e<a[0]){switch(h){case A.setup:s.mix=s.data.mix,s.softness=s.data.softness,s.bendDirection=s.data.bendDirection,s.compress=s.data.compress,s.stretch=s.data.stretch;return;case A.first:s.mix+=(s.data.mix-s.mix)*i,s.softness+=(s.data.softness-s.softness)*i,s.bendDirection=s.data.bendDirection,s.compress=s.data.compress,s.stretch=s.data.stretch}return}let o=0,c=0;const d=Ct.search(a,e,6),u=this.curves[d/6];switch(u){case 0:const m=a[d];o=a[d+1],c=a[d+2];const g=(e-m)/(a[d+6]-m);o+=(a[d+6+1]-o)*g,c+=(a[d+6+2]-c)*g;break;case 1:o=a[d+1],c=a[d+2];break;default:o=this.getBezierValue(e,d,1,u-2),c=this.getBezierValue(e,d,2,u+18-2)}h==A.setup?(s.mix=s.data.mix+(o-s.data.mix)*i,s.softness=s.data.softness+(c-s.data.softness)*i,l==Q.mixOut?(s.bendDirection=s.data.bendDirection,s.compress=s.data.compress,s.stretch=s.data.stretch):(s.bendDirection=a[d+3],s.compress=a[d+4]!=0,s.stretch=a[d+5]!=0)):(s.mix+=(o-s.mix)*i,s.softness+=(c-s.softness)*i,l==Q.mixIn&&(s.bendDirection=a[d+3],s.compress=a[d+4]!=0,s.stretch=a[d+5]!=0))}}class hr extends tn{constructor(t,n,e){super(t,n,[`${ft.transformConstraint}|${e}`]),this.transformConstraintIndex=0,this.transformConstraintIndex=e}getFrameEntries(){return 7}setFrame(t,n,e,r,i,h,l,s){const a=this.frames;t*=7,a[t]=n,a[t+1]=e,a[t+2]=r,a[t+3]=i,a[t+4]=h,a[t+5]=l,a[t+6]=s}apply(t,n,e,r,i,h,l){const s=t.transformConstraints[this.transformConstraintIndex];if(!s.active)return;const a=this.frames;if(e<a[0]){const b=s.data;switch(h){case A.setup:s.mixRotate=b.mixRotate,s.mixX=b.mixX,s.mixY=b.mixY,s.mixScaleX=b.mixScaleX,s.mixScaleY=b.mixScaleY,s.mixShearY=b.mixShearY;return;case A.first:s.mixRotate+=(b.mixRotate-s.mixRotate)*i,s.mixX+=(b.mixX-s.mixX)*i,s.mixY+=(b.mixY-s.mixY)*i,s.mixScaleX+=(b.mixScaleX-s.mixScaleX)*i,s.mixScaleY+=(b.mixScaleY-s.mixScaleY)*i,s.mixShearY+=(b.mixShearY-s.mixShearY)*i}return}let o,c,d,u,m,g;const x=Ct.search(a,e,7),w=this.curves[x/7];switch(w){case 0:const b=a[x];o=a[x+1],c=a[x+2],d=a[x+3],u=a[x+4],m=a[x+5],g=a[x+6];const E=(e-b)/(a[x+7]-b);o+=(a[x+7+1]-o)*E,c+=(a[x+7+2]-c)*E,d+=(a[x+7+3]-d)*E,u+=(a[x+7+4]-u)*E,m+=(a[x+7+5]-m)*E,g+=(a[x+7+6]-g)*E;break;case 1:o=a[x+1],c=a[x+2],d=a[x+3],u=a[x+4],m=a[x+5],g=a[x+6];break;default:o=this.getBezierValue(e,x,1,w-2),c=this.getBezierValue(e,x,2,w+18-2),d=this.getBezierValue(e,x,3,w+18*2-2),u=this.getBezierValue(e,x,4,w+18*3-2),m=this.getBezierValue(e,x,5,w+18*4-2),g=this.getBezierValue(e,x,6,w+18*5-2)}if(h==A.setup){const b=s.data;s.mixRotate=b.mixRotate+(o-b.mixRotate)*i,s.mixX=b.mixX+(c-b.mixX)*i,s.mixY=b.mixY+(d-b.mixY)*i,s.mixScaleX=b.mixScaleX+(u-b.mixScaleX)*i,s.mixScaleY=b.mixScaleY+(m-b.mixScaleY)*i,s.mixShearY=b.mixShearY+(g-b.mixShearY)*i}else s.mixRotate+=(o-s.mixRotate)*i,s.mixX+=(c-s.mixX)*i,s.mixY+=(d-s.mixY)*i,s.mixScaleX+=(u-s.mixScaleX)*i,s.mixScaleY+=(m-s.mixScaleY)*i,s.mixShearY+=(g-s.mixShearY)*i}}class dr extends en{constructor(t,n,e){super(t,n,`${ft.pathConstraintPosition}|${e}`),this.pathConstraintIndex=0,this.pathConstraintIndex=e}apply(t,n,e,r,i,h,l){const s=t.pathConstraints[this.pathConstraintIndex];if(!s.active)return;const a=this.frames;if(e<a[0]){switch(h){case A.setup:s.position=s.data.position;return;case A.first:s.position+=(s.data.position-s.position)*i}return}const o=this.getCurveValue(e);h==A.setup?s.position=s.data.position+(o-s.data.position)*i:s.position+=(o-s.position)*i}}class fr extends en{constructor(t,n,e){super(t,n,`${ft.pathConstraintSpacing}|${e}`),this.pathConstraintIndex=0,this.pathConstraintIndex=e}apply(t,n,e,r,i,h,l){const s=t.pathConstraints[this.pathConstraintIndex];if(!s.active)return;const a=this.frames;if(e<a[0]){switch(h){case A.setup:s.spacing=s.data.spacing;return;case A.first:s.spacing+=(s.data.spacing-s.spacing)*i}return}const o=this.getCurveValue(e);h==A.setup?s.spacing=s.data.spacing+(o-s.data.spacing)*i:s.spacing+=(o-s.spacing)*i}}class ur extends tn{constructor(t,n,e){super(t,n,[`${ft.pathConstraintMix}|${e}`]),this.pathConstraintIndex=0,this.pathConstraintIndex=e}getFrameEntries(){return 4}setFrame(t,n,e,r,i){const h=this.frames;t<<=2,h[t]=n,h[t+1]=e,h[t+2]=r,h[t+3]=i}apply(t,n,e,r,i,h,l){const s=t.pathConstraints[this.pathConstraintIndex];if(!s.active)return;const a=this.frames;if(e<a[0]){switch(h){case A.setup:s.mixRotate=s.data.mixRotate,s.mixX=s.data.mixX,s.mixY=s.data.mixY;return;case A.first:s.mixRotate+=(s.data.mixRotate-s.mixRotate)*i,s.mixX+=(s.data.mixX-s.mixX)*i,s.mixY+=(s.data.mixY-s.mixY)*i}return}let o,c,d;const u=Ct.search(a,e,4),m=this.curves[u>>2];switch(m){case 0:const g=a[u];o=a[u+1],c=a[u+2],d=a[u+3];const x=(e-g)/(a[u+4]-g);o+=(a[u+4+1]-o)*x,c+=(a[u+4+2]-c)*x,d+=(a[u+4+3]-d)*x;break;case 1:o=a[u+1],c=a[u+2],d=a[u+3];break;default:o=this.getBezierValue(e,u,1,m-2),c=this.getBezierValue(e,u,2,m+18-2),d=this.getBezierValue(e,u,3,m+18*2-2)}if(h==A.setup){const g=s.data;s.mixRotate=g.mixRotate+(o-g.mixRotate)*i,s.mixX=g.mixX+(c-g.mixX)*i,s.mixY=g.mixY+(d-g.mixY)*i}else s.mixRotate+=(o-s.mixRotate)*i,s.mixX+=(c-s.mixX)*i,s.mixY+=(d-s.mixY)*i}}const Pn=class extends Ct{constructor(f,t,n){super(f,[`${ft.sequence}|${t}|${n.sequence.id}`]),this.slotIndex=t,this.attachment=n}getFrameEntries(){return Pn.ENTRIES}getSlotIndex(){return this.slotIndex}getAttachment(){return this.attachment}setFrame(f,t,n,e,r){const i=this.frames;f*=Pn.ENTRIES,i[f]=t,i[f+Pn.MODE]=n|e<<4,i[f+Pn.DELAY]=r}apply(f,t,n,e,r,i,h){const l=f.slots[this.slotIndex];if(!l.bone.active)return;const s=l.attachment,a=this.attachment;if(s!=a&&(!(s instanceof Je)||s.timelineAttachment!=a))return;const o=this.frames;if(n<o[0]){(i==A.setup||i==A.first)&&(l.sequenceIndex=-1);return}const c=Ct.search(o,n,Pn.ENTRIES),d=o[c],u=o[c+Pn.MODE],m=o[c+Pn.DELAY];if(!this.attachment.sequence)return;let g=u>>4;const x=this.attachment.sequence.regions.length,w=zi[u&15];if(w!=dn.hold)switch(g+=(n-d)/m+1e-5|0,w){case dn.once:g=Math.min(x-1,g);break;case dn.loop:g%=x;break;case dn.pingpong:{const b=(x<<1)-2;g=b==0?0:g%b,g>=x&&(g=b-g);break}case dn.onceReverse:g=Math.max(x-1-g,0);break;case dn.loopReverse:g=x-1-g%x;break;case dn.pingpongReverse:{const b=(x<<1)-2;g=b==0?0:(g+x-1)%b,g>=x&&(g=b-g)}}l.sequenceIndex=g}};let os=Pn;os.ENTRIES=3,os.MODE=1,os.DELAY=2;const fn=class{constructor(f){this.tracks=new Array,this.timeScale=1,this.unkeyedState=0,this.events=new Array,this.listeners=new Array,this.queue=new ka(this),this.propertyIDs=new zs,this.animationsChanged=!1,this.trackEntryPool=new Zn(()=>new Ls),this.data=f}static emptyAnimation(){return fn._emptyAnimation}update(f){f*=this.timeScale;const t=this.tracks;for(let n=0,e=t.length;n<e;n++){const r=t[n];if(!r)continue;r.animationLast=r.nextAnimationLast,r.trackLast=r.nextTrackLast;let i=f*r.timeScale;if(r.delay>0){if(r.delay-=i,r.delay>0)continue;i=-r.delay,r.delay=0}let h=r.next;if(h){const l=r.trackLast-h.delay;if(l>=0){for(h.delay=0,h.trackTime+=r.timeScale==0?0:(l/r.timeScale+f)*h.timeScale,r.trackTime+=i,this.setCurrent(n,h,!0);h.mixingFrom;)h.mixTime+=f,h=h.mixingFrom;continue}}else if(r.trackLast>=r.trackEnd&&!r.mixingFrom){t[n]=null,this.queue.end(r),this.clearNext(r);continue}if(r.mixingFrom&&this.updateMixingFrom(r,f)){let l=r.mixingFrom;for(r.mixingFrom=null,l&&(l.mixingTo=null);l;)this.queue.end(l),l=l.mixingFrom}r.trackTime+=i}this.queue.drain()}updateMixingFrom(f,t){const n=f.mixingFrom;if(!n)return!0;const e=this.updateMixingFrom(n,t);return n.animationLast=n.nextAnimationLast,n.trackLast=n.nextTrackLast,f.mixTime>0&&f.mixTime>=f.mixDuration?((n.totalAlpha==0||f.mixDuration==0)&&(f.mixingFrom=n.mixingFrom,n.mixingFrom&&(n.mixingFrom.mixingTo=f),f.interruptAlpha=n.interruptAlpha,this.queue.end(n)),e):(n.trackTime+=t*n.timeScale,f.mixTime+=t,!1)}apply(f){if(!f)throw new Error("skeleton cannot be null.");this.animationsChanged&&this._animationsChanged();const t=this.events,n=this.tracks;let e=!1;for(let h=0,l=n.length;h<l;h++){const s=n[h];if(!s||s.delay>0)continue;e=!0;const a=h==0?A.first:s.mixBlend;let o=s.alpha;s.mixingFrom?o*=this.applyMixingFrom(s,f,a):s.trackTime>=s.trackEnd&&!s.next&&(o=0);const c=s.animationLast,d=s.getAnimationTime();let u=d,m=t;s.reverse&&(u=s.animation.duration-u,m=null);const g=s.animation.timelines,x=g.length;if(h==0&&o==1||a==A.add)for(let w=0;w<x;w++){k.webkit602BugfixHelper(o,a);const b=g[w];b instanceof qn?this.applyAttachmentTimeline(b,f,u,a,!0):b.apply(f,c,u,m,o,a,Q.mixIn)}else{const w=s.timelineMode,b=s.shortestRotation,E=!b&&s.timelinesRotation.length!=x<<1;E&&(s.timelinesRotation.length=x<<1);for(let p=0;p<x;p++){const S=g[p],y=w[p]==mr?a:A.setup;!b&&S instanceof gs?this.applyRotateTimeline(S,f,u,o,y,s.timelinesRotation,p<<1,E):S instanceof qn?this.applyAttachmentTimeline(S,f,u,a,!0):(k.webkit602BugfixHelper(o,a),S.apply(f,c,u,m,o,y,Q.mixIn))}}this.queueEvents(s,d),t.length=0,s.nextAnimationLast=d,s.nextTrackLast=s.trackTime}const r=this.unkeyedState+Pa,i=f.slots;for(let h=0,l=f.slots.length;h<l;h++){const s=i[h];if(s.attachmentState==r){const a=s.data.attachmentName;s.setAttachment(a?f.getAttachment(s.data.index,a):null)}}return this.unkeyedState+=2,this.queue.drain(),e}applyMixingFrom(f,t,n){const e=f.mixingFrom;e.mixingFrom&&this.applyMixingFrom(e,t,n);let r=0;f.mixDuration==0?(r=1,n==A.first&&(n=A.setup)):(r=f.mixTime/f.mixDuration,r>1&&(r=1),n!=A.first&&(n=e.mixBlend));const i=r<e.attachmentThreshold,h=r<e.drawOrderThreshold,l=e.animation.timelines,s=l.length,a=e.alpha*f.interruptAlpha,o=a*(1-r),c=e.animationLast,d=e.getAnimationTime();let u=d,m=null;if(e.reverse?u=e.animation.duration-u:r<e.eventThreshold&&(m=this.events),n==A.add)for(let g=0;g<s;g++)l[g].apply(t,c,u,m,o,n,Q.mixOut);else{const g=e.timelineMode,x=e.timelineHoldMix,w=e.shortestRotation,b=!w&&e.timelinesRotation.length!=s<<1;b&&(e.timelinesRotation.length=s<<1),e.totalAlpha=0;for(let E=0;E<s;E++){const p=l[E];let S=Q.mixOut,y,M=0;switch(g[E]){case mr:if(!h&&p instanceof Un)continue;y=n,M=o;break;case va:y=A.setup,M=o;break;case Va:y=n,M=a;break;case gr:y=A.setup,M=a;break;default:y=A.setup;const C=x[E];M=a*Math.max(0,1-C.mixTime/C.mixDuration);break}e.totalAlpha+=M,!w&&p instanceof gs?this.applyRotateTimeline(p,t,u,M,y,e.timelinesRotation,E<<1,b):p instanceof qn?this.applyAttachmentTimeline(p,t,u,y,i):(k.webkit602BugfixHelper(M,n),h&&p instanceof Un&&y==A.setup&&(S=Q.mixIn),p.apply(t,c,u,m,M,y,S))}}return f.mixDuration>0&&this.queueEvents(e,d),this.events.length=0,e.nextAnimationLast=d,e.nextTrackLast=e.trackTime,r}applyAttachmentTimeline(f,t,n,e,r){const i=t.slots[f.slotIndex];i.bone.active&&(n<f.frames[0]?(e==A.setup||e==A.first)&&this.setAttachment(t,i,i.data.attachmentName,r):this.setAttachment(t,i,f.attachmentNames[Ct.search1(f.frames,n)],r),i.attachmentState<=this.unkeyedState&&(i.attachmentState=this.unkeyedState+Pa))}setAttachment(f,t,n,e){t.setAttachment(n?f.getAttachment(t.data.index,n):null),e&&(t.attachmentState=this.unkeyedState+wo)}applyRotateTimeline(f,t,n,e,r,i,h,l){if(l&&(i[h]=0),e==1){f.apply(t,0,n,null,1,r,Q.mixIn);return}const s=t.bones[f.boneIndex];if(!s.active)return;const a=f.frames;let o=0,c=0;if(n<a[0])switch(r){case A.setup:s.rotation=s.data.rotation;default:return;case A.first:o=s.rotation,c=s.data.rotation}else o=r==A.setup?s.data.rotation:s.rotation,c=s.data.rotation+f.getCurveValue(n);let d=0,u=c-o;if(u-=(16384-(16384.499999999996-u/360|0))*360,u==0)d=i[h];else{let m=0,g=0;l?(m=0,g=u):(m=i[h],g=i[h+1]);const x=u>0;let w=m>=0;T.signum(g)!=T.signum(u)&&Math.abs(g)<=90&&(Math.abs(m)>180&&(m+=360*T.signum(m)),w=x),d=u+m-m%360,w!=x&&(d+=360*T.signum(m)),i[h]=d}i[h+1]=u,s.rotation=o+d*e}queueEvents(f,t){const n=f.animationStart,e=f.animationEnd,r=e-n,i=f.trackLast%r,h=this.events;let l=0;const s=h.length;for(;l<s;l++){const o=h[l];if(o.time<i)break;o.time>e||this.queue.event(f,o)}let a=!1;for(f.loop?a=r==0||i>f.trackTime%r:a=t>=e&&f.animationLast<e,a&&this.queue.complete(f);l<s;l++){const o=h[l];o.time<n||this.queue.event(f,o)}}clearTracks(){const f=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let t=0,n=this.tracks.length;t<n;t++)this.clearTrack(t);this.tracks.length=0,this.queue.drainDisabled=f,this.queue.drain()}clearTrack(f){if(f>=this.tracks.length)return;const t=this.tracks[f];if(!t)return;this.queue.end(t),this.clearNext(t);let n=t;for(;;){const e=n.mixingFrom;if(!e)break;this.queue.end(e),n.mixingFrom=null,n.mixingTo=null,n=e}this.tracks[t.trackIndex]=null,this.queue.drain()}setCurrent(f,t,n){const e=this.expandToIndex(f);this.tracks[f]=t,t.previous=null,e&&(n&&this.queue.interrupt(e),t.mixingFrom=e,e.mixingTo=t,t.mixTime=0,e.mixingFrom&&e.mixDuration>0&&(t.interruptAlpha*=Math.min(1,e.mixTime/e.mixDuration)),e.timelinesRotation.length=0),this.queue.start(t)}setAnimation(f,t,n=!1){const e=this.data.skeletonData.findAnimation(t);if(!e)throw new Error(`Animation not found: ${t}`);return this.setAnimationWith(f,e,n)}setAnimationWith(f,t,n=!1){if(!t)throw new Error("animation cannot be null.");let e=!0,r=this.expandToIndex(f);r&&(r.nextTrackLast==-1?(this.tracks[f]=r.mixingFrom,this.queue.interrupt(r),this.queue.end(r),this.clearNext(r),r=r.mixingFrom,e=!1):this.clearNext(r));const i=this.trackEntry(f,t,n,r);return this.setCurrent(f,i,e),this.queue.drain(),i}addAnimation(f,t,n=!1,e=0){const r=this.data.skeletonData.findAnimation(t);if(!r)throw new Error(`Animation not found: ${t}`);return this.addAnimationWith(f,r,n,e)}addAnimationWith(f,t,n=!1,e=0){if(!t)throw new Error("animation cannot be null.");let r=this.expandToIndex(f);if(r)for(;r.next;)r=r.next;const i=this.trackEntry(f,t,n,r);return r?(r.next=i,i.previous=r,e<=0&&(e+=r.getTrackComplete()-i.mixDuration)):(this.setCurrent(f,i,!0),this.queue.drain()),i.delay=e,i}setEmptyAnimation(f,t=0){const n=this.setAnimationWith(f,fn.emptyAnimation(),!1);return n.mixDuration=t,n.trackEnd=t,n}addEmptyAnimation(f,t=0,n=0){const e=this.addAnimationWith(f,fn.emptyAnimation(),!1,n);return n<=0&&(e.delay+=e.mixDuration-t),e.mixDuration=t,e.trackEnd=t,e}setEmptyAnimations(f=0){const t=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let n=0,e=this.tracks.length;n<e;n++){const r=this.tracks[n];r&&this.setEmptyAnimation(r.trackIndex,f)}this.queue.drainDisabled=t,this.queue.drain()}expandToIndex(f){return f<this.tracks.length?this.tracks[f]:(k.ensureArrayCapacity(this.tracks,f+1,null),this.tracks.length=f+1,null)}trackEntry(f,t,n,e){const r=this.trackEntryPool.obtain();return r.reset(),r.trackIndex=f,r.animation=t,r.loop=n,r.holdPrevious=!1,r.reverse=!1,r.shortestRotation=!1,r.eventThreshold=0,r.attachmentThreshold=0,r.drawOrderThreshold=0,r.animationStart=0,r.animationEnd=t.duration,r.animationLast=-1,r.nextAnimationLast=-1,r.delay=0,r.trackTime=0,r.trackLast=-1,r.nextTrackLast=-1,r.trackEnd=Number.MAX_VALUE,r.timeScale=1,r.alpha=1,r.mixTime=0,r.mixDuration=e?this.data.getMix(e.animation,t):0,r.interruptAlpha=1,r.totalAlpha=0,r.mixBlend=A.replace,r}clearNext(f){let t=f.next;for(;t;)this.queue.dispose(t),t=t.next;f.next=null}_animationsChanged(){this.animationsChanged=!1,this.propertyIDs.clear();const f=this.tracks;for(let t=0,n=f.length;t<n;t++){let e=f[t];if(e){for(;e.mixingFrom;)e=e.mixingFrom;do(!e.mixingTo||e.mixBlend!=A.add)&&this.computeHold(e),e=e.mixingTo;while(e)}}}computeHold(f){const t=f.mixingTo,n=f.animation.timelines,e=f.animation.timelines.length,r=f.timelineMode;r.length=e;const i=f.timelineHoldMix;i.length=0;const h=this.propertyIDs;if(t&&t.holdPrevious){for(let l=0;l<e;l++)r[l]=h.addAll(n[l].getPropertyIds())?gr:Va;return}t:for(let l=0;l<e;l++){const s=n[l],a=s.getPropertyIds();if(!h.addAll(a))r[l]=mr;else if(!t||s instanceof qn||s instanceof Un||s instanceof xs||!t.animation.hasTimeline(a))r[l]=va;else{for(let o=t.mixingTo;o;o=o.mixingTo)if(!o.animation.hasTimeline(a)){if(f.mixDuration>0){r[l]=po,i[l]=o;continue t}break}r[l]=gr}}}getCurrent(f){return f>=this.tracks.length?null:this.tracks[f]}addListener(f){if(!f)throw new Error("listener cannot be null.");this.listeners.push(f)}removeListener(f){const t=this.listeners.indexOf(f);t>=0&&this.listeners.splice(t,1)}clearListeners(){this.listeners.length=0}clearListenerNotifications(){this.queue.clear()}setAnimationByName(f,t,n){fn.deprecatedWarning1||(fn.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.")),this.setAnimation(f,t,n)}addAnimationByName(f,t,n,e){fn.deprecatedWarning2||(fn.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.")),this.addAnimation(f,t,n,e)}hasAnimation(f){return this.data.skeletonData.findAnimation(f)!==null}hasAnimationByName(f){return fn.deprecatedWarning3||(fn.deprecatedWarning3=!0,console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.")),this.hasAnimation(f)}};let ls=fn;ls._emptyAnimation=new Ds("<empty>",[],0),ls.deprecatedWarning1=!1,ls.deprecatedWarning2=!1,ls.deprecatedWarning3=!1;const En=class{constructor(){this.animation=null,this.previous=null,this.next=null,this.mixingFrom=null,this.mixingTo=null,this.listener=null,this.trackIndex=0,this.loop=!1,this.holdPrevious=!1,this.reverse=!1,this.shortestRotation=!1,this.eventThreshold=0,this.attachmentThreshold=0,this.drawOrderThreshold=0,this.animationStart=0,this.animationEnd=0,this.animationLast=0,this.nextAnimationLast=0,this.delay=0,this.trackTime=0,this.trackLast=0,this.nextTrackLast=0,this.trackEnd=0,this.timeScale=0,this.alpha=0,this.mixTime=0,this.mixDuration=0,this.interruptAlpha=0,this.totalAlpha=0,this.mixBlend=A.replace,this.timelineMode=new Array,this.timelineHoldMix=new Array,this.timelinesRotation=new Array}reset(){this.next=null,this.previous=null,this.mixingFrom=null,this.mixingTo=null,this.animation=null,this.listener=null,this.timelineMode.length=0,this.timelineHoldMix.length=0,this.timelinesRotation.length=0}getAnimationTime(){if(this.loop){const f=this.animationEnd-this.animationStart;return f==0?this.animationStart:this.trackTime%f+this.animationStart}return Math.min(this.trackTime+this.animationStart,this.animationEnd)}setAnimationLast(f){this.animationLast=f,this.nextAnimationLast=f}isComplete(){return this.trackTime>=this.animationEnd-this.animationStart}resetRotationDirections(){this.timelinesRotation.length=0}getTrackComplete(){const f=this.animationEnd-this.animationStart;if(f!=0){if(this.loop)return f*(1+(this.trackTime/f|0));if(this.trackTime<f)return f}return this.trackTime}get time(){return En.deprecatedWarning1||(En.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime}set time(f){En.deprecatedWarning1||(En.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime=f}get endTime(){return En.deprecatedWarning2||(En.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime}set endTime(f){En.deprecatedWarning2||(En.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime=f}loopsCount(){return Math.floor(this.trackTime/this.trackEnd)}};let Ls=En;Ls.deprecatedWarning1=!1,Ls.deprecatedWarning2=!1;class ka{constructor(t){this.objects=[],this.drainDisabled=!1,this.animState=t}start(t){this.objects.push(Ae.start),this.objects.push(t),this.animState.animationsChanged=!0}interrupt(t){this.objects.push(Ae.interrupt),this.objects.push(t)}end(t){this.objects.push(Ae.end),this.objects.push(t),this.animState.animationsChanged=!0}dispose(t){this.objects.push(Ae.dispose),this.objects.push(t)}complete(t){this.objects.push(Ae.complete),this.objects.push(t)}event(t,n){this.objects.push(Ae.event),this.objects.push(t),this.objects.push(n)}drain(){if(this.drainDisabled)return;this.drainDisabled=!0;const t=this.objects,n=this.animState.listeners;for(let e=0;e<t.length;e+=2){const r=t[e],i=t[e+1];switch(r){case Ae.start:i.listener&&i.listener.start&&i.listener.start(i);for(let l=0;l<n.length;l++){const s=n[l];s.start&&s.start(i)}break;case Ae.interrupt:i.listener&&i.listener.interrupt&&i.listener.interrupt(i);for(let l=0;l<n.length;l++){const s=n[l];s.interrupt&&s.interrupt(i)}break;case Ae.end:i.listener&&i.listener.end&&i.listener.end(i);for(let l=0;l<n.length;l++){const s=n[l];s.end&&s.end(i)}case Ae.dispose:i.listener&&i.listener.dispose&&i.listener.dispose(i);for(let l=0;l<n.length;l++){const s=n[l];s.dispose&&s.dispose(i)}this.animState.trackEntryPool.free(i);break;case Ae.complete:i.listener&&i.listener.complete&&i.listener.complete(i);for(let l=0;l<n.length;l++){const s=n[l];s.complete&&s.complete(i)}break;case Ae.event:const h=t[e+++2];i.listener&&i.listener.event&&i.listener.event(i,h);for(let l=0;l<n.length;l++){const s=n[l];s.event&&s.event(i,h)}break}}this.clear(),this.drainDisabled=!1}clear(){this.objects.length=0}}var Ae=(f=>(f[f.start=0]="start",f[f.interrupt=1]="interrupt",f[f.end=2]="end",f[f.dispose=3]="dispose",f[f.complete=4]="complete",f[f.event=5]="event",f))(Ae||{});class xo{start(t){}interrupt(t){}end(t){}dispose(t){}complete(t){}event(t,n){}}const mr=0,va=1,Va=2,gr=3,po=4,Pa=1,wo=2;class Fa{constructor(t){if(this.animationToMixTime={},this.defaultMix=0,!t)throw new Error("skeletonData cannot be null.");this.skeletonData=t}setMix(t,n,e){const r=this.skeletonData.findAnimation(t);if(!r)throw new Error(`Animation not found: ${t}`);const i=this.skeletonData.findAnimation(n);if(!i)throw new Error(`Animation not found: ${n}`);this.setMixWith(r,i,e)}setMixWith(t,n,e){if(!t)throw new Error("from cannot be null.");if(!n)throw new Error("to cannot be null.");const r=`${t.name}.${n.name}`;this.animationToMixTime[r]=e}getMix(t,n){const e=`${t.name}.${n.name}`,r=this.animationToMixTime[e];return r===void 0?this.defaultMix:r}}class xr{constructor(t){this.atlas=t}loadSequence(t,n,e){const r=e.regions;for(let i=0,h=r.length;i<h;i++){const l=e.getPath(n,i),s=this.atlas.findRegion(l);if(s==null)throw new Error(`Region not found in atlas: ${l} (sequence: ${t})`);r[i]=s,r[i].renderObject=r[i]}}newRegionAttachment(t,n,e,r){const i=new lt(n,e);if(r!=null)this.loadSequence(n,e,r);else{const h=this.atlas.findRegion(e);if(!h)throw new Error(`Region not found in atlas: ${e} (region attachment: ${n})`);h.renderObject=h,i.region=h}return i}newMeshAttachment(t,n,e,r){const i=new $n(n,e);if(r!=null)this.loadSequence(n,e,r);else{const h=this.atlas.findRegion(e);if(!h)throw new Error(`Region not found in atlas: ${e} (mesh attachment: ${n})`);h.renderObject=h,i.region=h}return i}newBoundingBoxAttachment(t,n){return new Fs(n)}newPathAttachment(t,n){return new Wn(n)}newPointAttachment(t,n){return new Ns(n)}newClippingAttachment(t,n){return new Ys(n)}}class pr{constructor(t,n,e){if(this.matrix=new G.Matrix,this.parent=null,this.children=new Array,this.x=0,this.y=0,this.rotation=0,this.scaleX=0,this.scaleY=0,this.shearX=0,this.shearY=0,this.ax=0,this.ay=0,this.arotation=0,this.ascaleX=0,this.ascaleY=0,this.ashearX=0,this.ashearY=0,this.sorted=!1,this.active=!1,!t)throw new Error("data cannot be null.");if(!n)throw new Error("skeleton cannot be null.");this.data=t,this.skeleton=n,this.parent=e,this.setToSetupPose()}get worldX(){return this.matrix.tx}get worldY(){return this.matrix.ty}isActive(){return this.active}update(){this.updateWorldTransformWith(this.ax,this.ay,this.arotation,this.ascaleX,this.ascaleY,this.ashearX,this.ashearY)}updateWorldTransform(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransformWith(t,n,e,r,i,h,l){this.ax=t,this.ay=n,this.arotation=e,this.ascaleX=r,this.ascaleY=i,this.ashearX=h,this.ashearY=l;const s=this.parent,a=this.matrix,o=this.skeleton.scaleX,c=jt.yDown?-this.skeleton.scaleY:this.skeleton.scaleY;if(!s){const x=this.skeleton,w=e+90+l;a.a=T.cosDeg(e+h)*r*o,a.c=T.cosDeg(w)*i*o,a.b=T.sinDeg(e+h)*r*c,a.d=T.sinDeg(w)*i*c,a.tx=t*o+x.x,a.ty=n*c+x.y;return}let d=s.matrix.a,u=s.matrix.c,m=s.matrix.b,g=s.matrix.d;switch(a.tx=d*t+u*n+s.matrix.tx,a.ty=m*t+g*n+s.matrix.ty,this.data.transformMode){case z.Normal:{const x=e+90+l,w=T.cosDeg(e+h)*r,b=T.cosDeg(x)*i,E=T.sinDeg(e+h)*r,p=T.sinDeg(x)*i;a.a=d*w+u*E,a.c=d*b+u*p,a.b=m*w+g*E,a.d=m*b+g*p;return}case z.OnlyTranslation:{const x=e+90+l;a.a=T.cosDeg(e+h)*r,a.c=T.cosDeg(x)*i,a.b=T.sinDeg(e+h)*r,a.d=T.sinDeg(x)*i;break}case z.NoRotationOrReflection:{let x=d*d+m*m,w=0;x>1e-4?(x=Math.abs(d*g-u*m)/x,d/=o,m/=c,u=m*x,g=d*x,w=Math.atan2(m,d)*T.radDeg):(d=0,m=0,w=90-Math.atan2(g,u)*T.radDeg);const b=e+h-w,E=e+l-w+90,p=T.cosDeg(b)*r,S=T.cosDeg(E)*i,y=T.sinDeg(b)*r,M=T.sinDeg(E)*i;a.a=d*p-u*y,a.c=d*S-u*M,a.b=m*p+g*y,a.d=m*S+g*M;break}case z.NoScale:case z.NoScaleOrReflection:{const x=T.cosDeg(e),w=T.sinDeg(e);let b=(d*x+u*w)/o,E=(m*x+g*w)/c,p=Math.sqrt(b*b+E*E);p>1e-5&&(p=1/p),b*=p,E*=p,p=Math.sqrt(b*b+E*E),this.data.transformMode==z.NoScale&&d*g-u*m<0!=(o<0!=c<0)&&(p=-p);const S=Math.PI/2+Math.atan2(E,b),y=Math.cos(S)*p,M=Math.sin(S)*p,C=T.cosDeg(h)*r,I=T.cosDeg(90+l)*i,R=T.sinDeg(h)*r,v=T.sinDeg(90+l)*i;a.a=b*C+y*R,a.c=b*I+y*v,a.b=E*C+M*R,a.d=E*I+M*v;break}}a.a*=o,a.c*=o,a.b*=c,a.d*=c}setToSetupPose(){const t=this.data;this.x=t.x,this.y=t.y,this.rotation=t.rotation,this.scaleX=t.scaleX,this.scaleY=t.scaleY,this.shearX=t.shearX,this.shearY=t.shearY}getWorldRotationX(){return Math.atan2(this.matrix.b,this.matrix.a)*T.radDeg}getWorldRotationY(){return Math.atan2(this.matrix.d,this.matrix.c)*T.radDeg}getWorldScaleX(){const t=this.matrix;return Math.sqrt(t.a*t.a+t.b*t.b)}getWorldScaleY(){const t=this.matrix;return Math.sqrt(t.c*t.c+t.d*t.d)}updateAppliedTransform(){const t=this.parent,n=this.matrix;if(!t){this.ax=n.tx-this.skeleton.x,this.ay=n.ty-this.skeleton.y,this.arotation=Math.atan2(n.b,n.a)*T.radDeg,this.ascaleX=Math.sqrt(n.a*n.a+n.b*n.b),this.ascaleY=Math.sqrt(n.c*n.c+n.d*n.d),this.ashearX=0,this.ashearY=Math.atan2(n.a*n.c+n.b*n.d,n.a*n.d-n.b*n.c)*T.radDeg;return}const e=t.matrix,r=1/(e.a*e.d-e.b*e.c),i=n.tx-e.tx,h=n.ty-e.ty;this.ax=i*e.d*r-h*e.c*r,this.ay=h*e.a*r-i*e.b*r;const l=r*e.d,s=r*e.a,a=r*e.c,o=r*e.b,c=l*n.a-a*n.b,d=l*n.c-a*n.d,u=s*n.b-o*n.a,m=s*n.d-o*n.c;if(this.ashearX=0,this.ascaleX=Math.sqrt(c*c+u*u),this.ascaleX>1e-4){const g=c*m-d*u;this.ascaleY=g/this.ascaleX,this.ashearY=Math.atan2(c*d+u*m,g)*T.radDeg,this.arotation=Math.atan2(u,c)*T.radDeg}else this.ascaleX=0,this.ascaleY=Math.sqrt(d*d+m*m),this.ashearY=0,this.arotation=90-Math.atan2(m,d)*T.radDeg}worldToLocal(t){const n=this.matrix,e=n.a,r=n.c,i=n.b,h=n.d,l=1/(e*h-r*i),s=t.x-n.tx,a=t.y-n.ty;return t.x=s*h*l-a*r*l,t.y=a*e*l-s*i*l,t}localToWorld(t){const n=this.matrix,e=t.x,r=t.y;return t.x=e*n.a+r*n.c+n.tx,t.y=e*n.b+r*n.d+n.ty,t}worldToLocalRotation(t){const n=T.sinDeg(t),e=T.cosDeg(t),r=this.matrix;return Math.atan2(r.a*n-r.b*e,r.d*e-r.c*n)*T.radDeg}localToWorldRotation(t){t-=this.rotation-this.shearX;const n=T.sinDeg(t),e=T.cosDeg(t),r=this.matrix;return Math.atan2(e*r.b+n*r.d,e*r.a+n*r.c)*T.radDeg}rotateWorld(t){const n=this.matrix,e=n.a,r=n.c,i=n.b,h=n.d,l=T.cosDeg(t),s=T.sinDeg(t);n.a=l*e-s*i,n.c=l*r-s*h,n.b=s*e+l*i,n.d=s*r+l*h}}class wr{constructor(t,n,e){if(this.index=0,this.parent=null,this.length=0,this.x=0,this.y=0,this.rotation=0,this.scaleX=1,this.scaleY=1,this.shearX=0,this.shearY=0,this.transformMode=z.Normal,this.skinRequired=!1,this.color=new O,t<0)throw new Error("index must be >= 0.");if(!n)throw new Error("name cannot be null.");this.index=t,this.name=n,this.parent=e}}class Os{constructor(t,n,e){this.name=t,this.order=n,this.skinRequired=e}}class br{constructor(t,n){if(this.intValue=0,this.floatValue=0,this.stringValue=null,this.time=0,this.volume=0,this.balance=0,!n)throw new Error("data cannot be null.");this.time=t,this.data=n}}class Er{constructor(t){this.intValue=0,this.floatValue=0,this.stringValue=null,this.audioPath=null,this.volume=0,this.balance=0,this.name=t}}class Ya{constructor(t,n){if(this.bendDirection=0,this.compress=!1,this.stretch=!1,this.mix=1,this.softness=0,this.active=!1,!t)throw new Error("data cannot be null.");if(!n)throw new Error("skeleton cannot be null.");this.data=t,this.mix=t.mix,this.softness=t.softness,this.bendDirection=t.bendDirection,this.compress=t.compress,this.stretch=t.stretch,this.bones=new Array;for(let r=0;r<t.bones.length;r++){const i=n.findBone(t.bones[r].name);if(!i)throw new Error(`Couldn't find bone ${t.bones[r].name}`);this.bones.push(i)}const e=n.findBone(t.target.name);if(!e)throw new Error(`Couldn't find bone ${t.target.name}`);this.target=e}isActive(){return this.active}update(){if(this.mix==0)return;const t=this.target,n=this.bones;switch(n.length){case 1:this.apply1(n[0],t.worldX,t.worldY,this.compress,this.stretch,this.data.uniform,this.mix);break;case 2:this.apply2(n[0],n[1],t.worldX,t.worldY,this.bendDirection,this.stretch,this.data.uniform,this.softness,this.mix);break}}apply1(t,n,e,r,i,h,l){const s=t.parent.matrix;if(!s)throw new Error("IK bone must have parent.");const a=s.a;let o=s.c;const c=s.b;let d=s.d,u=-t.ashearX-t.arotation,m=0,g=0;const x=t.skeleton.scaleX,w=jt.yDown?-t.skeleton.scaleY:t.skeleton.scaleY;switch(t.data.transformMode){case z.OnlyTranslation:m=n-t.worldX,g=e-t.worldY,jt.yDown&&(g=-g);break;case z.NoRotationOrReflection:const p=Math.abs(a*d-o*c)/(a*a+c*c),S=a/x,y=c/w;o=-y*p*x,d=S*p*w,u+=Math.atan2(y,S)*T.radDeg;default:const M=n-s.tx,C=e-s.ty,I=a*d-o*c;m=(M*d-C*o)/I-t.ax,g=(C*a-M*c)/I-t.ay}u+=Math.atan2(g,m)*T.radDeg,t.ascaleX<0&&(u+=180),u>180?u-=360:u<-180&&(u+=360);let b=t.ascaleX,E=t.ascaleY;if(r||i){switch(t.data.transformMode){case z.NoScale:case z.NoScaleOrReflection:m=n-t.worldX,g=e-t.worldY}const p=t.data.length*b,S=Math.sqrt(m*m+g*g);if(r&&S<p||i&&S>p&&p>1e-4){const y=(S/p-1)*l+1;b*=y,h&&(E*=y)}}t.updateWorldTransformWith(t.ax,t.ay,t.arotation+u*l,b,E,t.ashearX,t.ashearY)}apply2(t,n,e,r,i,h,l,s,a){const o=t.ax,c=t.ay;let d=t.ascaleX,u=t.ascaleY,m=d,g=u,x=n.ascaleX;const w=t.matrix;let b=0,E=0,p=0;d<0?(d=-d,b=180,p=-1):(b=0,p=1),u<0&&(u=-u,p=-p),x<0?(x=-x,E=180):E=0;const S=n.ax;let y=0,M=0,C=0,I=w.a,R=w.c,v=w.b,V=w.d;const P=Math.abs(d-u)<=1e-4;!P||h?(y=0,M=I*S+w.tx,C=v*S+w.ty):(y=n.ay,M=I*S+R*y+w.tx,C=v*S+V*y+w.ty);const D=t.parent.matrix;if(!D)throw new Error("IK parent must itself have a parent.");I=D.a,R=D.c,v=D.b,V=D.d;const F=1/(I*V-R*v);let B=M-D.tx,H=C-D.ty;const U=(B*V-H*R)*F-o,X=(H*I-B*v)*F-c,N=Math.sqrt(U*U+X*X);let _=n.data.length*x,$,q;if(N<1e-4){this.apply1(t,e,r,!1,h,!1,a),n.updateWorldTransformWith(S,y,0,n.ascaleX,n.ascaleY,n.ashearX,n.ashearY);return}B=e-D.tx,H=r-D.ty;let W=(B*V-H*R)*F-o,L=(H*I-B*v)*F-c,j=W*W+L*L;if(s!=0){s*=d*(x+1)*.5;const nt=Math.sqrt(j),It=nt-N-_*d+s;if(It>0){let Gt=Math.min(1,It/(s*2))-1;Gt=(It-s*(1-Gt*Gt))/nt,W-=Gt*W,L-=Gt*L,j=W*W+L*L}}t:if(P){_*=d;let nt=(j-N*N-_*_)/(2*N*_);nt<-1?(nt=-1,q=Math.PI*i):nt>1?(nt=1,q=0,h&&(I=(Math.sqrt(j)/(N+_)-1)*a+1,m*=I,l&&(g*=I))):q=Math.acos(nt)*i,I=N+_*nt,R=_*Math.sin(q),$=Math.atan2(L*I-W*R,W*I+L*R)}else{I=d*_,R=u*_;const nt=I*I,It=R*R,Gt=Math.atan2(L,W);v=It*N*N+nt*j-nt*It;const pe=-2*It*N,ne=It-nt;if(V=pe*pe-4*ne*v,V>=0){let $t=Math.sqrt(V);pe<0&&($t=-$t),$t=-(pe+$t)*.5;const ie=$t/ne,_a=v/$t,hs=Math.abs(ie)<Math.abs(_a)?ie:_a;if(hs*hs<=j){H=Math.sqrt(j-hs*hs)*i,$=Gt-Math.atan2(H,hs),q=Math.atan2(H/u,(hs-N)/d);break t}}let _e=T.PI,Le=N-I,Ce=Le*Le,se=0,Oe=0,ee=N+I,Bt=ee*ee,rn=0;v=-I*N/(nt-It),v>=-1&&v<=1&&(v=Math.acos(v),B=I*Math.cos(v)+N,H=R*Math.sin(v),V=B*B+H*H,V<Ce&&(_e=v,Ce=V,Le=B,se=H),V>Bt&&(Oe=v,Bt=V,ee=B,rn=H)),j<=(Ce+Bt)*.5?($=Gt-Math.atan2(se*i,Le),q=_e*i):($=Gt-Math.atan2(rn*i,ee),q=Oe*i)}const K=Math.atan2(y,S)*p;let mt=t.arotation;$=($-K)*T.radDeg+b-mt,$>180?$-=360:$<-180&&($+=360),t.updateWorldTransformWith(o,c,mt+$*a,m,g,0,0),mt=n.arotation,q=((q+K)*T.radDeg-n.ashearX)*p+E-mt,q>180?q-=360:q<-180&&(q+=360),n.updateWorldTransformWith(S,y,mt+q*a,n.ascaleX,n.ascaleY,n.ashearX,n.ashearY)}}class Sr extends Os{constructor(t){super(t,0,!1),this.bones=new Array,this._target=null,this.bendDirection=1,this.compress=!1,this.stretch=!1,this.uniform=!1,this.mix=1,this.softness=0}set target(t){this._target=t}get target(){if(this._target)return this._target;throw new Error("BoneData not set.")}}class yr extends Os{constructor(t){super(t,0,!1),this.bones=new Array,this._target=null,this.positionMode=dt.Fixed,this.spacingMode=Ot.Fixed,this.rotateMode=ut.Chain,this.offsetRotation=0,this.position=0,this.spacing=0,this.mixRotate=0,this.mixX=0,this.mixY=0}set target(t){this._target=t}get target(){if(this._target)return this._target;throw new Error("SlotData not set.")}}var Ot=(f=>(f[f.Length=0]="Length",f[f.Fixed=1]="Fixed",f[f.Percent=2]="Percent",f[f.Proportional=3]="Proportional",f))(Ot||{});const Sn=class{constructor(f,t){if(this.position=0,this.spacing=0,this.mixRotate=0,this.mixX=0,this.mixY=0,this.spaces=new Array,this.positions=new Array,this.world=new Array,this.curves=new Array,this.lengths=new Array,this.segments=new Array,this.active=!1,!f)throw new Error("data cannot be null.");if(!t)throw new Error("skeleton cannot be null.");this.data=f,this.bones=new Array;for(let e=0,r=f.bones.length;e<r;e++){const i=t.findBone(f.bones[e].name);if(!i)throw new Error(`Couldn't find bone ${f.bones[e].name}.`);this.bones.push(i)}const n=t.findSlot(f.target.name);if(!n)throw new Error(`Couldn't find target bone ${f.target.name}`);this.target=n,this.position=f.position,this.spacing=f.spacing,this.mixRotate=f.mixRotate,this.mixX=f.mixX,this.mixY=f.mixY}isActive(){return this.active}update(){const f=this.target.getAttachment();if(!(f instanceof Wn))return;const t=this.mixRotate,n=this.mixX,e=this.mixY;if(t==0&&n==0&&e==0)return;const r=this.data,i=r.rotateMode==ut.Tangent,h=r.rotateMode==ut.ChainScale,l=this.bones,s=l.length,a=i?s:s+1,o=k.setArraySize(this.spaces,a),c=h?this.lengths=k.setArraySize(this.lengths,s):[],d=this.spacing;switch(r.spacingMode){case Ot.Percent:if(h)for(let p=0,S=a-1;p<S;p++){const y=l[p],M=y.data.length;if(M<Sn.epsilon)c[p]=0;else{const C=M*y.matrix.a,I=M*y.matrix.b;c[p]=Math.sqrt(C*C+I*I)}}k.arrayFill(o,1,a,d);break;case Ot.Proportional:let b=0;for(let p=0,S=a-1;p<S;){const y=l[p],M=y.data.length;if(M<Sn.epsilon)h&&(c[p]=0),o[++p]=d;else{const C=M*y.matrix.a,I=M*y.matrix.b,R=Math.sqrt(C*C+I*I);h&&(c[p]=R),o[++p]=R,b+=R}}if(b>0){b=a/b*d;for(let p=1;p<a;p++)o[p]*=b}break;default:const E=r.spacingMode==Ot.Length;for(let p=0,S=a-1;p<S;){const y=l[p],M=y.data.length;if(M<Sn.epsilon)h&&(c[p]=0),o[++p]=d;else{const C=M*y.matrix.a,I=M*y.matrix.b,R=Math.sqrt(C*C+I*I);h&&(c[p]=R),o[++p]=(E?M+d:d)*R/M}}}const u=this.computeWorldPositions(f,a,i);let m=u[0],g=u[1],x=r.offsetRotation,w=!1;if(x==0)w=r.rotateMode==ut.Chain;else{w=!1;const b=this.target.bone.matrix;x*=b.a*b.d-b.b*b.c>0?T.degRad:-T.degRad}for(let b=0,E=3;b<s;b++,E+=3){const p=l[b],S=p.matrix;S.tx+=(m-S.tx)*n,S.ty+=(g-S.ty)*e;const y=u[E],M=u[E+1],C=y-m,I=M-g;if(h){const R=c[b];if(R!=0){const v=(Math.sqrt(C*C+I*I)/R-1)*t+1;S.a*=v,S.b*=v}}if(m=y,g=M,t>0){const R=S.a,v=S.c,V=S.b,P=S.d;let D=0,F=0,B=0;if(i?D=u[E-1]:o[b+1]==0?D=u[E+2]:D=Math.atan2(I,C),D-=Math.atan2(V,R),w){F=Math.cos(D),B=Math.sin(D);const H=p.data.length;m+=(H*(F*R-B*V)-C)*t,g+=(H*(B*R+F*V)-I)*t}else D+=x;D>T.PI?D-=T.PI2:D<-T.PI&&(D+=T.PI2),D*=t,F=Math.cos(D),B=Math.sin(D),S.a=F*R-B*V,S.c=F*v-B*P,S.b=B*R+F*V,S.d=B*v+F*P}p.updateAppliedTransform()}}computeWorldPositions(f,t,n){const e=this.target;let r=this.position;const i=this.spaces,h=k.setArraySize(this.positions,t*3+2);let l=this.world;const s=f.closed;let a=f.worldVerticesLength,o=a/6,c=Sn.NONE;if(!f.constantSpeed){const H=f.lengths;o-=s?1:2;const U=H[o];this.data.positionMode==dt.Percent&&(r*=U);let X;switch(this.data.spacingMode){case Ot.Percent:X=U;break;case Ot.Proportional:X=U/t;break;default:X=1}l=k.setArraySize(this.world,8);for(let N=0,_=0,$=0;N<t;N++,_+=3){const q=i[N]*X;r+=q;let W=r;if(s)W%=U,W<0&&(W+=U),$=0;else if(W<0){c!=Sn.BEFORE&&(c=Sn.BEFORE,f.computeWorldVertices(e,2,4,l,0,2)),this.addBeforePosition(W,l,0,h,_);continue}else if(W>U){c!=Sn.AFTER&&(c=Sn.AFTER,f.computeWorldVertices(e,a-6,4,l,0,2)),this.addAfterPosition(W-U,l,0,h,_);continue}for(;;$++){const L=H[$];if(!(W>L)){if($==0)W/=L;else{const j=H[$-1];W=(W-j)/(L-j)}break}}$!=c&&(c=$,s&&$==o?(f.computeWorldVertices(e,a-4,4,l,0,2),f.computeWorldVertices(e,0,4,l,4,2)):f.computeWorldVertices(e,$*6+2,8,l,0,2)),this.addCurvePosition(W,l[0],l[1],l[2],l[3],l[4],l[5],l[6],l[7],h,_,n||N>0&&q==0)}return h}s?(a+=2,l=k.setArraySize(this.world,a),f.computeWorldVertices(e,2,a-4,l,0,2),f.computeWorldVertices(e,0,2,l,a-4,2),l[a-2]=l[0],l[a-1]=l[1]):(o--,a-=4,l=k.setArraySize(this.world,a),f.computeWorldVertices(e,2,a,l,0,2));const d=k.setArraySize(this.curves,o);let u=0,m=l[0],g=l[1],x=0,w=0,b=0,E=0,p=0,S=0,y=0,M=0,C=0,I=0,R=0,v=0,V=0,P=0;for(let H=0,U=2;H<o;H++,U+=6)x=l[U],w=l[U+1],b=l[U+2],E=l[U+3],p=l[U+4],S=l[U+5],y=(m-x*2+b)*.1875,M=(g-w*2+E)*.1875,C=((x-b)*3-m+p)*.09375,I=((w-E)*3-g+S)*.09375,R=y*2+C,v=M*2+I,V=(x-m)*.75+y+C*.16666667,P=(w-g)*.75+M+I*.16666667,u+=Math.sqrt(V*V+P*P),V+=R,P+=v,R+=C,v+=I,u+=Math.sqrt(V*V+P*P),V+=R,P+=v,u+=Math.sqrt(V*V+P*P),V+=R+C,P+=v+I,u+=Math.sqrt(V*V+P*P),d[H]=u,m=p,g=S;this.data.positionMode==dt.Percent&&(r*=u);let D;switch(this.data.spacingMode){case Ot.Percent:D=u;break;case Ot.Proportional:D=u/t;break;default:D=1}const F=this.segments;let B=0;for(let H=0,U=0,X=0,N=0;H<t;H++,U+=3){const _=i[H]*D;r+=_;let $=r;if(s)$%=u,$<0&&($+=u),X=0;else if($<0){this.addBeforePosition($,l,0,h,U);continue}else if($>u){this.addAfterPosition($-u,l,a-4,h,U);continue}for(;;X++){const q=d[X];if(!($>q)){if(X==0)$/=q;else{const W=d[X-1];$=($-W)/(q-W)}break}}if(X!=c){c=X;let q=X*6;for(m=l[q],g=l[q+1],x=l[q+2],w=l[q+3],b=l[q+4],E=l[q+5],p=l[q+6],S=l[q+7],y=(m-x*2+b)*.03,M=(g-w*2+E)*.03,C=((x-b)*3-m+p)*.006,I=((w-E)*3-g+S)*.006,R=y*2+C,v=M*2+I,V=(x-m)*.3+y+C*.16666667,P=(w-g)*.3+M+I*.16666667,B=Math.sqrt(V*V+P*P),F[0]=B,q=1;q<8;q++)V+=R,P+=v,R+=C,v+=I,B+=Math.sqrt(V*V+P*P),F[q]=B;V+=R,P+=v,B+=Math.sqrt(V*V+P*P),F[8]=B,V+=R+C,P+=v+I,B+=Math.sqrt(V*V+P*P),F[9]=B,N=0}for($*=B;;N++){const q=F[N];if(!($>q)){if(N==0)$/=q;else{const W=F[N-1];$=N+($-W)/(q-W)}break}}this.addCurvePosition($*.1,m,g,x,w,b,E,p,S,h,U,n||H>0&&_==0)}return h}addBeforePosition(f,t,n,e,r){const i=t[n],h=t[n+1],l=t[n+2]-i,s=t[n+3]-h,a=Math.atan2(s,l);e[r]=i+f*Math.cos(a),e[r+1]=h+f*Math.sin(a),e[r+2]=a}addAfterPosition(f,t,n,e,r){const i=t[n+2],h=t[n+3],l=i-t[n],s=h-t[n+1],a=Math.atan2(s,l);e[r]=i+f*Math.cos(a),e[r+1]=h+f*Math.sin(a),e[r+2]=a}addCurvePosition(f,t,n,e,r,i,h,l,s,a,o,c){if(f==0||isNaN(f)){a[o]=t,a[o+1]=n,a[o+2]=Math.atan2(r-n,e-t);return}const d=f*f,u=d*f,m=1-f,g=m*m,x=g*m,w=m*f,b=w*3,E=m*b,p=b*f,S=t*x+e*E+i*p+l*u,y=n*x+r*E+h*p+s*u;a[o]=S,a[o+1]=y,c&&(f<.001?a[o+2]=Math.atan2(r-n,e-t):a[o+2]=Math.atan2(y-(n*g+r*w*2+h*d),S-(t*g+e*w*2+i*d)))}};let cs=Sn;cs.NONE=-1,cs.BEFORE=-2,cs.AFTER=-3,cs.epsilon=1e-5;class Na{constructor(t,n){if(this.darkColor=null,this.attachment=null,this.attachmentState=0,this.sequenceIndex=-1,this.deform=new Array,!t)throw new Error("data cannot be null.");if(!n)throw new Error("bone cannot be null.");this.data=t,this.bone=n,this.color=new O,this.darkColor=t.darkColor?new O:null,this.setToSetupPose(),this.blendMode=this.data.blendMode}getSkeleton(){return this.bone.skeleton}getAttachment(){return this.attachment}setAttachment(t){this.attachment!=t&&((!(t instanceof Je)||!(this.attachment instanceof Je)||t.timelineAttachment!=this.attachment.timelineAttachment)&&(this.deform.length=0),this.attachment=t,this.sequenceIndex=-1)}setToSetupPose(){this.color.setFromColor(this.data.color),this.darkColor&&this.darkColor.setFromColor(this.data.darkColor),this.data.attachmentName?(this.attachment=null,this.setAttachment(this.bone.skeleton.getAttachment(this.data.index,this.data.attachmentName))):this.attachment=null}}class Xa{constructor(t,n){if(this.mixRotate=0,this.mixX=0,this.mixY=0,this.mixScaleX=0,this.mixScaleY=0,this.mixShearY=0,this.temp=new Yn,this.active=!1,!t)throw new Error("data cannot be null.");if(!n)throw new Error("skeleton cannot be null.");this.data=t,this.mixRotate=t.mixRotate,this.mixX=t.mixX,this.mixY=t.mixY,this.mixScaleX=t.mixScaleX,this.mixScaleY=t.mixScaleY,this.mixShearY=t.mixShearY,this.bones=new Array;for(let r=0;r<t.bones.length;r++){const i=n.findBone(t.bones[r].name);if(!i)throw new Error(`Couldn't find bone ${t.bones[r].name}.`);this.bones.push(i)}const e=n.findBone(t.target.name);if(!e)throw new Error(`Couldn't find target bone ${t.target.name}.`);this.target=e}isActive(){return this.active}update(){this.mixRotate==0&&this.mixX==0&&this.mixY==0&&this.mixScaleX==0&&this.mixScaleX==0&&this.mixShearY==0||(this.data.local?this.data.relative?this.applyRelativeLocal():this.applyAbsoluteLocal():this.data.relative?this.applyRelativeWorld():this.applyAbsoluteWorld())}applyAbsoluteWorld(){const t=this.mixRotate,n=this.mixX,e=this.mixY,r=this.mixScaleX,i=this.mixScaleY,h=this.mixShearY,l=n!=0||e!=0,s=this.target,a=s.matrix,o=a.a,c=a.c,d=a.b,u=a.d,m=o*u-c*d>0?T.degRad:-T.degRad,g=this.data.offsetRotation*m,x=this.data.offsetShearY*m,w=this.bones;for(let b=0,E=w.length;b<E;b++){const p=w[b],S=p.matrix;if(t!=0){const y=S.a,M=S.c,C=S.b,I=S.d;let R=Math.atan2(d,o)-Math.atan2(C,y)+g;R>T.PI?R-=T.PI2:R<-T.PI&&(R+=T.PI2),R*=t;const v=Math.cos(R),V=Math.sin(R);S.a=v*y-V*C,S.c=v*M-V*I,S.b=V*y+v*C,S.d=V*M+v*I}if(l){const y=this.temp;s.localToWorld(y.set(this.data.offsetX,this.data.offsetY)),S.tx+=(y.x-S.tx)*n,S.ty+=(y.y-S.ty)*e}if(r!=0){let y=Math.sqrt(S.a*S.a+S.b*S.b);y!=0&&(y=(y+(Math.sqrt(o*o+d*d)-y+this.data.offsetScaleX)*r)/y),S.a*=y,S.b*=y}if(i!=0){let y=Math.sqrt(S.c*S.c+S.d*S.d);y!=0&&(y=(y+(Math.sqrt(c*c+u*u)-y+this.data.offsetScaleY)*i)/y),S.c*=y,S.d*=y}if(h>0){const y=S.c,M=S.d,C=Math.atan2(M,y);let I=Math.atan2(u,c)-Math.atan2(d,o)-(C-Math.atan2(S.b,S.a));I>T.PI?I-=T.PI2:I<-T.PI&&(I+=T.PI2),I=C+(I+x)*h;const R=Math.sqrt(y*y+M*M);S.c=Math.cos(I)*R,S.d=Math.sin(I)*R}p.updateAppliedTransform()}}applyRelativeWorld(){const t=this.mixRotate,n=this.mixX,e=this.mixY,r=this.mixScaleX,i=this.mixScaleY,h=this.mixShearY,l=n!=0||e!=0,s=this.target,a=s.matrix,o=a.a,c=a.c,d=a.b,u=a.d,m=o*u-c*d>0?T.degRad:-T.degRad,g=this.data.offsetRotation*m,x=this.data.offsetShearY*m,w=this.bones;for(let b=0,E=w.length;b<E;b++){const p=w[b],S=p.matrix;if(t!=0){const y=S.a,M=S.c,C=S.b,I=S.d;let R=Math.atan2(d,o)+g;R>T.PI?R-=T.PI2:R<-T.PI&&(R+=T.PI2),R*=t;const v=Math.cos(R),V=Math.sin(R);S.a=v*y-V*C,S.c=v*M-V*I,S.b=V*y+v*C,S.d=V*M+v*I}if(l){const y=this.temp;s.localToWorld(y.set(this.data.offsetX,this.data.offsetY)),S.tx+=y.x*n,S.ty+=y.y*e}if(r!=0){const y=(Math.sqrt(o*o+d*d)-1+this.data.offsetScaleX)*r+1;S.a*=y,S.b*=y}if(i!=0){const y=(Math.sqrt(c*c+u*u)-1+this.data.offsetScaleY)*i+1;S.c*=y,S.d*=y}if(h>0){let y=Math.atan2(u,c)-Math.atan2(d,o);y>T.PI?y-=T.PI2:y<-T.PI&&(y+=T.PI2);const M=S.c,C=S.d;y=Math.atan2(C,M)+(y-T.PI/2+x)*h;const I=Math.sqrt(M*M+C*C);S.c=Math.cos(y)*I,S.d=Math.sin(y)*I}p.updateAppliedTransform()}}applyAbsoluteLocal(){const t=this.mixRotate,n=this.mixX,e=this.mixY,r=this.mixScaleX,i=this.mixScaleY,h=this.mixShearY,l=this.target,s=this.bones;for(let a=0,o=s.length;a<o;a++){const c=s[a];let d=c.arotation;if(t!=0){let b=l.arotation-d+this.data.offsetRotation;b-=(16384-(16384.499999999996-b/360|0))*360,d+=b*t}let u=c.ax,m=c.ay;u+=(l.ax-u+this.data.offsetX)*n,m+=(l.ay-m+this.data.offsetY)*e;let g=c.ascaleX,x=c.ascaleY;r!=0&&g!=0&&(g=(g+(l.ascaleX-g+this.data.offsetScaleX)*r)/g),i!=0&&x!=0&&(x=(x+(l.ascaleY-x+this.data.offsetScaleY)*i)/x);let w=c.ashearY;if(h!=0){let b=l.ashearY-w+this.data.offsetShearY;b-=(16384-(16384.499999999996-b/360|0))*360,w+=b*h}c.updateWorldTransformWith(u,m,d,g,x,c.ashearX,w)}}applyRelativeLocal(){const t=this.mixRotate,n=this.mixX,e=this.mixY,r=this.mixScaleX,i=this.mixScaleY,h=this.mixShearY,l=this.target,s=this.bones;for(let a=0,o=s.length;a<o;a++){const c=s[a],d=c.arotation+(l.arotation+this.data.offsetRotation)*t,u=c.ax+(l.ax+this.data.offsetX)*n,m=c.ay+(l.ay+this.data.offsetY)*e,g=c.ascaleX*((l.ascaleX-1+this.data.offsetScaleX)*r+1),x=c.ascaleY*((l.ascaleY-1+this.data.offsetScaleY)*i+1),w=c.ashearY+(l.ashearY+this.data.offsetShearY)*h;c.updateWorldTransformWith(u,m,d,g,x,c.ashearX,w)}}}const ps=class{constructor(f){if(this._updateCache=new Array,this.skin=null,this.scaleX=1,this.scaleY=1,this.x=0,this.y=0,!f)throw new Error("data cannot be null.");this.data=f,this.bones=new Array;for(let t=0;t<f.bones.length;t++){const n=f.bones[t];let e;if(!n.parent)e=new pr(n,this,null);else{const r=this.bones[n.parent.index];e=new pr(n,this,r),r.children.push(e)}this.bones.push(e)}this.slots=new Array,this.drawOrder=new Array;for(let t=0;t<f.slots.length;t++){const n=f.slots[t],e=this.bones[n.boneData.index],r=new Na(n,e);this.slots.push(r),this.drawOrder.push(r)}this.ikConstraints=new Array;for(let t=0;t<f.ikConstraints.length;t++){const n=f.ikConstraints[t];this.ikConstraints.push(new Ya(n,this))}this.transformConstraints=new Array;for(let t=0;t<f.transformConstraints.length;t++){const n=f.transformConstraints[t];this.transformConstraints.push(new Xa(n,this))}this.pathConstraints=new Array;for(let t=0;t<f.pathConstraints.length;t++){const n=f.pathConstraints[t];this.pathConstraints.push(new cs(n,this))}this.color=new O(1,1,1,1),this.updateCache()}updateCache(){const f=this._updateCache;f.length=0;const t=this.bones;for(let a=0,o=t.length;a<o;a++){const c=t[a];c.sorted=c.data.skinRequired,c.active=!c.sorted}if(this.skin){const a=this.skin.bones;for(let o=0,c=this.skin.bones.length;o<c;o++){let d=this.bones[a[o].index];do d.sorted=!1,d.active=!0,d=d.parent;while(d)}}const n=this.ikConstraints,e=this.transformConstraints,r=this.pathConstraints,i=n.length,h=e.length,l=r.length,s=i+h+l;t:for(let a=0;a<s;a++){for(let o=0;o<i;o++){const c=n[o];if(c.data.order==a){this.sortIkConstraint(c);continue t}}for(let o=0;o<h;o++){const c=e[o];if(c.data.order==a){this.sortTransformConstraint(c);continue t}}for(let o=0;o<l;o++){const c=r[o];if(c.data.order==a){this.sortPathConstraint(c);continue t}}}for(let a=0,o=t.length;a<o;a++)this.sortBone(t[a])}sortIkConstraint(f){if(f.active=f.target.isActive()&&(!f.data.skinRequired||this.skin&&k.contains(this.skin.constraints,f.data,!0)),!f.active)return;const t=f.target;this.sortBone(t);const n=f.bones,e=n[0];if(this.sortBone(e),n.length==1)this._updateCache.push(f),this.sortReset(e.children);else{const r=n[n.length-1];this.sortBone(r),this._updateCache.push(f),this.sortReset(e.children),r.sorted=!0}}sortPathConstraint(f){if(f.active=f.target.bone.isActive()&&(!f.data.skinRequired||this.skin&&k.contains(this.skin.constraints,f.data,!0)),!f.active)return;const t=f.target,n=t.data.index,e=t.bone;this.skin&&this.sortPathConstraintAttachment(this.skin,n,e),this.data.defaultSkin&&this.data.defaultSkin!=this.skin&&this.sortPathConstraintAttachment(this.data.defaultSkin,n,e);for(let l=0,s=this.data.skins.length;l<s;l++)this.sortPathConstraintAttachment(this.data.skins[l],n,e);const r=t.getAttachment();r instanceof Wn&&this.sortPathConstraintAttachmentWith(r,e);const i=f.bones,h=i.length;for(let l=0;l<h;l++)this.sortBone(i[l]);this._updateCache.push(f);for(let l=0;l<h;l++)this.sortReset(i[l].children);for(let l=0;l<h;l++)i[l].sorted=!0}sortTransformConstraint(f){if(f.active=f.target.isActive()&&(!f.data.skinRequired||this.skin&&k.contains(this.skin.constraints,f.data,!0)),!f.active)return;this.sortBone(f.target);const t=f.bones,n=t.length;if(f.data.local)for(let e=0;e<n;e++){const r=t[e];this.sortBone(r.parent),this.sortBone(r)}else for(let e=0;e<n;e++)this.sortBone(t[e]);this._updateCache.push(f);for(let e=0;e<n;e++)this.sortReset(t[e].children);for(let e=0;e<n;e++)t[e].sorted=!0}sortPathConstraintAttachment(f,t,n){const e=f.attachments[t];if(e)for(const r in e)this.sortPathConstraintAttachmentWith(e[r],n)}sortPathConstraintAttachmentWith(f,t){if(!(f instanceof Wn))return;const n=f.bones;if(!n)this.sortBone(t);else{const e=this.bones;for(let r=0,i=n.length;r<i;){let h=n[r++];for(h+=r;r<h;)this.sortBone(e[n[r++]])}}}sortBone(f){if(!f||f.sorted)return;const t=f.parent;t&&this.sortBone(t),f.sorted=!0,this._updateCache.push(f)}sortReset(f){for(let t=0,n=f.length;t<n;t++){const e=f[t];e.active&&(e.sorted&&this.sortReset(e.children),e.sorted=!1)}}updateWorldTransform(){const f=this.bones;for(let n=0,e=f.length;n<e;n++){const r=f[n];r.ax=r.x,r.ay=r.y,r.arotation=r.rotation,r.ascaleX=r.scaleX,r.ascaleY=r.scaleY,r.ashearX=r.shearX,r.ashearY=r.shearY}const t=this._updateCache;for(let n=0,e=t.length;n<e;n++)t[n].update()}updateWorldTransformWith(f){const t=this.getRootBone(),n=f.matrix.a,e=f.matrix.c,r=f.matrix.b,i=f.matrix.d;t.matrix.tx=n*this.x+e*this.y+f.worldX,t.matrix.ty=r*this.x+i*this.y+f.worldY;const h=t.rotation+90+t.shearY,l=T.cosDeg(t.rotation+t.shearX)*t.scaleX,s=T.cosDeg(h)*t.scaleY,a=T.sinDeg(t.rotation+t.shearX)*t.scaleX,o=T.sinDeg(h)*t.scaleY,c=this.scaleX,d=jt.yDown?-this.scaleY:this.scaleY;t.matrix.a=(n*l+e*a)*c,t.matrix.c=(n*s+e*o)*c,t.matrix.b=(r*l+i*a)*d,t.matrix.d=(r*s+i*o)*d;const u=this._updateCache;for(let m=0,g=u.length;m<g;m++){const x=u[m];x!=t&&x.update()}}setToSetupPose(){this.setBonesToSetupPose(),this.setSlotsToSetupPose()}setBonesToSetupPose(){const f=this.bones;for(let r=0,i=f.length;r<i;r++)f[r].setToSetupPose();const t=this.ikConstraints;for(let r=0,i=t.length;r<i;r++){const h=t[r];h.mix=h.data.mix,h.softness=h.data.softness,h.bendDirection=h.data.bendDirection,h.compress=h.data.compress,h.stretch=h.data.stretch}const n=this.transformConstraints;for(let r=0,i=n.length;r<i;r++){const h=n[r],l=h.data;h.mixRotate=l.mixRotate,h.mixX=l.mixX,h.mixY=l.mixY,h.mixScaleX=l.mixScaleX,h.mixScaleY=l.mixScaleY,h.mixShearY=l.mixShearY}const e=this.pathConstraints;for(let r=0,i=e.length;r<i;r++){const h=e[r],l=h.data;h.position=l.position,h.spacing=l.spacing,h.mixRotate=l.mixRotate,h.mixX=l.mixX,h.mixY=l.mixY}}setSlotsToSetupPose(){const f=this.slots;k.arrayCopy(f,0,this.drawOrder,0,f.length);for(let t=0,n=f.length;t<n;t++)f[t].setToSetupPose()}getRootBone(){return this.bones.length==0?null:this.bones[0]}findBone(f){if(!f)throw new Error("boneName cannot be null.");const t=this.bones;for(let n=0,e=t.length;n<e;n++){const r=t[n];if(r.data.name==f)return r}return null}findBoneIndex(f){if(!f)throw new Error("boneName cannot be null.");const t=this.bones;for(let n=0,e=t.length;n<e;n++)if(t[n].data.name==f)return n;return-1}findSlot(f){if(!f)throw new Error("slotName cannot be null.");const t=this.slots;for(let n=0,e=t.length;n<e;n++){const r=t[n];if(r.data.name==f)return r}return null}findSlotIndex(f){if(!f)throw new Error("slotName cannot be null.");const t=this.slots;for(let n=0,e=t.length;n<e;n++)if(t[n].data.name==f)return n;return-1}setSkinByName(f){const t=this.data.findSkin(f);if(!t)throw new Error(`Skin not found: ${f}`);this.setSkin(t)}setSkin(f){if(f!=this.skin){if(f)if(this.skin)f.attachAll(this,this.skin);else{const t=this.slots;for(let n=0,e=t.length;n<e;n++){const r=t[n],i=r.data.attachmentName;if(i){const h=f.getAttachment(n,i);h&&r.setAttachment(h)}}}this.skin=f,this.updateCache()}}getAttachmentByName(f,t){const n=this.data.findSlot(f);if(!n)throw new Error(`Can't find slot with name ${f}`);return this.getAttachment(n.index,t)}getAttachment(f,t){if(!t)throw new Error("attachmentName cannot be null.");if(this.skin){const n=this.skin.getAttachment(f,t);if(n)return n}return this.data.defaultSkin?this.data.defaultSkin.getAttachment(f,t):null}setAttachment(f,t){if(!f)throw new Error("slotName cannot be null.");const n=this.slots;for(let e=0,r=n.length;e<r;e++){const i=n[e];if(i.data.name==f){let h=null;if(t&&(h=this.getAttachment(e,t),!h))throw new Error(`Attachment not found: ${t}, for slot: ${f}`);i.setAttachment(h);return}}throw new Error(`Slot not found: ${f}`)}findIkConstraint(f){if(!f)throw new Error("constraintName cannot be null.");const t=this.ikConstraints;for(let n=0,e=t.length;n<e;n++){const r=t[n];if(r.data.name==f)return r}return null}findTransformConstraint(f){if(!f)throw new Error("constraintName cannot be null.");const t=this.transformConstraints;for(let n=0,e=t.length;n<e;n++){const r=t[n];if(r.data.name==f)return r}return null}findPathConstraint(f){if(!f)throw new Error("constraintName cannot be null.");const t=this.pathConstraints;for(let n=0,e=t.length;n<e;n++){const r=t[n];if(r.data.name==f)return r}return null}getBoundsRect(){const f=new Yn,t=new Yn;return this.getBounds(f,t),{x:f.x,y:f.y,width:t.x,height:t.y}}getBounds(f,t,n=new Array(2)){if(!f)throw new Error("offset cannot be null.");if(!t)throw new Error("size cannot be null.");const e=this.drawOrder;let r=Number.POSITIVE_INFINITY,i=Number.POSITIVE_INFINITY,h=Number.NEGATIVE_INFINITY,l=Number.NEGATIVE_INFINITY;for(let s=0,a=e.length;s<a;s++){const o=e[s];if(!o.bone.active)continue;let c=0,d=null;const u=o.getAttachment();if(u instanceof lt)c=8,d=k.setArraySize(n,c,0),u.computeWorldVertices(o,d,0,2);else if(u instanceof $n){const m=u;c=m.worldVerticesLength,d=k.setArraySize(n,c,0),m.computeWorldVertices(o,0,c,d,0,2)}if(d)for(let m=0,g=d.length;m<g;m+=2){const x=d[m],w=d[m+1];r=Math.min(r,x),i=Math.min(i,w),h=Math.max(h,x),l=Math.max(l,w)}}f.set(r,i),t.set(h-r,l-i)}get flipX(){return this.scaleX==-1}set flipX(f){ps.deprecatedWarning1||(ps.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleX=f?1:-1}get flipY(){return this.scaleY==-1}set flipY(f){ps.deprecatedWarning1||(ps.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleY=f?1:-1}};let Mr=ps;Mr.deprecatedWarning1=!1;class Ar{constructor(){this.name=null,this.bones=new Array,this.slots=new Array,this.skins=new Array,this.defaultSkin=null,this.events=new Array,this.animations=new Array,this.ikConstraints=new Array,this.transformConstraints=new Array,this.pathConstraints=new Array,this.x=0,this.y=0,this.width=0,this.height=0,this.version=null,this.hash=null,this.fps=0,this.imagesPath=null,this.audioPath=null}findBone(t){if(!t)throw new Error("boneName cannot be null.");const n=this.bones;for(let e=0,r=n.length;e<r;e++){const i=n[e];if(i.name==t)return i}return null}findBoneIndex(t){if(!t)throw new Error("boneName cannot be null.");const n=this.bones;for(let e=0,r=n.length;e<r;e++)if(n[e].name==t)return e;return-1}findSlot(t){if(!t)throw new Error("slotName cannot be null.");const n=this.slots;for(let e=0,r=n.length;e<r;e++){const i=n[e];if(i.name==t)return i}return null}findSlotIndex(t){if(!t)throw new Error("slotName cannot be null.");const n=this.slots;for(let e=0,r=n.length;e<r;e++)if(n[e].name==t)return e;return-1}findSkin(t){if(!t)throw new Error("skinName cannot be null.");const n=this.skins;for(let e=0,r=n.length;e<r;e++){const i=n[e];if(i.name==t)return i}return null}findEvent(t){if(!t)throw new Error("eventDataName cannot be null.");const n=this.events;for(let e=0,r=n.length;e<r;e++){const i=n[e];if(i.name==t)return i}return null}findAnimation(t){if(!t)throw new Error("animationName cannot be null.");const n=this.animations;for(let e=0,r=n.length;e<r;e++){const i=n[e];if(i.name==t)return i}return null}findIkConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const n=this.ikConstraints;for(let e=0,r=n.length;e<r;e++){const i=n[e];if(i.name==t)return i}return null}findTransformConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const n=this.transformConstraints;for(let e=0,r=n.length;e<r;e++){const i=n[e];if(i.name==t)return i}return null}findPathConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const n=this.pathConstraints;for(let e=0,r=n.length;e<r;e++){const i=n[e];if(i.name==t)return i}return null}findPathConstraintIndex(t){if(t==null)throw new Error("pathConstraintName cannot be null.");const n=this.pathConstraints;for(let e=0,r=n.length;e<r;e++)if(n[e].name==t)return e;return-1}}class Tr{constructor(t,n,e){if(this.index=0,this.color=new O(1,1,1,1),this.darkColor=null,this.attachmentName=null,this.blendMode=G.BLEND_MODES.NORMAL,t<0)throw new Error("index must be >= 0.");if(!n)throw new Error("name cannot be null.");if(!e)throw new Error("boneData cannot be null.");this.index=t,this.name=n,this.boneData=e}}class Cr extends Os{constructor(t){super(t,0,!1),this.bones=new Array,this._target=null,this.mixRotate=0,this.mixX=0,this.mixY=0,this.mixScaleX=0,this.mixScaleY=0,this.mixShearY=0,this.offsetRotation=0,this.offsetX=0,this.offsetY=0,this.offsetScaleX=0,this.offsetScaleY=0,this.offsetShearY=0,this.relative=!1,this.local=!1}set target(t){this._target=t}get target(){if(this._target)return this._target;throw new Error("BoneData not set.")}}class Ir{constructor(t,n,e){this.slotIndex=t,this.name=n,this.attachment=e}}class $s{constructor(t){if(this.attachments=new Array,this.bones=Array(),this.constraints=new Array,!t)throw new Error("name cannot be null.");this.name=t}setAttachment(t,n,e){if(!e)throw new Error("attachment cannot be null.");const r=this.attachments;t>=r.length&&(r.length=t+1),r[t]||(r[t]={}),r[t][n]=e}addSkin(t){for(let e=0;e<t.bones.length;e++){const r=t.bones[e];let i=!1;for(let h=0;h<this.bones.length;h++)if(this.bones[h]==r){i=!0;break}i||this.bones.push(r)}for(let e=0;e<t.constraints.length;e++){const r=t.constraints[e];let i=!1;for(let h=0;h<this.constraints.length;h++)if(this.constraints[h]==r){i=!0;break}i||this.constraints.push(r)}const n=t.getAttachments();for(let e=0;e<n.length;e++){const r=n[e];this.setAttachment(r.slotIndex,r.name,r.attachment)}}copySkin(t){for(let e=0;e<t.bones.length;e++){const r=t.bones[e];let i=!1;for(let h=0;h<this.bones.length;h++)if(this.bones[h]==r){i=!0;break}i||this.bones.push(r)}for(let e=0;e<t.constraints.length;e++){const r=t.constraints[e];let i=!1;for(let h=0;h<this.constraints.length;h++)if(this.constraints[h]==r){i=!0;break}i||this.constraints.push(r)}const n=t.getAttachments();for(let e=0;e<n.length;e++){const r=n[e];r.attachment&&(r.attachment instanceof $n?(r.attachment=r.attachment.newLinkedMesh(),this.setAttachment(r.slotIndex,r.name,r.attachment)):(r.attachment=r.attachment.copy(),this.setAttachment(r.slotIndex,r.name,r.attachment)))}}getAttachment(t,n){const e=this.attachments[t];return e?e[n]:null}removeAttachment(t,n){const e=this.attachments[t];e&&delete e[n]}getAttachments(){const t=new Array;for(let n=0;n<this.attachments.length;n++){const e=this.attachments[n];if(e)for(const r in e){const i=e[r];i&&t.push(new Ir(n,r,i))}}return t}getAttachmentsForSlot(t,n){const e=this.attachments[t];if(e)for(const r in e){const i=e[r];i&&n.push(new Ir(t,r,i))}}clear(){this.attachments.length=0,this.bones.length=0,this.constraints.length=0}attachAll(t,n){let e=0;for(let r=0;r<t.slots.length;r++){const i=t.slots[r],h=i.getAttachment();if(h&&e<n.attachments.length){const l=n.attachments[e];for(const s in l){const a=l[s];if(h==a){const o=this.getAttachment(e,s);o&&i.setAttachment(o);break}}}e++}}}class Rr{constructor(t){this.ver40=!1,this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=t}readSkeletonData(t){const n=this.scale,e=new Ar;e.name="";const r=new Gn(t),i=r.readInt32(),h=r.readInt32();e.hash=h==0&&i==0?null:h.toString(16)+i.toString(16),e.version=r.readString();const l=e.version.substr(0,3);if(l!=="4.0"&&l!=="4.1"){const c=`Spine 4.1 loader cant load version ${e.version}. Please configure your pixi-spine bundle`;console.error(c)}this.ver40=l==="4.0",e.x=r.readFloat(),e.y=r.readFloat(),e.width=r.readFloat(),e.height=r.readFloat();const s=r.readBoolean();s&&(e.fps=r.readFloat(),e.imagesPath=r.readString(),e.audioPath=r.readString());let a=0;a=r.readInt(!0);for(let c=0;c<a;c++){const d=r.readString();if(!d)throw new Error("String in string table must not be null.");r.strings.push(d)}a=r.readInt(!0);for(let c=0;c<a;c++){const d=r.readString();if(!d)throw new Error("Bone name must not be null.");const u=c==0?null:e.bones[r.readInt(!0)],m=new wr(c,d,u);m.rotation=r.readFloat(),m.x=r.readFloat()*n,m.y=r.readFloat()*n,m.scaleX=r.readFloat(),m.scaleY=r.readFloat(),m.shearX=r.readFloat(),m.shearY=r.readFloat(),m.length=r.readFloat()*n,m.transformMode=r.readInt(!0),m.skinRequired=r.readBoolean(),s&&O.rgba8888ToColor(m.color,r.readInt32()),e.bones.push(m)}a=r.readInt(!0);for(let c=0;c<a;c++){const d=r.readString();if(!d)throw new Error("Slot name must not be null.");const u=e.bones[r.readInt(!0)],m=new Tr(c,d,u);O.rgba8888ToColor(m.color,r.readInt32());const g=r.readInt32();g!=-1&&O.rgb888ToColor(m.darkColor=new O,g),m.attachmentName=r.readStringRef(),m.blendMode=r.readInt(!0),e.slots.push(m)}a=r.readInt(!0);for(let c=0,d;c<a;c++){const u=r.readString();if(!u)throw new Error("IK constraint data name must not be null.");const m=new Sr(u);m.order=r.readInt(!0),m.skinRequired=r.readBoolean(),d=r.readInt(!0);for(let g=0;g<d;g++)m.bones.push(e.bones[r.readInt(!0)]);m.target=e.bones[r.readInt(!0)],m.mix=r.readFloat(),m.softness=r.readFloat()*n,m.bendDirection=r.readByte(),m.compress=r.readBoolean(),m.stretch=r.readBoolean(),m.uniform=r.readBoolean(),e.ikConstraints.push(m)}a=r.readInt(!0);for(let c=0,d;c<a;c++){const u=r.readString();if(!u)throw new Error("Transform constraint data name must not be null.");const m=new Cr(u);m.order=r.readInt(!0),m.skinRequired=r.readBoolean(),d=r.readInt(!0);for(let g=0;g<d;g++)m.bones.push(e.bones[r.readInt(!0)]);m.target=e.bones[r.readInt(!0)],m.local=r.readBoolean(),m.relative=r.readBoolean(),m.offsetRotation=r.readFloat(),m.offsetX=r.readFloat()*n,m.offsetY=r.readFloat()*n,m.offsetScaleX=r.readFloat(),m.offsetScaleY=r.readFloat(),m.offsetShearY=r.readFloat(),m.mixRotate=r.readFloat(),m.mixX=r.readFloat(),m.mixY=r.readFloat(),m.mixScaleX=r.readFloat(),m.mixScaleY=r.readFloat(),m.mixShearY=r.readFloat(),e.transformConstraints.push(m)}a=r.readInt(!0);for(let c=0,d;c<a;c++){const u=r.readString();if(!u)throw new Error("Path constraint data name must not be null.");const m=new yr(u);m.order=r.readInt(!0),m.skinRequired=r.readBoolean(),d=r.readInt(!0);for(let g=0;g<d;g++)m.bones.push(e.bones[r.readInt(!0)]);m.target=e.slots[r.readInt(!0)],m.positionMode=r.readInt(!0),m.spacingMode=r.readInt(!0),m.rotateMode=r.readInt(!0),m.offsetRotation=r.readFloat(),m.position=r.readFloat(),m.positionMode==dt.Fixed&&(m.position*=n),m.spacing=r.readFloat(),(m.spacingMode==Ot.Length||m.spacingMode==Ot.Fixed)&&(m.spacing*=n),m.mixRotate=r.readFloat(),m.mixX=r.readFloat(),m.mixY=r.readFloat(),e.pathConstraints.push(m)}const o=this.readSkin(r,e,!0,s);o&&(e.defaultSkin=o,e.skins.push(o));{let c=e.skins.length;for(k.setArraySize(e.skins,a=c+r.readInt(!0));c<a;c++){const d=this.readSkin(r,e,!1,s);if(!d)throw new Error("readSkin() should not have returned null.");e.skins[c]=d}}a=this.linkedMeshes.length;for(let c=0;c<a;c++){const d=this.linkedMeshes[c],u=d.skin?e.findSkin(d.skin):e.defaultSkin;if(!u)throw new Error("Not skin found for linked mesh.");if(!d.parent)throw new Error("Linked mesh parent must not be null");const m=u.getAttachment(d.slotIndex,d.parent);if(!m)throw new Error(`Parent mesh not found: ${d.parent}`);d.mesh.timelineAttachment=d.inheritTimeline?m:d.mesh,d.mesh.setParentMesh(m)}this.linkedMeshes.length=0,a=r.readInt(!0);for(let c=0;c<a;c++){const d=r.readStringRef();if(!d)throw new Error;const u=new Er(d);u.intValue=r.readInt(!1),u.floatValue=r.readFloat(),u.stringValue=r.readString(),u.audioPath=r.readString(),u.audioPath&&(u.volume=r.readFloat(),u.balance=r.readFloat()),e.events.push(u)}a=r.readInt(!0);for(let c=0;c<a;c++){const d=r.readString();if(!d)throw new Error("Animatio name must not be null.");e.animations.push(this.readAnimation(r,d,e))}return e}readSkin(t,n,e,r){let i=null,h=0;if(e){if(h=t.readInt(!0),h==0)return null;i=new $s("default")}else{const l=t.readStringRef();if(!l)throw new Error("Skin name must not be null.");i=new $s(l),i.bones.length=t.readInt(!0);for(let s=0,a=i.bones.length;s<a;s++)i.bones[s]=n.bones[t.readInt(!0)];for(let s=0,a=t.readInt(!0);s<a;s++)i.constraints.push(n.ikConstraints[t.readInt(!0)]);for(let s=0,a=t.readInt(!0);s<a;s++)i.constraints.push(n.transformConstraints[t.readInt(!0)]);for(let s=0,a=t.readInt(!0);s<a;s++)i.constraints.push(n.pathConstraints[t.readInt(!0)]);h=t.readInt(!0)}for(let l=0;l<h;l++){const s=t.readInt(!0);for(let a=0,o=t.readInt(!0);a<o;a++){const c=t.readStringRef();if(!c)throw new Error("Attachment name must not be null");const d=this.readAttachment(t,n,i,s,c,r);d&&i.setAttachment(s,c,d)}}return i}readAttachment(t,n,e,r,i,h){const l=this.scale;let s=t.readStringRef();switch(s||(s=i),t.readByte()){case Z.Region:{let a=t.readStringRef();const o=t.readFloat(),c=t.readFloat(),d=t.readFloat(),u=t.readFloat(),m=t.readFloat(),g=t.readFloat(),x=t.readFloat(),w=t.readInt32(),b=this.readSequence(t);a||(a=s);const E=this.attachmentLoader.newRegionAttachment(e,s,a,b);return E?(E.path=a,E.x=c*l,E.y=d*l,E.scaleX=u,E.scaleY=m,E.rotation=o,E.width=g*l,E.height=x*l,O.rgba8888ToColor(E.color,w),E.sequence=b,b==null&&E.updateRegion(),E):null}case Z.BoundingBox:{const a=t.readInt(!0),o=this.readVertices(t,a),c=h?t.readInt32():0,d=this.attachmentLoader.newBoundingBoxAttachment(e,s);return d?(d.worldVerticesLength=a<<1,d.vertices=o.vertices,d.bones=o.bones,h&&O.rgba8888ToColor(d.color,c),d):null}case Z.Mesh:{let a=t.readStringRef();const o=t.readInt32(),c=t.readInt(!0),d=this.readFloatArray(t,c<<1,1),u=this.readShortArray(t),m=this.readVertices(t,c),g=t.readInt(!0),x=this.readSequence(t);let w=[],b=0,E=0;h&&(w=this.readShortArray(t),b=t.readFloat(),E=t.readFloat()),a||(a=s);const p=this.attachmentLoader.newMeshAttachment(e,s,a,x);return p?(p.path=a,O.rgba8888ToColor(p.color,o),p.bones=m.bones,p.vertices=m.vertices,p.worldVerticesLength=c<<1,p.triangles=u,p.regionUVs=new Float32Array(d),p.hullLength=g<<1,p.sequence=x,h&&(p.edges=w,p.width=b*l,p.height=E*l),p):null}case Z.LinkedMesh:{let a=t.readStringRef();const o=t.readInt32(),c=t.readStringRef(),d=t.readStringRef(),u=t.readBoolean(),m=this.readSequence(t);let g=0,x=0;h&&(g=t.readFloat(),x=t.readFloat()),a||(a=s);const w=this.attachmentLoader.newMeshAttachment(e,s,a,m);return w?(w.path=a,O.rgba8888ToColor(w.color,o),w.sequence=m,h&&(w.width=g*l,w.height=x*l),this.linkedMeshes.push(new bo(w,c,r,d,u)),w):null}case Z.Path:{const a=t.readBoolean(),o=t.readBoolean(),c=t.readInt(!0),d=this.readVertices(t,c),u=k.newArray(c/3,0);for(let x=0,w=u.length;x<w;x++)u[x]=t.readFloat()*l;const m=h?t.readInt32():0,g=this.attachmentLoader.newPathAttachment(e,s);return g?(g.closed=a,g.constantSpeed=o,g.worldVerticesLength=c<<1,g.vertices=d.vertices,g.bones=d.bones,g.lengths=u,h&&O.rgba8888ToColor(g.color,m),g):null}case Z.Point:{const a=t.readFloat(),o=t.readFloat(),c=t.readFloat(),d=h?t.readInt32():0,u=this.attachmentLoader.newPointAttachment(e,s);return u?(u.x=o*l,u.y=c*l,u.rotation=a,h&&O.rgba8888ToColor(u.color,d),u):null}case Z.Clipping:{const a=t.readInt(!0),o=t.readInt(!0),c=this.readVertices(t,o),d=h?t.readInt32():0,u=this.attachmentLoader.newClippingAttachment(e,s);return u?(u.endSlot=n.slots[a],u.worldVerticesLength=o<<1,u.vertices=c.vertices,u.bones=c.bones,h&&O.rgba8888ToColor(u.color,d),u):null}}return null}readSequence(t){if(this.ver40||!t.readBoolean())return null;const n=new Bs(t.readInt(!0));return n.start=t.readInt(!0),n.digits=t.readInt(!0),n.setupIndex=t.readInt(!0),n}readDeformTimelineType(t){return this.ver40?Ba:t.readByte()}readVertices(t,n){const e=this.scale,r=n<<1,i=new Eo;if(!t.readBoolean())return i.vertices=this.readFloatArray(t,r,e),i;const h=new Array,l=new Array;for(let s=0;s<n;s++){const a=t.readInt(!0);l.push(a);for(let o=0;o<a;o++)l.push(t.readInt(!0)),h.push(t.readFloat()*e),h.push(t.readFloat()*e),h.push(t.readFloat())}return i.vertices=k.toFloatArray(h),i.bones=l,i}readFloatArray(t,n,e){const r=new Array(n);if(e==1)for(let i=0;i<n;i++)r[i]=t.readFloat();else for(let i=0;i<n;i++)r[i]=t.readFloat()*e;return r}readShortArray(t){const n=t.readInt(!0),e=new Array(n);for(let r=0;r<n;r++)e[r]=t.readShort();return e}readAnimation(t,n,e){t.readInt(!0);const r=new Array,i=this.scale;for(let a=0,o=t.readInt(!0);a<o;a++){const c=t.readInt(!0);for(let d=0,u=t.readInt(!0);d<u;d++){const m=t.readByte(),g=t.readInt(!0),x=g-1;switch(m){case Vo:{const w=new qn(g,c);for(let b=0;b<g;b++)w.setFrame(b,t.readFloat(),t.readStringRef());r.push(w);break}case Po:{const w=t.readInt(!0),b=new sr(g,w,c);let E=t.readFloat(),p=t.readUnsignedByte()/255,S=t.readUnsignedByte()/255,y=t.readUnsignedByte()/255,M=t.readUnsignedByte()/255;for(let C=0,I=0;b.setFrame(C,E,p,S,y,M),C!=x;C++){const R=t.readFloat(),v=t.readUnsignedByte()/255,V=t.readUnsignedByte()/255,P=t.readUnsignedByte()/255,D=t.readUnsignedByte()/255;switch(t.readByte()){case nn:b.setStepped(C);break;case sn:it(t,b,I++,C,0,E,R,p,v,1),it(t,b,I++,C,1,E,R,S,V,1),it(t,b,I++,C,2,E,R,y,P,1),it(t,b,I++,C,3,E,R,M,D,1)}E=R,p=v,S=V,y=P,M=D}r.push(b);break}case Fo:{const w=t.readInt(!0),b=new ir(g,w,c);let E=t.readFloat(),p=t.readUnsignedByte()/255,S=t.readUnsignedByte()/255,y=t.readUnsignedByte()/255;for(let M=0,C=0;b.setFrame(M,E,p,S,y),M!=x;M++){const I=t.readFloat(),R=t.readUnsignedByte()/255,v=t.readUnsignedByte()/255,V=t.readUnsignedByte()/255;switch(t.readByte()){case nn:b.setStepped(M);break;case sn:it(t,b,C++,M,0,E,I,p,R,1),it(t,b,C++,M,1,E,I,S,v,1),it(t,b,C++,M,2,E,I,y,V,1)}E=I,p=R,S=v,y=V}r.push(b);break}case Yo:{const w=t.readInt(!0),b=new ar(g,w,c);let E=t.readFloat(),p=t.readUnsignedByte()/255,S=t.readUnsignedByte()/255,y=t.readUnsignedByte()/255,M=t.readUnsignedByte()/255,C=t.readUnsignedByte()/255,I=t.readUnsignedByte()/255,R=t.readUnsignedByte()/255;for(let v=0,V=0;b.setFrame(v,E,p,S,y,M,C,I,R),v!=x;v++){const P=t.readFloat(),D=t.readUnsignedByte()/255,F=t.readUnsignedByte()/255,B=t.readUnsignedByte()/255,H=t.readUnsignedByte()/255,U=t.readUnsignedByte()/255,X=t.readUnsignedByte()/255,N=t.readUnsignedByte()/255;switch(t.readByte()){case nn:b.setStepped(v);break;case sn:it(t,b,V++,v,0,E,P,p,D,1),it(t,b,V++,v,1,E,P,S,F,1),it(t,b,V++,v,2,E,P,y,B,1),it(t,b,V++,v,3,E,P,M,H,1),it(t,b,V++,v,4,E,P,C,U,1),it(t,b,V++,v,5,E,P,I,X,1),it(t,b,V++,v,6,E,P,R,N,1)}E=P,p=D,S=F,y=B,M=H,C=U,I=X,R=N}r.push(b);break}case No:{const w=t.readInt(!0),b=new or(g,w,c);let E=t.readFloat(),p=t.readUnsignedByte()/255,S=t.readUnsignedByte()/255,y=t.readUnsignedByte()/255,M=t.readUnsignedByte()/255,C=t.readUnsignedByte()/255,I=t.readUnsignedByte()/255;for(let R=0,v=0;b.setFrame(R,E,p,S,y,M,C,I),R!=x;R++){const V=t.readFloat(),P=t.readUnsignedByte()/255,D=t.readUnsignedByte()/255,F=t.readUnsignedByte()/255,B=t.readUnsignedByte()/255,H=t.readUnsignedByte()/255,U=t.readUnsignedByte()/255;switch(t.readByte()){case nn:b.setStepped(R);break;case sn:it(t,b,v++,R,0,E,V,p,P,1),it(t,b,v++,R,1,E,V,S,D,1),it(t,b,v++,R,2,E,V,y,F,1),it(t,b,v++,R,3,E,V,M,B,1),it(t,b,v++,R,4,E,V,C,H,1),it(t,b,v++,R,5,E,V,I,U,1)}E=V,p=P,S=D,y=F,M=B,C=H,I=U}r.push(b);break}case Xo:{const w=new rr(g,t.readInt(!0),c);let b=t.readFloat(),E=t.readUnsignedByte()/255;for(let p=0,S=0;w.setFrame(p,b,E),p!=x;p++){const y=t.readFloat(),M=t.readUnsignedByte()/255;switch(t.readByte()){case nn:w.setStepped(p);break;case sn:it(t,w,S++,p,0,b,y,E,M,1)}b=y,E=M}r.push(w)}}}}for(let a=0,o=t.readInt(!0);a<o;a++){const c=t.readInt(!0);for(let d=0,u=t.readInt(!0);d<u;d++){const m=t.readByte(),g=t.readInt(!0),x=t.readInt(!0);switch(m){case So:r.push(yn(t,new gs(g,x,c),1));break;case yo:r.push(kr(t,new Gi(g,x,c),i));break;case Mo:r.push(yn(t,new ji(g,x,c),i));break;case Ao:r.push(yn(t,new Zi(g,x,c),i));break;case To:r.push(kr(t,new Qi(g,x,c),1));break;case Co:r.push(yn(t,new Ki(g,x,c),1));break;case Io:r.push(yn(t,new Ji(g,x,c),1));break;case Ro:r.push(kr(t,new tr(g,x,c),1));break;case ko:r.push(yn(t,new er(g,x,c),1));break;case vo:r.push(yn(t,new nr(g,x,c),1))}}}for(let a=0,o=t.readInt(!0);a<o;a++){const c=t.readInt(!0),d=t.readInt(!0),u=d-1,m=new cr(d,t.readInt(!0),c);let g=t.readFloat(),x=t.readFloat(),w=t.readFloat()*i;for(let b=0,E=0;m.setFrame(b,g,x,w,t.readByte(),t.readBoolean(),t.readBoolean()),b!=u;b++){const p=t.readFloat(),S=t.readFloat(),y=t.readFloat()*i;switch(t.readByte()){case nn:m.setStepped(b);break;case sn:it(t,m,E++,b,0,g,p,x,S,1),it(t,m,E++,b,1,g,p,w,y,i)}g=p,x=S,w=y}r.push(m)}for(let a=0,o=t.readInt(!0);a<o;a++){const c=t.readInt(!0),d=t.readInt(!0),u=d-1,m=new hr(d,t.readInt(!0),c);let g=t.readFloat(),x=t.readFloat(),w=t.readFloat(),b=t.readFloat(),E=t.readFloat(),p=t.readFloat(),S=t.readFloat();for(let y=0,M=0;m.setFrame(y,g,x,w,b,E,p,S),y!=u;y++){const C=t.readFloat(),I=t.readFloat(),R=t.readFloat(),v=t.readFloat(),V=t.readFloat(),P=t.readFloat(),D=t.readFloat();switch(t.readByte()){case nn:m.setStepped(y);break;case sn:it(t,m,M++,y,0,g,C,x,I,1),it(t,m,M++,y,1,g,C,w,R,1),it(t,m,M++,y,2,g,C,b,v,1),it(t,m,M++,y,3,g,C,E,V,1),it(t,m,M++,y,4,g,C,p,P,1),it(t,m,M++,y,5,g,C,S,D,1)}g=C,x=I,w=R,b=v,E=V,p=P,S=D}r.push(m)}for(let a=0,o=t.readInt(!0);a<o;a++){const c=t.readInt(!0),d=e.pathConstraints[c];for(let u=0,m=t.readInt(!0);u<m;u++)switch(t.readByte()){case Do:r.push(yn(t,new dr(t.readInt(!0),t.readInt(!0),c),d.positionMode==dt.Fixed?i:1));break;case _o:r.push(yn(t,new fr(t.readInt(!0),t.readInt(!0),c),d.spacingMode==Ot.Length||d.spacingMode==Ot.Fixed?i:1));break;case Lo:const g=new ur(t.readInt(!0),t.readInt(!0),c);let x=t.readFloat(),w=t.readFloat(),b=t.readFloat(),E=t.readFloat();for(let p=0,S=0,y=g.getFrameCount()-1;g.setFrame(p,x,w,b,E),p!=y;p++){const M=t.readFloat(),C=t.readFloat(),I=t.readFloat(),R=t.readFloat();switch(t.readByte()){case nn:g.setStepped(p);break;case sn:it(t,g,S++,p,0,x,M,w,C,1),it(t,g,S++,p,1,x,M,b,I,1),it(t,g,S++,p,2,x,M,E,R,1)}x=M,w=C,b=I,E=R}r.push(g)}}for(let a=0,o=t.readInt(!0);a<o;a++){const c=e.skins[t.readInt(!0)];for(let d=0,u=t.readInt(!0);d<u;d++){const m=t.readInt(!0);for(let g=0,x=t.readInt(!0);g<x;g++){const w=t.readStringRef();if(!w)throw new Error("attachmentName must not be null.");const b=c.getAttachment(m,w),E=this.readDeformTimelineType(t),p=t.readInt(!0),S=p-1;switch(E){case Ba:{const y=b,M=y.bones,C=y.vertices,I=M?C.length/3*2:C.length,R=t.readInt(!0),v=new lr(p,R,m,y);let V=t.readFloat();for(let P=0,D=0;;P++){let F,B=t.readInt(!0);if(B==0)F=M?k.newFloatArray(I):C;else{F=k.newFloatArray(I);const U=t.readInt(!0);if(B+=U,i==1)for(let X=U;X<B;X++)F[X]=t.readFloat();else for(let X=U;X<B;X++)F[X]=t.readFloat()*i;if(!M)for(let X=0,N=F.length;X<N;X++)F[X]+=C[X]}if(v.setFrame(P,V,F),P==S)break;const H=t.readFloat();switch(t.readByte()){case nn:v.setStepped(P);break;case sn:it(t,v,D++,P,0,V,H,0,1,1)}V=H}r.push(v);break}case Bo:{const y=new os(p,m,b);for(let M=0;M<p;M++){const C=t.readFloat(),I=t.readInt32();y.setFrame(M,C,zi[I&15],I>>4,t.readFloat())}r.push(y);break}}}}}const h=t.readInt(!0);if(h>0){const a=new Un(h),o=e.slots.length;for(let c=0;c<h;c++){const d=t.readFloat(),u=t.readInt(!0),m=k.newArray(o,0);for(let b=o-1;b>=0;b--)m[b]=-1;const g=k.newArray(o-u,0);let x=0,w=0;for(let b=0;b<u;b++){const E=t.readInt(!0);for(;x!=E;)g[w++]=x++;m[x+t.readInt(!0)]=x++}for(;x<o;)g[w++]=x++;for(let b=o-1;b>=0;b--)m[b]==-1&&(m[b]=g[--w]);a.setFrame(c,d,m)}r.push(a)}const l=t.readInt(!0);if(l>0){const a=new xs(l);for(let o=0;o<l;o++){const c=t.readFloat(),d=e.events[t.readInt(!0)],u=new br(c,d);u.intValue=t.readInt(!1),u.floatValue=t.readFloat(),u.stringValue=t.readBoolean()?t.readString():d.stringValue,u.data.audioPath&&(u.volume=t.readFloat(),u.balance=t.readFloat()),a.setFrame(o,u)}r.push(a)}let s=0;for(let a=0,o=r.length;a<o;a++)s=Math.max(s,r[a].getDuration());return new Ds(n,r,s)}}Rr.BlendModeValues=[G.BLEND_MODES.NORMAL,G.BLEND_MODES.ADD,G.BLEND_MODES.MULTIPLY,G.BLEND_MODES.SCREEN];let bo=class{constructor(t,n,e,r,i){this.mesh=t,this.skin=n,this.slotIndex=e,this.parent=r,this.inheritTimeline=i}};class Eo{constructor(t=null,n=null){this.bones=t,this.vertices=n}}function yn(f,t,n){let e=f.readFloat(),r=f.readFloat()*n;for(let i=0,h=0,l=t.getFrameCount()-1;t.setFrame(i,e,r),i!=l;i++){const s=f.readFloat(),a=f.readFloat()*n;switch(f.readByte()){case nn:t.setStepped(i);break;case sn:it(f,t,h++,i,0,e,s,r,a,n)}e=s,r=a}return t}function kr(f,t,n){let e=f.readFloat(),r=f.readFloat()*n,i=f.readFloat()*n;for(let h=0,l=0,s=t.getFrameCount()-1;t.setFrame(h,e,r,i),h!=s;h++){const a=f.readFloat(),o=f.readFloat()*n,c=f.readFloat()*n;switch(f.readByte()){case nn:t.setStepped(h);break;case sn:it(f,t,l++,h,0,e,a,r,o,n),it(f,t,l++,h,1,e,a,i,c,n)}e=a,r=o,i=c}return t}function it(f,t,n,e,r,i,h,l,s,a){t.setBezier(n,e,r,i,l,f.readFloat(),f.readFloat()*a,f.readFloat(),f.readFloat()*a,h,s)}const So=0,yo=1,Mo=2,Ao=3,To=4,Co=5,Io=6,Ro=7,ko=8,vo=9,Vo=0,Po=1,Fo=2,Yo=3,No=4,Xo=5,Ba=0,Bo=1,Do=0,_o=1,Lo=2,nn=1,sn=2;let Da=class extends Qn{},vr=class{constructor(t){this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=t}readSkeletonData(t){const n=this.scale,e=new Ar,r=typeof t=="string"?JSON.parse(t):t,i=r.skeleton;if(i){e.hash=i.hash,e.version=i.spine;const h=e.version.substr(0,3);if(h!=="4.0"&&h!=="4.1"){const l=`Spine 4.1 loader cant load version ${i.spine}. Please configure your pixi-spine bundle`;console.error(l)}e.x=i.x,e.y=i.y,e.width=i.width,e.height=i.height,e.fps=i.fps,e.imagesPath=i.images}if(r.bones)for(let h=0;h<r.bones.length;h++){const l=r.bones[h];let s=null;const a=Y(l,"parent",null);if(a!=null&&(s=e.findBone(a),s==null))throw new Error(`Parent bone not found: ${a}`);const o=new wr(e.bones.length,l.name,s);o.length=Y(l,"length",0)*n,o.x=Y(l,"x",0)*n,o.y=Y(l,"y",0)*n,o.rotation=Y(l,"rotation",0),o.scaleX=Y(l,"scaleX",1),o.scaleY=Y(l,"scaleY",1),o.shearX=Y(l,"shearX",0),o.shearY=Y(l,"shearY",0),o.transformMode=k.enumValue(z,Y(l,"transform","Normal")),o.skinRequired=Y(l,"skin",!1);const c=Y(l,"color",null);c&&o.color.setFromString(c),e.bones.push(o)}if(r.slots)for(let h=0;h<r.slots.length;h++){const l=r.slots[h],s=e.findBone(l.bone);if(!s)throw new Error(`Couldn't find bone ${l.bone} for slot ${l.name}`);const a=new Tr(e.slots.length,l.name,s),o=Y(l,"color",null);o&&a.color.setFromString(o);const c=Y(l,"dark",null);c&&(a.darkColor=O.fromString(c)),a.attachmentName=Y(l,"attachment",null),a.blendMode=vr.blendModeFromString(Y(l,"blend","normal")),e.slots.push(a)}if(r.ik)for(let h=0;h<r.ik.length;h++){const l=r.ik[h],s=new Sr(l.name);s.order=Y(l,"order",0),s.skinRequired=Y(l,"skin",!1);for(let a=0;a<l.bones.length;a++){const o=l.bones[a],c=e.findBone(o);if(c==null)throw new Error(`IK bone not found: ${o}`);s.bones.push(c)}s.target=e.findBone(l.target),s.mix=Y(l,"mix",1),s.softness=Y(l,"softness",0)*n,s.bendDirection=Y(l,"bendPositive",!0)?1:-1,s.compress=Y(l,"compress",!1),s.stretch=Y(l,"stretch",!1),s.uniform=Y(l,"uniform",!1),e.ikConstraints.push(s)}if(r.transform)for(let h=0;h<r.transform.length;h++){const l=r.transform[h],s=new Cr(l.name);s.order=Y(l,"order",0),s.skinRequired=Y(l,"skin",!1);for(let c=0;c<l.bones.length;c++){const d=l.bones[c],u=e.findBone(d);if(!u)throw new Error(`Couldn't find bone ${d} for transform constraint ${l.name}.`);s.bones.push(u)}const a=l.target,o=e.findBone(a);if(!o)throw new Error(`Couldn't find target bone ${a} for transform constraint ${l.name}.`);s.target=o,s.local=Y(l,"local",!1),s.relative=Y(l,"relative",!1),s.offsetRotation=Y(l,"rotation",0),s.offsetX=Y(l,"x",0)*n,s.offsetY=Y(l,"y",0)*n,s.offsetScaleX=Y(l,"scaleX",0),s.offsetScaleY=Y(l,"scaleY",0),s.offsetShearY=Y(l,"shearY",0),s.mixRotate=Y(l,"mixRotate",1),s.mixX=Y(l,"mixX",1),s.mixY=Y(l,"mixY",s.mixX),s.mixScaleX=Y(l,"mixScaleX",1),s.mixScaleY=Y(l,"mixScaleY",s.mixScaleX),s.mixShearY=Y(l,"mixShearY",1),e.transformConstraints.push(s)}if(r.path)for(let h=0;h<r.path.length;h++){const l=r.path[h],s=new yr(l.name);s.order=Y(l,"order",0),s.skinRequired=Y(l,"skin",!1);for(let c=0;c<l.bones.length;c++){const d=l.bones[c],u=e.findBone(d);if(!u)throw new Error(`Couldn't find bone ${d} for path constraint ${l.name}.`);s.bones.push(u)}const a=l.target,o=e.findSlot(a);if(!o)throw new Error(`Couldn't find target slot ${a} for path constraint ${l.name}.`);s.target=o,s.positionMode=k.enumValue(dt,Y(l,"positionMode","Percent")),s.spacingMode=k.enumValue(Ot,Y(l,"spacingMode","Length")),s.rotateMode=k.enumValue(ut,Y(l,"rotateMode","Tangent")),s.offsetRotation=Y(l,"rotation",0),s.position=Y(l,"position",0),s.positionMode==dt.Fixed&&(s.position*=n),s.spacing=Y(l,"spacing",0),(s.spacingMode==Ot.Length||s.spacingMode==Ot.Fixed)&&(s.spacing*=n),s.mixRotate=Y(l,"mixRotate",1),s.mixX=Y(l,"mixX",1),s.mixY=Y(l,"mixY",s.mixX),e.pathConstraints.push(s)}if(r.skins)for(let h=0;h<r.skins.length;h++){const l=r.skins[h],s=new $s(l.name);if(l.bones)for(let a=0;a<l.bones.length;a++){const o=l.bones[a],c=e.findBone(o);if(!c)throw new Error(`Couldn't find bone ${o} for skin ${l.name}.`);s.bones.push(c)}if(l.ik)for(let a=0;a<l.ik.length;a++){const o=l.ik[a],c=e.findIkConstraint(o);if(!c)throw new Error(`Couldn't find IK constraint ${o} for skin ${l.name}.`);s.constraints.push(c)}if(l.transform)for(let a=0;a<l.transform.length;a++){const o=l.transform[a],c=e.findTransformConstraint(o);if(!c)throw new Error(`Couldn't find transform constraint ${o} for skin ${l.name}.`);s.constraints.push(c)}if(l.path)for(let a=0;a<l.path.length;a++){const o=l.path[a],c=e.findPathConstraint(o);if(!c)throw new Error(`Couldn't find path constraint ${o} for skin ${l.name}.`);s.constraints.push(c)}for(const a in l.attachments){const o=e.findSlot(a);if(!o)throw new Error(`Couldn't find slot ${a} for skin ${l.name}.`);const c=l.attachments[a];for(const d in c){const u=this.readAttachment(c[d],s,o.index,d,e);u&&s.setAttachment(o.index,d,u)}}e.skins.push(s),s.name=="default"&&(e.defaultSkin=s)}for(let h=0,l=this.linkedMeshes.length;h<l;h++){const s=this.linkedMeshes[h],a=s.skin?e.findSkin(s.skin):e.defaultSkin;if(!a)throw new Error(`Skin not found: ${s.skin}`);const o=a.getAttachment(s.slotIndex,s.parent);if(!o)throw new Error(`Parent mesh not found: ${s.parent}`);s.mesh.timelineAttachment=s.inheritTimeline?o:s.mesh,s.mesh.setParentMesh(o)}if(this.linkedMeshes.length=0,r.events)for(const h in r.events){const l=r.events[h],s=new Er(h);s.intValue=Y(l,"int",0),s.floatValue=Y(l,"float",0),s.stringValue=Y(l,"string",""),s.audioPath=Y(l,"audio",null),s.audioPath&&(s.volume=Y(l,"volume",1),s.balance=Y(l,"balance",0)),e.events.push(s)}if(r.animations)for(const h in r.animations){const l=r.animations[h];this.readAnimation(l,h,e)}return e}readAttachment(t,n,e,r,i){const h=this.scale;switch(r=Y(t,"name",r),Y(t,"type","region")){case"region":{const l=Y(t,"path",r),s=this.readSequence(Y(t,"sequence",null)),a=this.attachmentLoader.newRegionAttachment(n,r,l,s);if(!a)return null;a.path=l,a.x=Y(t,"x",0)*h,a.y=Y(t,"y",0)*h,a.scaleX=Y(t,"scaleX",1),a.scaleY=Y(t,"scaleY",1),a.rotation=Y(t,"rotation",0),a.width=t.width*h,a.height=t.height*h,a.sequence=s;const o=Y(t,"color",null);return o&&a.color.setFromString(o),a}case"boundingbox":{const l=this.attachmentLoader.newBoundingBoxAttachment(n,r);if(!l)return null;this.readVertices(t,l,t.vertexCount<<1);const s=Y(t,"color",null);return s&&l.color.setFromString(s),l}case"mesh":case"linkedmesh":{const l=Y(t,"path",r),s=this.readSequence(Y(t,"sequence",null)),a=this.attachmentLoader.newMeshAttachment(n,r,l,s);if(!a)return null;a.path=l;const o=Y(t,"color",null);o&&a.color.setFromString(o),a.width=Y(t,"width",0)*h,a.height=Y(t,"height",0)*h,a.sequence=s;const c=Y(t,"parent",null);if(c)return this.linkedMeshes.push(new Oo(a,Y(t,"skin",null),e,c,Y(t,"timelines",!0))),a;const d=t.uvs;return this.readVertices(t,a,d.length),a.triangles=t.triangles,a.regionUVs=new Float32Array(d),a.edges=Y(t,"edges",null),a.hullLength=Y(t,"hull",0)*2,a}case"path":{const l=this.attachmentLoader.newPathAttachment(n,r);if(!l)return null;l.closed=Y(t,"closed",!1),l.constantSpeed=Y(t,"constantSpeed",!0);const s=t.vertexCount;this.readVertices(t,l,s<<1);const a=k.newArray(s/3,0);for(let c=0;c<t.lengths.length;c++)a[c]=t.lengths[c]*h;l.lengths=a;const o=Y(t,"color",null);return o&&l.color.setFromString(o),l}case"point":{const l=this.attachmentLoader.newPointAttachment(n,r);if(!l)return null;l.x=Y(t,"x",0)*h,l.y=Y(t,"y",0)*h,l.rotation=Y(t,"rotation",0);const s=Y(t,"color",null);return s&&l.color.setFromString(s),l}case"clipping":{const l=this.attachmentLoader.newClippingAttachment(n,r);if(!l)return null;const s=Y(t,"end",null);if(s!=null){const c=i.findSlot(s);if(c==null)throw new Error(`Clipping end slot not found: ${s}`);l.endSlot=c}const a=t.vertexCount;this.readVertices(t,l,a<<1);const o=Y(t,"color",null);return o&&l.color.setFromString(o),l}}return null}readSequence(t){if(t==null)return null;const n=new Bs(Y(t,"count",0));return n.start=Y(t,"start",1),n.digits=Y(t,"digits",0),n.setupIndex=Y(t,"setup",0),n}readVertices(t,n,e){const r=this.scale;n.worldVerticesLength=e;const i=t.vertices;if(e==i.length){const s=k.toFloatArray(i);if(r!=1)for(let a=0,o=i.length;a<o;a++)s[a]*=r;n.vertices=s;return}const h=new Array,l=new Array;for(let s=0,a=i.length;s<a;){const o=i[s++];l.push(o);for(let c=s+o*4;s<c;s+=4)l.push(i[s]),h.push(i[s+1]*r),h.push(i[s+2]*r),h.push(i[s+3])}n.bones=l,n.vertices=k.toFloatArray(h)}readAnimation(t,n,e){const r=this.scale,i=new Array;if(t.slots)for(const l in t.slots){const s=t.slots[l],a=e.findSlot(l);if(!a)throw new Error(`Slot not found: ${l}`);const o=a.index;for(const c in s){const d=s[c];if(!d)continue;const u=d.length;if(c=="attachment"){const m=new qn(u,o);for(let g=0;g<u;g++){const x=d[g];m.setFrame(g,Y(x,"time",0),Y(x,"name",null))}i.push(m)}else if(c=="rgba"){const m=new sr(u,u<<2,o);let g=d[0],x=Y(g,"time",0),w=O.fromString(g.color);for(let b=0,E=0;;b++){m.setFrame(b,x,w.r,w.g,w.b,w.a);const p=d[b+1];if(!p){m.shrink(E);break}const S=Y(p,"time",0),y=O.fromString(p.color),M=g.curve;M&&(E=ct(M,m,E,b,0,x,S,w.r,y.r,1),E=ct(M,m,E,b,1,x,S,w.g,y.g,1),E=ct(M,m,E,b,2,x,S,w.b,y.b,1),E=ct(M,m,E,b,3,x,S,w.a,y.a,1)),x=S,w=y,g=p}i.push(m)}else if(c=="rgb"){const m=new ir(u,u*3,o);let g=d[0],x=Y(g,"time",0),w=O.fromString(g.color);for(let b=0,E=0;;b++){m.setFrame(b,x,w.r,w.g,w.b);const p=d[b+1];if(!p){m.shrink(E);break}const S=Y(p,"time",0),y=O.fromString(p.color),M=g.curve;M&&(E=ct(M,m,E,b,0,x,S,w.r,y.r,1),E=ct(M,m,E,b,1,x,S,w.g,y.g,1),E=ct(M,m,E,b,2,x,S,w.b,y.b,1)),x=S,w=y,g=p}i.push(m)}else if(c=="alpha")i.push(un(d,new rr(u,u,o),0,1));else if(c=="rgba2"){const m=new ar(u,u*7,o);let g=d[0],x=Y(g,"time",0),w=O.fromString(g.light),b=O.fromString(g.dark);for(let E=0,p=0;;E++){m.setFrame(E,x,w.r,w.g,w.b,w.a,b.r,b.g,b.b);const S=d[E+1];if(!S){m.shrink(p);break}const y=Y(S,"time",0),M=O.fromString(S.light),C=O.fromString(S.dark),I=g.curve;I&&(p=ct(I,m,p,E,0,x,y,w.r,M.r,1),p=ct(I,m,p,E,1,x,y,w.g,M.g,1),p=ct(I,m,p,E,2,x,y,w.b,M.b,1),p=ct(I,m,p,E,3,x,y,w.a,M.a,1),p=ct(I,m,p,E,4,x,y,b.r,C.r,1),p=ct(I,m,p,E,5,x,y,b.g,C.g,1),p=ct(I,m,p,E,6,x,y,b.b,C.b,1)),x=y,w=M,b=C,g=S}i.push(m)}else if(c=="rgb2"){const m=new or(u,u*6,o);let g=d[0],x=Y(g,"time",0),w=O.fromString(g.light),b=O.fromString(g.dark);for(let E=0,p=0;;E++){m.setFrame(E,x,w.r,w.g,w.b,b.r,b.g,b.b);const S=d[E+1];if(!S){m.shrink(p);break}const y=Y(S,"time",0),M=O.fromString(S.light),C=O.fromString(S.dark),I=g.curve;I&&(p=ct(I,m,p,E,0,x,y,w.r,M.r,1),p=ct(I,m,p,E,1,x,y,w.g,M.g,1),p=ct(I,m,p,E,2,x,y,w.b,M.b,1),p=ct(I,m,p,E,3,x,y,b.r,C.r,1),p=ct(I,m,p,E,4,x,y,b.g,C.g,1),p=ct(I,m,p,E,5,x,y,b.b,C.b,1)),x=y,w=M,b=C,g=S}i.push(m)}}}if(t.bones)for(const l in t.bones){const s=t.bones[l],a=e.findBone(l);if(!a)throw new Error(`Bone not found: ${l}`);const o=a.index;for(const c in s){const d=s[c],u=d.length;if(u!=0){if(c==="rotate")i.push(un(d,new gs(u,u,o),0,1));else if(c==="translate"){const m=new Gi(u,u<<1,o);i.push(Vr(d,m,"x","y",0,r))}else if(c==="translatex"){const m=new ji(u,u,o);i.push(un(d,m,0,r))}else if(c==="translatey"){const m=new Zi(u,u,o);i.push(un(d,m,0,r))}else if(c==="scale"){const m=new Qi(u,u<<1,o);i.push(Vr(d,m,"x","y",1,1))}else if(c==="scalex"){const m=new Ki(u,u,o);i.push(un(d,m,1,1))}else if(c==="scaley"){const m=new Ji(u,u,o);i.push(un(d,m,1,1))}else if(c==="shear"){const m=new tr(u,u<<1,o);i.push(Vr(d,m,"x","y",0,1))}else if(c==="shearx"){const m=new er(u,u,o);i.push(un(d,m,0,1))}else if(c==="sheary"){const m=new nr(u,u,o);i.push(un(d,m,0,1))}}}}if(t.ik)for(const l in t.ik){const s=t.ik[l];let a=s[0];if(!a)continue;const o=e.findIkConstraint(l);if(!o)throw new Error(`IK Constraint not found: ${l}`);const c=e.ikConstraints.indexOf(o),d=new cr(s.length,s.length<<1,c);let u=Y(a,"time",0),m=Y(a,"mix",1),g=Y(a,"softness",0)*r;for(let x=0,w=0;;x++){d.setFrame(x,u,m,g,Y(a,"bendPositive",!0)?1:-1,Y(a,"compress",!1),Y(a,"stretch",!1));const b=s[x+1];if(!b){d.shrink(w);break}const E=Y(b,"time",0),p=Y(b,"mix",1),S=Y(b,"softness",0)*r,y=a.curve;y&&(w=ct(y,d,w,x,0,u,E,m,p,1),w=ct(y,d,w,x,1,u,E,g,S,r)),u=E,m=p,g=S,a=b}i.push(d)}if(t.transform)for(const l in t.transform){const s=t.transform[l];let a=s[0];if(!a)continue;const o=e.findTransformConstraint(l);if(!o)throw new Error(`Transform constraint not found: ${l}`);const c=e.transformConstraints.indexOf(o),d=new hr(s.length,s.length*6,c);let u=Y(a,"time",0),m=Y(a,"mixRotate",1),g=Y(a,"mixX",1),x=Y(a,"mixY",g),w=Y(a,"mixScaleX",1),b=Y(a,"mixScaleY",w);const E=Y(a,"mixShearY",1);for(let p=0,S=0;;p++){d.setFrame(p,u,m,g,x,w,b,E);const y=s[p+1];if(!y){d.shrink(S);break}const M=Y(y,"time",0),C=Y(y,"mixRotate",1),I=Y(y,"mixX",1),R=Y(y,"mixY",I),v=Y(y,"mixScaleX",1),V=Y(y,"mixScaleY",v),P=Y(y,"mixShearY",1),D=a.curve;D&&(S=ct(D,d,S,p,0,u,M,m,C,1),S=ct(D,d,S,p,1,u,M,g,I,1),S=ct(D,d,S,p,2,u,M,x,R,1),S=ct(D,d,S,p,3,u,M,w,v,1),S=ct(D,d,S,p,4,u,M,b,V,1),S=ct(D,d,S,p,5,u,M,E,P,1)),u=M,m=C,g=I,x=R,w=v,b=V,w=v,a=y}i.push(d)}if(t.path)for(const l in t.path){const s=t.path[l],a=e.findPathConstraint(l);if(!a)throw new Error(`Path constraint not found: ${l}`);const o=e.pathConstraints.indexOf(a);for(const c in s){const d=s[c];let u=d[0];if(!u)continue;const m=d.length;if(c==="position"){const g=new dr(m,m,o);i.push(un(d,g,0,a.positionMode==dt.Fixed?r:1))}else if(c==="spacing"){const g=new fr(m,m,o);i.push(un(d,g,0,a.spacingMode==Ot.Length||a.spacingMode==Ot.Fixed?r:1))}else if(c==="mix"){const g=new ur(m,m*3,o);let x=Y(u,"time",0),w=Y(u,"mixRotate",1),b=Y(u,"mixX",1),E=Y(u,"mixY",b);for(let p=0,S=0;;p++){g.setFrame(p,x,w,b,E);const y=d[p+1];if(!y){g.shrink(S);break}const M=Y(y,"time",0),C=Y(y,"mixRotate",1),I=Y(y,"mixX",1),R=Y(y,"mixY",I),v=u.curve;v&&(S=ct(v,g,S,p,0,x,M,w,C,1),S=ct(v,g,S,p,1,x,M,b,I,1),S=ct(v,g,S,p,2,x,M,E,R,1)),x=M,w=C,b=I,E=R,u=y}i.push(g)}}}if(t.deform){t.attachments={};for(const l in t.deform){const s=t.deform[l],a=t.attachments[l]={};for(const o in s){const c=s[o],d=a[o]={};for(const u in c)d[u]={deform:c[u]}}}}if(t.attachments)for(const l in t.attachments){const s=t.attachments[l],a=e.findSkin(l);if(a==null){if(jt.FAIL_ON_NON_EXISTING_SKIN)throw new Error(`Skin not found: ${l}`);continue}for(const o in s){const c=s[o],d=e.findSlot(o);if(!d)throw new Error(`Slot not found: ${o}`);const u=d.index;for(const m in c){const g=c[m],x=a.getAttachment(u,m);for(const w in g){const b=g[w];let E=b[0];if(E){if(w=="deform"){const p=x.bones,S=x.vertices,y=p?S.length/3*2:S.length,M=new lr(b.length,b.length,u,x);let C=Y(E,"time",0);for(let I=0,R=0;;I++){let v;const V=Y(E,"vertices",null);if(!V)v=p?k.newFloatArray(y):S;else{v=k.newFloatArray(y);const B=Y(E,"offset",0);if(k.arrayCopy(V,0,v,B,V.length),r!=1)for(let H=B,U=H+V.length;H<U;H++)v[H]*=r;if(!p)for(let H=0;H<y;H++)v[H]+=S[H]}M.setFrame(I,C,v);const P=b[I+1];if(!P){M.shrink(R);break}const D=Y(P,"time",0),F=E.curve;F&&(R=ct(F,M,R,I,0,C,D,0,1,1)),C=D,E=P}i.push(M)}else if(w=="sequence"){const p=new os(b.length,u,x);let S=0;for(let y=0;y<b.length;y++){const M=Y(E,"delay",S),C=Y(E,"time",0),I=dn[Y(E,"mode","hold")],R=Y(E,"index",0);p.setFrame(y,C,I,R,M),S=M,E=b[y+1]}i.push(p)}}}}}}if(t.drawOrder){const l=new Un(t.drawOrder.length),s=e.slots.length;let a=0;for(let o=0;o<t.drawOrder.length;o++,a++){const c=t.drawOrder[o];let d=null;const u=Y(c,"offsets",null);if(u){d=k.newArray(s,-1);const m=k.newArray(s-u.length,0);let g=0,x=0;for(let w=0;w<u.length;w++){const b=u[w],E=e.findSlot(b.slot);if(!E)throw new Error(`Slot not found: ${E}`);const p=E.index;for(;g!=p;)m[x++]=g++;d[g+b.offset]=g++}for(;g<s;)m[x++]=g++;for(let w=s-1;w>=0;w--)d[w]==-1&&(d[w]=m[--x])}l.setFrame(a,Y(c,"time",0),d)}i.push(l)}if(t.events){const l=new xs(t.events.length);let s=0;for(let a=0;a<t.events.length;a++,s++){const o=t.events[a],c=e.findEvent(o.name);if(!c)throw new Error(`Event not found: ${o.name}`);const d=new br(k.toSinglePrecision(Y(o,"time",0)),c);d.intValue=Y(o,"int",c.intValue),d.floatValue=Y(o,"float",c.floatValue),d.stringValue=Y(o,"string",c.stringValue),d.data.audioPath&&(d.volume=Y(o,"volume",1),d.balance=Y(o,"balance",0)),l.setFrame(s,d)}i.push(l)}let h=0;for(let l=0,s=i.length;l<s;l++)h=Math.max(h,i[l].getDuration());if(isNaN(h))throw new Error("Error while parsing animation, duration is NaN");e.animations.push(new Ds(n,i,h))}static blendModeFromString(t){if(t=t.toLowerCase(),t=="normal")return G.BLEND_MODES.NORMAL;if(t=="additive")return G.BLEND_MODES.ADD;if(t=="multiply")return G.BLEND_MODES.MULTIPLY;if(t=="screen")return G.BLEND_MODES.SCREEN;throw new Error(`Unknown blend mode: ${t}`)}},Oo=class{constructor(t,n,e,r,i){this.mesh=t,this.skin=n,this.slotIndex=e,this.parent=r,this.inheritTimeline=i}};function un(f,t,n,e){let r=f[0],i=Y(r,"time",0),h=Y(r,"value",n)*e,l=0;for(let s=0;;s++){t.setFrame(s,i,h);const a=f[s+1];if(!a)return t.shrink(l),t;const o=Y(a,"time",0),c=Y(a,"value",n)*e;r.curve&&(l=ct(r.curve,t,l,s,0,i,o,h,c,e)),i=o,h=c,r=a}}function Vr(f,t,n,e,r,i){let h=f[0],l=Y(h,"time",0),s=Y(h,n,r)*i,a=Y(h,e,r)*i,o=0;for(let c=0;;c++){t.setFrame(c,l,s,a);const d=f[c+1];if(!d)return t.shrink(o),t;const u=Y(d,"time",0),m=Y(d,n,r)*i,g=Y(d,e,r)*i,x=h.curve;x&&(o=ct(x,t,o,c,0,l,u,s,m,i),o=ct(x,t,o,c,1,l,u,a,g,i)),l=u,s=m,a=g,h=d}}function ct(f,t,n,e,r,i,h,l,s,a){if(f=="stepped")return t.setStepped(e),n;const o=r<<2,c=f[o],d=f[o+1]*a,u=f[o+2],m=f[o+3]*a;return t.setBezier(n,e,r,i,l,c,d,u,m,h,s),n+1}function Y(f,t,n){return f[t]!==void 0?f[t]:n}var $o=Object.freeze({__proto__:null,AlphaTimeline:rr,Animation:Ds,AnimationState:ls,AnimationStateAdapter:xo,AnimationStateData:Fa,AtlasAttachmentLoader:xr,Attachment:Hi,AttachmentTimeline:qn,Bone:pr,BoneData:wr,BoundingBoxAttachment:Fs,ClippingAttachment:Ys,ConstraintData:Os,CurveTimeline:tn,CurveTimeline1:en,CurveTimeline2:_s,DeformTimeline:lr,DrawOrderTimeline:Un,Event:br,EventData:Er,EventQueue:ka,EventTimeline:xs,EventType:Ae,IkConstraint:Ya,IkConstraintData:Sr,IkConstraintTimeline:cr,MeshAttachment:$n,PathAttachment:Wn,PathConstraint:cs,PathConstraintData:yr,PathConstraintMixTimeline:ur,PathConstraintPositionTimeline:dr,PathConstraintSpacingTimeline:fr,PointAttachment:Ns,RGB2Timeline:or,RGBA2Timeline:ar,RGBATimeline:sr,RGBTimeline:ir,RegionAttachment:lt,RotateTimeline:gs,ScaleTimeline:Qi,ScaleXTimeline:Ki,ScaleYTimeline:Ji,Sequence:Bs,SequenceMode:dn,SequenceModeValues:zi,SequenceTimeline:os,ShearTimeline:tr,ShearXTimeline:er,ShearYTimeline:nr,Skeleton:Mr,SkeletonBinary:Rr,SkeletonBounds:Da,SkeletonData:Ar,SkeletonJson:vr,Skin:$s,SkinEntry:Ir,Slot:Na,SlotData:Tr,SpacingMode:Ot,Spine:class extends An{createSkeleton(t){this.skeleton=new Mr(t),this.skeleton.updateWorldTransform(),this.stateData=new Fa(t),this.state=new ls(this.stateData)}},Timeline:Ct,TrackEntry:Ls,TransformConstraint:Xa,TransformConstraintData:Cr,TransformConstraintTimeline:hr,TranslateTimeline:Gi,TranslateXTimeline:ji,TranslateYTimeline:Zi,VertexAttachment:Je}),Te=(f=>(f[f.UNKNOWN=0]="UNKNOWN",f[f.VER34=34]="VER34",f[f.VER37=37]="VER37",f[f.VER38=38]="VER38",f[f.VER40=40]="VER40",f[f.VER41=41]="VER41",f))(Te||{});function Ws(f){const t=f.substr(0,3),n=Math.floor(Number(t)*10+.001);return t==="3.3"||t==="3.4"?34:t==="3.7"?37:t==="3.8"?38:t==="4.0"?40:t==="4.1"?41:n<37?37:0}class Wo{constructor(){this.scale=1}readSkeletonData(t,n){let e=null,r=this.readVersionOldFormat(n),i=Ws(r);if(i===Te.VER34&&(e=new vt(new zr(t))),i===Te.VER38&&(e=new Yt(new Ti(t))),r=this.readVersionNewFormat(n),i=Ws(r),(i===Te.VER40||i===Te.VER41)&&(e=new Rr(new xr(t))),!e){const h=`Unsupported version of spine model ${r}, please update pixi-spine`;console.error(h)}return e.scale=this.scale,e.readSkeletonData(n)}readVersionOldFormat(t){const n=new Gn(t);let e;try{n.readString(),e=n.readString()}catch(r){e=""}return e||""}readVersionNewFormat(t){const n=new Gn(t);n.readInt32(),n.readInt32();let e;try{e=n.readString()}catch(r){e=""}return e||""}}class qo{constructor(){this.scale=1}readSkeletonData(t,n){const e=n.skeleton.spine,r=Ws(e);let i=null;if(r===Te.VER37&&(i=new On(new ua(t))),r===Te.VER38&&(i=new _n(new Ti(t))),(r===Te.VER40||r===Te.VER41)&&(i=new vr(new xr(t))),!i){const h=`Unsupported version of spine model ${e}, please update pixi-spine`;console.error(h)}return i.scale=this.scale,i.readSkeletonData(n)}}class Uo extends Ka{createBinaryParser(){return new Wo}createJsonParser(){return new qo}parseData(t,n,e){return{spineData:t.readSkeletonData(n,e),spineAtlas:n}}}class Ho{constructor(t,n){this.jitterX=0,this.jitterY=0,this.jitterX=t,this.jitterY=n}begin(t){}transform(t,n,e,r){t.x+=T.randomTriangular(-this.jitterX,this.jitterY),t.y+=T.randomTriangular(-this.jitterX,this.jitterY)}end(){}}class zo extends Qn{}class Hn{constructor(t){this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=t}readSkeletonData(t){const n=this.scale,e=new li,r=typeof t=="string"?JSON.parse(t):t,i=r.skeleton;if(i!=null){if(e.hash=i.hash,e.version=i.spine,e.version.substr(0,3)!=="3.4"){const h=`Spine 3.4 loader cant load version ${i.spine}. Please configure your pixi-spine bundle`;console.error(h)}e.version==="3.4.75"&&console.error("Unsupported skeleton data, 3.4.75 is deprecated, please export with a newer version of Spine."),e.x=i.x,e.y=i.y,e.width=i.width,e.height=i.height,e.fps=i.fps,e.imagesPath=i.images}if(r.bones)for(let h=0;h<r.bones.length;h++){const l=r.bones[h];let s=null;const a=this.getValue(l,"parent",null);if(a!=null&&(s=e.findBone(a),s==null))throw new Error(`Parent bone not found: ${a}`);const o=new hi(e.bones.length,l.name,s);o.length=this.getValue(l,"length",0)*n,o.x=this.getValue(l,"x",0)*n,o.y=this.getValue(l,"y",0)*n,o.rotation=this.getValue(l,"rotation",0),o.scaleX=this.getValue(l,"scaleX",1),o.scaleY=this.getValue(l,"scaleY",1),o.shearX=this.getValue(l,"shearX",0),o.shearY=this.getValue(l,"shearY",0),o.transformMode=Hn.transformModeFromString(this.getValue(l,"transform","normal")),o.skinRequired=this.getValue(l,"skin",!1),e.bones.push(o)}if(r.slots)for(let h=0;h<r.slots.length;h++){const l=r.slots[h],s=l.name,a=l.bone,o=e.findBone(a);if(o==null)throw new Error(`Slot bone not found: ${a}`);const c=new ci(e.slots.length,s,o),d=this.getValue(l,"color",null);d!=null&&c.color.setFromString(d);const u=this.getValue(l,"dark",null);u!=null&&(c.darkColor=new O(1,1,1,1),c.darkColor.setFromString(u)),c.attachmentName=this.getValue(l,"attachment",null),c.blendMode=Hn.blendModeFromString(this.getValue(l,"blend","normal")),e.slots.push(c)}if(r.ik)for(let h=0;h<r.ik.length;h++){const l=r.ik[h],s=new di(l.name);s.order=this.getValue(l,"order",0),s.skinRequired=this.getValue(l,"skin",!1);for(let o=0;o<l.bones.length;o++){const c=l.bones[o],d=e.findBone(c);if(d==null)throw new Error(`IK bone not found: ${c}`);s.bones.push(d)}const a=l.target;if(s.target=e.findBone(a),s.target==null)throw new Error(`IK target bone not found: ${a}`);s.mix=this.getValue(l,"mix",1),s.softness=this.getValue(l,"softness",0)*n,s.bendDirection=this.getValue(l,"bendPositive",!0)?1:-1,s.compress=this.getValue(l,"compress",!1),s.stretch=this.getValue(l,"stretch",!1),s.uniform=this.getValue(l,"uniform",!1),e.ikConstraints.push(s)}if(r.transform)for(let h=0;h<r.transform.length;h++){const l=r.transform[h],s=new fi(l.name);s.order=this.getValue(l,"order",0),s.skinRequired=this.getValue(l,"skin",!1);for(let o=0;o<l.bones.length;o++){const c=l.bones[o],d=e.findBone(c);if(d==null)throw new Error(`Transform constraint bone not found: ${c}`);s.bones.push(d)}const a=l.target;if(s.target=e.findBone(a),s.target==null)throw new Error(`Transform constraint target bone not found: ${a}`);s.local=this.getValue(l,"local",!1),s.relative=this.getValue(l,"relative",!1),s.offsetRotation=this.getValue(l,"rotation",0),s.offsetX=this.getValue(l,"x",0)*n,s.offsetY=this.getValue(l,"y",0)*n,s.offsetScaleX=this.getValue(l,"scaleX",0),s.offsetScaleY=this.getValue(l,"scaleY",0),s.offsetShearY=this.getValue(l,"shearY",0),s.rotateMix=this.getValue(l,"rotateMix",1),s.translateMix=this.getValue(l,"translateMix",1),s.scaleMix=this.getValue(l,"scaleMix",1),s.shearMix=this.getValue(l,"shearMix",1),e.transformConstraints.push(s)}if(r.path)for(let h=0;h<r.path.length;h++){const l=r.path[h],s=new ii(l.name);s.order=this.getValue(l,"order",0),s.skinRequired=this.getValue(l,"skin",!1);for(let o=0;o<l.bones.length;o++){const c=l.bones[o],d=e.findBone(c);if(d==null)throw new Error(`Transform constraint bone not found: ${c}`);s.bones.push(d)}const a=l.target;if(s.target=e.findSlot(a),s.target==null)throw new Error(`Path target slot not found: ${a}`);s.positionMode=Hn.positionModeFromString(this.getValue(l,"positionMode","percent")),s.spacingMode=Hn.spacingModeFromString(this.getValue(l,"spacingMode","length")),s.rotateMode=Hn.rotateModeFromString(this.getValue(l,"rotateMode","tangent")),s.offsetRotation=this.getValue(l,"rotation",0),s.position=this.getValue(l,"position",0),s.positionMode==dt.Fixed&&(s.position*=n),s.spacing=this.getValue(l,"spacing",0),(s.spacingMode==qt.Length||s.spacingMode==qt.Fixed)&&(s.spacing*=n),s.rotateMix=this.getValue(l,"rotateMix",1),s.translateMix=this.getValue(l,"translateMix",1),e.pathConstraints.push(s)}if(r.skins)for(let h=0;h<r.skins.length;h++){const l=r.skins[h],s=new Ts(l.name);if(l.bones)for(let a=0;a<l.bones.length;a++){const o=e.findBone(l.bones[a]);if(o==null)throw new Error(`Skin bone not found: ${l.bones[h]}`);s.bones.push(o)}if(l.ik)for(let a=0;a<l.ik.length;a++){const o=e.findIkConstraint(l.ik[a]);if(o==null)throw new Error(`Skin IK constraint not found: ${l.ik[h]}`);s.constraints.push(o)}if(l.transform)for(let a=0;a<l.transform.length;a++){const o=e.findTransformConstraint(l.transform[a]);if(o==null)throw new Error(`Skin transform constraint not found: ${l.transform[h]}`);s.constraints.push(o)}if(l.path)for(let a=0;a<l.path.length;a++){const o=e.findPathConstraint(l.path[a]);if(o==null)throw new Error(`Skin path constraint not found: ${l.path[h]}`);s.constraints.push(o)}for(const a in l.attachments){const o=e.findSlot(a);if(o==null)throw new Error(`Slot not found: ${a}`);const c=l.attachments[a];for(const d in c){const u=this.readAttachment(c[d],s,o.index,d,e);u!=null&&s.setAttachment(o.index,d,u)}}e.skins.push(s),s.name=="default"&&(e.defaultSkin=s)}for(let h=0,l=this.linkedMeshes.length;h<l;h++){const s=this.linkedMeshes[h],a=s.skin==null?e.defaultSkin:e.findSkin(s.skin);if(a==null)throw new Error(`Skin not found: ${s.skin}`);const o=a.getAttachment(s.slotIndex,s.parent);if(o==null)throw new Error(`Parent mesh not found: ${s.parent}`);s.mesh.deformAttachment=s.inheritDeform?o:s.mesh,s.mesh.setParentMesh(o)}if(this.linkedMeshes.length=0,r.events)for(const h in r.events){const l=r.events[h],s=new mi(h);s.intValue=this.getValue(l,"int",0),s.floatValue=this.getValue(l,"float",0),s.stringValue=this.getValue(l,"string",""),s.audioPath=this.getValue(l,"audio",null),s.audioPath!=null&&(s.volume=this.getValue(l,"volume",1),s.balance=this.getValue(l,"balance",0)),e.events.push(s)}if(r.animations)for(const h in r.animations){const l=r.animations[h];this.readAnimation(l,h,e)}return e}readAttachment(t,n,e,r,i){const h=this.scale;switch(r=this.getValue(t,"name",r),this.getValue(t,"type","region")){case"region":{const s=this.getValue(t,"path",r),a=this.attachmentLoader.newRegionAttachment(n,r,s);if(a==null)return null;a.path=s,a.x=this.getValue(t,"x",0)*h,a.y=this.getValue(t,"y",0)*h,a.scaleX=this.getValue(t,"scaleX",1),a.scaleY=this.getValue(t,"scaleY",1),a.rotation=this.getValue(t,"rotation",0),a.width=t.width*h,a.height=t.height*h;const o=this.getValue(t,"color",null);return o!=null&&a.color.setFromString(o),a}case"boundingbox":{const s=this.attachmentLoader.newBoundingBoxAttachment(n,r);if(s==null)return null;this.readVertices(t,s,t.vertexCount<<1);const a=this.getValue(t,"color",null);return a!=null&&s.color.setFromString(a),s}case"mesh":case"linkedmesh":{const s=this.getValue(t,"path",r),a=this.attachmentLoader.newMeshAttachment(n,r,s);if(a==null)return null;a.path=s;const o=this.getValue(t,"color",null);o!=null&&a.color.setFromString(o),a.width=this.getValue(t,"width",0)*h,a.height=this.getValue(t,"height",0)*h;const c=this.getValue(t,"parent",null);if(c!=null)return this.linkedMeshes.push(new Go(a,this.getValue(t,"skin",null),e,c,this.getValue(t,"deform",!0))),a;const d=t.uvs;return this.readVertices(t,a,d.length),a.triangles=t.triangles,a.regionUVs=new Float32Array(d),a.edges=this.getValue(t,"edges",null),a.hullLength=this.getValue(t,"hull",0)*2,a}case"path":{const s=this.attachmentLoader.newPathAttachment(n,r);if(s==null)return null;s.closed=this.getValue(t,"closed",!1),s.constantSpeed=this.getValue(t,"constantSpeed",!0);const a=t.vertexCount;this.readVertices(t,s,a<<1);const o=k.newArray(a/3,0);for(let d=0;d<t.lengths.length;d++)o[d]=t.lengths[d]*h;s.lengths=o;const c=this.getValue(t,"color",null);return c!=null&&s.color.setFromString(c),s}case"point":{const s=this.attachmentLoader.newPointAttachment(n,r);if(s==null)return null;s.x=this.getValue(t,"x",0)*h,s.y=this.getValue(t,"y",0)*h,s.rotation=this.getValue(t,"rotation",0);const a=this.getValue(t,"color",null);return a!=null&&s.color.setFromString(a),s}case"clipping":{const s=this.attachmentLoader.newClippingAttachment(n,r);if(s==null)return null;const a=this.getValue(t,"end",null);if(a!=null){const d=i.findSlot(a);if(d==null)throw new Error(`Clipping end slot not found: ${a}`);s.endSlot=d}const o=t.vertexCount;this.readVertices(t,s,o<<1);const c=this.getValue(t,"color",null);return c!=null&&s.color.setFromString(c),s}}return null}readVertices(t,n,e){const r=this.scale;n.worldVerticesLength=e;const i=t.vertices;if(e==i.length){const s=k.toFloatArray(i);if(r!=1)for(let a=0,o=i.length;a<o;a++)s[a]*=r;n.vertices=s;return}const h=new Array,l=new Array;for(let s=0,a=i.length;s<a;){const o=i[s++];l.push(o);for(let c=s+o*4;s<c;s+=4)l.push(i[s]),h.push(i[s+1]*r),h.push(i[s+2]*r),h.push(i[s+3])}n.bones=l,n.vertices=k.toFloatArray(h)}readAnimation(t,n,e){const r=this.scale,i=new Array;let h=0;if(t.slots)for(const s in t.slots){const a=t.slots[s],o=e.findSlotIndex(s);if(o==-1)throw new Error(`Slot not found: ${s}`);for(const c in a){const d=a[c];if(c=="attachment"){const u=new Nn(d.length);u.slotIndex=o;let m=0;for(let g=0;g<d.length;g++){const x=d[g];u.setFrame(m++,this.getValue(x,"time",0),x.name)}i.push(u),h=Math.max(h,u.frames[u.getFrameCount()-1])}else if(c=="color"){const u=new oe(d.length);u.slotIndex=o;let m=0;for(let g=0;g<d.length;g++){const x=d[g],w=new O;w.setFromString(x.color||"ffffffff"),u.setFrame(m,this.getValue(x,"time",0),w.r,w.g,w.b,w.a),this.readCurve(x,u,m),m++}i.push(u),h=Math.max(h,u.frames[(u.getFrameCount()-1)*oe.ENTRIES])}else if(c=="twoColor"){const u=new Dt(d.length);u.slotIndex=o;let m=0;for(let g=0;g<d.length;g++){const x=d[g],w=new O,b=new O;w.setFromString(x.light),b.setFromString(x.dark),u.setFrame(m,this.getValue(x,"time",0),w.r,w.g,w.b,w.a,b.r,b.g,b.b),this.readCurve(x,u,m),m++}i.push(u),h=Math.max(h,u.frames[(u.getFrameCount()-1)*Dt.ENTRIES])}else throw new Error(`Invalid timeline type for a slot: ${c} (${s})`)}}if(t.bones)for(const s in t.bones){const a=t.bones[s],o=e.findBoneIndex(s);if(o==-1)throw new Error(`Bone not found: ${s}`);for(const c in a){const d=a[c];if(c==="rotate"){const u=new Zt(d.length);u.boneIndex=o;let m=0;for(let g=0;g<d.length;g++){const x=d[g];u.setFrame(m,this.getValue(x,"time",0),this.getValue(x,"angle",0)),this.readCurve(x,u,m),m++}i.push(u),h=Math.max(h,u.frames[(u.getFrameCount()-1)*Zt.ENTRIES])}else if(c==="translate"||c==="scale"||c==="shear"){let u=null,m=1,g=0;c==="scale"?(u=new ke(d.length),g=1):c==="shear"?u=new ve(d.length):(u=new Re(d.length),m=r),u.boneIndex=o;let x=0;for(let w=0;w<d.length;w++){const b=d[w],E=this.getValue(b,"x",g),p=this.getValue(b,"y",g);u.setFrame(x,this.getValue(b,"time",0),E*m,p*m),this.readCurve(b,u,x),x++}i.push(u),h=Math.max(h,u.frames[(u.getFrameCount()-1)*Re.ENTRIES])}else throw new Error(`Invalid timeline type for a bone: ${c} (${s})`)}}if(t.ik)for(const s in t.ik){const a=t.ik[s],o=e.findIkConstraint(s),c=new Qt(a.length);c.ikConstraintIndex=e.ikConstraints.indexOf(o);let d=0;for(let u=0;u<a.length;u++){const m=a[u];c.setFrame(d,this.getValue(m,"time",0),this.getValue(m,"mix",1),this.getValue(m,"softness",0)*r),this.readCurve(m,c,d),d++}i.push(c),h=Math.max(h,c.frames[(c.getFrameCount()-1)*Qt.ENTRIES])}if(t.transform)for(const s in t.transform){const a=t.transform[s],o=e.findTransformConstraint(s),c=new le(a.length);c.transformConstraintIndex=e.transformConstraints.indexOf(o);let d=0;for(let u=0;u<a.length;u++){const m=a[u];c.setFrame(d,this.getValue(m,"time",0),this.getValue(m,"rotateMix",1),this.getValue(m,"translateMix",1),this.getValue(m,"scaleMix",1),this.getValue(m,"shearMix",1)),this.readCurve(m,c,d),d++}i.push(c),h=Math.max(h,c.frames[(c.getFrameCount()-1)*le.ENTRIES])}if(t.path)for(const s in t.path){const a=t.path[s],o=e.findPathConstraintIndex(s);if(o==-1)throw new Error(`Path constraint not found: ${s}`);const c=e.pathConstraints[o];for(const d in a){const u=a[d];if(d==="position"||d==="spacing"){let m=null,g=1;d==="spacing"?(m=new on(u.length),(c.spacingMode==qt.Length||c.spacingMode==qt.Fixed)&&(g=r)):(m=new an(u.length),c.positionMode==dt.Fixed&&(g=r)),m.pathConstraintIndex=o;let x=0;for(let w=0;w<u.length;w++){const b=u[w];m.setFrame(x,this.getValue(b,"time",0),this.getValue(b,d,0)*g),this.readCurve(b,m,x),x++}i.push(m),h=Math.max(h,m.frames[(m.getFrameCount()-1)*an.ENTRIES])}else if(d==="mix"){const m=new ze(u.length);m.pathConstraintIndex=o;let g=0;for(let x=0;x<u.length;x++){const w=u[x];m.setFrame(g,this.getValue(w,"time",0),this.getValue(w,"rotateMix",1),this.getValue(w,"translateMix",1)),this.readCurve(w,m,g),g++}i.push(m),h=Math.max(h,m.frames[(m.getFrameCount()-1)*ze.ENTRIES])}}}if(t.deform)for(const s in t.deform){const a=t.deform[s],o=e.findSkin(s);if(o==null){if(jt.FAIL_ON_NON_EXISTING_SKIN)throw new Error(`Skin not found: ${s}`);continue}for(const c in a){const d=a[c],u=e.findSlotIndex(c);if(u==-1)throw new Error(`Slot not found: ${d.name}`);for(const m in d){const g=d[m],x=o.getAttachment(u,m);if(x==null)throw new Error(`Deform attachment not found: ${g.name}`);const w=x.bones!=null,b=x.vertices,E=w?b.length/3*2:b.length,p=new Zs(g.length);p.slotIndex=u,p.attachment=x;let S=0;for(let y=0;y<g.length;y++){const M=g[y];let C;const I=this.getValue(M,"vertices",null);if(I==null)C=w?k.newFloatArray(E):b;else{C=k.newFloatArray(E);const R=this.getValue(M,"offset",0);if(k.arrayCopy(I,0,C,R,I.length),r!=1)for(let v=R,V=v+I.length;v<V;v++)C[v]*=r;if(!w)for(let v=0;v<E;v++)C[v]+=b[v]}p.setFrame(S,this.getValue(M,"time",0),C,o.name),this.readCurve(M,p,S),S++}i.push(p),h=Math.max(h,p.frames[p.getFrameCount()-1])}}}let l=t.drawOrder;if(l==null&&(l=t.draworder),l!=null){const s=new Kn(l.length),a=e.slots.length;let o=0;for(let c=0;c<l.length;c++){const d=l[c];let u=null;const m=this.getValue(d,"offsets",null);if(m!=null){u=k.newArray(a,-1);const g=k.newArray(a-m.length,0);let x=0,w=0;for(let b=0;b<m.length;b++){const E=m[b],p=e.findSlotIndex(E.slot);if(p==-1)throw new Error(`Slot not found: ${E.slot}`);for(;x!=p;)g[w++]=x++;u[x+E.offset]=x++}for(;x<a;)g[w++]=x++;for(let b=a-1;b>=0;b--)u[b]==-1&&(u[b]=g[--w])}s.setFrame(o++,this.getValue(d,"time",0),u)}i.push(s),h=Math.max(h,s.frames[s.getFrameCount()-1])}if(t.events){const s=new ys(t.events.length);let a=0;for(let o=0;o<t.events.length;o++){const c=t.events[o],d=e.findEvent(c.name);if(d==null)throw new Error(`Event not found: ${c.name}`);const u=new oi(k.toSinglePrecision(this.getValue(c,"time",0)),d);u.intValue=this.getValue(c,"int",d.intValue),u.floatValue=this.getValue(c,"float",d.floatValue),u.stringValue=this.getValue(c,"string",d.stringValue),u.data.audioPath!=null&&(u.volume=this.getValue(c,"volume",1),u.balance=this.getValue(c,"balance",0)),s.setFrame(a++,u)}i.push(s),h=Math.max(h,s.frames[s.getFrameCount()-1])}if(isNaN(h))throw new Error("Error while parsing animation, duration is NaN");e.animations.push(new Rt(n,i,h))}readCurve(t,n,e){if(t.hasOwnProperty("curve"))if(t.curve==="stepped")n.setStepped(e);else{const r=t.curve;n.setCurve(e,r,this.getValue(t,"c2",0),this.getValue(t,"c3",1),this.getValue(t,"c4",1))}}getValue(t,n,e){return t[n]!==void 0?t[n]:e}static blendModeFromString(t){if(t=t.toLowerCase(),t=="normal")return G.BLEND_MODES.NORMAL;if(t=="additive")return G.BLEND_MODES.ADD;if(t=="multiply")return G.BLEND_MODES.MULTIPLY;if(t=="screen")return G.BLEND_MODES.SCREEN;throw new Error(`Unknown blend mode: ${t}`)}static positionModeFromString(t){if(t=t.toLowerCase(),t=="fixed")return dt.Fixed;if(t=="percent")return dt.Percent;throw new Error(`Unknown position mode: ${t}`)}static spacingModeFromString(t){if(t=t.toLowerCase(),t=="length")return qt.Length;if(t=="fixed")return qt.Fixed;if(t=="percent")return qt.Percent;throw new Error(`Unknown position mode: ${t}`)}static rotateModeFromString(t){if(t=t.toLowerCase(),t=="tangent")return ut.Tangent;if(t=="chain")return ut.Chain;if(t=="chainscale")return ut.ChainScale;throw new Error(`Unknown rotate mode: ${t}`)}static transformModeFromString(t){if(t=t.toLowerCase(),t=="normal")return z.Normal;if(t=="onlytranslation")return z.OnlyTranslation;if(t=="norotationorreflection")return z.NoRotationOrReflection;if(t=="noscale")return z.NoScale;if(t=="noscaleorreflection")return z.NoScaleOrReflection;throw new Error(`Unknown transform mode: ${t}`)}}class Go{constructor(t,n,e,r,i){this.mesh=t,this.skin=n,this.slotIndex=e,this.parent=r,this.inheritDeform=i}}var jo=Object.freeze({__proto__:null,Animation:Rt,AnimationState:Ve,AnimationStateAdapter:to,AnimationStateData:ti,AtlasAttachmentLoader:zr,Attachment:Gs,AttachmentTimeline:Nn,Bone:ri,BoneData:hi,BoundingBoxAttachment:ei,ClippingAttachment:ni,ColorTimeline:oe,ConstraintData:As,CurveTimeline:we,DeformTimeline:Zs,DrawOrderTimeline:Kn,Event:oi,EventData:mi,EventQueue:Ks,EventTimeline:ys,EventType:be,IkConstraint:Gr,IkConstraintData:di,IkConstraintTimeline:Qt,JitterEffect:Ho,MeshAttachment:Jn,PathAttachment:ts,PathConstraint:es,PathConstraintData:ii,PathConstraintMixTimeline:ze,PathConstraintPositionTimeline:an,PathConstraintSpacingTimeline:on,PointAttachment:si,RegionAttachment:J,RotateTimeline:Zt,ScaleTimeline:ke,ShearTimeline:ve,Skeleton:ai,SkeletonBinary:vt,SkeletonBounds:zo,SkeletonData:li,SkeletonJson:Hn,Skin:Ts,SkinEntry:ui,Slot:js,SlotData:ci,SpacingMode:qt,Spine:class extends An{createSkeleton(t){this.skeleton=new ai(t),this.skeleton.updateWorldTransform(),this.stateData=new ti(t),this.state=new Ve(this.stateData)}},SwirlEffect:qr,TimelineType:Ur,TrackEntry:Ms,TransformConstraint:jr,TransformConstraintData:fi,TransformConstraintTimeline:le,TranslateTimeline:Re,TwoColorTimeline:Dt,VertexAttachment:Tn});class Zo extends An{createSkeleton(t){const n=Ws(t.version);let e=null;if(n===Te.VER34&&(e=jo),n===Te.VER37&&(e=go),n===Te.VER38&&(e=co),(n===Te.VER40||n===Te.VER41)&&(e=$o),!e){const r=`Cant detect version of spine model ${t.version}`;console.error(r)}this.skeleton=new e.Skeleton(t),this.skeleton.updateWorldTransform(),this.stateData=new e.AnimationStateData(t),this.state=new e.AnimationState(this.stateData)}}return new Uo().installLoader(),st.AttachmentType=Z,st.BinaryInput=Gn,st.Color=O,st.DebugUtils=Ua,st.IntSet=Es,st.Interpolation=Pr,st.MathUtils=T,st.MixBlend=A,st.MixDirection=Q,st.Pool=Zn,st.PositionMode=dt,st.Pow=Fr,st.PowOut=Ss,st.RotateMode=ut,st.SkeletonBounds=Da,st.SkeletonBoundsBase=Qn,st.Spine=Zo,st.SpineBase=An,st.SpineDebugRenderer=Ga,st.SpineMesh=Nr,st.SpineSprite=Yr,st.StringSet=zs,st.TextureAtlas=bs,st.TextureAtlasPage=Us,st.TextureAtlasRegion=Hs,st.TextureFilter=re,st.TextureRegion=ws,st.TextureWrap=Ue,st.TimeKeeper=Ha,st.TransformMode=z,st.Utils=k,st.Vector2=Yn,st.WindowedMean=za,st.filterFromString=qs,st.settings=jt,st.wrapFromString=$a,st}({},PIXI,PIXI,PIXI,PIXI,PIXI,PIXI);
//# sourceMappingURL=pixi-spine.js.map
