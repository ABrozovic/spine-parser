{"version":3,"file":"pixi-spine.js","sources":["../../../packages/base/lib/core/AttachmentType.mjs","../../../packages/base/lib/core/BinaryInput.mjs","../../../packages/base/lib/core/IAnimation.mjs","../../../packages/base/lib/core/IConstraint.mjs","../../../packages/base/lib/core/ISkeleton.mjs","../../../packages/base/lib/core/TextureRegion.mjs","../../../packages/base/lib/core/TextureAtlas.mjs","../../../packages/base/lib/core/Utils.mjs","../../../packages/base/lib/core/SkeletonBoundsBase.mjs","../../../packages/base/lib/settings.mjs","../../../packages/base/lib/SpineBase.mjs","../../../packages/base/lib/SpineDebugRenderer.mjs","../../../packages/loader-base/lib/atlasLoader.mjs","../../../packages/loader-base/lib/SpineLoaderAbstract.mjs","../../../packages/loader-uni/lib/runtime-3.4/lib/core/attachments/Attachment.mjs","../../../packages/loader-uni/lib/runtime-3.4/lib/core/Slot.mjs","../../../packages/loader-uni/lib/runtime-3.4/lib/core/attachments/RegionAttachment.mjs","../../../packages/loader-uni/lib/runtime-3.4/lib/core/vertexeffects/SwirlEffect.mjs","../../../packages/loader-uni/lib/runtime-3.4/lib/core/Animation.mjs","../../../packages/loader-uni/lib/runtime-3.4/lib/core/AnimationState.mjs","../../../packages/loader-uni/lib/runtime-3.4/lib/core/AnimationStateData.mjs","../../../packages/loader-uni/lib/runtime-3.4/lib/core/attachments/BoundingBoxAttachment.mjs","../../../packages/loader-uni/lib/runtime-3.4/lib/core/attachments/ClippingAttachment.mjs","../../../packages/loader-uni/lib/runtime-3.4/lib/core/attachments/MeshAttachment.mjs","../../../packages/loader-uni/lib/runtime-3.4/lib/core/attachments/PathAttachment.mjs","../../../packages/loader-uni/lib/runtime-3.4/lib/core/attachments/PointAttachment.mjs","../../../packages/loader-uni/lib/runtime-3.4/lib/core/AtlasAttachmentLoader.mjs","../../../packages/loader-uni/lib/runtime-3.4/lib/core/Constraint.mjs","../../../packages/loader-uni/lib/runtime-3.4/lib/core/PathConstraintData.mjs","../../../packages/loader-uni/lib/runtime-3.4/lib/core/PathConstraint.mjs","../../../packages/loader-uni/lib/runtime-3.4/lib/core/Bone.mjs","../../../packages/loader-uni/lib/runtime-3.4/lib/core/IkConstraint.mjs","../../../packages/loader-uni/lib/runtime-3.4/lib/core/TransformConstraint.mjs","../../../packages/loader-uni/lib/runtime-3.4/lib/core/Skeleton.mjs","../../../packages/loader-uni/lib/runtime-3.4/lib/core/Event.mjs","../../../packages/loader-uni/lib/runtime-3.4/lib/core/SkeletonData.mjs","../../../packages/loader-uni/lib/runtime-3.4/lib/core/SlotData.mjs","../../../packages/loader-uni/lib/runtime-3.4/lib/core/BoneData.mjs","../../../packages/loader-uni/lib/runtime-3.4/lib/core/IkConstraintData.mjs","../../../packages/loader-uni/lib/runtime-3.4/lib/core/TransformConstraintData.mjs","../../../packages/loader-uni/lib/runtime-3.4/lib/core/Skin.mjs","../../../packages/loader-uni/lib/runtime-3.4/lib/core/EventData.mjs","../../../packages/loader-uni/lib/runtime-3.4/lib/core/SkeletonBinary.mjs","../../../packages/runtime-3.8/lib/core/attachments/Attachment.mjs","../../../packages/runtime-3.8/lib/core/attachments/BoundingBoxAttachment.mjs","../../../packages/runtime-3.8/lib/core/attachments/ClippingAttachment.mjs","../../../packages/runtime-3.8/lib/core/attachments/MeshAttachment.mjs","../../../packages/runtime-3.8/lib/core/attachments/PathAttachment.mjs","../../../packages/runtime-3.8/lib/core/attachments/PointAttachment.mjs","../../../packages/runtime-3.8/lib/core/Slot.mjs","../../../packages/runtime-3.8/lib/core/attachments/RegionAttachment.mjs","../../../packages/runtime-3.8/lib/core/vertexeffects/JitterEffect.mjs","../../../packages/runtime-3.8/lib/core/vertexeffects/SwirlEffect.mjs","../../../packages/runtime-3.8/lib/core/Animation.mjs","../../../packages/runtime-3.8/lib/core/AnimationState.mjs","../../../packages/runtime-3.8/lib/core/AnimationStateData.mjs","../../../packages/runtime-3.8/lib/core/AtlasAttachmentLoader.mjs","../../../packages/runtime-3.8/lib/core/Bone.mjs","../../../packages/runtime-3.8/lib/core/BoneData.mjs","../../../packages/runtime-3.8/lib/core/Constraint.mjs","../../../packages/runtime-3.8/lib/core/Event.mjs","../../../packages/runtime-3.8/lib/core/EventData.mjs","../../../packages/runtime-3.8/lib/core/IkConstraint.mjs","../../../packages/runtime-3.8/lib/core/IkConstraintData.mjs","../../../packages/runtime-3.8/lib/core/PathConstraintData.mjs","../../../packages/runtime-3.8/lib/core/PathConstraint.mjs","../../../packages/runtime-3.8/lib/core/TransformConstraint.mjs","../../../packages/runtime-3.8/lib/core/Skeleton.mjs","../../../packages/runtime-3.8/lib/core/SkeletonData.mjs","../../../packages/runtime-3.8/lib/core/SlotData.mjs","../../../packages/runtime-3.8/lib/core/TransformConstraintData.mjs","../../../packages/runtime-3.8/lib/core/Skin.mjs","../../../packages/runtime-3.8/lib/core/SkeletonBinary.mjs","../../../packages/runtime-3.8/lib/core/SkeletonBounds.mjs","../../../packages/runtime-3.8/lib/core/SkeletonJson.mjs","../../../packages/runtime-3.8/lib/Spine.mjs","../../../packages/runtime-3.7/lib/core/attachments/Attachment.mjs","../../../packages/runtime-3.7/lib/core/attachments/BoundingBoxAttachment.mjs","../../../packages/runtime-3.7/lib/core/attachments/ClippingAttachment.mjs","../../../packages/runtime-3.7/lib/core/attachments/MeshAttachment.mjs","../../../packages/runtime-3.7/lib/core/attachments/PathAttachment.mjs","../../../packages/runtime-3.7/lib/core/attachments/PointAttachment.mjs","../../../packages/runtime-3.7/lib/core/Slot.mjs","../../../packages/runtime-3.7/lib/core/attachments/RegionAttachment.mjs","../../../packages/runtime-3.7/lib/core/vertexeffects/JitterEffect.mjs","../../../packages/runtime-3.7/lib/core/vertexeffects/SwirlEffect.mjs","../../../packages/runtime-3.7/lib/core/Animation.mjs","../../../packages/runtime-3.7/lib/core/AnimationState.mjs","../../../packages/runtime-3.7/lib/core/AnimationStateData.mjs","../../../packages/runtime-3.7/lib/core/AtlasAttachmentLoader.mjs","../../../packages/runtime-3.7/lib/core/Bone.mjs","../../../packages/runtime-3.7/lib/core/BoneData.mjs","../../../packages/runtime-3.7/lib/core/Event.mjs","../../../packages/runtime-3.7/lib/core/EventData.mjs","../../../packages/runtime-3.7/lib/core/IkConstraint.mjs","../../../packages/runtime-3.7/lib/core/IkConstraintData.mjs","../../../packages/runtime-3.7/lib/core/PathConstraintData.mjs","../../../packages/runtime-3.7/lib/core/PathConstraint.mjs","../../../packages/runtime-3.7/lib/core/TransformConstraint.mjs","../../../packages/runtime-3.7/lib/core/Skeleton.mjs","../../../packages/runtime-3.7/lib/core/SkeletonBounds.mjs","../../../packages/runtime-3.7/lib/core/SkeletonData.mjs","../../../packages/runtime-3.7/lib/core/SlotData.mjs","../../../packages/runtime-3.7/lib/core/TransformConstraintData.mjs","../../../packages/runtime-3.7/lib/core/Skin.mjs","../../../packages/runtime-3.7/lib/core/SkeletonJson.mjs","../../../packages/runtime-3.7/lib/Spine.mjs","../../../packages/runtime-4.1/lib/core/attachments/Attachment.mjs","../../../packages/runtime-4.1/lib/core/attachments/BoundingBoxAttachment.mjs","../../../packages/runtime-4.1/lib/core/attachments/ClippingAttachment.mjs","../../../packages/runtime-4.1/lib/core/attachments/MeshAttachment.mjs","../../../packages/runtime-4.1/lib/core/attachments/PathAttachment.mjs","../../../packages/runtime-4.1/lib/core/attachments/PointAttachment.mjs","../../../packages/runtime-4.1/lib/core/attachments/RegionAttachment.mjs","../../../packages/runtime-4.1/lib/core/attachments/Sequence.mjs","../../../packages/runtime-4.1/lib/core/Animation.mjs","../../../packages/runtime-4.1/lib/core/AnimationState.mjs","../../../packages/runtime-4.1/lib/core/AnimationStateData.mjs","../../../packages/runtime-4.1/lib/core/AtlasAttachmentLoader.mjs","../../../packages/runtime-4.1/lib/core/Bone.mjs","../../../packages/runtime-4.1/lib/core/BoneData.mjs","../../../packages/runtime-4.1/lib/core/ConstraintData.mjs","../../../packages/runtime-4.1/lib/core/Event.mjs","../../../packages/runtime-4.1/lib/core/EventData.mjs","../../../packages/runtime-4.1/lib/core/IkConstraint.mjs","../../../packages/runtime-4.1/lib/core/IkConstraintData.mjs","../../../packages/runtime-4.1/lib/core/PathConstraintData.mjs","../../../packages/runtime-4.1/lib/core/PathConstraint.mjs","../../../packages/runtime-4.1/lib/core/Slot.mjs","../../../packages/runtime-4.1/lib/core/TransformConstraint.mjs","../../../packages/runtime-4.1/lib/core/Skeleton.mjs","../../../packages/runtime-4.1/lib/core/SkeletonData.mjs","../../../packages/runtime-4.1/lib/core/SlotData.mjs","../../../packages/runtime-4.1/lib/core/TransformConstraintData.mjs","../../../packages/runtime-4.1/lib/core/Skin.mjs","../../../packages/runtime-4.1/lib/core/SkeletonBinary.mjs","../../../packages/runtime-4.1/lib/core/SkeletonBounds.mjs","../../../packages/runtime-4.1/lib/core/SkeletonJson.mjs","../../../packages/runtime-4.1/lib/Spine.mjs","../../../packages/loader-uni/lib/versions.mjs","../../../packages/loader-uni/lib/SpineLoader.mjs","../../../packages/loader-uni/lib/runtime-3.4/lib/core/vertexeffects/JitterEffect.mjs","../../../packages/loader-uni/lib/runtime-3.4/lib/core/SkeletonBounds.mjs","../../../packages/loader-uni/lib/runtime-3.4/lib/core/SkeletonJson.mjs","../../../packages/loader-uni/lib/runtime-3.4/lib/Spine.mjs","../../../packages/loader-uni/lib/Spine.mjs","../../../packages/loader-uni/lib/index.mjs"],"sourcesContent":["var AttachmentType = /* @__PURE__ */ ((AttachmentType2) => {\n  AttachmentType2[AttachmentType2[\"Region\"] = 0] = \"Region\";\n  AttachmentType2[AttachmentType2[\"BoundingBox\"] = 1] = \"BoundingBox\";\n  AttachmentType2[AttachmentType2[\"Mesh\"] = 2] = \"Mesh\";\n  AttachmentType2[AttachmentType2[\"LinkedMesh\"] = 3] = \"LinkedMesh\";\n  AttachmentType2[AttachmentType2[\"Path\"] = 4] = \"Path\";\n  AttachmentType2[AttachmentType2[\"Point\"] = 5] = \"Point\";\n  AttachmentType2[AttachmentType2[\"Clipping\"] = 6] = \"Clipping\";\n  return AttachmentType2;\n})(AttachmentType || {});\n\nexport { AttachmentType };\n//# sourceMappingURL=AttachmentType.mjs.map\n","class BinaryInput {\n  constructor(data, strings = new Array(), index = 0, buffer = new DataView(data.buffer)) {\n    this.strings = strings;\n    this.index = index;\n    this.buffer = buffer;\n  }\n  readByte() {\n    return this.buffer.getInt8(this.index++);\n  }\n  readUnsignedByte() {\n    return this.buffer.getUint8(this.index++);\n  }\n  readShort() {\n    const value = this.buffer.getInt16(this.index);\n    this.index += 2;\n    return value;\n  }\n  readInt32() {\n    const value = this.buffer.getInt32(this.index);\n    this.index += 4;\n    return value;\n  }\n  readInt(optimizePositive) {\n    let b = this.readByte();\n    let result = b & 127;\n    if ((b & 128) != 0) {\n      b = this.readByte();\n      result |= (b & 127) << 7;\n      if ((b & 128) != 0) {\n        b = this.readByte();\n        result |= (b & 127) << 14;\n        if ((b & 128) != 0) {\n          b = this.readByte();\n          result |= (b & 127) << 21;\n          if ((b & 128) != 0) {\n            b = this.readByte();\n            result |= (b & 127) << 28;\n          }\n        }\n      }\n    }\n    return optimizePositive ? result : result >>> 1 ^ -(result & 1);\n  }\n  readStringRef() {\n    const index = this.readInt(true);\n    return index == 0 ? null : this.strings[index - 1];\n  }\n  readString() {\n    let byteCount = this.readInt(true);\n    switch (byteCount) {\n      case 0:\n        return null;\n      case 1:\n        return \"\";\n    }\n    byteCount--;\n    let chars = \"\";\n    for (let i = 0; i < byteCount; ) {\n      const b = this.readUnsignedByte();\n      switch (b >> 4) {\n        case 12:\n        case 13:\n          chars += String.fromCharCode((b & 31) << 6 | this.readByte() & 63);\n          i += 2;\n          break;\n        case 14:\n          chars += String.fromCharCode((b & 15) << 12 | (this.readByte() & 63) << 6 | this.readByte() & 63);\n          i += 3;\n          break;\n        default:\n          chars += String.fromCharCode(b);\n          i++;\n      }\n    }\n    return chars;\n  }\n  readFloat() {\n    const value = this.buffer.getFloat32(this.index);\n    this.index += 4;\n    return value;\n  }\n  readBoolean() {\n    return this.readByte() != 0;\n  }\n}\n\nexport { BinaryInput };\n//# sourceMappingURL=BinaryInput.mjs.map\n","var MixBlend = /* @__PURE__ */ ((MixBlend2) => {\n  MixBlend2[MixBlend2[\"setup\"] = 0] = \"setup\";\n  MixBlend2[MixBlend2[\"first\"] = 1] = \"first\";\n  MixBlend2[MixBlend2[\"replace\"] = 2] = \"replace\";\n  MixBlend2[MixBlend2[\"add\"] = 3] = \"add\";\n  return MixBlend2;\n})(MixBlend || {});\nvar MixDirection = /* @__PURE__ */ ((MixDirection2) => {\n  MixDirection2[MixDirection2[\"mixIn\"] = 0] = \"mixIn\";\n  MixDirection2[MixDirection2[\"mixOut\"] = 1] = \"mixOut\";\n  return MixDirection2;\n})(MixDirection || {});\n\nexport { MixBlend, MixDirection };\n//# sourceMappingURL=IAnimation.mjs.map\n","var PositionMode = /* @__PURE__ */ ((PositionMode2) => {\n  PositionMode2[PositionMode2[\"Fixed\"] = 0] = \"Fixed\";\n  PositionMode2[PositionMode2[\"Percent\"] = 1] = \"Percent\";\n  return PositionMode2;\n})(PositionMode || {});\nvar RotateMode = /* @__PURE__ */ ((RotateMode2) => {\n  RotateMode2[RotateMode2[\"Tangent\"] = 0] = \"Tangent\";\n  RotateMode2[RotateMode2[\"Chain\"] = 1] = \"Chain\";\n  RotateMode2[RotateMode2[\"ChainScale\"] = 2] = \"ChainScale\";\n  return RotateMode2;\n})(RotateMode || {});\n\nexport { PositionMode, RotateMode };\n//# sourceMappingURL=IConstraint.mjs.map\n","var TransformMode = /* @__PURE__ */ ((TransformMode2) => {\n  TransformMode2[TransformMode2[\"Normal\"] = 0] = \"Normal\";\n  TransformMode2[TransformMode2[\"OnlyTranslation\"] = 1] = \"OnlyTranslation\";\n  TransformMode2[TransformMode2[\"NoRotationOrReflection\"] = 2] = \"NoRotationOrReflection\";\n  TransformMode2[TransformMode2[\"NoScale\"] = 3] = \"NoScale\";\n  TransformMode2[TransformMode2[\"NoScaleOrReflection\"] = 4] = \"NoScaleOrReflection\";\n  return TransformMode2;\n})(TransformMode || {});\n\nexport { TransformMode };\n//# sourceMappingURL=ISkeleton.mjs.map\n","function filterFromString(text) {\n  switch (text.toLowerCase()) {\n    case \"nearest\":\n      return TextureFilter.Nearest;\n    case \"linear\":\n      return TextureFilter.Linear;\n    case \"mipmap\":\n      return TextureFilter.MipMap;\n    case \"mipmapnearestnearest\":\n      return TextureFilter.MipMapNearestNearest;\n    case \"mipmaplinearnearest\":\n      return TextureFilter.MipMapLinearNearest;\n    case \"mipmapnearestlinear\":\n      return TextureFilter.MipMapNearestLinear;\n    case \"mipmaplinearlinear\":\n      return TextureFilter.MipMapLinearLinear;\n    default:\n      throw new Error(`Unknown texture filter ${text}`);\n  }\n}\nfunction wrapFromString(text) {\n  switch (text.toLowerCase()) {\n    case \"mirroredtepeat\":\n      return TextureWrap.MirroredRepeat;\n    case \"clamptoedge\":\n      return TextureWrap.ClampToEdge;\n    case \"repeat\":\n      return TextureWrap.Repeat;\n    default:\n      throw new Error(`Unknown texture wrap ${text}`);\n  }\n}\nvar TextureFilter = /* @__PURE__ */ ((TextureFilter2) => {\n  TextureFilter2[TextureFilter2[\"Nearest\"] = 9728] = \"Nearest\";\n  TextureFilter2[TextureFilter2[\"Linear\"] = 9729] = \"Linear\";\n  TextureFilter2[TextureFilter2[\"MipMap\"] = 9987] = \"MipMap\";\n  TextureFilter2[TextureFilter2[\"MipMapNearestNearest\"] = 9984] = \"MipMapNearestNearest\";\n  TextureFilter2[TextureFilter2[\"MipMapLinearNearest\"] = 9985] = \"MipMapLinearNearest\";\n  TextureFilter2[TextureFilter2[\"MipMapNearestLinear\"] = 9986] = \"MipMapNearestLinear\";\n  TextureFilter2[TextureFilter2[\"MipMapLinearLinear\"] = 9987] = \"MipMapLinearLinear\";\n  return TextureFilter2;\n})(TextureFilter || {});\nvar TextureWrap = /* @__PURE__ */ ((TextureWrap2) => {\n  TextureWrap2[TextureWrap2[\"MirroredRepeat\"] = 33648] = \"MirroredRepeat\";\n  TextureWrap2[TextureWrap2[\"ClampToEdge\"] = 33071] = \"ClampToEdge\";\n  TextureWrap2[TextureWrap2[\"Repeat\"] = 10497] = \"Repeat\";\n  return TextureWrap2;\n})(TextureWrap || {});\nclass TextureRegion {\n  constructor() {\n    // thats for overrides\n    this.size = null;\n    this.names = null;\n    this.values = null;\n    this.renderObject = null;\n  }\n  get width() {\n    const tex = this.texture;\n    if (tex.trim) {\n      return tex.trim.width;\n    }\n    return tex.orig.width;\n  }\n  get height() {\n    const tex = this.texture;\n    if (tex.trim) {\n      return tex.trim.height;\n    }\n    return tex.orig.height;\n  }\n  get u() {\n    return this.texture._uvs.x0;\n  }\n  get v() {\n    return this.texture._uvs.y0;\n  }\n  get u2() {\n    return this.texture._uvs.x2;\n  }\n  get v2() {\n    return this.texture._uvs.y2;\n  }\n  get offsetX() {\n    const tex = this.texture;\n    return tex.trim ? tex.trim.x : 0;\n  }\n  get offsetY() {\n    return this.spineOffsetY;\n  }\n  get pixiOffsetY() {\n    const tex = this.texture;\n    return tex.trim ? tex.trim.y : 0;\n  }\n  get spineOffsetY() {\n    const tex = this.texture;\n    return this.originalHeight - this.height - (tex.trim ? tex.trim.y : 0);\n  }\n  get originalWidth() {\n    return this.texture.orig.width;\n  }\n  get originalHeight() {\n    return this.texture.orig.height;\n  }\n  get x() {\n    return this.texture.frame.x;\n  }\n  get y() {\n    return this.texture.frame.y;\n  }\n  get rotate() {\n    return this.texture.rotate !== 0;\n  }\n  get degrees() {\n    return (360 - this.texture.rotate * 45) % 360;\n  }\n}\n\nexport { TextureFilter, TextureRegion, TextureWrap, filterFromString, wrapFromString };\n//# sourceMappingURL=TextureRegion.mjs.map\n","import { SCALE_MODES, MIPMAP_MODES, ALPHA_MODES, Rectangle, Texture } from '@pixi/core';\nimport { TextureFilter, TextureWrap, TextureRegion, filterFromString } from './TextureRegion.mjs';\n\nclass RegionFields {\n  constructor() {\n    this.x = 0;\n    this.y = 0;\n    this.width = 0;\n    this.height = 0;\n    this.offsetX = 0;\n    this.offsetY = 0;\n    this.originalWidth = 0;\n    this.originalHeight = 0;\n    this.rotate = 0;\n    this.index = 0;\n  }\n}\nclass TextureAtlas {\n  constructor(atlasText, textureLoader, callback) {\n    this.pages = new Array();\n    this.regions = new Array();\n    if (atlasText) {\n      this.addSpineAtlas(atlasText, textureLoader, callback);\n    }\n  }\n  addTexture(name, texture) {\n    const pages = this.pages;\n    let page = null;\n    for (let i = 0; i < pages.length; i++) {\n      if (pages[i].baseTexture === texture.baseTexture) {\n        page = pages[i];\n        break;\n      }\n    }\n    if (page === null) {\n      page = new TextureAtlasPage();\n      page.name = \"texturePage\";\n      const baseTexture = texture.baseTexture;\n      page.width = baseTexture.realWidth;\n      page.height = baseTexture.realHeight;\n      page.baseTexture = baseTexture;\n      page.minFilter = page.magFilter = TextureFilter.Nearest;\n      page.uWrap = TextureWrap.ClampToEdge;\n      page.vWrap = TextureWrap.ClampToEdge;\n      pages.push(page);\n    }\n    const region = new TextureAtlasRegion();\n    region.name = name;\n    region.page = page;\n    region.texture = texture;\n    region.index = -1;\n    this.regions.push(region);\n    return region;\n  }\n  addTextureHash(textures, stripExtension) {\n    for (const key in textures) {\n      if (textures.hasOwnProperty(key)) {\n        this.addTexture(stripExtension && key.indexOf(\".\") !== -1 ? key.substr(0, key.lastIndexOf(\".\")) : key, textures[key]);\n      }\n    }\n  }\n  addSpineAtlas(atlasText, textureLoader, callback) {\n    return this.load(atlasText, textureLoader, callback);\n  }\n  load(atlasText, textureLoader, callback) {\n    if (textureLoader == null) {\n      throw new Error(\"textureLoader cannot be null.\");\n    }\n    const reader = new TextureAtlasReader(atlasText);\n    const entry = new Array(4);\n    let page = null;\n    const pageFields = {};\n    let region = null;\n    pageFields.size = () => {\n      page.width = parseInt(entry[1]);\n      page.height = parseInt(entry[2]);\n    };\n    pageFields.format = () => {\n    };\n    pageFields.filter = () => {\n      page.minFilter = filterFromString(entry[1]);\n      page.magFilter = filterFromString(entry[2]);\n    };\n    pageFields.repeat = () => {\n      if (entry[1].indexOf(\"x\") != -1)\n        page.uWrap = TextureWrap.Repeat;\n      if (entry[1].indexOf(\"y\") != -1)\n        page.vWrap = TextureWrap.Repeat;\n    };\n    pageFields.pma = () => {\n      page.pma = entry[1] == \"true\";\n    };\n    const regionFields = {};\n    regionFields.xy = () => {\n      region.x = parseInt(entry[1]);\n      region.y = parseInt(entry[2]);\n    };\n    regionFields.size = () => {\n      region.width = parseInt(entry[1]);\n      region.height = parseInt(entry[2]);\n    };\n    regionFields.bounds = () => {\n      region.x = parseInt(entry[1]);\n      region.y = parseInt(entry[2]);\n      region.width = parseInt(entry[3]);\n      region.height = parseInt(entry[4]);\n    };\n    regionFields.offset = () => {\n      region.offsetX = parseInt(entry[1]);\n      region.offsetY = parseInt(entry[2]);\n    };\n    regionFields.orig = () => {\n      region.originalWidth = parseInt(entry[1]);\n      region.originalHeight = parseInt(entry[2]);\n    };\n    regionFields.offsets = () => {\n      region.offsetX = parseInt(entry[1]);\n      region.offsetY = parseInt(entry[2]);\n      region.originalWidth = parseInt(entry[3]);\n      region.originalHeight = parseInt(entry[4]);\n    };\n    regionFields.rotate = () => {\n      const rotateValue = entry[1];\n      let rotate = 0;\n      if (rotateValue.toLocaleLowerCase() == \"true\") {\n        rotate = 6;\n      } else if (rotateValue.toLocaleLowerCase() == \"false\") {\n        rotate = 0;\n      } else {\n        rotate = (720 - parseFloat(rotateValue)) % 360 / 45;\n      }\n      region.rotate = rotate;\n    };\n    regionFields.index = () => {\n      region.index = parseInt(entry[1]);\n    };\n    let line = reader.readLine();\n    while (line != null && line.trim().length == 0) {\n      line = reader.readLine();\n    }\n    while (true) {\n      if (line == null || line.trim().length == 0)\n        break;\n      if (reader.readEntry(entry, line) == 0)\n        break;\n      line = reader.readLine();\n    }\n    const iterateParser = () => {\n      while (true) {\n        if (line == null) {\n          return callback && callback(this);\n        }\n        if (line.trim().length == 0) {\n          page = null;\n          line = reader.readLine();\n        } else if (page === null) {\n          page = new TextureAtlasPage();\n          page.name = line.trim();\n          while (true) {\n            if (reader.readEntry(entry, line = reader.readLine()) == 0)\n              break;\n            const field = pageFields[entry[0]];\n            if (field)\n              field();\n          }\n          this.pages.push(page);\n          textureLoader(page.name, (texture) => {\n            if (texture === null) {\n              this.pages.splice(this.pages.indexOf(page), 1);\n              return callback && callback(null);\n            }\n            page.baseTexture = texture;\n            if (page.pma) {\n              texture.alphaMode = ALPHA_MODES.PMA;\n            }\n            if (!texture.valid) {\n              texture.setSize(page.width, page.height);\n            }\n            page.setFilters();\n            if (!page.width || !page.height) {\n              page.width = texture.realWidth;\n              page.height = texture.realHeight;\n              if (!page.width || !page.height) {\n                console.log(\n                  `ERROR spine atlas page ${page.name}: meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)`\n                );\n              }\n            }\n            iterateParser();\n          });\n          break;\n        } else {\n          region = new RegionFields();\n          const atlasRegion = new TextureAtlasRegion();\n          atlasRegion.name = line;\n          atlasRegion.page = page;\n          let names = null;\n          let values = null;\n          while (true) {\n            const count = reader.readEntry(entry, line = reader.readLine());\n            if (count == 0)\n              break;\n            const field = regionFields[entry[0]];\n            if (field) {\n              field();\n            } else {\n              if (names == null) {\n                names = [];\n                values = [];\n              }\n              names.push(entry[0]);\n              const entryValues = [];\n              for (let i = 0; i < count; i++) {\n                entryValues.push(parseInt(entry[i + 1]));\n              }\n              values.push(entryValues);\n            }\n          }\n          if (region.originalWidth == 0 && region.originalHeight == 0) {\n            region.originalWidth = region.width;\n            region.originalHeight = region.height;\n          }\n          const resolution = page.baseTexture.resolution;\n          region.x /= resolution;\n          region.y /= resolution;\n          region.width /= resolution;\n          region.height /= resolution;\n          region.originalWidth /= resolution;\n          region.originalHeight /= resolution;\n          region.offsetX /= resolution;\n          region.offsetY /= resolution;\n          const swapWH = region.rotate % 4 !== 0;\n          const frame = new Rectangle(region.x, region.y, swapWH ? region.height : region.width, swapWH ? region.width : region.height);\n          const orig = new Rectangle(0, 0, region.originalWidth, region.originalHeight);\n          const trim = new Rectangle(region.offsetX, region.originalHeight - region.height - region.offsetY, region.width, region.height);\n          atlasRegion.texture = new Texture(atlasRegion.page.baseTexture, frame, orig, trim, region.rotate);\n          atlasRegion.index = region.index;\n          atlasRegion.texture.updateUvs();\n          this.regions.push(atlasRegion);\n        }\n      }\n    };\n    iterateParser();\n  }\n  findRegion(name) {\n    for (let i = 0; i < this.regions.length; i++) {\n      if (this.regions[i].name == name) {\n        return this.regions[i];\n      }\n    }\n    return null;\n  }\n  dispose() {\n    for (let i = 0; i < this.pages.length; i++) {\n      this.pages[i].baseTexture.dispose();\n    }\n  }\n}\nclass TextureAtlasReader {\n  constructor(text) {\n    this.index = 0;\n    this.lines = text.split(/\\r\\n|\\r|\\n/);\n  }\n  readLine() {\n    if (this.index >= this.lines.length) {\n      return null;\n    }\n    return this.lines[this.index++];\n  }\n  readEntry(entry, line) {\n    if (line == null)\n      return 0;\n    line = line.trim();\n    if (line.length == 0)\n      return 0;\n    const colon = line.indexOf(\":\");\n    if (colon == -1)\n      return 0;\n    entry[0] = line.substr(0, colon).trim();\n    for (let i = 1, lastMatch = colon + 1; ; i++) {\n      const comma = line.indexOf(\",\", lastMatch);\n      if (comma == -1) {\n        entry[i] = line.substr(lastMatch).trim();\n        return i;\n      }\n      entry[i] = line.substr(lastMatch, comma - lastMatch).trim();\n      lastMatch = comma + 1;\n      if (i == 4)\n        return 4;\n    }\n  }\n}\nclass TextureAtlasPage {\n  constructor() {\n    this.minFilter = TextureFilter.Nearest;\n    this.magFilter = TextureFilter.Nearest;\n    this.uWrap = TextureWrap.ClampToEdge;\n    this.vWrap = TextureWrap.ClampToEdge;\n  }\n  setFilters() {\n    const tex = this.baseTexture;\n    const filter = this.minFilter;\n    if (filter == TextureFilter.Linear) {\n      tex.scaleMode = SCALE_MODES.LINEAR;\n    } else if (this.minFilter == TextureFilter.Nearest) {\n      tex.scaleMode = SCALE_MODES.NEAREST;\n    } else {\n      tex.mipmap = MIPMAP_MODES.POW2;\n      if (filter == TextureFilter.MipMapNearestNearest) {\n        tex.scaleMode = SCALE_MODES.NEAREST;\n      } else {\n        tex.scaleMode = SCALE_MODES.LINEAR;\n      }\n    }\n  }\n}\nclass TextureAtlasRegion extends TextureRegion {\n}\n\nexport { TextureAtlas, TextureAtlasPage, TextureAtlasRegion };\n//# sourceMappingURL=TextureAtlas.mjs.map\n","class IntSet {\n  constructor() {\n    this.array = new Array();\n  }\n  add(value) {\n    const contains = this.contains(value);\n    this.array[value | 0] = value | 0;\n    return !contains;\n  }\n  contains(value) {\n    return this.array[value | 0] != void 0;\n  }\n  remove(value) {\n    this.array[value | 0] = void 0;\n  }\n  clear() {\n    this.array.length = 0;\n  }\n}\nclass StringSet {\n  constructor() {\n    this.entries = {};\n    this.size = 0;\n  }\n  add(value) {\n    const contains = this.entries[value];\n    this.entries[value] = true;\n    if (!contains) {\n      this.size++;\n      return true;\n    }\n    return false;\n  }\n  addAll(values) {\n    const oldSize = this.size;\n    for (let i = 0, n = values.length; i < n; i++) {\n      this.add(values[i]);\n    }\n    return oldSize != this.size;\n  }\n  contains(value) {\n    return this.entries[value];\n  }\n  clear() {\n    this.entries = {};\n    this.size = 0;\n  }\n}\nconst _Color = class {\n  constructor(r = 0, g = 0, b = 0, a = 0) {\n    this.r = r;\n    this.g = g;\n    this.b = b;\n    this.a = a;\n  }\n  set(r, g, b, a) {\n    this.r = r;\n    this.g = g;\n    this.b = b;\n    this.a = a;\n    return this.clamp();\n  }\n  setFromColor(c) {\n    this.r = c.r;\n    this.g = c.g;\n    this.b = c.b;\n    this.a = c.a;\n    return this;\n  }\n  setFromString(hex) {\n    hex = hex.charAt(0) == \"#\" ? hex.substr(1) : hex;\n    this.r = parseInt(hex.substr(0, 2), 16) / 255;\n    this.g = parseInt(hex.substr(2, 2), 16) / 255;\n    this.b = parseInt(hex.substr(4, 2), 16) / 255;\n    this.a = hex.length != 8 ? 1 : parseInt(hex.substr(6, 2), 16) / 255;\n    return this;\n  }\n  add(r, g, b, a) {\n    this.r += r;\n    this.g += g;\n    this.b += b;\n    this.a += a;\n    return this.clamp();\n  }\n  clamp() {\n    if (this.r < 0)\n      this.r = 0;\n    else if (this.r > 1)\n      this.r = 1;\n    if (this.g < 0)\n      this.g = 0;\n    else if (this.g > 1)\n      this.g = 1;\n    if (this.b < 0)\n      this.b = 0;\n    else if (this.b > 1)\n      this.b = 1;\n    if (this.a < 0)\n      this.a = 0;\n    else if (this.a > 1)\n      this.a = 1;\n    return this;\n  }\n  static rgba8888ToColor(color, value) {\n    color.r = ((value & 4278190080) >>> 24) / 255;\n    color.g = ((value & 16711680) >>> 16) / 255;\n    color.b = ((value & 65280) >>> 8) / 255;\n    color.a = (value & 255) / 255;\n  }\n  static rgb888ToColor(color, value) {\n    color.r = ((value & 16711680) >>> 16) / 255;\n    color.g = ((value & 65280) >>> 8) / 255;\n    color.b = (value & 255) / 255;\n  }\n  static fromString(hex) {\n    return new _Color().setFromString(hex);\n  }\n};\nlet Color = _Color;\nColor.WHITE = new _Color(1, 1, 1, 1);\nColor.RED = new _Color(1, 0, 0, 1);\nColor.GREEN = new _Color(0, 1, 0, 1);\nColor.BLUE = new _Color(0, 0, 1, 1);\nColor.MAGENTA = new _Color(1, 0, 1, 1);\nconst _MathUtils = class {\n  static clamp(value, min, max) {\n    if (value < min)\n      return min;\n    if (value > max)\n      return max;\n    return value;\n  }\n  static cosDeg(degrees) {\n    return Math.cos(degrees * _MathUtils.degRad);\n  }\n  static sinDeg(degrees) {\n    return Math.sin(degrees * _MathUtils.degRad);\n  }\n  static signum(value) {\n    return Math.sign(value);\n  }\n  static toInt(x) {\n    return x > 0 ? Math.floor(x) : Math.ceil(x);\n  }\n  static cbrt(x) {\n    const y = Math.pow(Math.abs(x), 1 / 3);\n    return x < 0 ? -y : y;\n  }\n  static randomTriangular(min, max) {\n    return _MathUtils.randomTriangularWith(min, max, (min + max) * 0.5);\n  }\n  static randomTriangularWith(min, max, mode) {\n    const u = Math.random();\n    const d = max - min;\n    if (u <= (mode - min) / d)\n      return min + Math.sqrt(u * d * (mode - min));\n    return max - Math.sqrt((1 - u) * d * (max - mode));\n  }\n  static isPowerOfTwo(value) {\n    return value && (value & value - 1) === 0;\n  }\n};\nlet MathUtils = _MathUtils;\nMathUtils.PI = 3.1415927;\nMathUtils.PI2 = _MathUtils.PI * 2;\nMathUtils.radiansToDegrees = 180 / _MathUtils.PI;\nMathUtils.radDeg = _MathUtils.radiansToDegrees;\nMathUtils.degreesToRadians = _MathUtils.PI / 180;\nMathUtils.degRad = _MathUtils.degreesToRadians;\nclass Interpolation {\n  apply(start, end, a) {\n    return start + (end - start) * this.applyInternal(a);\n  }\n}\nclass Pow extends Interpolation {\n  constructor(power) {\n    super();\n    this.power = 2;\n    this.power = power;\n  }\n  applyInternal(a) {\n    if (a <= 0.5)\n      return Math.pow(a * 2, this.power) / 2;\n    return Math.pow((a - 1) * 2, this.power) / (this.power % 2 == 0 ? -2 : 2) + 1;\n  }\n}\nclass PowOut extends Pow {\n  applyInternal(a) {\n    return Math.pow(a - 1, this.power) * (this.power % 2 == 0 ? -1 : 1) + 1;\n  }\n}\nconst _Utils = class {\n  static arrayCopy(source, sourceStart, dest, destStart, numElements) {\n    for (let i = sourceStart, j = destStart; i < sourceStart + numElements; i++, j++) {\n      dest[j] = source[i];\n    }\n  }\n  static arrayFill(array, fromIndex, toIndex, value) {\n    for (let i = fromIndex; i < toIndex; i++) {\n      array[i] = value;\n    }\n  }\n  static setArraySize(array, size, value = 0) {\n    const oldSize = array.length;\n    if (oldSize == size)\n      return array;\n    array.length = size;\n    if (oldSize < size) {\n      for (let i = oldSize; i < size; i++)\n        array[i] = value;\n    }\n    return array;\n  }\n  static ensureArrayCapacity(array, size, value = 0) {\n    if (array.length >= size)\n      return array;\n    return _Utils.setArraySize(array, size, value);\n  }\n  static newArray(size, defaultValue) {\n    const array = new Array(size);\n    for (let i = 0; i < size; i++)\n      array[i] = defaultValue;\n    return array;\n  }\n  static newFloatArray(size) {\n    if (_Utils.SUPPORTS_TYPED_ARRAYS) {\n      return new Float32Array(size);\n    }\n    const array = new Array(size);\n    for (let i = 0; i < array.length; i++)\n      array[i] = 0;\n    return array;\n  }\n  static newShortArray(size) {\n    if (_Utils.SUPPORTS_TYPED_ARRAYS) {\n      return new Int16Array(size);\n    }\n    const array = new Array(size);\n    for (let i = 0; i < array.length; i++)\n      array[i] = 0;\n    return array;\n  }\n  static toFloatArray(array) {\n    return _Utils.SUPPORTS_TYPED_ARRAYS ? new Float32Array(array) : array;\n  }\n  static toSinglePrecision(value) {\n    return _Utils.SUPPORTS_TYPED_ARRAYS ? Math.fround(value) : value;\n  }\n  // This function is used to fix WebKit 602 specific issue described at http://esotericsoftware.com/forum/iOS-10-disappearing-graphics-10109\n  static webkit602BugfixHelper(alpha, blend) {\n  }\n  static contains(array, element, identity = true) {\n    for (let i = 0; i < array.length; i++) {\n      if (array[i] == element)\n        return true;\n    }\n    return false;\n  }\n  static enumValue(type, name) {\n    return type[name[0].toUpperCase() + name.slice(1)];\n  }\n};\nlet Utils = _Utils;\nUtils.SUPPORTS_TYPED_ARRAYS = typeof Float32Array !== \"undefined\";\nclass DebugUtils {\n  static logBones(skeleton) {\n    for (let i = 0; i < skeleton.bones.length; i++) {\n      const bone = skeleton.bones[i];\n      const mat = bone.matrix;\n      console.log(`${bone.data.name}, ${mat.a}, ${mat.b}, ${mat.c}, ${mat.d}, ${mat.tx}, ${mat.ty}`);\n    }\n  }\n}\nclass Pool {\n  constructor(instantiator) {\n    this.items = new Array();\n    this.instantiator = instantiator;\n  }\n  obtain() {\n    return this.items.length > 0 ? this.items.pop() : this.instantiator();\n  }\n  free(item) {\n    if (item.reset)\n      item.reset();\n    this.items.push(item);\n  }\n  freeAll(items) {\n    for (let i = 0; i < items.length; i++) {\n      this.free(items[i]);\n    }\n  }\n  clear() {\n    this.items.length = 0;\n  }\n}\nclass Vector2 {\n  constructor(x = 0, y = 0) {\n    this.x = x;\n    this.y = y;\n  }\n  set(x, y) {\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n  length() {\n    const x = this.x;\n    const y = this.y;\n    return Math.sqrt(x * x + y * y);\n  }\n  normalize() {\n    const len = this.length();\n    if (len != 0) {\n      this.x /= len;\n      this.y /= len;\n    }\n    return this;\n  }\n}\nclass TimeKeeper {\n  constructor() {\n    this.maxDelta = 0.064;\n    this.framesPerSecond = 0;\n    this.delta = 0;\n    this.totalTime = 0;\n    this.lastTime = Date.now() / 1e3;\n    this.frameCount = 0;\n    this.frameTime = 0;\n  }\n  update() {\n    const now = Date.now() / 1e3;\n    this.delta = now - this.lastTime;\n    this.frameTime += this.delta;\n    this.totalTime += this.delta;\n    if (this.delta > this.maxDelta)\n      this.delta = this.maxDelta;\n    this.lastTime = now;\n    this.frameCount++;\n    if (this.frameTime > 1) {\n      this.framesPerSecond = this.frameCount / this.frameTime;\n      this.frameTime = 0;\n      this.frameCount = 0;\n    }\n  }\n}\nclass WindowedMean {\n  constructor(windowSize = 32) {\n    this.addedValues = 0;\n    this.lastValue = 0;\n    this.mean = 0;\n    this.dirty = true;\n    this.values = new Array(windowSize);\n  }\n  hasEnoughData() {\n    return this.addedValues >= this.values.length;\n  }\n  addValue(value) {\n    if (this.addedValues < this.values.length)\n      this.addedValues++;\n    this.values[this.lastValue++] = value;\n    if (this.lastValue > this.values.length - 1)\n      this.lastValue = 0;\n    this.dirty = true;\n  }\n  getMean() {\n    if (this.hasEnoughData()) {\n      if (this.dirty) {\n        let mean = 0;\n        for (let i = 0; i < this.values.length; i++) {\n          mean += this.values[i];\n        }\n        this.mean = mean / this.values.length;\n        this.dirty = false;\n      }\n      return this.mean;\n    }\n    return 0;\n  }\n}\n\nexport { Color, DebugUtils, IntSet, Interpolation, MathUtils, Pool, Pow, PowOut, StringSet, TimeKeeper, Utils, Vector2, WindowedMean };\n//# sourceMappingURL=Utils.mjs.map\n","import { AttachmentType } from './AttachmentType.mjs';\nimport { Pool, Utils } from './Utils.mjs';\n\nclass SkeletonBoundsBase {\n  constructor() {\n    /** The left edge of the axis aligned bounding box. */\n    this.minX = 0;\n    /** The bottom edge of the axis aligned bounding box. */\n    this.minY = 0;\n    /** The right edge of the axis aligned bounding box. */\n    this.maxX = 0;\n    /** The top edge of the axis aligned bounding box. */\n    this.maxY = 0;\n    /** The visible bounding boxes. */\n    this.boundingBoxes = new Array();\n    /** The world vertices for the bounding box polygons. */\n    this.polygons = new Array();\n    this.polygonPool = new Pool(() => Utils.newFloatArray(16));\n  }\n  /** Clears any previous polygons, finds all visible bounding box attachments, and computes the world vertices for each bounding\n   * box's polygon.\n   * @param updateAabb If true, the axis aligned bounding box containing all the polygons is computed. If false, the\n   *           SkeletonBounds AABB methods will always return true. */\n  update(skeleton, updateAabb) {\n    if (!skeleton)\n      throw new Error(\"skeleton cannot be null.\");\n    const boundingBoxes = this.boundingBoxes;\n    const polygons = this.polygons;\n    const polygonPool = this.polygonPool;\n    const slots = skeleton.slots;\n    const slotCount = slots.length;\n    boundingBoxes.length = 0;\n    polygonPool.freeAll(polygons);\n    polygons.length = 0;\n    for (let i = 0; i < slotCount; i++) {\n      const slot = slots[i];\n      if (!slot.bone.active)\n        continue;\n      const attachment = slot.getAttachment();\n      if (attachment != null && attachment.type === AttachmentType.BoundingBox) {\n        const boundingBox = attachment;\n        boundingBoxes.push(boundingBox);\n        let polygon = polygonPool.obtain();\n        if (polygon.length != boundingBox.worldVerticesLength) {\n          polygon = Utils.newFloatArray(boundingBox.worldVerticesLength);\n        }\n        polygons.push(polygon);\n        boundingBox.computeWorldVertices(slot, 0, boundingBox.worldVerticesLength, polygon, 0, 2);\n      }\n    }\n    if (updateAabb) {\n      this.aabbCompute();\n    } else {\n      this.minX = Number.POSITIVE_INFINITY;\n      this.minY = Number.POSITIVE_INFINITY;\n      this.maxX = Number.NEGATIVE_INFINITY;\n      this.maxY = Number.NEGATIVE_INFINITY;\n    }\n  }\n  aabbCompute() {\n    let minX = Number.POSITIVE_INFINITY;\n    let minY = Number.POSITIVE_INFINITY;\n    let maxX = Number.NEGATIVE_INFINITY;\n    let maxY = Number.NEGATIVE_INFINITY;\n    const polygons = this.polygons;\n    for (let i = 0, n = polygons.length; i < n; i++) {\n      const polygon = polygons[i];\n      const vertices = polygon;\n      for (let ii = 0, nn = polygon.length; ii < nn; ii += 2) {\n        const x = vertices[ii];\n        const y = vertices[ii + 1];\n        minX = Math.min(minX, x);\n        minY = Math.min(minY, y);\n        maxX = Math.max(maxX, x);\n        maxY = Math.max(maxY, y);\n      }\n    }\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  }\n  /** Returns true if the axis aligned bounding box contains the point. */\n  aabbContainsPoint(x, y) {\n    return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;\n  }\n  /** Returns true if the axis aligned bounding box intersects the line segment. */\n  aabbIntersectsSegment(x1, y1, x2, y2) {\n    const minX = this.minX;\n    const minY = this.minY;\n    const maxX = this.maxX;\n    const maxY = this.maxY;\n    if (x1 <= minX && x2 <= minX || y1 <= minY && y2 <= minY || x1 >= maxX && x2 >= maxX || y1 >= maxY && y2 >= maxY) {\n      return false;\n    }\n    const m = (y2 - y1) / (x2 - x1);\n    let y = m * (minX - x1) + y1;\n    if (y > minY && y < maxY)\n      return true;\n    y = m * (maxX - x1) + y1;\n    if (y > minY && y < maxY)\n      return true;\n    let x = (minY - y1) / m + x1;\n    if (x > minX && x < maxX)\n      return true;\n    x = (maxY - y1) / m + x1;\n    if (x > minX && x < maxX)\n      return true;\n    return false;\n  }\n  /** Returns true if the axis aligned bounding box intersects the axis aligned bounding box of the specified bounds. */\n  aabbIntersectsSkeleton(bounds) {\n    return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;\n  }\n  /** Returns the first bounding box attachment that contains the point, or null. When doing many checks, it is usually more\n   * efficient to only call this method if {@link #aabbContainsPoint(float, float)} returns true.\n   * Cannot be done here because BoundingBoxAttachment is not a thing yet*/\n  containsPoint(x, y) {\n    const polygons = this.polygons;\n    for (let i = 0, n = polygons.length; i < n; i++) {\n      if (this.containsPointPolygon(polygons[i], x, y))\n        return this.boundingBoxes[i];\n    }\n    return null;\n  }\n  /** Returns true if the polygon contains the point. */\n  containsPointPolygon(polygon, x, y) {\n    const vertices = polygon;\n    const nn = polygon.length;\n    let prevIndex = nn - 2;\n    let inside = false;\n    for (let ii = 0; ii < nn; ii += 2) {\n      const vertexY = vertices[ii + 1];\n      const prevY = vertices[prevIndex + 1];\n      if (vertexY < y && prevY >= y || prevY < y && vertexY >= y) {\n        const vertexX = vertices[ii];\n        if (vertexX + (y - vertexY) / (prevY - vertexY) * (vertices[prevIndex] - vertexX) < x)\n          inside = !inside;\n      }\n      prevIndex = ii;\n    }\n    return inside;\n  }\n  /** Returns the first bounding box attachment that contains any part of the line segment, or null. When doing many checks, it\n   * is usually more efficient to only call this method if {@link #aabbIntersectsSegment()} returns\n   * true. */\n  intersectsSegment(x1, y1, x2, y2) {\n    const polygons = this.polygons;\n    for (let i = 0, n = polygons.length; i < n; i++) {\n      if (this.intersectsSegmentPolygon(polygons[i], x1, y1, x2, y2))\n        return this.boundingBoxes[i];\n    }\n    return null;\n  }\n  /** Returns true if the polygon contains any part of the line segment. */\n  intersectsSegmentPolygon(polygon, x1, y1, x2, y2) {\n    const vertices = polygon;\n    const nn = polygon.length;\n    const width12 = x1 - x2;\n    const height12 = y1 - y2;\n    const det1 = x1 * y2 - y1 * x2;\n    let x3 = vertices[nn - 2];\n    let y3 = vertices[nn - 1];\n    for (let ii = 0; ii < nn; ii += 2) {\n      const x4 = vertices[ii];\n      const y4 = vertices[ii + 1];\n      const det2 = x3 * y4 - y3 * x4;\n      const width34 = x3 - x4;\n      const height34 = y3 - y4;\n      const det3 = width12 * height34 - height12 * width34;\n      const x = (det1 * width34 - width12 * det2) / det3;\n      if ((x >= x3 && x <= x4 || x >= x4 && x <= x3) && (x >= x1 && x <= x2 || x >= x2 && x <= x1)) {\n        const y = (det1 * height34 - height12 * det2) / det3;\n        if ((y >= y3 && y <= y4 || y >= y4 && y <= y3) && (y >= y1 && y <= y2 || y >= y2 && y <= y1))\n          return true;\n      }\n      x3 = x4;\n      y3 = y4;\n    }\n    return false;\n  }\n  /** Returns the polygon for the specified bounding box, or null. */\n  getPolygon(boundingBox) {\n    if (!boundingBox)\n      throw new Error(\"boundingBox cannot be null.\");\n    const index = this.boundingBoxes.indexOf(boundingBox);\n    return index == -1 ? null : this.polygons[index];\n  }\n  /** The width of the axis aligned bounding box. */\n  getWidth() {\n    return this.maxX - this.minX;\n  }\n  /** The height of the axis aligned bounding box. */\n  getHeight() {\n    return this.maxY - this.minY;\n  }\n}\n\nexport { SkeletonBoundsBase };\n//# sourceMappingURL=SkeletonBoundsBase.mjs.map\n","const settings = {\n  yDown: true,\n  /**\n   * pixi-spine gives option to not fail at certain parsing errors\n   * spine-ts fails here\n   */\n  FAIL_ON_NON_EXISTING_SKIN: false,\n  /**\n   * past Spine.globalAutoUpdate\n   */\n  GLOBAL_AUTO_UPDATE: true,\n  /**\n   * past Spine.globalDelayLimit\n   */\n  GLOBAL_DELAY_LIMIT: 0\n};\n\nexport { settings };\n//# sourceMappingURL=settings.mjs.map\n","import { AttachmentType } from './core/AttachmentType.mjs';\nimport { TextureRegion } from './core/TextureRegion.mjs';\nimport { MathUtils } from './core/Utils.mjs';\nimport { utils, Transform, DRAW_MODES, Polygon } from '@pixi/core';\nimport { Container } from '@pixi/display';\nimport { Sprite } from '@pixi/sprite';\nimport { SimpleMesh } from '@pixi/mesh-extras';\nimport { Graphics } from '@pixi/graphics';\nimport { settings } from './settings.mjs';\n\nconst tempRgb = [0, 0, 0];\nclass SpineSprite extends Sprite {\n  constructor() {\n    super(...arguments);\n    this.region = null;\n    this.attachment = null;\n  }\n}\nclass SpineMesh extends SimpleMesh {\n  constructor(texture, vertices, uvs, indices, drawMode) {\n    super(texture, vertices, uvs, indices, drawMode);\n    this.region = null;\n    this.attachment = null;\n  }\n}\nconst _SpineBase = class extends Container {\n  constructor(spineData) {\n    super();\n    if (!spineData) {\n      throw new Error(\"The spineData param is required.\");\n    }\n    if (typeof spineData === \"string\") {\n      throw new Error('spineData param cant be string. Please use spine.Spine.fromAtlas(\"YOUR_RESOURCE_NAME\") from now on.');\n    }\n    this.spineData = spineData;\n    this.createSkeleton(spineData);\n    this.slotContainers = [];\n    this.tempClipContainers = [];\n    for (let i = 0, n = this.skeleton.slots.length; i < n; i++) {\n      const slot = this.skeleton.slots[i];\n      const attachment = slot.getAttachment();\n      const slotContainer = this.newContainer();\n      this.slotContainers.push(slotContainer);\n      this.addChild(slotContainer);\n      this.tempClipContainers.push(null);\n      if (!attachment) {\n        continue;\n      }\n      if (attachment.type === AttachmentType.Region) {\n        const spriteName = attachment.name;\n        const sprite = this.createSprite(slot, attachment, spriteName);\n        slot.currentSprite = sprite;\n        slot.currentSpriteName = spriteName;\n        slotContainer.addChild(sprite);\n      } else if (attachment.type === AttachmentType.Mesh) {\n        const mesh = this.createMesh(slot, attachment);\n        slot.currentMesh = mesh;\n        slot.currentMeshId = attachment.id;\n        slot.currentMeshName = attachment.name;\n        slotContainer.addChild(mesh);\n      } else if (attachment.type === AttachmentType.Clipping) {\n        this.createGraphics(slot, attachment);\n        slotContainer.addChild(slot.clippingContainer);\n        slotContainer.addChild(slot.currentGraphics);\n      }\n    }\n    this.tintRgb = new Float32Array([1, 1, 1]);\n    this.autoUpdate = true;\n    this.visible = true;\n  }\n  get debug() {\n    return this._debug;\n  }\n  set debug(value) {\n    if (value == this._debug) {\n      return;\n    }\n    this._debug?.unregisterSpine(this);\n    value?.registerSpine(this);\n    this._debug = value;\n  }\n  /**\n   * If this flag is set to true, the spine animation will be automatically updated every\n   * time the object id drawn. The down side of this approach is that the delta time is\n   * automatically calculated and you could miss out on cool effects like slow motion,\n   * pause, skip ahead and the sorts. Most of these effects can be achieved even with\n   * autoUpdate enabled but are harder to achieve.\n   *\n   * @member {boolean}\n   * @memberof spine.Spine#\n   * @default true\n   */\n  get autoUpdate() {\n    return this._autoUpdate;\n  }\n  set autoUpdate(value) {\n    if (value !== this._autoUpdate) {\n      this._autoUpdate = value;\n      this.updateTransform = value ? _SpineBase.prototype.autoUpdateTransform : Container.prototype.updateTransform;\n    }\n  }\n  /**\n   * The tint applied to the spine object. This is a hex value. A value of 0xFFFFFF will remove any tint effect.\n   *\n   * @member {number}\n   * @memberof spine.Spine#\n   * @default 0xFFFFFF\n   */\n  get tint() {\n    return utils.rgb2hex(this.tintRgb);\n  }\n  set tint(value) {\n    this.tintRgb = utils.hex2rgb(value, this.tintRgb);\n  }\n  /**\n   * Limit value for the update dt with Spine.globalDelayLimit\n   * that can be overridden with localDelayLimit\n   * @return {number} - Maximum processed dt value for the update\n   */\n  get delayLimit() {\n    const limit = typeof this.localDelayLimit !== \"undefined\" ? this.localDelayLimit : settings.GLOBAL_DELAY_LIMIT;\n    return limit || Number.MAX_VALUE;\n  }\n  /**\n   * Update the spine skeleton and its animations by delta time (dt)\n   *\n   * @param dt {number} Delta time. Time by which the animation should be updated\n   */\n  update(dt) {\n    const delayLimit = this.delayLimit;\n    if (dt > delayLimit)\n      dt = delayLimit;\n    this.state.update(dt);\n    this.state.apply(this.skeleton);\n    if (!this.skeleton) {\n      return;\n    }\n    this.skeleton.updateWorldTransform();\n    const slots = this.skeleton.slots;\n    const globalClr = this.color;\n    let light = null;\n    let dark = null;\n    if (globalClr) {\n      light = globalClr.light;\n      dark = globalClr.dark;\n    } else {\n      light = this.tintRgb;\n    }\n    for (let i = 0, n = slots.length; i < n; i++) {\n      const slot = slots[i];\n      const attachment = slot.getAttachment();\n      const slotContainer = this.slotContainers[i];\n      if (!attachment) {\n        slotContainer.visible = false;\n        continue;\n      }\n      let spriteColor = null;\n      if (attachment.sequence) {\n        attachment.sequence.apply(slot, attachment);\n      }\n      let region = attachment.region;\n      const attColor = attachment.color;\n      switch (attachment != null && attachment.type) {\n        case AttachmentType.Region:\n          const transform = slotContainer.transform;\n          transform.setFromMatrix(slot.bone.matrix);\n          region = attachment.region;\n          if (slot.currentMesh) {\n            slot.currentMesh.visible = false;\n            slot.currentMesh = null;\n            slot.currentMeshId = void 0;\n            slot.currentMeshName = void 0;\n          }\n          if (!region) {\n            if (slot.currentSprite) {\n              slot.currentSprite.renderable = false;\n            }\n            break;\n          }\n          if (!slot.currentSpriteName || slot.currentSpriteName !== attachment.name) {\n            const spriteName = attachment.name;\n            if (slot.currentSprite) {\n              slot.currentSprite.visible = false;\n            }\n            slot.sprites = slot.sprites || {};\n            if (slot.sprites[spriteName] !== void 0) {\n              slot.sprites[spriteName].visible = true;\n            } else {\n              const sprite = this.createSprite(slot, attachment, spriteName);\n              slotContainer.addChild(sprite);\n            }\n            slot.currentSprite = slot.sprites[spriteName];\n            slot.currentSpriteName = spriteName;\n          }\n          slot.currentSprite.renderable = true;\n          if (!slot.hackRegion) {\n            this.setSpriteRegion(attachment, slot.currentSprite, region);\n          }\n          if (slot.currentSprite.color) {\n            spriteColor = slot.currentSprite.color;\n          } else {\n            tempRgb[0] = light[0] * slot.color.r * attColor.r;\n            tempRgb[1] = light[1] * slot.color.g * attColor.g;\n            tempRgb[2] = light[2] * slot.color.b * attColor.b;\n            slot.currentSprite.tint = utils.rgb2hex(tempRgb);\n          }\n          slot.currentSprite.blendMode = slot.blendMode;\n          break;\n        case AttachmentType.Mesh:\n          if (slot.currentSprite) {\n            slot.currentSprite.visible = false;\n            slot.currentSprite = null;\n            slot.currentSpriteName = void 0;\n            const transform2 = new Transform();\n            transform2._parentID = -1;\n            transform2._worldID = slotContainer.transform._worldID;\n            slotContainer.transform = transform2;\n          }\n          if (!region) {\n            if (slot.currentMesh) {\n              slot.currentMesh.renderable = false;\n            }\n            break;\n          }\n          const id = attachment.id;\n          if (slot.currentMeshId === void 0 || slot.currentMeshId !== id) {\n            const meshId = id;\n            if (slot.currentMesh) {\n              slot.currentMesh.visible = false;\n            }\n            slot.meshes = slot.meshes || {};\n            if (slot.meshes[meshId] !== void 0) {\n              slot.meshes[meshId].visible = true;\n            } else {\n              const mesh = this.createMesh(slot, attachment);\n              slotContainer.addChild(mesh);\n            }\n            slot.currentMesh = slot.meshes[meshId];\n            slot.currentMeshName = attachment.name;\n            slot.currentMeshId = meshId;\n          }\n          slot.currentMesh.renderable = true;\n          attachment.computeWorldVerticesOld(slot, slot.currentMesh.vertices);\n          if (slot.currentMesh.color) {\n            spriteColor = slot.currentMesh.color;\n          } else {\n            tempRgb[0] = light[0] * slot.color.r * attColor.r;\n            tempRgb[1] = light[1] * slot.color.g * attColor.g;\n            tempRgb[2] = light[2] * slot.color.b * attColor.b;\n            slot.currentMesh.tint = utils.rgb2hex(tempRgb);\n          }\n          slot.currentMesh.blendMode = slot.blendMode;\n          if (!slot.hackRegion) {\n            this.setMeshRegion(attachment, slot.currentMesh, region);\n          }\n          break;\n        case AttachmentType.Clipping:\n          if (!slot.currentGraphics) {\n            this.createGraphics(slot, attachment);\n            slotContainer.addChild(slot.clippingContainer);\n            slotContainer.addChild(slot.currentGraphics);\n          }\n          this.updateGraphics(slot, attachment);\n          slotContainer.alpha = 1;\n          slotContainer.visible = true;\n          continue;\n        default:\n          slotContainer.visible = false;\n          continue;\n      }\n      slotContainer.visible = true;\n      if (spriteColor) {\n        let r0 = slot.color.r * attColor.r;\n        let g0 = slot.color.g * attColor.g;\n        let b0 = slot.color.b * attColor.b;\n        spriteColor.setLight(light[0] * r0 + dark[0] * (1 - r0), light[1] * g0 + dark[1] * (1 - g0), light[2] * b0 + dark[2] * (1 - b0));\n        if (slot.darkColor) {\n          r0 = slot.darkColor.r;\n          g0 = slot.darkColor.g;\n          b0 = slot.darkColor.b;\n        } else {\n          r0 = 0;\n          g0 = 0;\n          b0 = 0;\n        }\n        spriteColor.setDark(light[0] * r0 + dark[0] * (1 - r0), light[1] * g0 + dark[1] * (1 - g0), light[2] * b0 + dark[2] * (1 - b0));\n      }\n      slotContainer.alpha = slot.color.a;\n    }\n    const drawOrder = this.skeleton.drawOrder;\n    let clippingAttachment = null;\n    let clippingContainer = null;\n    for (let i = 0, n = drawOrder.length; i < n; i++) {\n      const slot = slots[drawOrder[i].data.index];\n      const slotContainer = this.slotContainers[drawOrder[i].data.index];\n      if (!clippingContainer) {\n        if (slotContainer.parent !== null && slotContainer.parent !== this) {\n          slotContainer.parent.removeChild(slotContainer);\n          slotContainer.parent = this;\n        }\n      }\n      if (slot.currentGraphics && slot.getAttachment()) {\n        clippingContainer = slot.clippingContainer;\n        clippingAttachment = slot.getAttachment();\n        clippingContainer.children.length = 0;\n        this.children[i] = slotContainer;\n        if (clippingAttachment.endSlot === slot.data) {\n          clippingAttachment.endSlot = null;\n        }\n      } else if (clippingContainer) {\n        let c = this.tempClipContainers[i];\n        if (!c) {\n          c = this.tempClipContainers[i] = this.newContainer();\n          c.visible = false;\n        }\n        this.children[i] = c;\n        slotContainer.parent = null;\n        clippingContainer.addChild(slotContainer);\n        if (clippingAttachment.endSlot == slot.data) {\n          clippingContainer.renderable = true;\n          clippingContainer = null;\n          clippingAttachment = null;\n        }\n      } else {\n        this.children[i] = slotContainer;\n      }\n    }\n    this._debug?.renderDebug(this);\n  }\n  setSpriteRegion(attachment, sprite, region) {\n    if (sprite.attachment === attachment && sprite.region === region) {\n      return;\n    }\n    sprite.region = region;\n    sprite.attachment = attachment;\n    sprite.texture = region.texture;\n    sprite.rotation = attachment.rotation * MathUtils.degRad;\n    sprite.position.x = attachment.x;\n    sprite.position.y = attachment.y;\n    sprite.alpha = attachment.color.a;\n    if (!region.size) {\n      sprite.scale.x = attachment.scaleX * attachment.width / region.originalWidth;\n      sprite.scale.y = -attachment.scaleY * attachment.height / region.originalHeight;\n    } else {\n      sprite.scale.x = region.size.width / region.originalWidth;\n      sprite.scale.y = -region.size.height / region.originalHeight;\n    }\n  }\n  setMeshRegion(attachment, mesh, region) {\n    if (mesh.attachment === attachment && mesh.region === region) {\n      return;\n    }\n    mesh.region = region;\n    mesh.attachment = attachment;\n    mesh.texture = region.texture;\n    region.texture.updateUvs();\n    mesh.uvBuffer.update(attachment.regionUVs);\n  }\n  /**\n   * When autoupdate is set to yes this function is used as pixi's updateTransform function\n   *\n   * @private\n   */\n  autoUpdateTransform() {\n    if (settings.GLOBAL_AUTO_UPDATE) {\n      this.lastTime = this.lastTime || Date.now();\n      const timeDelta = (Date.now() - this.lastTime) * 1e-3;\n      this.lastTime = Date.now();\n      this.update(timeDelta);\n    } else {\n      this.lastTime = 0;\n    }\n    Container.prototype.updateTransform.call(this);\n  }\n  /**\n   * Create a new sprite to be used with core.RegionAttachment\n   *\n   * @param slot {spine.Slot} The slot to which the attachment is parented\n   * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\n   * @private\n   */\n  createSprite(slot, attachment, defName) {\n    let region = attachment.region;\n    if (slot.hackAttachment === attachment) {\n      region = slot.hackRegion;\n    }\n    const texture = region ? region.texture : null;\n    const sprite = this.newSprite(texture);\n    sprite.anchor.set(0.5);\n    if (region) {\n      this.setSpriteRegion(attachment, sprite, attachment.region);\n    }\n    slot.sprites = slot.sprites || {};\n    slot.sprites[defName] = sprite;\n    return sprite;\n  }\n  /**\n   * Creates a Strip from the spine data\n   * @param slot {spine.Slot} The slot to which the attachment is parented\n   * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\n   * @private\n   */\n  createMesh(slot, attachment) {\n    let region = attachment.region;\n    if (slot.hackAttachment === attachment) {\n      region = slot.hackRegion;\n      slot.hackAttachment = null;\n      slot.hackRegion = null;\n    }\n    const strip = this.newMesh(\n      region ? region.texture : null,\n      new Float32Array(attachment.regionUVs.length),\n      attachment.regionUVs,\n      new Uint16Array(attachment.triangles),\n      DRAW_MODES.TRIANGLES\n    );\n    if (typeof strip._canvasPadding !== \"undefined\") {\n      strip._canvasPadding = 1.5;\n    }\n    strip.alpha = attachment.color.a;\n    strip.region = attachment.region;\n    if (region) {\n      this.setMeshRegion(attachment, strip, region);\n    }\n    slot.meshes = slot.meshes || {};\n    slot.meshes[attachment.id] = strip;\n    return strip;\n  }\n  // @ts-ignore\n  createGraphics(slot, clip) {\n    const graphics = this.newGraphics();\n    const poly = new Polygon([]);\n    graphics.clear();\n    graphics.beginFill(16777215, 1);\n    graphics.drawPolygon(poly);\n    graphics.renderable = false;\n    slot.currentGraphics = graphics;\n    slot.clippingContainer = this.newContainer();\n    slot.clippingContainer.mask = slot.currentGraphics;\n    return graphics;\n  }\n  updateGraphics(slot, clip) {\n    const geom = slot.currentGraphics.geometry;\n    const vertices = geom.graphicsData[0].shape.points;\n    const n = clip.worldVerticesLength;\n    vertices.length = n;\n    clip.computeWorldVertices(slot, 0, n, vertices, 0, 2);\n    geom.invalidate();\n  }\n  /**\n   * Changes texture in attachment in specific slot.\n   *\n   * PIXI runtime feature, it was made to satisfy our users.\n   *\n   * @param slotIndex {number}\n   * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\n   * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\n   * @returns {boolean} Success flag\n   */\n  hackTextureBySlotIndex(slotIndex, texture = null, size = null) {\n    const slot = this.skeleton.slots[slotIndex];\n    if (!slot) {\n      return false;\n    }\n    const attachment = slot.getAttachment();\n    let region = attachment.region;\n    if (texture) {\n      region = new TextureRegion();\n      region.texture = texture;\n      region.size = size;\n      slot.hackRegion = region;\n      slot.hackAttachment = attachment;\n    } else {\n      slot.hackRegion = null;\n      slot.hackAttachment = null;\n    }\n    if (slot.currentSprite) {\n      this.setSpriteRegion(attachment, slot.currentSprite, region);\n    } else if (slot.currentMesh) {\n      this.setMeshRegion(attachment, slot.currentMesh, region);\n    }\n    return true;\n  }\n  /**\n   * Changes texture in attachment in specific slot.\n   *\n   * PIXI runtime feature, it was made to satisfy our users.\n   *\n   * @param slotName {string}\n   * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\n   * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\n   * @returns {boolean} Success flag\n   */\n  hackTextureBySlotName(slotName, texture = null, size = null) {\n    const index = this.skeleton.findSlotIndex(slotName);\n    if (index == -1) {\n      return false;\n    }\n    return this.hackTextureBySlotIndex(index, texture, size);\n  }\n  /**\n   * Changes texture of an attachment\n   *\n   * PIXI runtime feature, it was made to satisfy our users.\n   *\n   * @param slotName {string}\n   * @param attachmentName {string}\n   * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\n   * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\n   * @returns {boolean} Success flag\n   */\n  hackTextureAttachment(slotName, attachmentName, texture, size = null) {\n    const slotIndex = this.skeleton.findSlotIndex(slotName);\n    const attachment = this.skeleton.getAttachmentByName(slotName, attachmentName);\n    attachment.region.texture = texture;\n    const slot = this.skeleton.slots[slotIndex];\n    if (!slot) {\n      return false;\n    }\n    const currentAttachment = slot.getAttachment();\n    if (attachmentName === currentAttachment.name) {\n      let region = attachment.region;\n      if (texture) {\n        region = new TextureRegion();\n        region.texture = texture;\n        region.size = size;\n        slot.hackRegion = region;\n        slot.hackAttachment = currentAttachment;\n      } else {\n        slot.hackRegion = null;\n        slot.hackAttachment = null;\n      }\n      if (slot.currentSprite && slot.currentSprite.region != region) {\n        this.setSpriteRegion(currentAttachment, slot.currentSprite, region);\n        slot.currentSprite.region = region;\n      } else if (slot.currentMesh && slot.currentMesh.region != region) {\n        this.setMeshRegion(currentAttachment, slot.currentMesh, region);\n      }\n      return true;\n    }\n    return false;\n  }\n  // those methods can be overriden to spawn different classes\n  newContainer() {\n    return new Container();\n  }\n  newSprite(tex) {\n    return new SpineSprite(tex);\n  }\n  newGraphics() {\n    return new Graphics();\n  }\n  newMesh(texture, vertices, uvs, indices, drawMode) {\n    return new SpineMesh(texture, vertices, uvs, indices, drawMode);\n  }\n  transformHack() {\n    return 1;\n  }\n  /**\n   * Hack for pixi-display and pixi-lights. Every attachment name ending with a suffix will be added to different layer\n   * @param nameSuffix\n   * @param group\n   * @param outGroup\n   */\n  hackAttachmentGroups(nameSuffix, group, outGroup) {\n    if (!nameSuffix) {\n      return void 0;\n    }\n    const list_d = [];\n    const list_n = [];\n    for (let i = 0, len = this.skeleton.slots.length; i < len; i++) {\n      const slot = this.skeleton.slots[i];\n      const name = slot.currentSpriteName || slot.currentMeshName || \"\";\n      const target = slot.currentSprite || slot.currentMesh;\n      if (name.endsWith(nameSuffix)) {\n        target.parentGroup = group;\n        list_n.push(target);\n      } else if (outGroup && target) {\n        target.parentGroup = outGroup;\n        list_d.push(target);\n      }\n    }\n    return [list_d, list_n];\n  }\n  destroy(options) {\n    this.debug = null;\n    for (let i = 0, n = this.skeleton.slots.length; i < n; i++) {\n      const slot = this.skeleton.slots[i];\n      for (const name in slot.meshes) {\n        slot.meshes[name].destroy(options);\n      }\n      slot.meshes = null;\n      for (const name in slot.sprites) {\n        slot.sprites[name].destroy(options);\n      }\n      slot.sprites = null;\n    }\n    for (let i = 0, n = this.slotContainers.length; i < n; i++) {\n      this.slotContainers[i].destroy(options);\n    }\n    this.spineData = null;\n    this.skeleton = null;\n    this.slotContainers = null;\n    this.stateData = null;\n    this.state = null;\n    this.tempClipContainers = null;\n    super.destroy(options);\n  }\n};\nlet SpineBase = _SpineBase;\nSpineBase.clippingPolygon = [];\nObject.defineProperty(SpineBase.prototype, \"visible\", {\n  get() {\n    return this._visible;\n  },\n  set(value) {\n    if (value !== this._visible) {\n      this._visible = value;\n      if (value) {\n        this.lastTime = 0;\n      }\n    }\n  }\n});\n\nexport { SpineBase, SpineMesh, SpineSprite };\n//# sourceMappingURL=SpineBase.mjs.map\n","import { Container } from '@pixi/display';\nimport { Graphics } from '@pixi/graphics';\nimport { AttachmentType } from './core/AttachmentType.mjs';\nimport { SkeletonBoundsBase } from './core/SkeletonBoundsBase.mjs';\n\nclass SpineDebugRenderer {\n  constructor() {\n    this.registeredSpines = /* @__PURE__ */ new Map();\n    this.drawDebug = true;\n    this.drawMeshHull = true;\n    this.drawMeshTriangles = true;\n    this.drawBones = true;\n    this.drawPaths = true;\n    this.drawBoundingBoxes = true;\n    this.drawClipping = true;\n    this.drawRegionAttachments = true;\n    this.lineWidth = 1;\n    this.regionAttachmentsColor = 30975;\n    this.meshHullColor = 30975;\n    this.meshTrianglesColor = 16763904;\n    this.clippingPolygonColor = 16711935;\n    this.boundingBoxesRectColor = 65280;\n    this.boundingBoxesPolygonColor = 65280;\n    this.boundingBoxesCircleColor = 65280;\n    this.pathsCurveColor = 16711680;\n    this.pathsLineColor = 16711935;\n    this.skeletonXYColor = 16711680;\n    this.bonesColor = 61132;\n  }\n  /**\n   * The debug is attached by force to each spine object. So we need to create it inside the spine when we get the first update\n   */\n  registerSpine(spine) {\n    if (this.registeredSpines.has(spine)) {\n      console.warn(\"SpineDebugRenderer.registerSpine() - this spine is already registered!\", spine);\n    }\n    const debugDisplayObjects = {\n      parentDebugContainer: new Container(),\n      bones: new Container(),\n      skeletonXY: new Graphics(),\n      regionAttachmentsShape: new Graphics(),\n      meshTrianglesLine: new Graphics(),\n      meshHullLine: new Graphics(),\n      clippingPolygon: new Graphics(),\n      boundingBoxesRect: new Graphics(),\n      boundingBoxesCircle: new Graphics(),\n      boundingBoxesPolygon: new Graphics(),\n      pathsCurve: new Graphics(),\n      pathsLine: new Graphics()\n    };\n    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.bones);\n    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.skeletonXY);\n    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.regionAttachmentsShape);\n    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.meshTrianglesLine);\n    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.meshHullLine);\n    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.clippingPolygon);\n    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.boundingBoxesRect);\n    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.boundingBoxesCircle);\n    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.boundingBoxesPolygon);\n    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.pathsCurve);\n    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.pathsLine);\n    spine.addChild(debugDisplayObjects.parentDebugContainer);\n    this.registeredSpines.set(spine, debugDisplayObjects);\n  }\n  renderDebug(spine) {\n    if (!this.registeredSpines.has(spine)) {\n      this.registerSpine(spine);\n    }\n    const debugDisplayObjects = this.registeredSpines.get(spine);\n    debugDisplayObjects.skeletonXY.clear();\n    debugDisplayObjects.regionAttachmentsShape.clear();\n    debugDisplayObjects.meshTrianglesLine.clear();\n    debugDisplayObjects.meshHullLine.clear();\n    debugDisplayObjects.clippingPolygon.clear();\n    debugDisplayObjects.boundingBoxesRect.clear();\n    debugDisplayObjects.boundingBoxesCircle.clear();\n    debugDisplayObjects.boundingBoxesPolygon.clear();\n    debugDisplayObjects.pathsCurve.clear();\n    debugDisplayObjects.pathsLine.clear();\n    for (let len = debugDisplayObjects.bones.children.length; len > 0; len--) {\n      debugDisplayObjects.bones.children[len - 1].destroy({ children: true, texture: true, baseTexture: true });\n    }\n    const scale = spine.scale.x || spine.scale.y || 1;\n    const lineWidth = this.lineWidth / scale;\n    if (this.drawBones) {\n      this.drawBonesFunc(spine, debugDisplayObjects, lineWidth, scale);\n    }\n    if (this.drawPaths) {\n      this.drawPathsFunc(spine, debugDisplayObjects, lineWidth);\n    }\n    if (this.drawBoundingBoxes) {\n      this.drawBoundingBoxesFunc(spine, debugDisplayObjects, lineWidth);\n    }\n    if (this.drawClipping) {\n      this.drawClippingFunc(spine, debugDisplayObjects, lineWidth);\n    }\n    if (this.drawMeshHull || this.drawMeshTriangles) {\n      this.drawMeshHullAndMeshTriangles(spine, debugDisplayObjects, lineWidth);\n    }\n    if (this.drawRegionAttachments) {\n      this.drawRegionAttachmentsFunc(spine, debugDisplayObjects, lineWidth);\n    }\n  }\n  drawBonesFunc(spine, debugDisplayObjects, lineWidth, scale) {\n    const skeleton = spine.skeleton;\n    const skeletonX = skeleton.x;\n    const skeletonY = skeleton.y;\n    const bones = skeleton.bones;\n    debugDisplayObjects.skeletonXY.lineStyle(lineWidth, this.skeletonXYColor, 1);\n    for (let i = 0, len = bones.length; i < len; i++) {\n      const bone = bones[i];\n      const boneLen = bone.data.length;\n      const starX = skeletonX + bone.matrix.tx;\n      const starY = skeletonY + bone.matrix.ty;\n      const endX = skeletonX + boneLen * bone.matrix.a + bone.matrix.tx;\n      const endY = skeletonY + boneLen * bone.matrix.b + bone.matrix.ty;\n      if (bone.data.name === \"root\" || bone.data.parent === null) {\n        continue;\n      }\n      const w = Math.abs(starX - endX);\n      const h = Math.abs(starY - endY);\n      const a2 = Math.pow(w, 2);\n      const b = h;\n      const b2 = Math.pow(h, 2);\n      const c = Math.sqrt(a2 + b2);\n      const c2 = Math.pow(c, 2);\n      const rad = Math.PI / 180;\n      const B = Math.acos((c2 + b2 - a2) / (2 * b * c)) || 0;\n      if (c === 0) {\n        continue;\n      }\n      const gp = new Graphics();\n      debugDisplayObjects.bones.addChild(gp);\n      const refRation = c / 50 / scale;\n      gp.beginFill(this.bonesColor, 1);\n      gp.drawPolygon(0, 0, 0 - refRation, c - refRation * 3, 0, c - refRation, 0 + refRation, c - refRation * 3);\n      gp.endFill();\n      gp.x = starX;\n      gp.y = starY;\n      gp.pivot.y = c;\n      let rotation = 0;\n      if (starX < endX && starY < endY) {\n        rotation = -B + 180 * rad;\n      } else if (starX > endX && starY < endY) {\n        rotation = 180 * rad + B;\n      } else if (starX > endX && starY > endY) {\n        rotation = -B;\n      } else if (starX < endX && starY > endY) {\n        rotation = B;\n      } else if (starY === endY && starX < endX) {\n        rotation = 90 * rad;\n      } else if (starY === endY && starX > endX) {\n        rotation = -90 * rad;\n      } else if (starX === endX && starY < endY) {\n        rotation = 180 * rad;\n      } else if (starX === endX && starY > endY) {\n        rotation = 0;\n      }\n      gp.rotation = rotation;\n      gp.lineStyle(lineWidth + refRation / 2.4, this.bonesColor, 1);\n      gp.beginFill(0, 0.6);\n      gp.drawCircle(0, c, refRation * 1.2);\n      gp.endFill();\n    }\n    const startDotSize = lineWidth * 3;\n    debugDisplayObjects.skeletonXY.moveTo(skeletonX - startDotSize, skeletonY - startDotSize);\n    debugDisplayObjects.skeletonXY.lineTo(skeletonX + startDotSize, skeletonY + startDotSize);\n    debugDisplayObjects.skeletonXY.moveTo(skeletonX + startDotSize, skeletonY - startDotSize);\n    debugDisplayObjects.skeletonXY.lineTo(skeletonX - startDotSize, skeletonY + startDotSize);\n  }\n  drawRegionAttachmentsFunc(spine, debugDisplayObjects, lineWidth) {\n    const skeleton = spine.skeleton;\n    const slots = skeleton.slots;\n    debugDisplayObjects.regionAttachmentsShape.lineStyle(lineWidth, this.regionAttachmentsColor, 1);\n    for (let i = 0, len = slots.length; i < len; i++) {\n      const slot = slots[i];\n      const attachment = slot.getAttachment();\n      if (attachment == null || attachment.type !== AttachmentType.Region) {\n        continue;\n      }\n      const regionAttachment = attachment;\n      const vertices = new Float32Array(8);\n      if (regionAttachment.updateOffset)\n        regionAttachment.updateOffset();\n      regionAttachment.computeWorldVertices(slot, vertices, 0, 2);\n      debugDisplayObjects.regionAttachmentsShape.drawPolygon(Array.from(vertices.slice(0, 8)));\n    }\n  }\n  drawMeshHullAndMeshTriangles(spine, debugDisplayObjects, lineWidth) {\n    const skeleton = spine.skeleton;\n    const slots = skeleton.slots;\n    debugDisplayObjects.meshHullLine.lineStyle(lineWidth, this.meshHullColor, 1);\n    debugDisplayObjects.meshTrianglesLine.lineStyle(lineWidth, this.meshTrianglesColor, 1);\n    for (let i = 0, len = slots.length; i < len; i++) {\n      const slot = slots[i];\n      if (!slot.bone.active) {\n        continue;\n      }\n      const attachment = slot.getAttachment();\n      if (attachment == null || attachment.type !== AttachmentType.Mesh) {\n        continue;\n      }\n      const meshAttachment = attachment;\n      const vertices = new Float32Array(meshAttachment.worldVerticesLength);\n      const triangles = meshAttachment.triangles;\n      let hullLength = meshAttachment.hullLength;\n      meshAttachment.computeWorldVertices(slot, 0, meshAttachment.worldVerticesLength, vertices, 0, 2);\n      if (this.drawMeshTriangles) {\n        for (let i2 = 0, len2 = triangles.length; i2 < len2; i2 += 3) {\n          const v1 = triangles[i2] * 2;\n          const v2 = triangles[i2 + 1] * 2;\n          const v3 = triangles[i2 + 2] * 2;\n          debugDisplayObjects.meshTrianglesLine.moveTo(vertices[v1], vertices[v1 + 1]);\n          debugDisplayObjects.meshTrianglesLine.lineTo(vertices[v2], vertices[v2 + 1]);\n          debugDisplayObjects.meshTrianglesLine.lineTo(vertices[v3], vertices[v3 + 1]);\n        }\n      }\n      if (this.drawMeshHull && hullLength > 0) {\n        hullLength = (hullLength >> 1) * 2;\n        let lastX = vertices[hullLength - 2];\n        let lastY = vertices[hullLength - 1];\n        for (let i2 = 0, len2 = hullLength; i2 < len2; i2 += 2) {\n          const x = vertices[i2];\n          const y = vertices[i2 + 1];\n          debugDisplayObjects.meshHullLine.moveTo(x, y);\n          debugDisplayObjects.meshHullLine.lineTo(lastX, lastY);\n          lastX = x;\n          lastY = y;\n        }\n      }\n    }\n  }\n  drawClippingFunc(spine, debugDisplayObjects, lineWidth) {\n    const skeleton = spine.skeleton;\n    const slots = skeleton.slots;\n    debugDisplayObjects.clippingPolygon.lineStyle(lineWidth, this.clippingPolygonColor, 1);\n    for (let i = 0, len = slots.length; i < len; i++) {\n      const slot = slots[i];\n      if (!slot.bone.active) {\n        continue;\n      }\n      const attachment = slot.getAttachment();\n      if (attachment == null || attachment.type !== AttachmentType.Clipping) {\n        continue;\n      }\n      const clippingAttachment = attachment;\n      const nn = clippingAttachment.worldVerticesLength;\n      const world = new Float32Array(nn);\n      clippingAttachment.computeWorldVertices(slot, 0, nn, world, 0, 2);\n      debugDisplayObjects.clippingPolygon.drawPolygon(Array.from(world));\n    }\n  }\n  drawBoundingBoxesFunc(spine, debugDisplayObjects, lineWidth) {\n    debugDisplayObjects.boundingBoxesRect.lineStyle(lineWidth, this.boundingBoxesRectColor, 5);\n    const bounds = new SkeletonBoundsBase();\n    bounds.update(spine.skeleton, true);\n    debugDisplayObjects.boundingBoxesRect.drawRect(bounds.minX, bounds.minY, bounds.getWidth(), bounds.getHeight());\n    const polygons = bounds.polygons;\n    const drawPolygon = (polygonVertices, _offset, count) => {\n      debugDisplayObjects.boundingBoxesPolygon.lineStyle(lineWidth, this.boundingBoxesPolygonColor, 1);\n      debugDisplayObjects.boundingBoxesPolygon.beginFill(this.boundingBoxesPolygonColor, 0.1);\n      if (count < 3) {\n        throw new Error(\"Polygon must contain at least 3 vertices\");\n      }\n      const paths = [];\n      const dotSize = lineWidth * 2;\n      for (let i = 0, len = polygonVertices.length; i < len; i += 2) {\n        const x1 = polygonVertices[i];\n        const y1 = polygonVertices[i + 1];\n        debugDisplayObjects.boundingBoxesCircle.lineStyle(0);\n        debugDisplayObjects.boundingBoxesCircle.beginFill(this.boundingBoxesCircleColor);\n        debugDisplayObjects.boundingBoxesCircle.drawCircle(x1, y1, dotSize);\n        debugDisplayObjects.boundingBoxesCircle.endFill();\n        paths.push(x1, y1);\n      }\n      debugDisplayObjects.boundingBoxesPolygon.drawPolygon(paths);\n      debugDisplayObjects.boundingBoxesPolygon.endFill();\n    };\n    for (let i = 0, len = polygons.length; i < len; i++) {\n      const polygon = polygons[i];\n      drawPolygon(polygon, 0, polygon.length);\n    }\n  }\n  drawPathsFunc(spine, debugDisplayObjects, lineWidth) {\n    const skeleton = spine.skeleton;\n    const slots = skeleton.slots;\n    debugDisplayObjects.pathsCurve.lineStyle(lineWidth, this.pathsCurveColor, 1);\n    debugDisplayObjects.pathsLine.lineStyle(lineWidth, this.pathsLineColor, 1);\n    for (let i = 0, len = slots.length; i < len; i++) {\n      const slot = slots[i];\n      if (!slot.bone.active) {\n        continue;\n      }\n      const attachment = slot.getAttachment();\n      if (attachment == null || attachment.type !== AttachmentType.Path) {\n        continue;\n      }\n      const pathAttachment = attachment;\n      let nn = pathAttachment.worldVerticesLength;\n      const world = new Float32Array(nn);\n      pathAttachment.computeWorldVertices(slot, 0, nn, world, 0, 2);\n      let x1 = world[2];\n      let y1 = world[3];\n      let x2 = 0;\n      let y2 = 0;\n      if (pathAttachment.closed) {\n        const cx1 = world[0];\n        const cy1 = world[1];\n        const cx2 = world[nn - 2];\n        const cy2 = world[nn - 1];\n        x2 = world[nn - 4];\n        y2 = world[nn - 3];\n        debugDisplayObjects.pathsCurve.moveTo(x1, y1);\n        debugDisplayObjects.pathsCurve.bezierCurveTo(cx1, cy1, cx2, cy2, x2, y2);\n        debugDisplayObjects.pathsLine.moveTo(x1, y1);\n        debugDisplayObjects.pathsLine.lineTo(cx1, cy1);\n        debugDisplayObjects.pathsLine.moveTo(x2, y2);\n        debugDisplayObjects.pathsLine.lineTo(cx2, cy2);\n      }\n      nn -= 4;\n      for (let ii = 4; ii < nn; ii += 6) {\n        const cx1 = world[ii];\n        const cy1 = world[ii + 1];\n        const cx2 = world[ii + 2];\n        const cy2 = world[ii + 3];\n        x2 = world[ii + 4];\n        y2 = world[ii + 5];\n        debugDisplayObjects.pathsCurve.moveTo(x1, y1);\n        debugDisplayObjects.pathsCurve.bezierCurveTo(cx1, cy1, cx2, cy2, x2, y2);\n        debugDisplayObjects.pathsLine.moveTo(x1, y1);\n        debugDisplayObjects.pathsLine.lineTo(cx1, cy1);\n        debugDisplayObjects.pathsLine.moveTo(x2, y2);\n        debugDisplayObjects.pathsLine.lineTo(cx2, cy2);\n        x1 = x2;\n        y1 = y2;\n      }\n    }\n  }\n  unregisterSpine(spine) {\n    if (!this.registeredSpines.has(spine)) {\n      console.warn(\"SpineDebugRenderer.unregisterSpine() - spine is not registered, can't unregister!\", spine);\n    }\n    const debugDisplayObjects = this.registeredSpines.get(spine);\n    debugDisplayObjects.parentDebugContainer.destroy({ baseTexture: true, children: true, texture: true });\n    this.registeredSpines.delete(spine);\n  }\n}\n\nexport { SpineDebugRenderer };\n//# sourceMappingURL=SpineDebugRenderer.mjs.map\n","import { TextureAtlas } from '@pixi-spine/base';\nimport { LoaderParserPriority, checkExtension } from '@pixi/assets';\nimport { ExtensionType, settings, utils, extensions } from '@pixi/core';\n\nconst spineTextureAtlasLoader = {\n  extension: ExtensionType.Asset,\n  // cache: {\n  //     test: (asset: RawAtlas | TextureAtlas) => asset instanceof TextureAtlas,\n  //     getCacheableAssets: (keys: string[], asset: RawAtlas | TextureAtlas) => getCacheableAssets(keys, asset),\n  // },\n  loader: {\n    extension: {\n      type: ExtensionType.LoadParser,\n      priority: LoaderParserPriority.Normal\n    },\n    test(url) {\n      return checkExtension(url, \".atlas\");\n    },\n    async load(url) {\n      const response = await settings.ADAPTER.fetch(url);\n      const txt = await response.text();\n      return txt;\n    },\n    testParse(asset, options) {\n      const isExtensionRight = checkExtension(options.src, \".atlas\");\n      const isString = typeof asset === \"string\";\n      return Promise.resolve(isExtensionRight && isString);\n    },\n    async parse(asset, options, loader) {\n      const metadata = options.data;\n      let basePath = utils.path.dirname(options.src);\n      if (basePath && basePath.lastIndexOf(\"/\") !== basePath.length - 1) {\n        basePath += \"/\";\n      }\n      let resolve = null;\n      let reject = null;\n      const retPromise = new Promise((res, rej) => {\n        resolve = res;\n        reject = rej;\n      });\n      let retval;\n      const resolveCallback = (newAtlas) => {\n        if (!newAtlas) {\n          reject(\"Something went terribly wrong loading a spine .atlas file\\nMost likely your texture failed to load.\");\n        }\n        resolve(retval);\n      };\n      if (metadata.image || metadata.images) {\n        const pages = Object.assign(metadata.image ? { default: metadata.image } : {}, metadata.images);\n        retval = new TextureAtlas(\n          asset,\n          (line, callback) => {\n            const page = pages[line] || pages.default;\n            if (page && page.baseTexture)\n              callback(page.baseTexture);\n            else\n              callback(page);\n          },\n          resolveCallback\n        );\n      } else {\n        retval = new TextureAtlas(asset, makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject(loader, basePath, metadata.imageMetadata), resolveCallback);\n      }\n      return await retPromise;\n    },\n    unload(atlas) {\n      atlas.dispose();\n    }\n  }\n};\nconst makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject = (loader, atlasBasePath, imageMetadata, imageURL) => {\n  return async (pageName, textureLoadedCallback) => {\n    const url = utils.path.normalize([...atlasBasePath.split(utils.path.sep), pageName].join(utils.path.sep));\n    const texture = await loader.load(imageURL ? imageURL : { src: url, data: imageMetadata });\n    textureLoadedCallback(texture.baseTexture);\n  };\n};\nextensions.add(spineTextureAtlasLoader);\n\nexport { makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject };\n//# sourceMappingURL=atlasLoader.mjs.map\n","import { TextureAtlas } from '@pixi-spine/base';\nimport { LoaderParserPriority, checkExtension, checkDataUrl } from '@pixi/assets';\nimport { ExtensionType, settings, utils, extensions } from '@pixi/core';\nimport { makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject } from './atlasLoader.mjs';\n\nconst validJSONExtension = \".json\";\nconst validJSONMIME = \"application/json\";\nconst validAtlasMIMEs = [\"application/octet-stream\", \"text/plain\"];\nconst validImageMIMEs = [\"image/jpeg\", \"image/png\"];\nfunction isJson(resource) {\n  return resource.hasOwnProperty(\"bones\");\n}\nfunction isBuffer(resource) {\n  return resource instanceof ArrayBuffer;\n}\nclass SpineLoaderAbstract {\n  constructor() {\n  }\n  installLoader() {\n    const spineAdapter = this;\n    const spineLoaderExtension = {\n      extension: ExtensionType.Asset,\n      loader: {\n        extension: {\n          type: ExtensionType.LoadParser,\n          priority: LoaderParserPriority.Normal\n        },\n        // #region Downloading skel buffer data\n        test(url) {\n          return checkExtension(url, \".skel\");\n        },\n        async load(url) {\n          const isSpineSkelFileURL = checkDataUrl(url, validAtlasMIMEs);\n          const buffer = isSpineSkelFileURL ? dataURLToArrayBuffer(url.slice(0, url.lastIndexOf(\".\"))) : await (await settings.ADAPTER.fetch(url)).arrayBuffer();\n          return buffer;\n        },\n        // #endregion\n        // #region Parsing spine data\n        testParse(asset, options) {\n          const isJsonSpineModel = checkDataUrl(options.src, validJSONMIME) || checkExtension(options.src, validJSONExtension) && isJson(asset);\n          const isBinarySpineModel = checkExtension(options.src, \".skel\") && isBuffer(asset);\n          const isMetadataAngry = options.data?.spineAtlas === false;\n          return Promise.resolve(isJsonSpineModel && !isMetadataAngry || isBinarySpineModel);\n        },\n        async parse(asset, loadAsset, loader) {\n          const fileExt = utils.path.extname(loadAsset.src).toLowerCase();\n          const fileName = utils.path.basename(loadAsset.src, fileExt);\n          let basePath = utils.path.dirname(loadAsset.src);\n          if (basePath && basePath.lastIndexOf(\"/\") !== basePath.length - 1) {\n            basePath += \"/\";\n          }\n          const isJsonSpineModel = checkDataUrl(loadAsset.src, validJSONMIME) || checkExtension(loadAsset.src, validJSONExtension) && isJson(asset);\n          let parser = null;\n          let dataToParse = asset;\n          if (isJsonSpineModel) {\n            parser = spineAdapter.createJsonParser();\n          } else {\n            parser = spineAdapter.createBinaryParser();\n            dataToParse = new Uint8Array(asset);\n          }\n          const metadata = loadAsset.data || {};\n          const metadataSkeletonScale = metadata?.spineSkeletonScale ?? null;\n          if (metadataSkeletonScale) {\n            parser.scale = metadataSkeletonScale;\n          }\n          const metadataAtlas = metadata.spineAtlas;\n          if (metadataAtlas && metadataAtlas.pages) {\n            return spineAdapter.parseData(parser, metadataAtlas, dataToParse);\n          }\n          let textAtlas = metadata.atlasRawData;\n          const isSpineAtlasFileURL = checkDataUrl(metadata.spineAtlasFile, validAtlasMIMEs);\n          if (isSpineAtlasFileURL) {\n            textAtlas = atob(metadata.spineAtlasFile.split(\",\")[1]);\n          }\n          if (textAtlas) {\n            let auxResolve = null;\n            let auxReject = null;\n            const atlasPromise = new Promise((resolve, reject) => {\n              auxResolve = resolve;\n              auxReject = reject;\n            });\n            const imageURL = typeof metadata.image === \"string\" && checkDataUrl(metadata.image, validImageMIMEs) ? metadata.image : null;\n            const atlas = new TextureAtlas(\n              textAtlas,\n              makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject(loader, basePath, metadata.imageMetadata, imageURL),\n              (newAtlas) => {\n                if (!newAtlas) {\n                  auxReject(\"Something went terribly wrong loading a spine .atlas file\\nMost likely your texture failed to load.\");\n                }\n                auxResolve(atlas);\n              }\n            );\n            const textureAtlas2 = await atlasPromise;\n            return spineAdapter.parseData(parser, textureAtlas2, dataToParse);\n          }\n          let atlasPath = metadata.spineAtlasFile;\n          if (!atlasPath) {\n            atlasPath = `${basePath + fileName}.atlas`;\n          }\n          const textureAtlas = await loader.load({ src: atlasPath, data: metadata, alias: metadata.spineAtlasAlias });\n          return spineAdapter.parseData(parser, textureAtlas, dataToParse);\n        }\n        // #endregion\n        // unload(asset: ISpineResource<SKD>, loadAsset, loader) {\n        // \t???\n        // },\n      }\n    };\n    extensions.add(spineLoaderExtension);\n    return spineLoaderExtension;\n  }\n}\nfunction dataURLToArrayBuffer(dataURL) {\n  const base64 = dataURL.split(\",\")[1];\n  const binaryString = atob(base64);\n  const length = binaryString.length;\n  const arrayBuffer = new ArrayBuffer(length);\n  const uint8Array = new Uint8Array(arrayBuffer);\n  for (let i = 0; i < length; i++) {\n    uint8Array[i] = binaryString.charCodeAt(i);\n  }\n  return arrayBuffer;\n}\n\nexport { SpineLoaderAbstract };\n//# sourceMappingURL=SpineLoaderAbstract.mjs.map\n","import { Utils } from '@pixi-spine/base';\n\nclass Attachment {\n  constructor(name) {\n    if (name == null)\n      throw new Error(\"name cannot be null.\");\n    this.name = name;\n  }\n}\nconst _VertexAttachment = class extends Attachment {\n  constructor(name) {\n    super(name);\n    this.id = (_VertexAttachment.nextID++ & 65535) << 11;\n    this.worldVerticesLength = 0;\n    this.deformAttachment = this;\n  }\n  computeWorldVerticesOld(slot, worldVertices) {\n    this.computeWorldVertices(slot, 0, this.worldVerticesLength, worldVertices, 0, 2);\n  }\n  /** Transforms local vertices to world coordinates.\n   * @param start The index of the first local vertex value to transform. Each vertex has 2 values, x and y.\n   * @param count The number of world vertex values to output. Must be <= {@link #getWorldVerticesLength()} - start.\n   * @param worldVertices The output world vertices. Must have a length >= offset + count.\n   * @param offset The worldVertices index to begin writing values. */\n  computeWorldVertices(slot, start, count, worldVertices, offset, stride) {\n    count = offset + (count >> 1) * stride;\n    const skeleton = slot.bone.skeleton;\n    const deformArray = slot.deform;\n    let vertices = this.vertices;\n    const bones = this.bones;\n    if (bones == null) {\n      if (deformArray.length > 0)\n        vertices = deformArray;\n      const mat = slot.bone.matrix;\n      const x = mat.tx;\n      const y = mat.ty;\n      const a = mat.a;\n      const b = mat.c;\n      const c = mat.b;\n      const d = mat.d;\n      for (let v2 = start, w = offset; w < count; v2 += 2, w += stride) {\n        const vx = vertices[v2];\n        const vy = vertices[v2 + 1];\n        worldVertices[w] = vx * a + vy * b + x;\n        worldVertices[w + 1] = vx * c + vy * d + y;\n      }\n      return;\n    }\n    let v = 0;\n    let skip = 0;\n    for (let i = 0; i < start; i += 2) {\n      const n = bones[v];\n      v += n + 1;\n      skip += n;\n    }\n    const skeletonBones = skeleton.bones;\n    if (deformArray.length == 0) {\n      for (let w = offset, b = skip * 3; w < count; w += stride) {\n        let wx = 0;\n        let wy = 0;\n        let n = bones[v++];\n        n += v;\n        for (; v < n; v++, b += 3) {\n          const mat = skeletonBones[bones[v]].matrix;\n          const vx = vertices[b];\n          const vy = vertices[b + 1];\n          const weight = vertices[b + 2];\n          wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\n          wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\n        }\n        worldVertices[w] = wx;\n        worldVertices[w + 1] = wy;\n      }\n    } else {\n      const deform = deformArray;\n      for (let w = offset, b = skip * 3, f = skip << 1; w < count; w += stride) {\n        let wx = 0;\n        let wy = 0;\n        let n = bones[v++];\n        n += v;\n        for (; v < n; v++, b += 3, f += 2) {\n          const mat = skeletonBones[bones[v]].matrix;\n          const vx = vertices[b] + deform[f];\n          const vy = vertices[b + 1] + deform[f + 1];\n          const weight = vertices[b + 2];\n          wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\n          wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\n        }\n        worldVertices[w] = wx;\n        worldVertices[w + 1] = wy;\n      }\n    }\n  }\n  copyTo(attachment) {\n    if (this.bones != null) {\n      attachment.bones = new Array(this.bones.length);\n      Utils.arrayCopy(this.bones, 0, attachment.bones, 0, this.bones.length);\n    } else\n      attachment.bones = null;\n    if (this.vertices != null) {\n      attachment.vertices = Utils.newFloatArray(this.vertices.length);\n      Utils.arrayCopy(this.vertices, 0, attachment.vertices, 0, this.vertices.length);\n    } else\n      attachment.vertices = null;\n    attachment.worldVerticesLength = this.worldVerticesLength;\n    attachment.deformAttachment = this.deformAttachment;\n  }\n};\nlet VertexAttachment = _VertexAttachment;\nVertexAttachment.nextID = 0;\n\nexport { Attachment, VertexAttachment };\n//# sourceMappingURL=Attachment.mjs.map\n","import { Color } from '@pixi-spine/base';\n\nclass Slot {\n  constructor(data, bone) {\n    this.deform = new Array();\n    if (data == null)\n      throw new Error(\"data cannot be null.\");\n    if (bone == null)\n      throw new Error(\"bone cannot be null.\");\n    this.data = data;\n    this.bone = bone;\n    this.color = new Color();\n    this.darkColor = data.darkColor == null ? null : new Color();\n    this.setToSetupPose();\n    this.blendMode = this.data.blendMode;\n  }\n  /** @return May be null. */\n  getAttachment() {\n    return this.attachment;\n  }\n  /** Sets the attachment and if it changed, resets {@link #getAttachmentTime()} and clears {@link #getAttachmentVertices()}.\n   * @param attachment May be null. */\n  setAttachment(attachment) {\n    if (this.attachment == attachment)\n      return;\n    this.attachment = attachment;\n    this.attachmentTime = this.bone.skeleton.time;\n    this.deform.length = 0;\n  }\n  setAttachmentTime(time) {\n    this.attachmentTime = this.bone.skeleton.time - time;\n  }\n  /** Returns the time since the attachment was set. */\n  getAttachmentTime() {\n    return this.bone.skeleton.time - this.attachmentTime;\n  }\n  setToSetupPose() {\n    this.color.setFromColor(this.data.color);\n    if (this.darkColor != null)\n      this.darkColor.setFromColor(this.data.darkColor);\n    if (this.data.attachmentName == null)\n      this.attachment = null;\n    else {\n      this.attachment = null;\n      this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));\n    }\n  }\n}\n\nexport { Slot };\n//# sourceMappingURL=Slot.mjs.map\n","import { Attachment } from './Attachment.mjs';\nimport { AttachmentType, Color, Utils } from '@pixi-spine/base';\nimport { Slot } from '../Slot.mjs';\n\nconst _RegionAttachment = class extends Attachment {\n  constructor(name) {\n    super(name);\n    this.type = AttachmentType.Region;\n    this.x = 0;\n    this.y = 0;\n    this.scaleX = 1;\n    this.scaleY = 1;\n    this.rotation = 0;\n    this.width = 0;\n    this.height = 0;\n    this.color = new Color(1, 1, 1, 1);\n    this.offset = Utils.newFloatArray(8);\n    this.uvs = Utils.newFloatArray(8);\n    this.tempColor = new Color(1, 1, 1, 1);\n  }\n  updateOffset() {\n    const regionScaleX = this.width / this.region.originalWidth * this.scaleX;\n    const regionScaleY = this.height / this.region.originalHeight * this.scaleY;\n    const localX = -this.width / 2 * this.scaleX + this.region.offsetX * regionScaleX;\n    const localY = -this.height / 2 * this.scaleY + this.region.offsetY * regionScaleY;\n    const localX2 = localX + this.region.width * regionScaleX;\n    const localY2 = localY + this.region.height * regionScaleY;\n    const radians = this.rotation * Math.PI / 180;\n    const cos = Math.cos(radians);\n    const sin = Math.sin(radians);\n    const localXCos = localX * cos + this.x;\n    const localXSin = localX * sin;\n    const localYCos = localY * cos + this.y;\n    const localYSin = localY * sin;\n    const localX2Cos = localX2 * cos + this.x;\n    const localX2Sin = localX2 * sin;\n    const localY2Cos = localY2 * cos + this.y;\n    const localY2Sin = localY2 * sin;\n    const offset = this.offset;\n    offset[_RegionAttachment.OX1] = localXCos - localYSin;\n    offset[_RegionAttachment.OY1] = localYCos + localXSin;\n    offset[_RegionAttachment.OX2] = localXCos - localY2Sin;\n    offset[_RegionAttachment.OY2] = localY2Cos + localXSin;\n    offset[_RegionAttachment.OX3] = localX2Cos - localY2Sin;\n    offset[_RegionAttachment.OY3] = localY2Cos + localX2Sin;\n    offset[_RegionAttachment.OX4] = localX2Cos - localYSin;\n    offset[_RegionAttachment.OY4] = localYCos + localX2Sin;\n  }\n  setRegion(region) {\n    this.region = region;\n    const uvs = this.uvs;\n    if (region.rotate) {\n      uvs[2] = region.u;\n      uvs[3] = region.v2;\n      uvs[4] = region.u;\n      uvs[5] = region.v;\n      uvs[6] = region.u2;\n      uvs[7] = region.v;\n      uvs[0] = region.u2;\n      uvs[1] = region.v2;\n    } else {\n      uvs[0] = region.u;\n      uvs[1] = region.v2;\n      uvs[2] = region.u;\n      uvs[3] = region.v;\n      uvs[4] = region.u2;\n      uvs[5] = region.v;\n      uvs[6] = region.u2;\n      uvs[7] = region.v2;\n    }\n  }\n  computeWorldVertices(bone, worldVertices, offset, stride) {\n    const vertexOffset = this.offset;\n    const mat = bone instanceof Slot ? bone.bone.matrix : bone.matrix;\n    const x = mat.tx;\n    const y = mat.ty;\n    const a = mat.a;\n    const b = mat.c;\n    const c = mat.b;\n    const d = mat.d;\n    let offsetX = 0;\n    let offsetY = 0;\n    offsetX = vertexOffset[_RegionAttachment.OX1];\n    offsetY = vertexOffset[_RegionAttachment.OY1];\n    worldVertices[offset] = offsetX * a + offsetY * b + x;\n    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n    offset += stride;\n    offsetX = vertexOffset[_RegionAttachment.OX2];\n    offsetY = vertexOffset[_RegionAttachment.OY2];\n    worldVertices[offset] = offsetX * a + offsetY * b + x;\n    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n    offset += stride;\n    offsetX = vertexOffset[_RegionAttachment.OX3];\n    offsetY = vertexOffset[_RegionAttachment.OY3];\n    worldVertices[offset] = offsetX * a + offsetY * b + x;\n    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n    offset += stride;\n    offsetX = vertexOffset[_RegionAttachment.OX4];\n    offsetY = vertexOffset[_RegionAttachment.OY4];\n    worldVertices[offset] = offsetX * a + offsetY * b + x;\n    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n  }\n  copy() {\n    const copy = new _RegionAttachment(this.name);\n    copy.region = this.region;\n    copy.rendererObject = this.rendererObject;\n    copy.path = this.path;\n    copy.x = this.x;\n    copy.y = this.y;\n    copy.scaleX = this.scaleX;\n    copy.scaleY = this.scaleY;\n    copy.rotation = this.rotation;\n    copy.width = this.width;\n    copy.height = this.height;\n    Utils.arrayCopy(this.uvs, 0, copy.uvs, 0, 8);\n    Utils.arrayCopy(this.offset, 0, copy.offset, 0, 8);\n    copy.color.setFromColor(this.color);\n    return copy;\n  }\n};\nlet RegionAttachment = _RegionAttachment;\nRegionAttachment.OX1 = 0;\nRegionAttachment.OY1 = 1;\nRegionAttachment.OX2 = 2;\nRegionAttachment.OY2 = 3;\nRegionAttachment.OX3 = 4;\nRegionAttachment.OY3 = 5;\nRegionAttachment.OX4 = 6;\nRegionAttachment.OY4 = 7;\nRegionAttachment.X1 = 0;\nRegionAttachment.Y1 = 1;\nRegionAttachment.C1R = 2;\nRegionAttachment.C1G = 3;\nRegionAttachment.C1B = 4;\nRegionAttachment.C1A = 5;\nRegionAttachment.U1 = 6;\nRegionAttachment.V1 = 7;\nRegionAttachment.X2 = 8;\nRegionAttachment.Y2 = 9;\nRegionAttachment.C2R = 10;\nRegionAttachment.C2G = 11;\nRegionAttachment.C2B = 12;\nRegionAttachment.C2A = 13;\nRegionAttachment.U2 = 14;\nRegionAttachment.V2 = 15;\nRegionAttachment.X3 = 16;\nRegionAttachment.Y3 = 17;\nRegionAttachment.C3R = 18;\nRegionAttachment.C3G = 19;\nRegionAttachment.C3B = 20;\nRegionAttachment.C3A = 21;\nRegionAttachment.U3 = 22;\nRegionAttachment.V3 = 23;\nRegionAttachment.X4 = 24;\nRegionAttachment.Y4 = 25;\nRegionAttachment.C4R = 26;\nRegionAttachment.C4G = 27;\nRegionAttachment.C4B = 28;\nRegionAttachment.C4A = 29;\nRegionAttachment.U4 = 30;\nRegionAttachment.V4 = 31;\n\nexport { RegionAttachment };\n//# sourceMappingURL=RegionAttachment.mjs.map\n","import { PowOut, MathUtils } from '@pixi-spine/base';\n\nconst _SwirlEffect = class {\n  constructor(radius) {\n    this.centerX = 0;\n    this.centerY = 0;\n    this.radius = 0;\n    this.angle = 0;\n    this.worldX = 0;\n    this.worldY = 0;\n    this.radius = radius;\n  }\n  begin(skeleton) {\n    this.worldX = skeleton.x + this.centerX;\n    this.worldY = skeleton.y + this.centerY;\n  }\n  transform(position, uv, light, dark) {\n    const radAngle = this.angle * MathUtils.degreesToRadians;\n    const x = position.x - this.worldX;\n    const y = position.y - this.worldY;\n    const dist = Math.sqrt(x * x + y * y);\n    if (dist < this.radius) {\n      const theta = _SwirlEffect.interpolation.apply(0, radAngle, (this.radius - dist) / this.radius);\n      const cos = Math.cos(theta);\n      const sin = Math.sin(theta);\n      position.x = cos * x - sin * y + this.worldX;\n      position.y = sin * x + cos * y + this.worldY;\n    }\n  }\n  end() {\n  }\n};\nlet SwirlEffect = _SwirlEffect;\nSwirlEffect.interpolation = new PowOut(2);\n\nexport { SwirlEffect };\n//# sourceMappingURL=SwirlEffect.mjs.map\n","import { VertexAttachment } from './attachments/Attachment.mjs';\nimport { MixBlend, MixDirection, MathUtils, Utils } from '@pixi-spine/base';\nimport './attachments/RegionAttachment.mjs';\n\nclass Animation {\n  constructor(name, timelines, duration) {\n    if (name == null)\n      throw new Error(\"name cannot be null.\");\n    if (timelines == null)\n      throw new Error(\"timelines cannot be null.\");\n    this.name = name;\n    this.timelines = timelines;\n    this.timelineIds = [];\n    for (let i = 0; i < timelines.length; i++)\n      this.timelineIds[timelines[i].getPropertyId()] = true;\n    this.duration = duration;\n  }\n  hasTimeline(id) {\n    return this.timelineIds[id] == true;\n  }\n  /** Applies all the animation's timelines to the specified skeleton.\n   *\n   * See Timeline {@link Timeline#apply(Skeleton, float, float, Array, float, MixBlend, MixDirection)}.\n   * @param loop If true, the animation repeats after {@link #getDuration()}.\n   * @param events May be null to ignore fired events. */\n  apply(skeleton, lastTime, time, loop, events, alpha, blend, direction) {\n    if (skeleton == null)\n      throw new Error(\"skeleton cannot be null.\");\n    if (loop && this.duration != 0) {\n      time %= this.duration;\n      if (lastTime > 0)\n        lastTime %= this.duration;\n    }\n    const timelines = this.timelines;\n    for (let i = 0, n = timelines.length; i < n; i++)\n      timelines[i].apply(skeleton, lastTime, time, events, alpha, blend, direction);\n  }\n  /** @param target After the first and before the last value.\n   * @returns index of first value greater than the target. */\n  static binarySearch(values, target, step = 1) {\n    let low = 0;\n    let high = values.length / step - 2;\n    if (high == 0)\n      return step;\n    let current = high >>> 1;\n    while (true) {\n      if (values[(current + 1) * step] <= target)\n        low = current + 1;\n      else\n        high = current;\n      if (low == high)\n        return (low + 1) * step;\n      current = low + high >>> 1;\n    }\n  }\n  static linearSearch(values, target, step) {\n    for (let i = 0, last = values.length - step; i <= last; i += step)\n      if (values[i] > target)\n        return i;\n    return -1;\n  }\n}\nvar TimelineType = /* @__PURE__ */ ((TimelineType2) => {\n  TimelineType2[TimelineType2[\"rotate\"] = 0] = \"rotate\";\n  TimelineType2[TimelineType2[\"translate\"] = 1] = \"translate\";\n  TimelineType2[TimelineType2[\"scale\"] = 2] = \"scale\";\n  TimelineType2[TimelineType2[\"shear\"] = 3] = \"shear\";\n  TimelineType2[TimelineType2[\"attachment\"] = 4] = \"attachment\";\n  TimelineType2[TimelineType2[\"color\"] = 5] = \"color\";\n  TimelineType2[TimelineType2[\"deform\"] = 6] = \"deform\";\n  TimelineType2[TimelineType2[\"event\"] = 7] = \"event\";\n  TimelineType2[TimelineType2[\"drawOrder\"] = 8] = \"drawOrder\";\n  TimelineType2[TimelineType2[\"ikConstraint\"] = 9] = \"ikConstraint\";\n  TimelineType2[TimelineType2[\"transformConstraint\"] = 10] = \"transformConstraint\";\n  TimelineType2[TimelineType2[\"pathConstraintPosition\"] = 11] = \"pathConstraintPosition\";\n  TimelineType2[TimelineType2[\"pathConstraintSpacing\"] = 12] = \"pathConstraintSpacing\";\n  TimelineType2[TimelineType2[\"pathConstraintMix\"] = 13] = \"pathConstraintMix\";\n  TimelineType2[TimelineType2[\"twoColor\"] = 14] = \"twoColor\";\n  return TimelineType2;\n})(TimelineType || {});\nconst _CurveTimeline = class {\n  constructor(frameCount) {\n    this.curveData = [];\n    if (frameCount <= 0)\n      throw new Error(`frameCount must be > 0: ${frameCount}`);\n    this.curves = Utils.newFloatArray((frameCount - 1) * _CurveTimeline.BEZIER_SIZE);\n  }\n  /** The number of key frames for this timeline. */\n  getFrameCount() {\n    return this.curves.length / _CurveTimeline.BEZIER_SIZE + 1;\n  }\n  /** Sets the specified key frame to linear interpolation. */\n  setLinear(frameIndex) {\n    this.curves[frameIndex * _CurveTimeline.BEZIER_SIZE] = _CurveTimeline.LINEAR;\n  }\n  /** Sets the specified key frame to stepped interpolation. */\n  setStepped(frameIndex) {\n    this.curves[frameIndex * _CurveTimeline.BEZIER_SIZE] = _CurveTimeline.STEPPED;\n  }\n  /** Returns the interpolation type for the specified key frame.\n   * @returns Linear is 0, stepped is 1, Bezier is 2. */\n  getCurveType(frameIndex) {\n    const index = frameIndex * _CurveTimeline.BEZIER_SIZE;\n    if (index == this.curves.length)\n      return _CurveTimeline.LINEAR;\n    const type = this.curves[index];\n    if (type == _CurveTimeline.LINEAR)\n      return _CurveTimeline.LINEAR;\n    if (type == _CurveTimeline.STEPPED)\n      return _CurveTimeline.STEPPED;\n    return _CurveTimeline.BEZIER;\n  }\n  /** Sets the specified key frame to Bezier interpolation. `cx1` and `cx2` are from 0 to 1,\n   * representing the percent of time between the two key frames. `cy1` and `cy2` are the percent of the\n   * difference between the key frame's values. */\n  setCurve(frameIndex, cx1, cy1, cx2, cy2) {\n    this.curveData.push({ frameIndex, cx1, cy1, cx2, cy2 });\n    const tmpx = (-cx1 * 2 + cx2) * 0.03;\n    const tmpy = (-cy1 * 2 + cy2) * 0.03;\n    const dddfx = ((cx1 - cx2) * 3 + 1) * 6e-3;\n    const dddfy = ((cy1 - cy2) * 3 + 1) * 6e-3;\n    let ddfx = tmpx * 2 + dddfx;\n    let ddfy = tmpy * 2 + dddfy;\n    let dfx = cx1 * 0.3 + tmpx + dddfx * 0.16666667;\n    let dfy = cy1 * 0.3 + tmpy + dddfy * 0.16666667;\n    let i = frameIndex * _CurveTimeline.BEZIER_SIZE;\n    const curves = this.curves;\n    curves[i++] = _CurveTimeline.BEZIER;\n    let x = dfx;\n    let y = dfy;\n    for (let n = i + _CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\n      curves[i] = x;\n      curves[i + 1] = y;\n      dfx += ddfx;\n      dfy += ddfy;\n      ddfx += dddfx;\n      ddfy += dddfy;\n      x += dfx;\n      y += dfy;\n    }\n  }\n  /** Returns the interpolated percentage for the specified key frame and linear percentage. */\n  getCurvePercent(frameIndex, percent) {\n    percent = MathUtils.clamp(percent, 0, 1);\n    const curves = this.curves;\n    let i = frameIndex * _CurveTimeline.BEZIER_SIZE;\n    const type = curves[i];\n    if (type == _CurveTimeline.LINEAR)\n      return percent;\n    if (type == _CurveTimeline.STEPPED)\n      return 0;\n    i++;\n    let x = 0;\n    for (let start = i, n = i + _CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\n      x = curves[i];\n      if (x >= percent) {\n        let prevX;\n        let prevY;\n        if (i == start) {\n          prevX = 0;\n          prevY = 0;\n        } else {\n          prevX = curves[i - 2];\n          prevY = curves[i - 1];\n        }\n        return prevY + (curves[i + 1] - prevY) * (percent - prevX) / (x - prevX);\n      }\n    }\n    const y = curves[i - 1];\n    return y + (1 - y) * (percent - x) / (1 - x);\n  }\n};\nlet CurveTimeline = _CurveTimeline;\nCurveTimeline.LINEAR = 0;\nCurveTimeline.STEPPED = 1;\nCurveTimeline.BEZIER = 2;\nCurveTimeline.BEZIER_SIZE = 10 * 2 - 1;\nconst _RotateTimeline = class extends CurveTimeline {\n  // time, degrees, ...\n  constructor(frameCount) {\n    super(frameCount);\n    this.type = \"RotateTimeline\";\n    this.data = [];\n    this.frames = Utils.newFloatArray(frameCount << 1);\n  }\n  getPropertyId() {\n    return (0 /* rotate */ << 24) + this.boneIndex;\n  }\n  /** Sets the time and angle of the specified keyframe. */\n  setFrame(frameIndex, time, degrees) {\n    this.data.push({ frameIndex, time, degrees });\n    frameIndex <<= 1;\n    this.frames[frameIndex] = time;\n    this.frames[frameIndex + _RotateTimeline.ROTATION] = degrees;\n  }\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    const frames = this.frames;\n    const bone = skeleton.bones[this.boneIndex];\n    if (!bone.active)\n      return;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.rotation = bone.data.rotation;\n          return;\n        case MixBlend.first:\n          const r2 = bone.data.rotation - bone.rotation;\n          bone.rotation += (r2 - (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360) * alpha;\n      }\n      return;\n    }\n    if (time >= frames[frames.length - _RotateTimeline.ENTRIES]) {\n      let r2 = frames[frames.length + _RotateTimeline.PREV_ROTATION];\n      switch (blend) {\n        case MixBlend.setup:\n          bone.rotation = bone.data.rotation + r2 * alpha;\n          break;\n        case MixBlend.first:\n        case MixBlend.replace:\n          r2 += bone.data.rotation - bone.rotation;\n          r2 -= (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360;\n        case MixBlend.add:\n          bone.rotation += r2 * alpha;\n      }\n      return;\n    }\n    const frame = Animation.binarySearch(frames, time, _RotateTimeline.ENTRIES);\n    const prevRotation = frames[frame + _RotateTimeline.PREV_ROTATION];\n    const frameTime = frames[frame];\n    const percent = this.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + _RotateTimeline.PREV_TIME] - frameTime));\n    let r = frames[frame + _RotateTimeline.ROTATION] - prevRotation;\n    r = prevRotation + (r - (16384 - (16384.499999999996 - r / 360 | 0)) * 360) * percent;\n    switch (blend) {\n      case MixBlend.setup:\n        bone.rotation = bone.data.rotation + (r - (16384 - (16384.499999999996 - r / 360 | 0)) * 360) * alpha;\n        break;\n      case MixBlend.first:\n      case MixBlend.replace:\n        r += bone.data.rotation - bone.rotation;\n      case MixBlend.add:\n        bone.rotation += (r - (16384 - (16384.499999999996 - r / 360 | 0)) * 360) * alpha;\n    }\n  }\n};\nlet RotateTimeline = _RotateTimeline;\nRotateTimeline.ENTRIES = 2;\nRotateTimeline.PREV_TIME = -2;\nRotateTimeline.PREV_ROTATION = -1;\nRotateTimeline.ROTATION = 1;\nconst _TranslateTimeline = class extends CurveTimeline {\n  // time, x, y, ...\n  constructor(frameCount) {\n    super(frameCount);\n    this.type = \"TranslateTimeline\";\n    this.data = [];\n    this.frames = Utils.newFloatArray(frameCount * _TranslateTimeline.ENTRIES);\n  }\n  getPropertyId() {\n    return (1 /* translate */ << 24) + this.boneIndex;\n  }\n  /** Sets the time in seconds, x, and y values for the specified key frame. */\n  setFrame(frameIndex, time, x, y) {\n    this.data.push({ frameIndex, time, x, y });\n    frameIndex *= _TranslateTimeline.ENTRIES;\n    this.frames[frameIndex] = time;\n    this.frames[frameIndex + _TranslateTimeline.X] = x;\n    this.frames[frameIndex + _TranslateTimeline.Y] = y;\n  }\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    const frames = this.frames;\n    const bone = skeleton.bones[this.boneIndex];\n    if (!bone.active)\n      return;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.x = bone.data.x;\n          bone.y = bone.data.y;\n          return;\n        case MixBlend.first:\n          bone.x += (bone.data.x - bone.x) * alpha;\n          bone.y += (bone.data.y - bone.y) * alpha;\n      }\n      return;\n    }\n    let x = 0;\n    let y = 0;\n    if (time >= frames[frames.length - _TranslateTimeline.ENTRIES]) {\n      x = frames[frames.length + _TranslateTimeline.PREV_X];\n      y = frames[frames.length + _TranslateTimeline.PREV_Y];\n    } else {\n      const frame = Animation.binarySearch(frames, time, _TranslateTimeline.ENTRIES);\n      x = frames[frame + _TranslateTimeline.PREV_X];\n      y = frames[frame + _TranslateTimeline.PREV_Y];\n      const frameTime = frames[frame];\n      const percent = this.getCurvePercent(frame / _TranslateTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + _TranslateTimeline.PREV_TIME] - frameTime));\n      x += (frames[frame + _TranslateTimeline.X] - x) * percent;\n      y += (frames[frame + _TranslateTimeline.Y] - y) * percent;\n    }\n    switch (blend) {\n      case MixBlend.setup:\n        bone.x = bone.data.x + x * alpha;\n        bone.y = bone.data.y + y * alpha;\n        break;\n      case MixBlend.first:\n      case MixBlend.replace:\n        bone.x += (bone.data.x + x - bone.x) * alpha;\n        bone.y += (bone.data.y + y - bone.y) * alpha;\n        break;\n      case MixBlend.add:\n        bone.x += x * alpha;\n        bone.y += y * alpha;\n    }\n  }\n};\nlet TranslateTimeline = _TranslateTimeline;\nTranslateTimeline.ENTRIES = 3;\nTranslateTimeline.PREV_TIME = -3;\nTranslateTimeline.PREV_X = -2;\nTranslateTimeline.PREV_Y = -1;\nTranslateTimeline.X = 1;\nTranslateTimeline.Y = 2;\nclass ScaleTimeline extends TranslateTimeline {\n  constructor(frameCount) {\n    super(frameCount);\n    this.type = \"ScaleTimeline\";\n  }\n  getPropertyId() {\n    return (2 /* scale */ << 24) + this.boneIndex;\n  }\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    const frames = this.frames;\n    const bone = skeleton.bones[this.boneIndex];\n    if (!bone.active)\n      return;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.scaleX = bone.data.scaleX;\n          bone.scaleY = bone.data.scaleY;\n          return;\n        case MixBlend.first:\n          bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;\n          bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;\n      }\n      return;\n    }\n    let x = 0;\n    let y = 0;\n    if (time >= frames[frames.length - ScaleTimeline.ENTRIES]) {\n      x = frames[frames.length + ScaleTimeline.PREV_X] * bone.data.scaleX;\n      y = frames[frames.length + ScaleTimeline.PREV_Y] * bone.data.scaleY;\n    } else {\n      const frame = Animation.binarySearch(frames, time, ScaleTimeline.ENTRIES);\n      x = frames[frame + ScaleTimeline.PREV_X];\n      y = frames[frame + ScaleTimeline.PREV_Y];\n      const frameTime = frames[frame];\n      const percent = this.getCurvePercent(frame / ScaleTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ScaleTimeline.PREV_TIME] - frameTime));\n      x = (x + (frames[frame + ScaleTimeline.X] - x) * percent) * bone.data.scaleX;\n      y = (y + (frames[frame + ScaleTimeline.Y] - y) * percent) * bone.data.scaleY;\n    }\n    if (alpha == 1) {\n      if (blend == MixBlend.add) {\n        bone.scaleX += x - bone.data.scaleX;\n        bone.scaleY += y - bone.data.scaleY;\n      } else {\n        bone.scaleX = x;\n        bone.scaleY = y;\n      }\n    } else {\n      let bx = 0;\n      let by = 0;\n      if (direction == MixDirection.mixOut) {\n        switch (blend) {\n          case MixBlend.setup:\n            bx = bone.data.scaleX;\n            by = bone.data.scaleY;\n            bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\n            bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\n            break;\n          case MixBlend.first:\n          case MixBlend.replace:\n            bx = bone.scaleX;\n            by = bone.scaleY;\n            bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\n            bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\n            break;\n          case MixBlend.add:\n            bx = bone.scaleX;\n            by = bone.scaleY;\n            bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bone.data.scaleX) * alpha;\n            bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - bone.data.scaleY) * alpha;\n        }\n      } else {\n        switch (blend) {\n          case MixBlend.setup:\n            bx = Math.abs(bone.data.scaleX) * MathUtils.signum(x);\n            by = Math.abs(bone.data.scaleY) * MathUtils.signum(y);\n            bone.scaleX = bx + (x - bx) * alpha;\n            bone.scaleY = by + (y - by) * alpha;\n            break;\n          case MixBlend.first:\n          case MixBlend.replace:\n            bx = Math.abs(bone.scaleX) * MathUtils.signum(x);\n            by = Math.abs(bone.scaleY) * MathUtils.signum(y);\n            bone.scaleX = bx + (x - bx) * alpha;\n            bone.scaleY = by + (y - by) * alpha;\n            break;\n          case MixBlend.add:\n            bx = MathUtils.signum(x);\n            by = MathUtils.signum(y);\n            bone.scaleX = Math.abs(bone.scaleX) * bx + (x - Math.abs(bone.data.scaleX) * bx) * alpha;\n            bone.scaleY = Math.abs(bone.scaleY) * by + (y - Math.abs(bone.data.scaleY) * by) * alpha;\n        }\n      }\n    }\n  }\n}\nclass ShearTimeline extends TranslateTimeline {\n  constructor(frameCount) {\n    super(frameCount);\n    this.type = \"ShearTimeline\";\n  }\n  getPropertyId() {\n    return (3 /* shear */ << 24) + this.boneIndex;\n  }\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    const frames = this.frames;\n    const bone = skeleton.bones[this.boneIndex];\n    if (!bone.active)\n      return;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.shearX = bone.data.shearX;\n          bone.shearY = bone.data.shearY;\n          return;\n        case MixBlend.first:\n          bone.shearX += (bone.data.shearX - bone.shearX) * alpha;\n          bone.shearY += (bone.data.shearY - bone.shearY) * alpha;\n      }\n      return;\n    }\n    let x = 0;\n    let y = 0;\n    if (time >= frames[frames.length - ShearTimeline.ENTRIES]) {\n      x = frames[frames.length + ShearTimeline.PREV_X];\n      y = frames[frames.length + ShearTimeline.PREV_Y];\n    } else {\n      const frame = Animation.binarySearch(frames, time, ShearTimeline.ENTRIES);\n      x = frames[frame + ShearTimeline.PREV_X];\n      y = frames[frame + ShearTimeline.PREV_Y];\n      const frameTime = frames[frame];\n      const percent = this.getCurvePercent(frame / ShearTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ShearTimeline.PREV_TIME] - frameTime));\n      x = x + (frames[frame + ShearTimeline.X] - x) * percent;\n      y = y + (frames[frame + ShearTimeline.Y] - y) * percent;\n    }\n    switch (blend) {\n      case MixBlend.setup:\n        bone.shearX = bone.data.shearX + x * alpha;\n        bone.shearY = bone.data.shearY + y * alpha;\n        break;\n      case MixBlend.first:\n      case MixBlend.replace:\n        bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;\n        bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;\n        break;\n      case MixBlend.add:\n        bone.shearX += x * alpha;\n        bone.shearY += y * alpha;\n    }\n  }\n}\nconst _ColorTimeline = class extends CurveTimeline {\n  constructor(frameCount) {\n    super(frameCount);\n    this.type = \"ColorTimeline\";\n    // time, r, g, b, a, ...\n    this.data = [];\n    this.frames = Utils.newFloatArray(frameCount * _ColorTimeline.ENTRIES);\n  }\n  getPropertyId() {\n    return (5 /* color */ << 24) + this.slotIndex;\n  }\n  /** Sets the time in seconds, red, green, blue, and alpha for the specified key frame. */\n  setFrame(frameIndex, time, r, g, b, a) {\n    this.data.push({ frameIndex, time, r, g, b, a });\n    frameIndex *= _ColorTimeline.ENTRIES;\n    this.frames[frameIndex] = time;\n    this.frames[frameIndex + _ColorTimeline.R] = r;\n    this.frames[frameIndex + _ColorTimeline.G] = g;\n    this.frames[frameIndex + _ColorTimeline.B] = b;\n    this.frames[frameIndex + _ColorTimeline.A] = a;\n  }\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    const slot = skeleton.slots[this.slotIndex];\n    if (!slot.bone.active)\n      return;\n    const frames = this.frames;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          slot.color.setFromColor(slot.data.color);\n          return;\n        case MixBlend.first:\n          const color = slot.color;\n          const setup = slot.data.color;\n          color.add((setup.r - color.r) * alpha, (setup.g - color.g) * alpha, (setup.b - color.b) * alpha, (setup.a - color.a) * alpha);\n      }\n      return;\n    }\n    let r = 0;\n    let g = 0;\n    let b = 0;\n    let a = 0;\n    if (time >= frames[frames.length - _ColorTimeline.ENTRIES]) {\n      const i = frames.length;\n      r = frames[i + _ColorTimeline.PREV_R];\n      g = frames[i + _ColorTimeline.PREV_G];\n      b = frames[i + _ColorTimeline.PREV_B];\n      a = frames[i + _ColorTimeline.PREV_A];\n    } else {\n      const frame = Animation.binarySearch(frames, time, _ColorTimeline.ENTRIES);\n      r = frames[frame + _ColorTimeline.PREV_R];\n      g = frames[frame + _ColorTimeline.PREV_G];\n      b = frames[frame + _ColorTimeline.PREV_B];\n      a = frames[frame + _ColorTimeline.PREV_A];\n      const frameTime = frames[frame];\n      const percent = this.getCurvePercent(frame / _ColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + _ColorTimeline.PREV_TIME] - frameTime));\n      r += (frames[frame + _ColorTimeline.R] - r) * percent;\n      g += (frames[frame + _ColorTimeline.G] - g) * percent;\n      b += (frames[frame + _ColorTimeline.B] - b) * percent;\n      a += (frames[frame + _ColorTimeline.A] - a) * percent;\n    }\n    if (alpha == 1)\n      slot.color.set(r, g, b, a);\n    else {\n      const color = slot.color;\n      if (blend == MixBlend.setup)\n        color.setFromColor(slot.data.color);\n      color.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);\n    }\n  }\n};\nlet ColorTimeline = _ColorTimeline;\nColorTimeline.ENTRIES = 5;\nColorTimeline.PREV_TIME = -5;\nColorTimeline.PREV_R = -4;\nColorTimeline.PREV_G = -3;\nColorTimeline.PREV_B = -2;\nColorTimeline.PREV_A = -1;\nColorTimeline.R = 1;\nColorTimeline.G = 2;\nColorTimeline.B = 3;\nColorTimeline.A = 4;\nconst _TwoColorTimeline = class extends CurveTimeline {\n  constructor(frameCount) {\n    super(frameCount);\n    this.type = \"TwoColorTimeline\";\n    // time, r, g, b, a, r2, g2, b2, ...\n    this.data = [];\n    this.frames = Utils.newFloatArray(frameCount * _TwoColorTimeline.ENTRIES);\n  }\n  getPropertyId() {\n    return (14 /* twoColor */ << 24) + this.slotIndex;\n  }\n  /** Sets the time in seconds, light, and dark colors for the specified key frame. */\n  setFrame(frameIndex, time, r, g, b, a, r2, g2, b2) {\n    this.data.push({ frameIndex, time, r, g, b, a, r2, g2, b2 });\n    frameIndex *= _TwoColorTimeline.ENTRIES;\n    this.frames[frameIndex] = time;\n    this.frames[frameIndex + _TwoColorTimeline.R] = r;\n    this.frames[frameIndex + _TwoColorTimeline.G] = g;\n    this.frames[frameIndex + _TwoColorTimeline.B] = b;\n    this.frames[frameIndex + _TwoColorTimeline.A] = a;\n    this.frames[frameIndex + _TwoColorTimeline.R2] = r2;\n    this.frames[frameIndex + _TwoColorTimeline.G2] = g2;\n    this.frames[frameIndex + _TwoColorTimeline.B2] = b2;\n  }\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    const slot = skeleton.slots[this.slotIndex];\n    if (!slot.bone.active)\n      return;\n    const frames = this.frames;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          slot.color.setFromColor(slot.data.color);\n          slot.darkColor.setFromColor(slot.data.darkColor);\n          return;\n        case MixBlend.first:\n          const light = slot.color;\n          const dark = slot.darkColor;\n          const setupLight = slot.data.color;\n          const setupDark = slot.data.darkColor;\n          light.add((setupLight.r - light.r) * alpha, (setupLight.g - light.g) * alpha, (setupLight.b - light.b) * alpha, (setupLight.a - light.a) * alpha);\n          dark.add((setupDark.r - dark.r) * alpha, (setupDark.g - dark.g) * alpha, (setupDark.b - dark.b) * alpha, 0);\n      }\n      return;\n    }\n    let r = 0;\n    let g = 0;\n    let b = 0;\n    let a = 0;\n    let r2 = 0;\n    let g2 = 0;\n    let b2 = 0;\n    if (time >= frames[frames.length - _TwoColorTimeline.ENTRIES]) {\n      const i = frames.length;\n      r = frames[i + _TwoColorTimeline.PREV_R];\n      g = frames[i + _TwoColorTimeline.PREV_G];\n      b = frames[i + _TwoColorTimeline.PREV_B];\n      a = frames[i + _TwoColorTimeline.PREV_A];\n      r2 = frames[i + _TwoColorTimeline.PREV_R2];\n      g2 = frames[i + _TwoColorTimeline.PREV_G2];\n      b2 = frames[i + _TwoColorTimeline.PREV_B2];\n    } else {\n      const frame = Animation.binarySearch(frames, time, _TwoColorTimeline.ENTRIES);\n      r = frames[frame + _TwoColorTimeline.PREV_R];\n      g = frames[frame + _TwoColorTimeline.PREV_G];\n      b = frames[frame + _TwoColorTimeline.PREV_B];\n      a = frames[frame + _TwoColorTimeline.PREV_A];\n      r2 = frames[frame + _TwoColorTimeline.PREV_R2];\n      g2 = frames[frame + _TwoColorTimeline.PREV_G2];\n      b2 = frames[frame + _TwoColorTimeline.PREV_B2];\n      const frameTime = frames[frame];\n      const percent = this.getCurvePercent(frame / _TwoColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + _TwoColorTimeline.PREV_TIME] - frameTime));\n      r += (frames[frame + _TwoColorTimeline.R] - r) * percent;\n      g += (frames[frame + _TwoColorTimeline.G] - g) * percent;\n      b += (frames[frame + _TwoColorTimeline.B] - b) * percent;\n      a += (frames[frame + _TwoColorTimeline.A] - a) * percent;\n      r2 += (frames[frame + _TwoColorTimeline.R2] - r2) * percent;\n      g2 += (frames[frame + _TwoColorTimeline.G2] - g2) * percent;\n      b2 += (frames[frame + _TwoColorTimeline.B2] - b2) * percent;\n    }\n    if (alpha == 1) {\n      slot.color.set(r, g, b, a);\n      slot.darkColor.set(r2, g2, b2, 1);\n    } else {\n      const light = slot.color;\n      const dark = slot.darkColor;\n      if (blend == MixBlend.setup) {\n        light.setFromColor(slot.data.color);\n        dark.setFromColor(slot.data.darkColor);\n      }\n      light.add((r - light.r) * alpha, (g - light.g) * alpha, (b - light.b) * alpha, (a - light.a) * alpha);\n      dark.add((r2 - dark.r) * alpha, (g2 - dark.g) * alpha, (b2 - dark.b) * alpha, 0);\n    }\n  }\n};\nlet TwoColorTimeline = _TwoColorTimeline;\nTwoColorTimeline.ENTRIES = 8;\nTwoColorTimeline.PREV_TIME = -8;\nTwoColorTimeline.PREV_R = -7;\nTwoColorTimeline.PREV_G = -6;\nTwoColorTimeline.PREV_B = -5;\nTwoColorTimeline.PREV_A = -4;\nTwoColorTimeline.PREV_R2 = -3;\nTwoColorTimeline.PREV_G2 = -2;\nTwoColorTimeline.PREV_B2 = -1;\nTwoColorTimeline.R = 1;\nTwoColorTimeline.G = 2;\nTwoColorTimeline.B = 3;\nTwoColorTimeline.A = 4;\nTwoColorTimeline.R2 = 5;\nTwoColorTimeline.G2 = 6;\nTwoColorTimeline.B2 = 7;\nclass AttachmentTimeline {\n  constructor(frameCount) {\n    this.type = \"AttachmentTimeline\";\n    this.data = [];\n    this.frames = Utils.newFloatArray(frameCount);\n    this.attachmentNames = new Array(frameCount);\n  }\n  getPropertyId() {\n    return (4 /* attachment */ << 24) + this.slotIndex;\n  }\n  /** The number of key frames for this timeline. */\n  getFrameCount() {\n    return this.frames.length;\n  }\n  /** Sets the time in seconds and the attachment name for the specified key frame. */\n  setFrame(frameIndex, time, attachmentName) {\n    this.data.push({ frameIndex, time, attachmentName });\n    this.frames[frameIndex] = time;\n    this.attachmentNames[frameIndex] = attachmentName;\n  }\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    const slot = skeleton.slots[this.slotIndex];\n    if (!slot.bone.active)\n      return;\n    if (direction == MixDirection.mixOut) {\n      if (blend == MixBlend.setup)\n        this.setAttachment(skeleton, slot, slot.data.attachmentName);\n      return;\n    }\n    const frames = this.frames;\n    if (time < frames[0]) {\n      if (blend == MixBlend.setup || blend == MixBlend.first)\n        this.setAttachment(skeleton, slot, slot.data.attachmentName);\n      return;\n    }\n    let frameIndex = 0;\n    if (time >= frames[frames.length - 1])\n      frameIndex = frames.length - 1;\n    else\n      frameIndex = Animation.binarySearch(frames, time, 1) - 1;\n    const attachmentName = this.attachmentNames[frameIndex];\n    skeleton.slots[this.slotIndex].setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\n  }\n  setAttachment(skeleton, slot, attachmentName) {\n    slot.setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\n  }\n}\nlet zeros = null;\nclass DeformTimeline extends CurveTimeline {\n  constructor(frameCount) {\n    super(frameCount);\n    this.type = \"DeformTimeline\";\n    this.data = [];\n    this.frames = Utils.newFloatArray(frameCount);\n    this.frameVertices = new Array(frameCount);\n    if (zeros == null)\n      zeros = Utils.newFloatArray(64);\n  }\n  getPropertyId() {\n    return (6 /* deform */ << 27) + Number(this.attachment.id) + this.slotIndex;\n  }\n  /** Sets the time in seconds and the vertices for the specified key frame.\n   * @param vertices Vertex positions for an unweighted VertexAttachment, or deform offsets if it has weights. */\n  setFrame(frameIndex, time, vertices, skin) {\n    this.data.push({ frameIndex, time, vertices, skin });\n    this.frames[frameIndex] = time;\n    this.frameVertices[frameIndex] = vertices;\n  }\n  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n    const slot = skeleton.slots[this.slotIndex];\n    if (!slot.bone.active)\n      return;\n    const slotAttachment = slot.getAttachment();\n    if (!(slotAttachment instanceof VertexAttachment) || !(slotAttachment.deformAttachment == this.attachment))\n      return;\n    const deformArray = slot.deform || [];\n    if (deformArray.length == 0)\n      blend = MixBlend.setup;\n    const frameVertices = this.frameVertices;\n    const vertexCount = frameVertices[0].length;\n    const frames = this.frames;\n    if (time < frames[0]) {\n      const vertexAttachment = slotAttachment;\n      switch (blend) {\n        case MixBlend.setup:\n          deformArray.length = 0;\n          return;\n        case MixBlend.first:\n          if (alpha == 1) {\n            deformArray.length = 0;\n            break;\n          }\n          const deform2 = Utils.setArraySize(deformArray, vertexCount);\n          if (vertexAttachment.bones == null) {\n            const setupVertices = vertexAttachment.vertices;\n            for (let i = 0; i < vertexCount; i++)\n              deform2[i] += (setupVertices[i] - deform2[i]) * alpha;\n          } else {\n            alpha = 1 - alpha;\n            for (let i = 0; i < vertexCount; i++)\n              deform2[i] *= alpha;\n          }\n      }\n      return;\n    }\n    const deform = Utils.setArraySize(deformArray, vertexCount);\n    if (time >= frames[frames.length - 1]) {\n      const lastVertices = frameVertices[frames.length - 1];\n      if (alpha == 1) {\n        if (blend == MixBlend.add) {\n          const vertexAttachment = slotAttachment;\n          if (vertexAttachment.bones == null) {\n            const setupVertices = vertexAttachment.vertices;\n            for (let i = 0; i < vertexCount; i++) {\n              deform[i] += lastVertices[i] - setupVertices[i];\n            }\n          } else {\n            for (let i = 0; i < vertexCount; i++)\n              deform[i] += lastVertices[i];\n          }\n        } else {\n          Utils.arrayCopy(lastVertices, 0, deform, 0, vertexCount);\n        }\n      } else {\n        switch (blend) {\n          case MixBlend.setup: {\n            const vertexAttachment2 = slotAttachment;\n            if (vertexAttachment2.bones == null) {\n              const setupVertices = vertexAttachment2.vertices;\n              for (let i = 0; i < vertexCount; i++) {\n                const setup = setupVertices[i];\n                deform[i] = setup + (lastVertices[i] - setup) * alpha;\n              }\n            } else {\n              for (let i = 0; i < vertexCount; i++)\n                deform[i] = lastVertices[i] * alpha;\n            }\n            break;\n          }\n          case MixBlend.first:\n          case MixBlend.replace:\n            for (let i = 0; i < vertexCount; i++)\n              deform[i] += (lastVertices[i] - deform[i]) * alpha;\n            break;\n          case MixBlend.add:\n            const vertexAttachment = slotAttachment;\n            if (vertexAttachment.bones == null) {\n              const setupVertices = vertexAttachment.vertices;\n              for (let i = 0; i < vertexCount; i++) {\n                deform[i] += (lastVertices[i] - setupVertices[i]) * alpha;\n              }\n            } else {\n              for (let i = 0; i < vertexCount; i++)\n                deform[i] += lastVertices[i] * alpha;\n            }\n        }\n      }\n      return;\n    }\n    const frame = Animation.binarySearch(frames, time);\n    const prevVertices = frameVertices[frame - 1];\n    const nextVertices = frameVertices[frame];\n    const frameTime = frames[frame];\n    const percent = this.getCurvePercent(frame - 1, 1 - (time - frameTime) / (frames[frame - 1] - frameTime));\n    if (alpha == 1) {\n      if (blend == MixBlend.add) {\n        const vertexAttachment = slotAttachment;\n        if (vertexAttachment.bones == null) {\n          const setupVertices = vertexAttachment.vertices;\n          for (let i = 0; i < vertexCount; i++) {\n            const prev = prevVertices[i];\n            deform[i] += prev + (nextVertices[i] - prev) * percent - setupVertices[i];\n          }\n        } else {\n          for (let i = 0; i < vertexCount; i++) {\n            const prev = prevVertices[i];\n            deform[i] += prev + (nextVertices[i] - prev) * percent;\n          }\n        }\n      } else {\n        for (let i = 0; i < vertexCount; i++) {\n          const prev = prevVertices[i];\n          deform[i] = prev + (nextVertices[i] - prev) * percent;\n        }\n      }\n    } else {\n      switch (blend) {\n        case MixBlend.setup: {\n          const vertexAttachment2 = slotAttachment;\n          if (vertexAttachment2.bones == null) {\n            const setupVertices = vertexAttachment2.vertices;\n            for (let i = 0; i < vertexCount; i++) {\n              const prev = prevVertices[i];\n              const setup = setupVertices[i];\n              deform[i] = setup + (prev + (nextVertices[i] - prev) * percent - setup) * alpha;\n            }\n          } else {\n            for (let i = 0; i < vertexCount; i++) {\n              const prev = prevVertices[i];\n              deform[i] = (prev + (nextVertices[i] - prev) * percent) * alpha;\n            }\n          }\n          break;\n        }\n        case MixBlend.first:\n        case MixBlend.replace:\n          for (let i = 0; i < vertexCount; i++) {\n            const prev = prevVertices[i];\n            deform[i] += (prev + (nextVertices[i] - prev) * percent - deform[i]) * alpha;\n          }\n          break;\n        case MixBlend.add:\n          const vertexAttachment = slotAttachment;\n          if (vertexAttachment.bones == null) {\n            const setupVertices = vertexAttachment.vertices;\n            for (let i = 0; i < vertexCount; i++) {\n              const prev = prevVertices[i];\n              deform[i] += (prev + (nextVertices[i] - prev) * percent - setupVertices[i]) * alpha;\n            }\n          } else {\n            for (let i = 0; i < vertexCount; i++) {\n              const prev = prevVertices[i];\n              deform[i] += (prev + (nextVertices[i] - prev) * percent) * alpha;\n            }\n          }\n      }\n    }\n  }\n}\nclass EventTimeline {\n  constructor(frameCount) {\n    this.type = \"EventTimeline\";\n    this.data = [];\n    this.frames = Utils.newFloatArray(frameCount);\n    this.events = new Array(frameCount);\n  }\n  getPropertyId() {\n    return 7 /* event */ << 24;\n  }\n  /** The number of key frames for this timeline. */\n  getFrameCount() {\n    return this.frames.length;\n  }\n  /** Sets the time in seconds and the event for the specified key frame. */\n  setFrame(frameIndex, event) {\n    this.data.push({ frameIndex, event });\n    this.frames[frameIndex] = event.time;\n    this.events[frameIndex] = event;\n  }\n  /** Fires events for frames > `lastTime` and <= `time`. */\n  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n    if (firedEvents == null)\n      return;\n    const frames = this.frames;\n    const frameCount = this.frames.length;\n    if (lastTime > time) {\n      this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, blend, direction);\n      lastTime = -1;\n    } else if (lastTime >= frames[frameCount - 1])\n      return;\n    if (time < frames[0])\n      return;\n    let frame = 0;\n    if (lastTime < frames[0])\n      frame = 0;\n    else {\n      frame = Animation.binarySearch(frames, lastTime);\n      const frameTime = frames[frame];\n      while (frame > 0) {\n        if (frames[frame - 1] != frameTime)\n          break;\n        frame--;\n      }\n    }\n    for (; frame < frameCount && time >= frames[frame]; frame++)\n      firedEvents.push(this.events[frame]);\n  }\n}\nclass DrawOrderTimeline {\n  constructor(frameCount) {\n    this.type = \"DrawOrderTimeline\";\n    this.data = [];\n    this.frames = Utils.newFloatArray(frameCount);\n    this.drawOrders = new Array(frameCount);\n  }\n  getPropertyId() {\n    return 8 /* drawOrder */ << 24;\n  }\n  /** The number of key frames for this timeline. */\n  getFrameCount() {\n    return this.frames.length;\n  }\n  /** Sets the time in seconds and the draw order for the specified key frame.\n   * @param drawOrder For each slot in {@link Skeleton#slots}, the index of the new draw order. May be null to use setup pose\n   *           draw order. */\n  setFrame(frameIndex, time, drawOrder) {\n    this.data.push({ frameIndex, time, drawOrder });\n    this.frames[frameIndex] = time;\n    this.drawOrders[frameIndex] = drawOrder;\n  }\n  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n    const drawOrder = skeleton.drawOrder;\n    const slots = skeleton.slots;\n    if (direction == MixDirection.mixOut && blend == MixBlend.setup) {\n      Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\n      return;\n    }\n    const frames = this.frames;\n    if (time < frames[0]) {\n      if (blend == MixBlend.setup || blend == MixBlend.first)\n        Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\n      return;\n    }\n    let frame = 0;\n    if (time >= frames[frames.length - 1])\n      frame = frames.length - 1;\n    else\n      frame = Animation.binarySearch(frames, time) - 1;\n    const drawOrderToSetupIndex = this.drawOrders[frame];\n    if (drawOrderToSetupIndex == null)\n      Utils.arrayCopy(slots, 0, drawOrder, 0, slots.length);\n    else {\n      for (let i = 0, n = drawOrderToSetupIndex.length; i < n; i++)\n        drawOrder[i] = slots[drawOrderToSetupIndex[i]];\n    }\n  }\n}\nconst _IkConstraintTimeline = class extends CurveTimeline {\n  constructor(frameCount) {\n    super(frameCount);\n    this.type = \"IkConstraintTimeline\";\n    // time, mix, softness, bendDirection, compress, stretch, ...\n    this.data = [];\n    this.frames = Utils.newFloatArray(frameCount * _IkConstraintTimeline.ENTRIES);\n  }\n  getPropertyId() {\n    return (9 /* ikConstraint */ << 24) + this.ikConstraintIndex;\n  }\n  /** Sets the time, mix and bend direction of the specified keyframe. */\n  setFrame(frameIndex, time, mix, bendDirection) {\n    this.data.push({ frameIndex, time, mix, bendDirection });\n    frameIndex *= _IkConstraintTimeline.ENTRIES;\n    this.frames[frameIndex] = time;\n    this.frames[frameIndex + _IkConstraintTimeline.MIX] = mix;\n    this.frames[frameIndex + _IkConstraintTimeline.BEND_DIRECTION] = bendDirection;\n  }\n  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n    const frames = this.frames;\n    const constraint = skeleton.ikConstraints[this.ikConstraintIndex];\n    if (!constraint.active)\n      return;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          constraint.mix = constraint.data.mix;\n          constraint.softness = constraint.data.softness;\n          constraint.bendDirection = constraint.data.bendDirection;\n          constraint.compress = constraint.data.compress;\n          constraint.stretch = constraint.data.stretch;\n          return;\n        case MixBlend.first:\n          constraint.mix += (constraint.data.mix - constraint.mix) * alpha;\n          constraint.softness += (constraint.data.softness - constraint.softness) * alpha;\n          constraint.bendDirection = constraint.data.bendDirection;\n          constraint.compress = constraint.data.compress;\n          constraint.stretch = constraint.data.stretch;\n      }\n      return;\n    }\n    if (time >= frames[frames.length - _IkConstraintTimeline.ENTRIES]) {\n      if (blend === MixBlend.setup) {\n        constraint.mix = constraint.data.mix + (frames[frames.length + _IkConstraintTimeline.PREV_MIX] - constraint.data.mix) * alpha;\n        constraint.softness = constraint.data.softness + (frames[frames.length + _IkConstraintTimeline.PREV_SOFTNESS] - constraint.data.softness) * alpha;\n        if (direction === MixDirection.mixOut) {\n          constraint.bendDirection = constraint.data.bendDirection;\n          constraint.compress = constraint.data.compress;\n          constraint.stretch = constraint.data.stretch;\n        } else {\n          constraint.bendDirection = frames[frames.length + _IkConstraintTimeline.PREV_BEND_DIRECTION];\n          constraint.compress = frames[frames.length + _IkConstraintTimeline.PREV_COMPRESS] !== 0;\n          constraint.stretch = frames[frames.length + _IkConstraintTimeline.PREV_STRETCH] !== 0;\n        }\n      } else {\n        constraint.mix += (frames[frames.length + _IkConstraintTimeline.PREV_MIX] - constraint.mix) * alpha;\n        constraint.softness += (frames[frames.length + _IkConstraintTimeline.PREV_SOFTNESS] - constraint.softness) * alpha;\n        if (direction === MixDirection.mixIn) {\n          constraint.bendDirection = frames[frames.length + _IkConstraintTimeline.PREV_BEND_DIRECTION];\n          constraint.compress = frames[frames.length + _IkConstraintTimeline.PREV_COMPRESS] !== 0;\n          constraint.stretch = frames[frames.length + _IkConstraintTimeline.PREV_STRETCH] !== 0;\n        }\n      }\n      return;\n    }\n    const frame = Animation.binarySearch(frames, time, _IkConstraintTimeline.ENTRIES);\n    const mix = frames[frame + _IkConstraintTimeline.PREV_MIX];\n    const frameTime = frames[frame];\n    const percent = this.getCurvePercent(frame / _IkConstraintTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + _IkConstraintTimeline.PREV_TIME] - frameTime));\n    constraint.mix += (mix + (frames[frame + _IkConstraintTimeline.MIX] - mix) * percent - constraint.mix) * alpha;\n    constraint.bendDirection = Math.floor(frames[frame + _IkConstraintTimeline.PREV_BEND_DIRECTION]);\n  }\n};\nlet IkConstraintTimeline = _IkConstraintTimeline;\nIkConstraintTimeline.ENTRIES = 6;\nIkConstraintTimeline.PREV_TIME = -6;\nIkConstraintTimeline.PREV_MIX = -5;\nIkConstraintTimeline.PREV_SOFTNESS = -4;\nIkConstraintTimeline.PREV_BEND_DIRECTION = -3;\nIkConstraintTimeline.PREV_COMPRESS = -2;\nIkConstraintTimeline.PREV_STRETCH = -1;\nIkConstraintTimeline.MIX = 1;\nIkConstraintTimeline.SOFTNESS = 2;\nIkConstraintTimeline.BEND_DIRECTION = 3;\nIkConstraintTimeline.COMPRESS = 4;\nIkConstraintTimeline.STRETCH = 5;\nconst _TransformConstraintTimeline = class extends CurveTimeline {\n  constructor(frameCount) {\n    super(frameCount);\n    this.type = \"TransformConstraintTimeline\";\n    // time, rotate mix, translate mix, scale mix, shear mix, ...\n    this.data = [];\n    this.frames = Utils.newFloatArray(frameCount * _TransformConstraintTimeline.ENTRIES);\n  }\n  getPropertyId() {\n    return (10 /* transformConstraint */ << 24) + this.transformConstraintIndex;\n  }\n  /** The time in seconds, rotate mix, translate mix, scale mix, and shear mix for the specified key frame. */\n  setFrame(frameIndex, time, rotateMix, translateMix, scaleMix, shearMix) {\n    this.data.push({ frameIndex, time, rotateMix, translateMix, scaleMix, shearMix });\n    frameIndex *= _TransformConstraintTimeline.ENTRIES;\n    this.frames[frameIndex] = time;\n    this.frames[frameIndex + _TransformConstraintTimeline.ROTATE] = rotateMix;\n    this.frames[frameIndex + _TransformConstraintTimeline.TRANSLATE] = translateMix;\n    this.frames[frameIndex + _TransformConstraintTimeline.SCALE] = scaleMix;\n    this.frames[frameIndex + _TransformConstraintTimeline.SHEAR] = shearMix;\n  }\n  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n    const frames = this.frames;\n    const constraint = skeleton.transformConstraints[this.transformConstraintIndex];\n    if (!constraint.active)\n      return;\n    if (time < frames[0]) {\n      const data = constraint.data;\n      switch (blend) {\n        case MixBlend.setup:\n          constraint.rotateMix = data.rotateMix;\n          constraint.translateMix = data.translateMix;\n          constraint.scaleMix = data.scaleMix;\n          constraint.shearMix = data.shearMix;\n          return;\n        case MixBlend.first:\n          constraint.rotateMix += (data.rotateMix - constraint.rotateMix) * alpha;\n          constraint.translateMix += (data.translateMix - constraint.translateMix) * alpha;\n          constraint.scaleMix += (data.scaleMix - constraint.scaleMix) * alpha;\n          constraint.shearMix += (data.shearMix - constraint.shearMix) * alpha;\n      }\n      return;\n    }\n    let rotate = 0;\n    let translate = 0;\n    let scale = 0;\n    let shear = 0;\n    if (time >= frames[frames.length - _TransformConstraintTimeline.ENTRIES]) {\n      const i = frames.length;\n      rotate = frames[i + _TransformConstraintTimeline.PREV_ROTATE];\n      translate = frames[i + _TransformConstraintTimeline.PREV_TRANSLATE];\n      scale = frames[i + _TransformConstraintTimeline.PREV_SCALE];\n      shear = frames[i + _TransformConstraintTimeline.PREV_SHEAR];\n    } else {\n      const frame = Animation.binarySearch(frames, time, _TransformConstraintTimeline.ENTRIES);\n      rotate = frames[frame + _TransformConstraintTimeline.PREV_ROTATE];\n      translate = frames[frame + _TransformConstraintTimeline.PREV_TRANSLATE];\n      scale = frames[frame + _TransformConstraintTimeline.PREV_SCALE];\n      shear = frames[frame + _TransformConstraintTimeline.PREV_SHEAR];\n      const frameTime = frames[frame];\n      const percent = this.getCurvePercent(\n        frame / _TransformConstraintTimeline.ENTRIES - 1,\n        1 - (time - frameTime) / (frames[frame + _TransformConstraintTimeline.PREV_TIME] - frameTime)\n      );\n      rotate += (frames[frame + _TransformConstraintTimeline.ROTATE] - rotate) * percent;\n      translate += (frames[frame + _TransformConstraintTimeline.TRANSLATE] - translate) * percent;\n      scale += (frames[frame + _TransformConstraintTimeline.SCALE] - scale) * percent;\n      shear += (frames[frame + _TransformConstraintTimeline.SHEAR] - shear) * percent;\n    }\n    if (blend == MixBlend.setup) {\n      const data = constraint.data;\n      constraint.rotateMix = data.rotateMix + (rotate - data.rotateMix) * alpha;\n      constraint.translateMix = data.translateMix + (translate - data.translateMix) * alpha;\n      constraint.scaleMix = data.scaleMix + (scale - data.scaleMix) * alpha;\n      constraint.shearMix = data.shearMix + (shear - data.shearMix) * alpha;\n    } else {\n      constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;\n      constraint.translateMix += (translate - constraint.translateMix) * alpha;\n      constraint.scaleMix += (scale - constraint.scaleMix) * alpha;\n      constraint.shearMix += (shear - constraint.shearMix) * alpha;\n    }\n  }\n};\nlet TransformConstraintTimeline = _TransformConstraintTimeline;\nTransformConstraintTimeline.ENTRIES = 5;\nTransformConstraintTimeline.PREV_TIME = -5;\nTransformConstraintTimeline.PREV_ROTATE = -4;\nTransformConstraintTimeline.PREV_TRANSLATE = -3;\nTransformConstraintTimeline.PREV_SCALE = -2;\nTransformConstraintTimeline.PREV_SHEAR = -1;\nTransformConstraintTimeline.ROTATE = 1;\nTransformConstraintTimeline.TRANSLATE = 2;\nTransformConstraintTimeline.SCALE = 3;\nTransformConstraintTimeline.SHEAR = 4;\nconst _PathConstraintPositionTimeline = class extends CurveTimeline {\n  constructor(frameCount) {\n    super(frameCount);\n    this.type = \"PathConstraintPositionTimeline\";\n    // time, position, ...\n    this.data = [];\n    this.frames = Utils.newFloatArray(frameCount * _PathConstraintPositionTimeline.ENTRIES);\n  }\n  getPropertyId() {\n    return (11 /* pathConstraintPosition */ << 24) + this.pathConstraintIndex;\n  }\n  /** Sets the time in seconds and path constraint position for the specified key frame. */\n  setFrame(frameIndex, time, value) {\n    this.data.push({ frameIndex, time, value });\n    frameIndex *= _PathConstraintPositionTimeline.ENTRIES;\n    this.frames[frameIndex] = time;\n    this.frames[frameIndex + _PathConstraintPositionTimeline.VALUE] = value;\n  }\n  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n    const frames = this.frames;\n    const constraint = skeleton.pathConstraints[this.pathConstraintIndex];\n    if (!constraint.active)\n      return;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          constraint.position = constraint.data.position;\n          return;\n        case MixBlend.first:\n          constraint.position += (constraint.data.position - constraint.position) * alpha;\n      }\n      return;\n    }\n    let position = 0;\n    if (time >= frames[frames.length - _PathConstraintPositionTimeline.ENTRIES])\n      position = frames[frames.length + _PathConstraintPositionTimeline.PREV_VALUE];\n    else {\n      const frame = Animation.binarySearch(frames, time, _PathConstraintPositionTimeline.ENTRIES);\n      position = frames[frame + _PathConstraintPositionTimeline.PREV_VALUE];\n      const frameTime = frames[frame];\n      const percent = this.getCurvePercent(\n        frame / _PathConstraintPositionTimeline.ENTRIES - 1,\n        1 - (time - frameTime) / (frames[frame + _PathConstraintPositionTimeline.PREV_TIME] - frameTime)\n      );\n      position += (frames[frame + _PathConstraintPositionTimeline.VALUE] - position) * percent;\n    }\n    if (blend == MixBlend.setup)\n      constraint.position = constraint.data.position + (position - constraint.data.position) * alpha;\n    else\n      constraint.position += (position - constraint.position) * alpha;\n  }\n};\nlet PathConstraintPositionTimeline = _PathConstraintPositionTimeline;\nPathConstraintPositionTimeline.ENTRIES = 2;\nPathConstraintPositionTimeline.PREV_TIME = -2;\nPathConstraintPositionTimeline.PREV_VALUE = -1;\nPathConstraintPositionTimeline.VALUE = 1;\nclass PathConstraintSpacingTimeline extends PathConstraintPositionTimeline {\n  constructor(frameCount) {\n    super(frameCount);\n    this.type = \"PathConstraintSpacingTimeline\";\n  }\n  getPropertyId() {\n    return (12 /* pathConstraintSpacing */ << 24) + this.pathConstraintIndex;\n  }\n  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n    const frames = this.frames;\n    const constraint = skeleton.pathConstraints[this.pathConstraintIndex];\n    if (!constraint.active)\n      return;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          constraint.spacing = constraint.data.spacing;\n          return;\n        case MixBlend.first:\n          constraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha;\n      }\n      return;\n    }\n    let spacing = 0;\n    if (time >= frames[frames.length - PathConstraintSpacingTimeline.ENTRIES])\n      spacing = frames[frames.length + PathConstraintSpacingTimeline.PREV_VALUE];\n    else {\n      const frame = Animation.binarySearch(frames, time, PathConstraintSpacingTimeline.ENTRIES);\n      spacing = frames[frame + PathConstraintSpacingTimeline.PREV_VALUE];\n      const frameTime = frames[frame];\n      const percent = this.getCurvePercent(\n        frame / PathConstraintSpacingTimeline.ENTRIES - 1,\n        1 - (time - frameTime) / (frames[frame + PathConstraintSpacingTimeline.PREV_TIME] - frameTime)\n      );\n      spacing += (frames[frame + PathConstraintSpacingTimeline.VALUE] - spacing) * percent;\n    }\n    if (blend == MixBlend.setup)\n      constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha;\n    else\n      constraint.spacing += (spacing - constraint.spacing) * alpha;\n  }\n}\nconst _PathConstraintMixTimeline = class extends CurveTimeline {\n  constructor(frameCount) {\n    super(frameCount);\n    this.type = \"PathConstraintMixTimeline\";\n    // time, rotate mix, translate mix, ...\n    this.data = [];\n    this.frames = Utils.newFloatArray(frameCount * _PathConstraintMixTimeline.ENTRIES);\n  }\n  getPropertyId() {\n    return (13 /* pathConstraintMix */ << 24) + this.pathConstraintIndex;\n  }\n  /** The time in seconds, rotate mix, and translate mix for the specified key frame. */\n  setFrame(frameIndex, time, rotateMix, translateMix) {\n    this.data.push({ frameIndex, time, rotateMix, translateMix });\n    frameIndex *= _PathConstraintMixTimeline.ENTRIES;\n    this.frames[frameIndex] = time;\n    this.frames[frameIndex + _PathConstraintMixTimeline.ROTATE] = rotateMix;\n    this.frames[frameIndex + _PathConstraintMixTimeline.TRANSLATE] = translateMix;\n  }\n  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n    const frames = this.frames;\n    const constraint = skeleton.pathConstraints[this.pathConstraintIndex];\n    if (!constraint.active)\n      return;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          constraint.rotateMix = constraint.data.rotateMix;\n          constraint.translateMix = constraint.data.translateMix;\n          return;\n        case MixBlend.first:\n          constraint.rotateMix += (constraint.data.rotateMix - constraint.rotateMix) * alpha;\n          constraint.translateMix += (constraint.data.translateMix - constraint.translateMix) * alpha;\n      }\n      return;\n    }\n    let rotate = 0;\n    let translate = 0;\n    if (time >= frames[frames.length - _PathConstraintMixTimeline.ENTRIES]) {\n      rotate = frames[frames.length + _PathConstraintMixTimeline.PREV_ROTATE];\n      translate = frames[frames.length + _PathConstraintMixTimeline.PREV_TRANSLATE];\n    } else {\n      const frame = Animation.binarySearch(frames, time, _PathConstraintMixTimeline.ENTRIES);\n      rotate = frames[frame + _PathConstraintMixTimeline.PREV_ROTATE];\n      translate = frames[frame + _PathConstraintMixTimeline.PREV_TRANSLATE];\n      const frameTime = frames[frame];\n      const percent = this.getCurvePercent(\n        frame / _PathConstraintMixTimeline.ENTRIES - 1,\n        1 - (time - frameTime) / (frames[frame + _PathConstraintMixTimeline.PREV_TIME] - frameTime)\n      );\n      rotate += (frames[frame + _PathConstraintMixTimeline.ROTATE] - rotate) * percent;\n      translate += (frames[frame + _PathConstraintMixTimeline.TRANSLATE] - translate) * percent;\n    }\n    if (blend == MixBlend.setup) {\n      constraint.rotateMix = constraint.data.rotateMix + (rotate - constraint.data.rotateMix) * alpha;\n      constraint.translateMix = constraint.data.translateMix + (translate - constraint.data.translateMix) * alpha;\n    } else {\n      constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;\n      constraint.translateMix += (translate - constraint.translateMix) * alpha;\n    }\n  }\n};\nlet PathConstraintMixTimeline = _PathConstraintMixTimeline;\nPathConstraintMixTimeline.ENTRIES = 3;\nPathConstraintMixTimeline.PREV_TIME = -3;\nPathConstraintMixTimeline.PREV_ROTATE = -2;\nPathConstraintMixTimeline.PREV_TRANSLATE = -1;\nPathConstraintMixTimeline.ROTATE = 1;\nPathConstraintMixTimeline.TRANSLATE = 2;\n\nexport { Animation, AttachmentTimeline, ColorTimeline, CurveTimeline, DeformTimeline, DrawOrderTimeline, EventTimeline, IkConstraintTimeline, PathConstraintMixTimeline, PathConstraintPositionTimeline, PathConstraintSpacingTimeline, RotateTimeline, ScaleTimeline, ShearTimeline, TimelineType, TransformConstraintTimeline, TranslateTimeline, TwoColorTimeline };\n//# sourceMappingURL=Animation.mjs.map\n","import { IntSet, Pool, MixBlend, Utils, MixDirection, MathUtils } from '@pixi-spine/base';\nimport { Animation, AttachmentTimeline, RotateTimeline, DrawOrderTimeline, EventTimeline } from './Animation.mjs';\n\nconst _AnimationState = class {\n  constructor(data) {\n    /** The list of tracks that currently have animations, which may contain null entries. */\n    this.tracks = new Array();\n    /** Multiplier for the delta time when the animation state is updated, causing time for all animations and mixes to play slower\n     * or faster. Defaults to 1.\n     *\n     * See TrackEntry {@link TrackEntry#timeScale} for affecting a single animation. */\n    this.timeScale = 1;\n    this.unkeyedState = 0;\n    this.events = new Array();\n    this.listeners = new Array();\n    this.queue = new EventQueue(this);\n    this.propertyIDs = new IntSet();\n    this.animationsChanged = false;\n    this.trackEntryPool = new Pool(() => new TrackEntry());\n    this.data = data;\n  }\n  /** Increments each track entry {@link TrackEntry#trackTime()}, setting queued animations as current if needed. */\n  update(delta) {\n    delta *= this.timeScale;\n    const tracks = this.tracks;\n    for (let i = 0, n = tracks.length; i < n; i++) {\n      const current = tracks[i];\n      if (current == null)\n        continue;\n      current.animationLast = current.nextAnimationLast;\n      current.trackLast = current.nextTrackLast;\n      let currentDelta = delta * current.timeScale;\n      if (current.delay > 0) {\n        current.delay -= currentDelta;\n        if (current.delay > 0)\n          continue;\n        currentDelta = -current.delay;\n        current.delay = 0;\n      }\n      let next = current.next;\n      if (next != null) {\n        const nextTime = current.trackLast - next.delay;\n        if (nextTime >= 0) {\n          next.delay = 0;\n          next.trackTime += current.timeScale == 0 ? 0 : (nextTime / current.timeScale + delta) * next.timeScale;\n          current.trackTime += currentDelta;\n          this.setCurrent(i, next, true);\n          while (next.mixingFrom != null) {\n            next.mixTime += delta;\n            next = next.mixingFrom;\n          }\n          continue;\n        }\n      } else if (current.trackLast >= current.trackEnd && current.mixingFrom == null) {\n        tracks[i] = null;\n        this.queue.end(current);\n        this.disposeNext(current);\n        continue;\n      }\n      if (current.mixingFrom != null && this.updateMixingFrom(current, delta)) {\n        let from = current.mixingFrom;\n        current.mixingFrom = null;\n        if (from != null)\n          from.mixingTo = null;\n        while (from != null) {\n          this.queue.end(from);\n          from = from.mixingFrom;\n        }\n      }\n      current.trackTime += currentDelta;\n    }\n    this.queue.drain();\n  }\n  /** Returns true when all mixing from entries are complete. */\n  updateMixingFrom(to, delta) {\n    const from = to.mixingFrom;\n    if (from == null)\n      return true;\n    const finished = this.updateMixingFrom(from, delta);\n    from.animationLast = from.nextAnimationLast;\n    from.trackLast = from.nextTrackLast;\n    if (to.mixTime > 0 && to.mixTime >= to.mixDuration) {\n      if (from.totalAlpha == 0 || to.mixDuration == 0) {\n        to.mixingFrom = from.mixingFrom;\n        if (from.mixingFrom != null)\n          from.mixingFrom.mixingTo = to;\n        to.interruptAlpha = from.interruptAlpha;\n        this.queue.end(from);\n      }\n      return finished;\n    }\n    from.trackTime += delta * from.timeScale;\n    to.mixTime += delta;\n    return false;\n  }\n  /** Poses the skeleton using the track entry animations. There are no side effects other than invoking listeners, so the\n   * animation state can be applied to multiple skeletons to pose them identically.\n   * @returns True if any animations were applied. */\n  apply(skeleton) {\n    if (skeleton == null)\n      throw new Error(\"skeleton cannot be null.\");\n    if (this.animationsChanged)\n      this._animationsChanged();\n    const events = this.events;\n    const tracks = this.tracks;\n    let applied = false;\n    for (let i = 0, n = tracks.length; i < n; i++) {\n      const current = tracks[i];\n      if (current == null || current.delay > 0)\n        continue;\n      applied = true;\n      const blend = i == 0 ? MixBlend.first : current.mixBlend;\n      let mix = current.alpha;\n      if (current.mixingFrom != null)\n        mix *= this.applyMixingFrom(current, skeleton, blend);\n      else if (current.trackTime >= current.trackEnd && current.next == null)\n        mix = 0;\n      const animationLast = current.animationLast;\n      const animationTime = current.getAnimationTime();\n      const timelineCount = current.animation.timelines.length;\n      const timelines = current.animation.timelines;\n      if (i == 0 && mix == 1 || blend == MixBlend.add) {\n        for (let ii = 0; ii < timelineCount; ii++) {\n          Utils.webkit602BugfixHelper(mix, blend);\n          const timeline = timelines[ii];\n          if (timeline instanceof AttachmentTimeline)\n            this.applyAttachmentTimeline(timeline, skeleton, animationTime, blend, true);\n          else\n            timeline.apply(skeleton, animationLast, animationTime, events, mix, blend, MixDirection.mixIn);\n        }\n      } else {\n        const timelineMode = current.timelineMode;\n        const firstFrame = current.timelinesRotation.length == 0;\n        if (firstFrame)\n          Utils.setArraySize(current.timelinesRotation, timelineCount << 1, null);\n        const timelinesRotation = current.timelinesRotation;\n        for (let ii = 0; ii < timelineCount; ii++) {\n          const timeline = timelines[ii];\n          const timelineBlend = timelineMode[ii] == _AnimationState.SUBSEQUENT ? blend : MixBlend.setup;\n          if (timeline instanceof RotateTimeline) {\n            this.applyRotateTimeline(timeline, skeleton, animationTime, mix, timelineBlend, timelinesRotation, ii << 1, firstFrame);\n          } else if (timeline instanceof AttachmentTimeline) {\n            this.applyAttachmentTimeline(timeline, skeleton, animationTime, blend, true);\n          } else {\n            Utils.webkit602BugfixHelper(mix, blend);\n            timeline.apply(skeleton, animationLast, animationTime, events, mix, timelineBlend, MixDirection.mixIn);\n          }\n        }\n      }\n      this.queueEvents(current, animationTime);\n      events.length = 0;\n      current.nextAnimationLast = animationTime;\n      current.nextTrackLast = current.trackTime;\n    }\n    const setupState = this.unkeyedState + _AnimationState.SETUP;\n    const slots = skeleton.slots;\n    for (let i = 0, n = skeleton.slots.length; i < n; i++) {\n      const slot = slots[i];\n      if (slot.attachmentState == setupState) {\n        const attachmentName = slot.data.attachmentName;\n        slot.setAttachment(attachmentName == null ? null : skeleton.getAttachment(slot.data.index, attachmentName));\n      }\n    }\n    this.unkeyedState += 2;\n    this.queue.drain();\n    return applied;\n  }\n  applyMixingFrom(to, skeleton, blend) {\n    const from = to.mixingFrom;\n    if (from.mixingFrom != null)\n      this.applyMixingFrom(from, skeleton, blend);\n    let mix = 0;\n    if (to.mixDuration == 0) {\n      mix = 1;\n      if (blend == MixBlend.first)\n        blend = MixBlend.setup;\n    } else {\n      mix = to.mixTime / to.mixDuration;\n      if (mix > 1)\n        mix = 1;\n      if (blend != MixBlend.first)\n        blend = from.mixBlend;\n    }\n    const events = mix < from.eventThreshold ? this.events : null;\n    const attachments = mix < from.attachmentThreshold;\n    const drawOrder = mix < from.drawOrderThreshold;\n    const animationLast = from.animationLast;\n    const animationTime = from.getAnimationTime();\n    const timelineCount = from.animation.timelines.length;\n    const timelines = from.animation.timelines;\n    const alphaHold = from.alpha * to.interruptAlpha;\n    const alphaMix = alphaHold * (1 - mix);\n    if (blend == MixBlend.add) {\n      for (let i = 0; i < timelineCount; i++)\n        timelines[i].apply(skeleton, animationLast, animationTime, events, alphaMix, blend, MixDirection.mixOut);\n    } else {\n      const timelineMode = from.timelineMode;\n      const timelineHoldMix = from.timelineHoldMix;\n      const firstFrame = from.timelinesRotation.length == 0;\n      if (firstFrame)\n        Utils.setArraySize(from.timelinesRotation, timelineCount << 1, null);\n      const timelinesRotation = from.timelinesRotation;\n      from.totalAlpha = 0;\n      for (let i = 0; i < timelineCount; i++) {\n        const timeline = timelines[i];\n        let direction = MixDirection.mixOut;\n        let timelineBlend;\n        let alpha = 0;\n        switch (timelineMode[i]) {\n          case _AnimationState.SUBSEQUENT:\n            if (!drawOrder && timeline instanceof DrawOrderTimeline)\n              continue;\n            timelineBlend = blend;\n            alpha = alphaMix;\n            break;\n          case _AnimationState.FIRST:\n            timelineBlend = MixBlend.setup;\n            alpha = alphaMix;\n            break;\n          case _AnimationState.HOLD_SUBSEQUENT:\n            timelineBlend = blend;\n            alpha = alphaHold;\n            break;\n          case _AnimationState.HOLD_FIRST:\n            timelineBlend = MixBlend.setup;\n            alpha = alphaHold;\n            break;\n          default:\n            timelineBlend = MixBlend.setup;\n            const holdMix = timelineHoldMix[i];\n            alpha = alphaHold * Math.max(0, 1 - holdMix.mixTime / holdMix.mixDuration);\n            break;\n        }\n        from.totalAlpha += alpha;\n        if (timeline instanceof RotateTimeline)\n          this.applyRotateTimeline(timeline, skeleton, animationTime, alpha, timelineBlend, timelinesRotation, i << 1, firstFrame);\n        else if (timeline instanceof AttachmentTimeline)\n          this.applyAttachmentTimeline(timeline, skeleton, animationTime, timelineBlend, attachments);\n        else {\n          Utils.webkit602BugfixHelper(alpha, blend);\n          if (drawOrder && timeline instanceof DrawOrderTimeline && timelineBlend == MixBlend.setup)\n            direction = MixDirection.mixIn;\n          timeline.apply(skeleton, animationLast, animationTime, events, alpha, timelineBlend, direction);\n        }\n      }\n    }\n    if (to.mixDuration > 0)\n      this.queueEvents(from, animationTime);\n    this.events.length = 0;\n    from.nextAnimationLast = animationTime;\n    from.nextTrackLast = from.trackTime;\n    return mix;\n  }\n  applyAttachmentTimeline(timeline, skeleton, time, blend, attachments) {\n    const slot = skeleton.slots[timeline.slotIndex];\n    if (!slot.bone.active)\n      return;\n    const frames = timeline.frames;\n    if (time < frames[0]) {\n      if (blend == MixBlend.setup || blend == MixBlend.first)\n        this.setAttachment(skeleton, slot, slot.data.attachmentName, attachments);\n    } else {\n      let frameIndex;\n      if (time >= frames[frames.length - 1])\n        frameIndex = frames.length - 1;\n      else\n        frameIndex = Animation.binarySearch(frames, time) - 1;\n      this.setAttachment(skeleton, slot, timeline.attachmentNames[frameIndex], attachments);\n    }\n    if (slot.attachmentState <= this.unkeyedState)\n      slot.attachmentState = this.unkeyedState + _AnimationState.SETUP;\n  }\n  setAttachment(skeleton, slot, attachmentName, attachments) {\n    slot.setAttachment(attachmentName == null ? null : skeleton.getAttachment(slot.data.index, attachmentName));\n    if (attachments)\n      slot.attachmentState = this.unkeyedState + _AnimationState.CURRENT;\n  }\n  applyRotateTimeline(timeline, skeleton, time, alpha, blend, timelinesRotation, i, firstFrame) {\n    if (firstFrame)\n      timelinesRotation[i] = 0;\n    if (alpha == 1) {\n      timeline.apply(skeleton, 0, time, null, 1, blend, MixDirection.mixIn);\n      return;\n    }\n    const rotateTimeline = timeline;\n    const frames = rotateTimeline.frames;\n    const bone = skeleton.bones[rotateTimeline.boneIndex];\n    if (!bone.active)\n      return;\n    let r1 = 0;\n    let r2 = 0;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.rotation = bone.data.rotation;\n        default:\n          return;\n        case MixBlend.first:\n          r1 = bone.rotation;\n          r2 = bone.data.rotation;\n      }\n    } else {\n      r1 = blend == MixBlend.setup ? bone.data.rotation : bone.rotation;\n      if (time >= frames[frames.length - RotateTimeline.ENTRIES])\n        r2 = bone.data.rotation + frames[frames.length + RotateTimeline.PREV_ROTATION];\n      else {\n        const frame = Animation.binarySearch(frames, time, RotateTimeline.ENTRIES);\n        const prevRotation = frames[frame + RotateTimeline.PREV_ROTATION];\n        const frameTime = frames[frame];\n        const percent = rotateTimeline.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + RotateTimeline.PREV_TIME] - frameTime));\n        r2 = frames[frame + RotateTimeline.ROTATION] - prevRotation;\n        r2 -= (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360;\n        r2 = prevRotation + r2 * percent + bone.data.rotation;\n        r2 -= (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360;\n      }\n    }\n    let total = 0;\n    let diff = r2 - r1;\n    diff -= (16384 - (16384.499999999996 - diff / 360 | 0)) * 360;\n    if (diff == 0) {\n      total = timelinesRotation[i];\n    } else {\n      let lastTotal = 0;\n      let lastDiff = 0;\n      if (firstFrame) {\n        lastTotal = 0;\n        lastDiff = diff;\n      } else {\n        lastTotal = timelinesRotation[i];\n        lastDiff = timelinesRotation[i + 1];\n      }\n      const current = diff > 0;\n      let dir = lastTotal >= 0;\n      if (MathUtils.signum(lastDiff) != MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {\n        if (Math.abs(lastTotal) > 180)\n          lastTotal += 360 * MathUtils.signum(lastTotal);\n        dir = current;\n      }\n      total = diff + lastTotal - lastTotal % 360;\n      if (dir != current)\n        total += 360 * MathUtils.signum(lastTotal);\n      timelinesRotation[i] = total;\n    }\n    timelinesRotation[i + 1] = diff;\n    r1 += total * alpha;\n    bone.rotation = r1 - (16384 - (16384.499999999996 - r1 / 360 | 0)) * 360;\n  }\n  queueEvents(entry, animationTime) {\n    const animationStart = entry.animationStart;\n    const animationEnd = entry.animationEnd;\n    const duration = animationEnd - animationStart;\n    const trackLastWrapped = entry.trackLast % duration;\n    const events = this.events;\n    let i = 0;\n    const n = events.length;\n    for (; i < n; i++) {\n      const event = events[i];\n      if (event.time < trackLastWrapped)\n        break;\n      if (event.time > animationEnd)\n        continue;\n      this.queue.event(entry, event);\n    }\n    let complete = false;\n    if (entry.loop)\n      complete = duration == 0 || trackLastWrapped > entry.trackTime % duration;\n    else\n      complete = animationTime >= animationEnd && entry.animationLast < animationEnd;\n    if (complete)\n      this.queue.complete(entry);\n    for (; i < n; i++) {\n      const event = events[i];\n      if (event.time < animationStart)\n        continue;\n      this.queue.event(entry, events[i]);\n    }\n  }\n  /** Removes all animations from all tracks, leaving skeletons in their current pose.\n   *\n   * It may be desired to use {@link AnimationState#setEmptyAnimation()} to mix the skeletons back to the setup pose,\n   * rather than leaving them in their current pose. */\n  clearTracks() {\n    const oldDrainDisabled = this.queue.drainDisabled;\n    this.queue.drainDisabled = true;\n    for (let i = 0, n = this.tracks.length; i < n; i++)\n      this.clearTrack(i);\n    this.tracks.length = 0;\n    this.queue.drainDisabled = oldDrainDisabled;\n    this.queue.drain();\n  }\n  /** Removes all animations from the track, leaving skeletons in their current pose.\n   *\n   * It may be desired to use {@link AnimationState#setEmptyAnimation()} to mix the skeletons back to the setup pose,\n   * rather than leaving them in their current pose. */\n  clearTrack(trackIndex) {\n    if (trackIndex >= this.tracks.length)\n      return;\n    const current = this.tracks[trackIndex];\n    if (current == null)\n      return;\n    this.queue.end(current);\n    this.disposeNext(current);\n    let entry = current;\n    while (true) {\n      const from = entry.mixingFrom;\n      if (from == null)\n        break;\n      this.queue.end(from);\n      entry.mixingFrom = null;\n      entry.mixingTo = null;\n      entry = from;\n    }\n    this.tracks[current.trackIndex] = null;\n    this.queue.drain();\n  }\n  setCurrent(index, current, interrupt) {\n    const from = this.expandToIndex(index);\n    this.tracks[index] = current;\n    if (from != null) {\n      if (interrupt)\n        this.queue.interrupt(from);\n      current.mixingFrom = from;\n      from.mixingTo = current;\n      current.mixTime = 0;\n      if (from.mixingFrom != null && from.mixDuration > 0)\n        current.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);\n      from.timelinesRotation.length = 0;\n    }\n    this.queue.start(current);\n  }\n  /** Sets an animation by name.\n   *\n   * {@link #setAnimationWith(}. */\n  setAnimation(trackIndex, animationName, loop) {\n    const animation = this.data.skeletonData.findAnimation(animationName);\n    if (animation == null)\n      throw new Error(`Animation not found: ${animationName}`);\n    return this.setAnimationWith(trackIndex, animation, loop);\n  }\n  /** Sets the current animation for a track, discarding any queued animations. If the formerly current track entry was never\n   * applied to a skeleton, it is replaced (not mixed from).\n   * @param loop If true, the animation will repeat. If false it will not, instead its last frame is applied if played beyond its\n   *           duration. In either case {@link TrackEntry#trackEnd} determines when the track is cleared.\n   * @returns A track entry to allow further customization of animation playback. References to the track entry must not be kept\n   *         after the {@link AnimationStateListener#dispose()} event occurs. */\n  setAnimationWith(trackIndex, animation, loop) {\n    if (animation == null)\n      throw new Error(\"animation cannot be null.\");\n    let interrupt = true;\n    let current = this.expandToIndex(trackIndex);\n    if (current != null) {\n      if (current.nextTrackLast == -1) {\n        this.tracks[trackIndex] = current.mixingFrom;\n        this.queue.interrupt(current);\n        this.queue.end(current);\n        this.disposeNext(current);\n        current = current.mixingFrom;\n        interrupt = false;\n      } else\n        this.disposeNext(current);\n    }\n    const entry = this.trackEntry(trackIndex, animation, loop, current);\n    this.setCurrent(trackIndex, entry, interrupt);\n    this.queue.drain();\n    return entry;\n  }\n  /** Queues an animation by name.\n   *\n   * See {@link #addAnimationWith()}. */\n  addAnimation(trackIndex, animationName, loop, delay) {\n    const animation = this.data.skeletonData.findAnimation(animationName);\n    if (animation == null)\n      throw new Error(`Animation not found: ${animationName}`);\n    return this.addAnimationWith(trackIndex, animation, loop, delay);\n  }\n  /** Adds an animation to be played after the current or last queued animation for a track. If the track is empty, it is\n   * equivalent to calling {@link #setAnimationWith()}.\n   * @param delay If > 0, sets {@link TrackEntry#delay}. If <= 0, the delay set is the duration of the previous track entry\n   *           minus any mix duration (from the {@link AnimationStateData}) plus the specified `delay` (ie the mix\n   *           ends at (`delay` = 0) or before (`delay` < 0) the previous track entry duration). If the\n   *           previous entry is looping, its next loop completion is used instead of its duration.\n   * @returns A track entry to allow further customization of animation playback. References to the track entry must not be kept\n   *         after the {@link AnimationStateListener#dispose()} event occurs. */\n  addAnimationWith(trackIndex, animation, loop, delay) {\n    if (animation == null)\n      throw new Error(\"animation cannot be null.\");\n    let last = this.expandToIndex(trackIndex);\n    if (last != null) {\n      while (last.next != null)\n        last = last.next;\n    }\n    const entry = this.trackEntry(trackIndex, animation, loop, last);\n    if (last == null) {\n      this.setCurrent(trackIndex, entry, true);\n      this.queue.drain();\n    } else {\n      last.next = entry;\n      if (delay <= 0) {\n        const duration = last.animationEnd - last.animationStart;\n        if (duration != 0) {\n          if (last.loop)\n            delay += duration * (1 + (last.trackTime / duration | 0));\n          else\n            delay += Math.max(duration, last.trackTime);\n          delay -= this.data.getMix(last.animation, animation);\n        } else\n          delay = last.trackTime;\n      }\n    }\n    entry.delay = delay;\n    return entry;\n  }\n  /** Sets an empty animation for a track, discarding any queued animations, and sets the track entry's\n   * {@link TrackEntry#mixduration}. An empty animation has no timelines and serves as a placeholder for mixing in or out.\n   *\n   * Mixing out is done by setting an empty animation with a mix duration using either {@link #setEmptyAnimation()},\n   * {@link #setEmptyAnimations()}, or {@link #addEmptyAnimation()}. Mixing to an empty animation causes\n   * the previous animation to be applied less and less over the mix duration. Properties keyed in the previous animation\n   * transition to the value from lower tracks or to the setup pose value if no lower tracks key the property. A mix duration of\n   * 0 still mixes out over one frame.\n   *\n   * Mixing in is done by first setting an empty animation, then adding an animation using\n   * {@link #addAnimation()} and on the returned track entry, set the\n   * {@link TrackEntry#setMixDuration()}. Mixing from an empty animation causes the new animation to be applied more and\n   * more over the mix duration. Properties keyed in the new animation transition from the value from lower tracks or from the\n   * setup pose value if no lower tracks key the property to the value keyed in the new animation. */\n  setEmptyAnimation(trackIndex, mixDuration) {\n    const entry = this.setAnimationWith(trackIndex, _AnimationState.emptyAnimation, false);\n    entry.mixDuration = mixDuration;\n    entry.trackEnd = mixDuration;\n    return entry;\n  }\n  /** Adds an empty animation to be played after the current or last queued animation for a track, and sets the track entry's\n   * {@link TrackEntry#mixDuration}. If the track is empty, it is equivalent to calling\n   * {@link #setEmptyAnimation()}.\n   *\n   * See {@link #setEmptyAnimation()}.\n   * @param delay If > 0, sets {@link TrackEntry#delay}. If <= 0, the delay set is the duration of the previous track entry\n   *           minus any mix duration plus the specified `delay` (ie the mix ends at (`delay` = 0) or\n   *           before (`delay` < 0) the previous track entry duration). If the previous entry is looping, its next\n   *           loop completion is used instead of its duration.\n   * @return A track entry to allow further customization of animation playback. References to the track entry must not be kept\n   *         after the {@link AnimationStateListener#dispose()} event occurs. */\n  addEmptyAnimation(trackIndex, mixDuration, delay) {\n    if (delay <= 0)\n      delay -= mixDuration;\n    const entry = this.addAnimationWith(trackIndex, _AnimationState.emptyAnimation, false, delay);\n    entry.mixDuration = mixDuration;\n    entry.trackEnd = mixDuration;\n    return entry;\n  }\n  /** Sets an empty animation for every track, discarding any queued animations, and mixes to it over the specified mix\n   * duration. */\n  setEmptyAnimations(mixDuration) {\n    const oldDrainDisabled = this.queue.drainDisabled;\n    this.queue.drainDisabled = true;\n    for (let i = 0, n = this.tracks.length; i < n; i++) {\n      const current = this.tracks[i];\n      if (current != null)\n        this.setEmptyAnimation(current.trackIndex, mixDuration);\n    }\n    this.queue.drainDisabled = oldDrainDisabled;\n    this.queue.drain();\n  }\n  expandToIndex(index) {\n    if (index < this.tracks.length)\n      return this.tracks[index];\n    Utils.ensureArrayCapacity(this.tracks, index + 1, null);\n    this.tracks.length = index + 1;\n    return null;\n  }\n  /** @param last May be null. */\n  trackEntry(trackIndex, animation, loop, last) {\n    const entry = this.trackEntryPool.obtain();\n    entry.trackIndex = trackIndex;\n    entry.animation = animation;\n    entry.loop = loop;\n    entry.holdPrevious = false;\n    entry.eventThreshold = 0;\n    entry.attachmentThreshold = 0;\n    entry.drawOrderThreshold = 0;\n    entry.animationStart = 0;\n    entry.animationEnd = animation.duration;\n    entry.animationLast = -1;\n    entry.nextAnimationLast = -1;\n    entry.delay = 0;\n    entry.trackTime = 0;\n    entry.trackLast = -1;\n    entry.nextTrackLast = -1;\n    entry.trackEnd = Number.MAX_VALUE;\n    entry.timeScale = 1;\n    entry.alpha = 1;\n    entry.interruptAlpha = 1;\n    entry.mixTime = 0;\n    entry.mixDuration = last == null ? 0 : this.data.getMix(last.animation, animation);\n    entry.mixBlend = MixBlend.replace;\n    return entry;\n  }\n  disposeNext(entry) {\n    let next = entry.next;\n    while (next != null) {\n      this.queue.dispose(next);\n      next = next.next;\n    }\n    entry.next = null;\n  }\n  _animationsChanged() {\n    this.animationsChanged = false;\n    this.propertyIDs.clear();\n    for (let i = 0, n = this.tracks.length; i < n; i++) {\n      let entry = this.tracks[i];\n      if (entry == null)\n        continue;\n      while (entry.mixingFrom != null)\n        entry = entry.mixingFrom;\n      do {\n        if (entry.mixingFrom == null || entry.mixBlend != MixBlend.add)\n          this.computeHold(entry);\n        entry = entry.mixingTo;\n      } while (entry != null);\n    }\n  }\n  computeHold(entry) {\n    const to = entry.mixingTo;\n    const timelines = entry.animation.timelines;\n    const timelinesCount = entry.animation.timelines.length;\n    const timelineMode = Utils.setArraySize(entry.timelineMode, timelinesCount);\n    entry.timelineHoldMix.length = 0;\n    const timelineDipMix = Utils.setArraySize(entry.timelineHoldMix, timelinesCount);\n    const propertyIDs = this.propertyIDs;\n    if (to != null && to.holdPrevious) {\n      for (let i = 0; i < timelinesCount; i++) {\n        timelineMode[i] = propertyIDs.add(timelines[i].getPropertyId()) ? _AnimationState.HOLD_FIRST : _AnimationState.HOLD_SUBSEQUENT;\n      }\n      return;\n    }\n    outer:\n      for (let i = 0; i < timelinesCount; i++) {\n        const timeline = timelines[i];\n        const id = timeline.getPropertyId();\n        if (!propertyIDs.add(id))\n          timelineMode[i] = _AnimationState.SUBSEQUENT;\n        else if (to == null || timeline instanceof AttachmentTimeline || timeline instanceof DrawOrderTimeline || timeline instanceof EventTimeline || !to.animation.hasTimeline(id)) {\n          timelineMode[i] = _AnimationState.FIRST;\n        } else {\n          for (let next = to.mixingTo; next != null; next = next.mixingTo) {\n            if (next.animation.hasTimeline(id))\n              continue;\n            if (entry.mixDuration > 0) {\n              timelineMode[i] = _AnimationState.HOLD_MIX;\n              timelineDipMix[i] = next;\n              continue outer;\n            }\n            break;\n          }\n          timelineMode[i] = _AnimationState.HOLD_FIRST;\n        }\n      }\n  }\n  /** Returns the track entry for the animation currently playing on the track, or null if no animation is currently playing. */\n  getCurrent(trackIndex) {\n    if (trackIndex >= this.tracks.length)\n      return null;\n    return this.tracks[trackIndex];\n  }\n  /** Adds a listener to receive events for all track entries. */\n  addListener(listener) {\n    if (listener == null)\n      throw new Error(\"listener cannot be null.\");\n    this.listeners.push(listener);\n  }\n  /** Removes the listener added with {@link #addListener()}. */\n  removeListener(listener) {\n    const index = this.listeners.indexOf(listener);\n    if (index >= 0)\n      this.listeners.splice(index, 1);\n  }\n  /** Removes all listeners added with {@link #addListener()}. */\n  clearListeners() {\n    this.listeners.length = 0;\n  }\n  /** Discards all listener notifications that have not yet been delivered. This can be useful to call from an\n   * {@link AnimationStateListener} when it is known that further notifications that may have been already queued for delivery\n   * are not wanted because new animations are being set. */\n  clearListenerNotifications() {\n    this.queue.clear();\n  }\n  setAnimationByName(trackIndex, animationName, loop) {\n    if (!_AnimationState.deprecatedWarning1) {\n      _AnimationState.deprecatedWarning1 = true;\n      console.warn(\"Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.\");\n    }\n    this.setAnimation(trackIndex, animationName, loop);\n  }\n  addAnimationByName(trackIndex, animationName, loop, delay) {\n    if (!_AnimationState.deprecatedWarning2) {\n      _AnimationState.deprecatedWarning2 = true;\n      console.warn(\"Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.\");\n    }\n    this.addAnimation(trackIndex, animationName, loop, delay);\n  }\n  hasAnimation(animationName) {\n    const animation = this.data.skeletonData.findAnimation(animationName);\n    return animation !== null;\n  }\n  hasAnimationByName(animationName) {\n    if (!_AnimationState.deprecatedWarning3) {\n      _AnimationState.deprecatedWarning3 = true;\n      console.warn(\"Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.\");\n    }\n    return this.hasAnimation(animationName);\n  }\n};\nlet AnimationState = _AnimationState;\nAnimationState.emptyAnimation = new Animation(\"<empty>\", [], 0);\n/** 1. A previously applied timeline has set this property.\n *\n * Result: Mix from the current pose to the timeline pose. */\nAnimationState.SUBSEQUENT = 0;\n/** 1. This is the first timeline to set this property.\n * 2. The next track entry applied after this one does not have a timeline to set this property.\n *\n * Result: Mix from the setup pose to the timeline pose. */\nAnimationState.FIRST = 1;\n/** 1) A previously applied timeline has set this property.<br>\n * 2) The next track entry to be applied does have a timeline to set this property.<br>\n * 3) The next track entry after that one does not have a timeline to set this property.<br>\n * Result: Mix from the current pose to the timeline pose, but do not mix out. This avoids \"dipping\" when crossfading\n * animations that key the same property. A subsequent timeline will set this property using a mix. */\nAnimationState.HOLD_SUBSEQUENT = 2;\n/** 1) This is the first timeline to set this property.<br>\n * 2) The next track entry to be applied does have a timeline to set this property.<br>\n * 3) The next track entry after that one does not have a timeline to set this property.<br>\n * Result: Mix from the setup pose to the timeline pose, but do not mix out. This avoids \"dipping\" when crossfading animations\n * that key the same property. A subsequent timeline will set this property using a mix. */\nAnimationState.HOLD_FIRST = 3;\n/** 1. This is the first timeline to set this property.\n * 2. The next track entry to be applied does have a timeline to set this property.\n * 3. The next track entry after that one does have a timeline to set this property.\n * 4. timelineHoldMix stores the first subsequent track entry that does not have a timeline to set this property.\n *\n * Result: The same as HOLD except the mix percentage from the timelineHoldMix track entry is used. This handles when more than\n * 2 track entries in a row have a timeline that sets the same property.\n *\n * Eg, A -> B -> C -> D where A, B, and C have a timeline setting same property, but D does not. When A is applied, to avoid\n * \"dipping\" A is not mixed out, however D (the first entry that doesn't set the property) mixing in is used to mix out A\n * (which affects B and C). Without using D to mix out, A would be applied fully until mixing completes, then snap into\n * place. */\nAnimationState.HOLD_MIX = 4;\nAnimationState.SETUP = 1;\nAnimationState.CURRENT = 2;\nAnimationState.deprecatedWarning1 = false;\nAnimationState.deprecatedWarning2 = false;\nAnimationState.deprecatedWarning3 = false;\nconst _TrackEntry = class {\n  constructor() {\n    /** Controls how properties keyed in the animation are mixed with lower tracks. Defaults to {@link MixBlend#replace}, which\n     * replaces the values from the lower tracks with the animation values. {@link MixBlend#add} adds the animation values to\n     * the values from the lower tracks.\n     *\n     * The `mixBlend` can be set for a new track entry only before {@link AnimationState#apply()} is first\n     * called. */\n    this.mixBlend = MixBlend.replace;\n    this.timelineMode = new Array();\n    this.timelineHoldMix = new Array();\n    this.timelinesRotation = new Array();\n  }\n  reset() {\n    this.next = null;\n    this.mixingFrom = null;\n    this.mixingTo = null;\n    this.animation = null;\n    this.listener = null;\n    this.timelineMode.length = 0;\n    this.timelineHoldMix.length = 0;\n    this.timelinesRotation.length = 0;\n  }\n  /** Uses {@link #trackTime} to compute the `animationTime`, which is between {@link #animationStart}\n   * and {@link #animationEnd}. When the `trackTime` is 0, the `animationTime` is equal to the\n   * `animationStart` time. */\n  getAnimationTime() {\n    if (this.loop) {\n      const duration = this.animationEnd - this.animationStart;\n      if (duration == 0)\n        return this.animationStart;\n      return this.trackTime % duration + this.animationStart;\n    }\n    return Math.min(this.trackTime + this.animationStart, this.animationEnd);\n  }\n  setAnimationLast(animationLast) {\n    this.animationLast = animationLast;\n    this.nextAnimationLast = animationLast;\n  }\n  /** Returns true if at least one loop has been completed.\n   *\n   * See {@link AnimationStateListener#complete()}. */\n  isComplete() {\n    return this.trackTime >= this.animationEnd - this.animationStart;\n  }\n  /** Resets the rotation directions for mixing this entry's rotate timelines. This can be useful to avoid bones rotating the\n   * long way around when using {@link #alpha} and starting animations on other tracks.\n   *\n   * Mixing with {@link MixBlend#replace} involves finding a rotation between two others, which has two possible solutions:\n   * the short way or the long way around. The two rotations likely change over time, so which direction is the short or long\n   * way also changes. If the short way was always chosen, bones would flip to the other side when that direction became the\n   * long way. TrackEntry chooses the short way the first time it is applied and remembers that direction. */\n  resetRotationDirections() {\n    this.timelinesRotation.length = 0;\n  }\n  get time() {\n    if (!_TrackEntry.deprecatedWarning1) {\n      _TrackEntry.deprecatedWarning1 = true;\n      console.warn(\"Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.\");\n    }\n    return this.trackTime;\n  }\n  set time(value) {\n    if (!_TrackEntry.deprecatedWarning1) {\n      _TrackEntry.deprecatedWarning1 = true;\n      console.warn(\"Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.\");\n    }\n    this.trackTime = value;\n  }\n  get endTime() {\n    if (!_TrackEntry.deprecatedWarning2) {\n      _TrackEntry.deprecatedWarning2 = true;\n      console.warn(\"Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.\");\n    }\n    return this.trackTime;\n  }\n  set endTime(value) {\n    if (!_TrackEntry.deprecatedWarning2) {\n      _TrackEntry.deprecatedWarning2 = true;\n      console.warn(\"Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.\");\n    }\n    this.trackTime = value;\n  }\n  loopsCount() {\n    return Math.floor(this.trackTime / this.trackEnd);\n  }\n};\nlet TrackEntry = _TrackEntry;\nTrackEntry.deprecatedWarning1 = false;\nTrackEntry.deprecatedWarning2 = false;\nconst _EventQueue = class {\n  constructor(animState) {\n    this.objects = [];\n    this.drainDisabled = false;\n    this.animState = animState;\n  }\n  start(entry) {\n    this.objects.push(EventType.start);\n    this.objects.push(entry);\n    this.animState.animationsChanged = true;\n  }\n  interrupt(entry) {\n    this.objects.push(EventType.interrupt);\n    this.objects.push(entry);\n  }\n  end(entry) {\n    this.objects.push(EventType.end);\n    this.objects.push(entry);\n    this.animState.animationsChanged = true;\n  }\n  dispose(entry) {\n    this.objects.push(EventType.dispose);\n    this.objects.push(entry);\n  }\n  complete(entry) {\n    this.objects.push(EventType.complete);\n    this.objects.push(entry);\n  }\n  event(entry, event) {\n    this.objects.push(EventType.event);\n    this.objects.push(entry);\n    this.objects.push(event);\n  }\n  deprecateStuff() {\n    if (!_EventQueue.deprecatedWarning1) {\n      _EventQueue.deprecatedWarning1 = true;\n      console.warn(\n        \"Spine Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'\"\n      );\n    }\n    return true;\n  }\n  drain() {\n    if (this.drainDisabled)\n      return;\n    this.drainDisabled = true;\n    const objects = this.objects;\n    const listeners = this.animState.listeners;\n    for (let i = 0; i < objects.length; i += 2) {\n      const type = objects[i];\n      const entry = objects[i + 1];\n      switch (type) {\n        case EventType.start:\n          if (entry.listener != null && entry.listener.start)\n            entry.listener.start(entry);\n          for (let ii = 0; ii < listeners.length; ii++)\n            if (listeners[ii].start)\n              listeners[ii].start(entry);\n          entry.onStart && this.deprecateStuff() && entry.onStart(entry.trackIndex);\n          this.animState.onStart && this.deprecateStuff() && this.deprecateStuff && this.animState.onStart(entry.trackIndex);\n          break;\n        case EventType.interrupt:\n          if (entry.listener != null && entry.listener.interrupt)\n            entry.listener.interrupt(entry);\n          for (let ii = 0; ii < listeners.length; ii++)\n            if (listeners[ii].interrupt)\n              listeners[ii].interrupt(entry);\n          break;\n        case EventType.end:\n          if (entry.listener != null && entry.listener.end)\n            entry.listener.end(entry);\n          for (let ii = 0; ii < listeners.length; ii++)\n            if (listeners[ii].end)\n              listeners[ii].end(entry);\n          entry.onEnd && this.deprecateStuff() && entry.onEnd(entry.trackIndex);\n          this.animState.onEnd && this.deprecateStuff() && this.animState.onEnd(entry.trackIndex);\n        case EventType.dispose:\n          if (entry.listener != null && entry.listener.dispose)\n            entry.listener.dispose(entry);\n          for (let ii = 0; ii < listeners.length; ii++)\n            if (listeners[ii].dispose)\n              listeners[ii].dispose(entry);\n          this.animState.trackEntryPool.free(entry);\n          break;\n        case EventType.complete:\n          if (entry.listener != null && entry.listener.complete)\n            entry.listener.complete(entry);\n          for (let ii = 0; ii < listeners.length; ii++)\n            if (listeners[ii].complete)\n              listeners[ii].complete(entry);\n          const count = MathUtils.toInt(entry.loopsCount());\n          entry.onComplete && this.deprecateStuff() && entry.onComplete(entry.trackIndex, count);\n          this.animState.onComplete && this.deprecateStuff() && this.animState.onComplete(entry.trackIndex, count);\n          break;\n        case EventType.event:\n          const event = objects[i++ + 2];\n          if (entry.listener != null && entry.listener.event)\n            entry.listener.event(entry, event);\n          for (let ii = 0; ii < listeners.length; ii++)\n            if (listeners[ii].event)\n              listeners[ii].event(entry, event);\n          entry.onEvent && this.deprecateStuff() && entry.onEvent(entry.trackIndex, event);\n          this.animState.onEvent && this.deprecateStuff() && this.animState.onEvent(entry.trackIndex, event);\n          break;\n      }\n    }\n    this.clear();\n    this.drainDisabled = false;\n  }\n  clear() {\n    this.objects.length = 0;\n  }\n};\nlet EventQueue = _EventQueue;\nEventQueue.deprecatedWarning1 = false;\nvar EventType = /* @__PURE__ */ ((EventType2) => {\n  EventType2[EventType2[\"start\"] = 0] = \"start\";\n  EventType2[EventType2[\"interrupt\"] = 1] = \"interrupt\";\n  EventType2[EventType2[\"end\"] = 2] = \"end\";\n  EventType2[EventType2[\"dispose\"] = 3] = \"dispose\";\n  EventType2[EventType2[\"complete\"] = 4] = \"complete\";\n  EventType2[EventType2[\"event\"] = 5] = \"event\";\n  return EventType2;\n})(EventType || {});\nclass AnimationStateAdapter {\n  start(entry) {\n  }\n  interrupt(entry) {\n  }\n  end(entry) {\n  }\n  dispose(entry) {\n  }\n  complete(entry) {\n  }\n  event(entry, event) {\n  }\n}\n\nexport { AnimationState, AnimationStateAdapter, EventQueue, EventType, TrackEntry };\n//# sourceMappingURL=AnimationState.mjs.map\n","const _AnimationStateData = class {\n  constructor(skeletonData) {\n    this.animationToMixTime = {};\n    this.defaultMix = 0;\n    if (skeletonData == null)\n      throw new Error(\"skeletonData cannot be null.\");\n    this.skeletonData = skeletonData;\n  }\n  setMix(fromName, toName, duration) {\n    const from = this.skeletonData.findAnimation(fromName);\n    if (from == null)\n      throw new Error(`Animation not found: ${fromName}`);\n    const to = this.skeletonData.findAnimation(toName);\n    if (to == null)\n      throw new Error(`Animation not found: ${toName}`);\n    this.setMixWith(from, to, duration);\n  }\n  setMixByName(fromName, toName, duration) {\n    if (!_AnimationStateData.deprecatedWarning1) {\n      _AnimationStateData.deprecatedWarning1 = true;\n      console.warn(\"Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.\");\n    }\n    this.setMix(fromName, toName, duration);\n  }\n  setMixWith(from, to, duration) {\n    if (from == null)\n      throw new Error(\"from cannot be null.\");\n    if (to == null)\n      throw new Error(\"to cannot be null.\");\n    const key = `${from.name}.${to.name}`;\n    this.animationToMixTime[key] = duration;\n  }\n  getMix(from, to) {\n    const key = `${from.name}.${to.name}`;\n    const value = this.animationToMixTime[key];\n    return value === void 0 ? this.defaultMix : value;\n  }\n};\nlet AnimationStateData = _AnimationStateData;\nAnimationStateData.deprecatedWarning1 = false;\n\nexport { AnimationStateData };\n//# sourceMappingURL=AnimationStateData.mjs.map\n","import { VertexAttachment } from './Attachment.mjs';\nimport { AttachmentType, Color } from '@pixi-spine/base';\n\nclass BoundingBoxAttachment extends VertexAttachment {\n  constructor(name) {\n    super(name);\n    this.type = AttachmentType.BoundingBox;\n    this.color = new Color(1, 1, 1, 1);\n  }\n  copy() {\n    const copy = new BoundingBoxAttachment(this.name);\n    this.copyTo(copy);\n    copy.color.setFromColor(this.color);\n    return copy;\n  }\n}\n\nexport { BoundingBoxAttachment };\n//# sourceMappingURL=BoundingBoxAttachment.mjs.map\n","import { VertexAttachment } from './Attachment.mjs';\nimport { AttachmentType, Color } from '@pixi-spine/base';\n\nclass ClippingAttachment extends VertexAttachment {\n  // ce3a3aff\n  constructor(name) {\n    super(name);\n    this.type = AttachmentType.Clipping;\n    // Nonessential.\n    this.color = new Color(0.2275, 0.2275, 0.8078, 1);\n  }\n  copy() {\n    const copy = new ClippingAttachment(this.name);\n    this.copyTo(copy);\n    copy.endSlot = this.endSlot;\n    copy.color.setFromColor(this.color);\n    return copy;\n  }\n}\n\nexport { ClippingAttachment };\n//# sourceMappingURL=ClippingAttachment.mjs.map\n","import { VertexAttachment } from './Attachment.mjs';\nimport { AttachmentType, Color, Utils } from '@pixi-spine/base';\n\nclass MeshAttachment extends VertexAttachment {\n  constructor(name) {\n    super(name);\n    this.type = AttachmentType.Mesh;\n    this.color = new Color(1, 1, 1, 1);\n    this.tempColor = new Color(0, 0, 0, 0);\n  }\n  getParentMesh() {\n    return this.parentMesh;\n  }\n  /** @param parentMesh May be null. */\n  setParentMesh(parentMesh) {\n    this.parentMesh = parentMesh;\n    if (parentMesh != null) {\n      this.bones = parentMesh.bones;\n      this.vertices = parentMesh.vertices;\n      this.worldVerticesLength = parentMesh.worldVerticesLength;\n      this.regionUVs = parentMesh.regionUVs;\n      this.triangles = parentMesh.triangles;\n      this.hullLength = parentMesh.hullLength;\n      this.worldVerticesLength = parentMesh.worldVerticesLength;\n    }\n  }\n  copy() {\n    if (this.parentMesh != null)\n      return this.newLinkedMesh();\n    const copy = new MeshAttachment(this.name);\n    copy.region = this.region;\n    copy.path = this.path;\n    copy.color.setFromColor(this.color);\n    this.copyTo(copy);\n    copy.regionUVs = new Float32Array(this.regionUVs.length);\n    Utils.arrayCopy(this.regionUVs, 0, copy.regionUVs, 0, this.regionUVs.length);\n    copy.triangles = new Array(this.triangles.length);\n    Utils.arrayCopy(this.triangles, 0, copy.triangles, 0, this.triangles.length);\n    copy.hullLength = this.hullLength;\n    if (this.edges != null) {\n      copy.edges = new Array(this.edges.length);\n      Utils.arrayCopy(this.edges, 0, copy.edges, 0, this.edges.length);\n    }\n    copy.width = this.width;\n    copy.height = this.height;\n    return copy;\n  }\n  newLinkedMesh() {\n    const copy = new MeshAttachment(this.name);\n    copy.region = this.region;\n    copy.path = this.path;\n    copy.color.setFromColor(this.color);\n    copy.deformAttachment = this.deformAttachment;\n    copy.setParentMesh(this.parentMesh != null ? this.parentMesh : this);\n    return copy;\n  }\n}\n\nexport { MeshAttachment };\n//# sourceMappingURL=MeshAttachment.mjs.map\n","import { VertexAttachment } from './Attachment.mjs';\nimport { AttachmentType, Color, Utils } from '@pixi-spine/base';\n\nclass PathAttachment extends VertexAttachment {\n  constructor(name) {\n    super(name);\n    this.type = AttachmentType.Path;\n    this.closed = false;\n    this.constantSpeed = false;\n    this.color = new Color(1, 1, 1, 1);\n  }\n  copy() {\n    const copy = new PathAttachment(this.name);\n    this.copyTo(copy);\n    copy.lengths = new Array(this.lengths.length);\n    Utils.arrayCopy(this.lengths, 0, copy.lengths, 0, this.lengths.length);\n    copy.closed = closed;\n    copy.constantSpeed = this.constantSpeed;\n    copy.color.setFromColor(this.color);\n    return copy;\n  }\n}\n\nexport { PathAttachment };\n//# sourceMappingURL=PathAttachment.mjs.map\n","import { VertexAttachment } from './Attachment.mjs';\nimport { AttachmentType, Color, MathUtils } from '@pixi-spine/base';\n\nclass PointAttachment extends VertexAttachment {\n  constructor(name) {\n    super(name);\n    this.type = AttachmentType.Point;\n    this.color = new Color(0.38, 0.94, 0, 1);\n  }\n  computeWorldPosition(bone, point) {\n    const mat = bone.matrix;\n    point.x = this.x * mat.a + this.y * mat.c + bone.worldX;\n    point.y = this.x * mat.b + this.y * mat.d + bone.worldY;\n    return point;\n  }\n  computeWorldRotation(bone) {\n    const mat = bone.matrix;\n    const cos = MathUtils.cosDeg(this.rotation);\n    const sin = MathUtils.sinDeg(this.rotation);\n    const x = cos * mat.a + sin * mat.c;\n    const y = cos * mat.b + sin * mat.d;\n    return Math.atan2(y, x) * MathUtils.radDeg;\n  }\n  copy() {\n    const copy = new PointAttachment(this.name);\n    copy.x = this.x;\n    copy.y = this.y;\n    copy.rotation = this.rotation;\n    copy.color.setFromColor(this.color);\n    return copy;\n  }\n}\n\nexport { PointAttachment };\n//# sourceMappingURL=PointAttachment.mjs.map\n","import './attachments/Attachment.mjs';\nimport { BoundingBoxAttachment } from './attachments/BoundingBoxAttachment.mjs';\nimport { ClippingAttachment } from './attachments/ClippingAttachment.mjs';\nimport { MeshAttachment } from './attachments/MeshAttachment.mjs';\nimport { PathAttachment } from './attachments/PathAttachment.mjs';\nimport { PointAttachment } from './attachments/PointAttachment.mjs';\nimport { RegionAttachment } from './attachments/RegionAttachment.mjs';\n\nclass AtlasAttachmentLoader {\n  constructor(atlas) {\n    this.atlas = atlas;\n  }\n  /** @return May be null to not load an attachment. */\n  newRegionAttachment(skin, name, path) {\n    const region = this.atlas.findRegion(path);\n    if (region == null)\n      throw new Error(`Region not found in atlas: ${path} (region attachment: ${name})`);\n    const attachment = new RegionAttachment(name);\n    attachment.region = region;\n    return attachment;\n  }\n  /** @return May be null to not load an attachment. */\n  newMeshAttachment(skin, name, path) {\n    const region = this.atlas.findRegion(path);\n    if (region == null)\n      throw new Error(`Region not found in atlas: ${path} (mesh attachment: ${name})`);\n    const attachment = new MeshAttachment(name);\n    attachment.region = region;\n    return attachment;\n  }\n  /** @return May be null to not load an attachment. */\n  newBoundingBoxAttachment(skin, name) {\n    return new BoundingBoxAttachment(name);\n  }\n  /** @return May be null to not load an attachment */\n  newPathAttachment(skin, name) {\n    return new PathAttachment(name);\n  }\n  newPointAttachment(skin, name) {\n    return new PointAttachment(name);\n  }\n  newClippingAttachment(skin, name) {\n    return new ClippingAttachment(name);\n  }\n}\n\nexport { AtlasAttachmentLoader };\n//# sourceMappingURL=AtlasAttachmentLoader.mjs.map\n","class ConstraintData {\n  constructor(name, order, skinRequired) {\n    this.name = name;\n    this.order = order;\n    this.skinRequired = skinRequired;\n  }\n}\n\nexport { ConstraintData };\n//# sourceMappingURL=Constraint.mjs.map\n","import { ConstraintData } from './Constraint.mjs';\n\nclass PathConstraintData extends ConstraintData {\n  constructor(name) {\n    super(name, 0, false);\n    this.bones = new Array();\n  }\n}\nvar SpacingMode = /* @__PURE__ */ ((SpacingMode2) => {\n  SpacingMode2[SpacingMode2[\"Length\"] = 0] = \"Length\";\n  SpacingMode2[SpacingMode2[\"Fixed\"] = 1] = \"Fixed\";\n  SpacingMode2[SpacingMode2[\"Percent\"] = 2] = \"Percent\";\n  return SpacingMode2;\n})(SpacingMode || {});\n\nexport { PathConstraintData, SpacingMode };\n//# sourceMappingURL=PathConstraintData.mjs.map\n","import './attachments/Attachment.mjs';\nimport { RotateMode, Utils, PositionMode, MathUtils } from '@pixi-spine/base';\nimport { PathAttachment } from './attachments/PathAttachment.mjs';\nimport './attachments/RegionAttachment.mjs';\nimport { SpacingMode } from './PathConstraintData.mjs';\n\nconst _PathConstraint = class {\n  constructor(data, skeleton) {\n    this.position = 0;\n    this.spacing = 0;\n    this.rotateMix = 0;\n    this.translateMix = 0;\n    this.spaces = new Array();\n    this.positions = new Array();\n    this.world = new Array();\n    this.curves = new Array();\n    this.lengths = new Array();\n    this.segments = new Array();\n    this.active = false;\n    if (data == null)\n      throw new Error(\"data cannot be null.\");\n    if (skeleton == null)\n      throw new Error(\"skeleton cannot be null.\");\n    this.data = data;\n    this.bones = new Array();\n    for (let i = 0, n = data.bones.length; i < n; i++)\n      this.bones.push(skeleton.findBone(data.bones[i].name));\n    this.target = skeleton.findSlot(data.target.name);\n    this.position = data.position;\n    this.spacing = data.spacing;\n    this.rotateMix = data.rotateMix;\n    this.translateMix = data.translateMix;\n  }\n  isActive() {\n    return this.active;\n  }\n  apply() {\n    this.update();\n  }\n  update() {\n    const attachment = this.target.getAttachment();\n    if (!(attachment instanceof PathAttachment))\n      return;\n    const rotateMix = this.rotateMix;\n    const translateMix = this.translateMix;\n    const translate = translateMix > 0;\n    const rotate = rotateMix > 0;\n    if (!translate && !rotate)\n      return;\n    const data = this.data;\n    const spacingMode = data.spacingMode;\n    const lengthSpacing = spacingMode == SpacingMode.Length;\n    const rotateMode = data.rotateMode;\n    const tangents = rotateMode == RotateMode.Tangent;\n    const scale = rotateMode == RotateMode.ChainScale;\n    const boneCount = this.bones.length;\n    const spacesCount = tangents ? boneCount : boneCount + 1;\n    const bones = this.bones;\n    const spaces = Utils.setArraySize(this.spaces, spacesCount);\n    let lengths = null;\n    const spacing = this.spacing;\n    if (scale || lengthSpacing) {\n      if (scale)\n        lengths = Utils.setArraySize(this.lengths, boneCount);\n      for (let i = 0, n = spacesCount - 1; i < n; ) {\n        const bone = bones[i];\n        const setupLength = bone.data.length;\n        if (setupLength < _PathConstraint.epsilon) {\n          if (scale)\n            lengths[i] = 0;\n          spaces[++i] = 0;\n        } else {\n          const x = setupLength * bone.matrix.a;\n          const y = setupLength * bone.matrix.b;\n          const length = Math.sqrt(x * x + y * y);\n          if (scale)\n            lengths[i] = length;\n          spaces[++i] = (lengthSpacing ? setupLength + spacing : spacing) * length / setupLength;\n        }\n      }\n    } else {\n      for (let i = 1; i < spacesCount; i++)\n        spaces[i] = spacing;\n    }\n    const positions = this.computeWorldPositions(\n      attachment,\n      spacesCount,\n      tangents,\n      data.positionMode == PositionMode.Percent,\n      spacingMode == SpacingMode.Percent\n    );\n    let boneX = positions[0];\n    let boneY = positions[1];\n    let offsetRotation = data.offsetRotation;\n    let tip = false;\n    if (offsetRotation == 0)\n      tip = rotateMode == RotateMode.Chain;\n    else {\n      tip = false;\n      const p = this.target.bone.matrix;\n      offsetRotation *= p.a * p.d - p.b * p.c > 0 ? MathUtils.degRad : -MathUtils.degRad;\n    }\n    for (let i = 0, p = 3; i < boneCount; i++, p += 3) {\n      const bone = bones[i];\n      const mat = bone.matrix;\n      mat.tx += (boneX - mat.tx) * translateMix;\n      mat.ty += (boneY - mat.ty) * translateMix;\n      const x = positions[p];\n      const y = positions[p + 1];\n      const dx = x - boneX;\n      const dy = y - boneY;\n      if (scale) {\n        const length = lengths[i];\n        if (length != 0) {\n          const s = (Math.sqrt(dx * dx + dy * dy) / length - 1) * rotateMix + 1;\n          mat.a *= s;\n          mat.b *= s;\n        }\n      }\n      boneX = x;\n      boneY = y;\n      if (rotate) {\n        const a = mat.a;\n        const b = mat.c;\n        const c = mat.b;\n        const d = mat.d;\n        let r = 0;\n        let cos = 0;\n        let sin = 0;\n        if (tangents)\n          if (tangents)\n            r = positions[p - 1];\n          else if (spaces[i + 1] == 0)\n            r = positions[p + 2];\n          else\n            r = Math.atan2(dy, dx);\n        r -= Math.atan2(c, a);\n        if (tip) {\n          cos = Math.cos(r);\n          sin = Math.sin(r);\n          const length = bone.data.length;\n          boneX += (length * (cos * a - sin * c) - dx) * rotateMix;\n          boneY += (length * (sin * a + cos * c) - dy) * rotateMix;\n        } else {\n          r += offsetRotation;\n        }\n        if (r > MathUtils.PI)\n          r -= MathUtils.PI2;\n        else if (r < -MathUtils.PI)\n          r += MathUtils.PI2;\n        r *= rotateMix;\n        cos = Math.cos(r);\n        sin = Math.sin(r);\n        mat.a = cos * a - sin * c;\n        mat.c = cos * b - sin * d;\n        mat.b = sin * a + cos * c;\n        mat.d = sin * b + cos * d;\n      }\n      bone.appliedValid = false;\n    }\n  }\n  computeWorldPositions(path, spacesCount, tangents, percentPosition, percentSpacing) {\n    const target = this.target;\n    let position = this.position;\n    const spaces = this.spaces;\n    const out = Utils.setArraySize(this.positions, spacesCount * 3 + 2);\n    let world = null;\n    const closed = path.closed;\n    let verticesLength = path.worldVerticesLength;\n    let curveCount = verticesLength / 6;\n    let prevCurve = _PathConstraint.NONE;\n    if (!path.constantSpeed) {\n      const lengths = path.lengths;\n      curveCount -= closed ? 1 : 2;\n      const pathLength2 = lengths[curveCount];\n      if (percentPosition)\n        position *= pathLength2;\n      if (percentSpacing) {\n        for (let i = 0; i < spacesCount; i++)\n          spaces[i] *= pathLength2;\n      }\n      world = Utils.setArraySize(this.world, 8);\n      for (let i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {\n        const space = spaces[i];\n        position += space;\n        let p = position;\n        if (closed) {\n          p %= pathLength2;\n          if (p < 0)\n            p += pathLength2;\n          curve = 0;\n        } else if (p < 0) {\n          if (prevCurve != _PathConstraint.BEFORE) {\n            prevCurve = _PathConstraint.BEFORE;\n            path.computeWorldVertices(target, 2, 4, world, 0, 2);\n          }\n          this.addBeforePosition(p, world, 0, out, o);\n          continue;\n        } else if (p > pathLength2) {\n          if (prevCurve != _PathConstraint.AFTER) {\n            prevCurve = _PathConstraint.AFTER;\n            path.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2);\n          }\n          this.addAfterPosition(p - pathLength2, world, 0, out, o);\n          continue;\n        }\n        for (; ; curve++) {\n          const length = lengths[curve];\n          if (p > length)\n            continue;\n          if (curve == 0)\n            p /= length;\n          else {\n            const prev = lengths[curve - 1];\n            p = (p - prev) / (length - prev);\n          }\n          break;\n        }\n        if (curve != prevCurve) {\n          prevCurve = curve;\n          if (closed && curve == curveCount) {\n            path.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);\n            path.computeWorldVertices(target, 0, 4, world, 4, 2);\n          } else\n            path.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2);\n        }\n        this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o, tangents || i > 0 && space == 0);\n      }\n      return out;\n    }\n    if (closed) {\n      verticesLength += 2;\n      world = Utils.setArraySize(this.world, verticesLength);\n      path.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);\n      path.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);\n      world[verticesLength - 2] = world[0];\n      world[verticesLength - 1] = world[1];\n    } else {\n      curveCount--;\n      verticesLength -= 4;\n      world = Utils.setArraySize(this.world, verticesLength);\n      path.computeWorldVertices(target, 2, verticesLength, world, 0, 2);\n    }\n    const curves = Utils.setArraySize(this.curves, curveCount);\n    let pathLength = 0;\n    let x1 = world[0];\n    let y1 = world[1];\n    let cx1 = 0;\n    let cy1 = 0;\n    let cx2 = 0;\n    let cy2 = 0;\n    let x2 = 0;\n    let y2 = 0;\n    let tmpx = 0;\n    let tmpy = 0;\n    let dddfx = 0;\n    let dddfy = 0;\n    let ddfx = 0;\n    let ddfy = 0;\n    let dfx = 0;\n    let dfy = 0;\n    for (let i = 0, w = 2; i < curveCount; i++, w += 6) {\n      cx1 = world[w];\n      cy1 = world[w + 1];\n      cx2 = world[w + 2];\n      cy2 = world[w + 3];\n      x2 = world[w + 4];\n      y2 = world[w + 5];\n      tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;\n      tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;\n      dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;\n      dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;\n      ddfx = tmpx * 2 + dddfx;\n      ddfy = tmpy * 2 + dddfy;\n      dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;\n      dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;\n      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n      dfx += ddfx;\n      dfy += ddfy;\n      ddfx += dddfx;\n      ddfy += dddfy;\n      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n      dfx += ddfx;\n      dfy += ddfy;\n      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n      dfx += ddfx + dddfx;\n      dfy += ddfy + dddfy;\n      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n      curves[i] = pathLength;\n      x1 = x2;\n      y1 = y2;\n    }\n    if (percentPosition)\n      position *= pathLength;\n    if (percentSpacing) {\n      for (let i = 0; i < spacesCount; i++)\n        spaces[i] *= pathLength;\n    }\n    const segments = this.segments;\n    let curveLength = 0;\n    for (let i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {\n      const space = spaces[i];\n      position += space;\n      let p = position;\n      if (closed) {\n        p %= pathLength;\n        if (p < 0)\n          p += pathLength;\n        curve = 0;\n      } else if (p < 0) {\n        this.addBeforePosition(p, world, 0, out, o);\n        continue;\n      } else if (p > pathLength) {\n        this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);\n        continue;\n      }\n      for (; ; curve++) {\n        const length = curves[curve];\n        if (p > length)\n          continue;\n        if (curve == 0)\n          p /= length;\n        else {\n          const prev = curves[curve - 1];\n          p = (p - prev) / (length - prev);\n        }\n        break;\n      }\n      if (curve != prevCurve) {\n        prevCurve = curve;\n        let ii = curve * 6;\n        x1 = world[ii];\n        y1 = world[ii + 1];\n        cx1 = world[ii + 2];\n        cy1 = world[ii + 3];\n        cx2 = world[ii + 4];\n        cy2 = world[ii + 5];\n        x2 = world[ii + 6];\n        y2 = world[ii + 7];\n        tmpx = (x1 - cx1 * 2 + cx2) * 0.03;\n        tmpy = (y1 - cy1 * 2 + cy2) * 0.03;\n        dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 6e-3;\n        dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 6e-3;\n        ddfx = tmpx * 2 + dddfx;\n        ddfy = tmpy * 2 + dddfy;\n        dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;\n        dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;\n        curveLength = Math.sqrt(dfx * dfx + dfy * dfy);\n        segments[0] = curveLength;\n        for (ii = 1; ii < 8; ii++) {\n          dfx += ddfx;\n          dfy += ddfy;\n          ddfx += dddfx;\n          ddfy += dddfy;\n          curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n          segments[ii] = curveLength;\n        }\n        dfx += ddfx;\n        dfy += ddfy;\n        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n        segments[8] = curveLength;\n        dfx += ddfx + dddfx;\n        dfy += ddfy + dddfy;\n        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n        segments[9] = curveLength;\n        segment = 0;\n      }\n      p *= curveLength;\n      for (; ; segment++) {\n        const length = segments[segment];\n        if (p > length)\n          continue;\n        if (segment == 0)\n          p /= length;\n        else {\n          const prev = segments[segment - 1];\n          p = segment + (p - prev) / (length - prev);\n        }\n        break;\n      }\n      this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || i > 0 && space == 0);\n    }\n    return out;\n  }\n  addBeforePosition(p, temp, i, out, o) {\n    const x1 = temp[i];\n    const y1 = temp[i + 1];\n    const dx = temp[i + 2] - x1;\n    const dy = temp[i + 3] - y1;\n    const r = Math.atan2(dy, dx);\n    out[o] = x1 + p * Math.cos(r);\n    out[o + 1] = y1 + p * Math.sin(r);\n    out[o + 2] = r;\n  }\n  addAfterPosition(p, temp, i, out, o) {\n    const x1 = temp[i + 2];\n    const y1 = temp[i + 3];\n    const dx = x1 - temp[i];\n    const dy = y1 - temp[i + 1];\n    const r = Math.atan2(dy, dx);\n    out[o] = x1 + p * Math.cos(r);\n    out[o + 1] = y1 + p * Math.sin(r);\n    out[o + 2] = r;\n  }\n  addCurvePosition(p, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents) {\n    if (p == 0 || isNaN(p))\n      p = 1e-4;\n    const tt = p * p;\n    const ttt = tt * p;\n    const u = 1 - p;\n    const uu = u * u;\n    const uuu = uu * u;\n    const ut = u * p;\n    const ut3 = ut * 3;\n    const uut3 = u * ut3;\n    const utt3 = ut3 * p;\n    const x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt;\n    const y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;\n    out[o] = x;\n    out[o + 1] = y;\n    if (tangents)\n      out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));\n  }\n};\nlet PathConstraint = _PathConstraint;\nPathConstraint.NONE = -1;\nPathConstraint.BEFORE = -2;\nPathConstraint.AFTER = -3;\nPathConstraint.epsilon = 1e-5;\n\nexport { PathConstraint };\n//# sourceMappingURL=PathConstraint.mjs.map\n","import { Matrix } from '@pixi/core';\nimport { settings, MathUtils, TransformMode } from '@pixi-spine/base';\n\nclass Bone {\n  /** @param parent May be null. */\n  constructor(data, skeleton, parent) {\n    // be careful! Spine b,c is c,b in pixi matrix\n    this.matrix = new Matrix();\n    this.children = new Array();\n    this.x = 0;\n    this.y = 0;\n    this.rotation = 0;\n    this.scaleX = 0;\n    this.scaleY = 0;\n    this.shearX = 0;\n    this.shearY = 0;\n    this.ax = 0;\n    this.ay = 0;\n    this.arotation = 0;\n    this.ascaleX = 0;\n    this.ascaleY = 0;\n    this.ashearX = 0;\n    this.ashearY = 0;\n    this.appliedValid = false;\n    this.sorted = false;\n    this.active = false;\n    if (data == null)\n      throw new Error(\"data cannot be null.\");\n    if (skeleton == null)\n      throw new Error(\"skeleton cannot be null.\");\n    this.data = data;\n    this.skeleton = skeleton;\n    this.parent = parent;\n    this.setToSetupPose();\n  }\n  get worldX() {\n    return this.matrix.tx;\n  }\n  get worldY() {\n    return this.matrix.ty;\n  }\n  isActive() {\n    return this.active;\n  }\n  /** Same as {@link #updateWorldTransform()}. This method exists for Bone to implement {@link Updatable}. */\n  update() {\n    this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\n  }\n  /** Computes the world transform using the parent bone and this bone's local transform. */\n  updateWorldTransform() {\n    this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\n  }\n  /** Computes the world transform using the parent bone and the specified local transform. */\n  updateWorldTransformWith(x, y, rotation, scaleX, scaleY, shearX, shearY) {\n    this.ax = x;\n    this.ay = y;\n    this.arotation = rotation;\n    this.ascaleX = scaleX;\n    this.ascaleY = scaleY;\n    this.ashearX = shearX;\n    this.ashearY = shearY;\n    this.appliedValid = true;\n    const parent = this.parent;\n    const m = this.matrix;\n    const sx = this.skeleton.scaleX;\n    const sy = settings.yDown ? -this.skeleton.scaleY : this.skeleton.scaleY;\n    if (parent == null) {\n      const skeleton = this.skeleton;\n      const rotationY = rotation + 90 + shearY;\n      m.a = MathUtils.cosDeg(rotation + shearX) * scaleX * sx;\n      m.c = MathUtils.cosDeg(rotationY) * scaleY * sx;\n      m.b = MathUtils.sinDeg(rotation + shearX) * scaleX * sy;\n      m.d = MathUtils.sinDeg(rotationY) * scaleY * sy;\n      m.tx = x * sx + skeleton.x;\n      m.ty = y * sy + skeleton.y;\n      return;\n    }\n    let pa = parent.matrix.a;\n    let pb = parent.matrix.c;\n    let pc = parent.matrix.b;\n    let pd = parent.matrix.d;\n    m.tx = pa * x + pb * y + parent.matrix.tx;\n    m.ty = pc * x + pd * y + parent.matrix.ty;\n    switch (this.data.transformMode) {\n      case TransformMode.Normal: {\n        const rotationY = rotation + 90 + shearY;\n        const la = MathUtils.cosDeg(rotation + shearX) * scaleX;\n        const lb = MathUtils.cosDeg(rotationY) * scaleY;\n        const lc = MathUtils.sinDeg(rotation + shearX) * scaleX;\n        const ld = MathUtils.sinDeg(rotationY) * scaleY;\n        m.a = pa * la + pb * lc;\n        m.c = pa * lb + pb * ld;\n        m.b = pc * la + pd * lc;\n        m.d = pc * lb + pd * ld;\n        return;\n      }\n      case TransformMode.OnlyTranslation: {\n        const rotationY = rotation + 90 + shearY;\n        m.a = MathUtils.cosDeg(rotation + shearX) * scaleX;\n        m.c = MathUtils.cosDeg(rotationY) * scaleY;\n        m.b = MathUtils.sinDeg(rotation + shearX) * scaleX;\n        m.d = MathUtils.sinDeg(rotationY) * scaleY;\n        break;\n      }\n      case TransformMode.NoRotationOrReflection: {\n        let s = pa * pa + pc * pc;\n        let prx = 0;\n        if (s > 1e-4) {\n          s = Math.abs(pa * pd - pb * pc) / s;\n          pa /= this.skeleton.scaleX;\n          pc /= this.skeleton.scaleY;\n          pb = pc * s;\n          pd = pa * s;\n          prx = Math.atan2(pc, pa) * MathUtils.radDeg;\n        } else {\n          pa = 0;\n          pc = 0;\n          prx = 90 - Math.atan2(pd, pb) * MathUtils.radDeg;\n        }\n        const rx = rotation + shearX - prx;\n        const ry = rotation + shearY - prx + 90;\n        const la = MathUtils.cosDeg(rx) * scaleX;\n        const lb = MathUtils.cosDeg(ry) * scaleY;\n        const lc = MathUtils.sinDeg(rx) * scaleX;\n        const ld = MathUtils.sinDeg(ry) * scaleY;\n        m.a = pa * la - pb * lc;\n        m.c = pa * lb - pb * ld;\n        m.b = pc * la + pd * lc;\n        m.d = pc * lb + pd * ld;\n        break;\n      }\n      case TransformMode.NoScale:\n      case TransformMode.NoScaleOrReflection: {\n        const cos = MathUtils.cosDeg(rotation);\n        const sin = MathUtils.sinDeg(rotation);\n        let za = (pa * cos + pb * sin) / sx;\n        let zc = (pc * cos + pd * sin) / sy;\n        let s = Math.sqrt(za * za + zc * zc);\n        if (s > 1e-5)\n          s = 1 / s;\n        za *= s;\n        zc *= s;\n        s = Math.sqrt(za * za + zc * zc);\n        if (this.data.transformMode == TransformMode.NoScale && pa * pd - pb * pc < 0 != (settings.yDown ? this.skeleton.scaleX < 0 != this.skeleton.scaleY > 0 : this.skeleton.scaleX < 0 != this.skeleton.scaleY < 0))\n          s = -s;\n        const r = Math.PI / 2 + Math.atan2(zc, za);\n        const zb = Math.cos(r) * s;\n        const zd = Math.sin(r) * s;\n        const la = MathUtils.cosDeg(shearX) * scaleX;\n        const lb = MathUtils.cosDeg(90 + shearY) * scaleY;\n        const lc = MathUtils.sinDeg(shearX) * scaleX;\n        const ld = MathUtils.sinDeg(90 + shearY) * scaleY;\n        m.a = za * la + zb * lc;\n        m.c = za * lb + zb * ld;\n        m.b = zc * la + zd * lc;\n        m.d = zc * lb + zd * ld;\n        break;\n      }\n    }\n    m.a *= sx;\n    m.c *= sx;\n    m.b *= sy;\n    m.d *= sy;\n  }\n  setToSetupPose() {\n    const data = this.data;\n    this.x = data.x;\n    this.y = data.y;\n    this.rotation = data.rotation;\n    this.scaleX = data.scaleX;\n    this.scaleY = data.scaleY;\n    this.shearX = data.shearX;\n    this.shearY = data.shearY;\n  }\n  getWorldRotationX() {\n    return Math.atan2(this.matrix.b, this.matrix.a) * MathUtils.radDeg;\n  }\n  getWorldRotationY() {\n    return Math.atan2(this.matrix.d, this.matrix.c) * MathUtils.radDeg;\n  }\n  getWorldScaleX() {\n    const m = this.matrix;\n    return Math.sqrt(m.a * m.a + m.c * m.c);\n  }\n  getWorldScaleY() {\n    const m = this.matrix;\n    return Math.sqrt(m.b * m.b + m.d * m.d);\n  }\n  /** Computes the individual applied transform values from the world transform. This can be useful to perform processing using\n   * the applied transform after the world transform has been modified directly (eg, by a constraint).\n   * <p>\n   * Some information is ambiguous in the world transform, such as -1,-1 scale versus 180 rotation. */\n  updateAppliedTransform() {\n    this.appliedValid = true;\n    const parent = this.parent;\n    const m = this.matrix;\n    if (parent == null) {\n      this.ax = m.tx;\n      this.ay = m.ty;\n      this.arotation = Math.atan2(m.b, m.a) * MathUtils.radDeg;\n      this.ascaleX = Math.sqrt(m.a * m.a + m.b * m.b);\n      this.ascaleY = Math.sqrt(m.c * m.c + m.d * m.d);\n      this.ashearX = 0;\n      this.ashearY = Math.atan2(m.a * m.c + m.b * m.d, m.a * m.d - m.b * m.c) * MathUtils.radDeg;\n      return;\n    }\n    const pm = parent.matrix;\n    const pid = 1 / (pm.a * pm.d - pm.b * pm.c);\n    const dx = m.tx - pm.tx;\n    const dy = m.ty - pm.ty;\n    this.ax = dx * pm.d * pid - dy * pm.c * pid;\n    this.ay = dy * pm.a * pid - dx * pm.b * pid;\n    const ia = pid * pm.d;\n    const id = pid * pm.a;\n    const ib = pid * pm.c;\n    const ic = pid * pm.b;\n    const ra = ia * m.a - ib * m.b;\n    const rb = ia * m.c - ib * m.d;\n    const rc = id * m.b - ic * m.a;\n    const rd = id * m.d - ic * m.c;\n    this.ashearX = 0;\n    this.ascaleX = Math.sqrt(ra * ra + rc * rc);\n    if (this.ascaleX > 1e-4) {\n      const det = ra * rd - rb * rc;\n      this.ascaleY = det / this.ascaleX;\n      this.ashearY = Math.atan2(ra * rb + rc * rd, det) * MathUtils.radDeg;\n      this.arotation = Math.atan2(rc, ra) * MathUtils.radDeg;\n    } else {\n      this.ascaleX = 0;\n      this.ascaleY = Math.sqrt(rb * rb + rd * rd);\n      this.ashearY = 0;\n      this.arotation = 90 - Math.atan2(rd, rb) * MathUtils.radDeg;\n    }\n  }\n  worldToLocal(world) {\n    const m = this.matrix;\n    const a = m.a;\n    const b = m.c;\n    const c = m.b;\n    const d = m.d;\n    const invDet = 1 / (a * d - b * c);\n    const x = world.x - m.tx;\n    const y = world.y - m.ty;\n    world.x = x * d * invDet - y * b * invDet;\n    world.y = y * a * invDet - x * c * invDet;\n    return world;\n  }\n  localToWorld(local) {\n    const m = this.matrix;\n    const x = local.x;\n    const y = local.y;\n    local.x = x * m.a + y * m.c + m.tx;\n    local.y = x * m.b + y * m.d + m.ty;\n    return local;\n  }\n  worldToLocalRotation(worldRotation) {\n    const sin = MathUtils.sinDeg(worldRotation);\n    const cos = MathUtils.cosDeg(worldRotation);\n    const mat = this.matrix;\n    return Math.atan2(mat.a * sin - mat.b * cos, mat.d * cos - mat.c * sin) * MathUtils.radDeg;\n  }\n  localToWorldRotation(localRotation) {\n    const sin = MathUtils.sinDeg(localRotation);\n    const cos = MathUtils.cosDeg(localRotation);\n    const mat = this.matrix;\n    return Math.atan2(cos * mat.b + sin * mat.d, cos * mat.a + sin * mat.c) * MathUtils.radDeg;\n  }\n  rotateWorld(degrees) {\n    const mat = this.matrix;\n    const a = mat.a;\n    const b = mat.c;\n    const c = mat.b;\n    const d = mat.d;\n    const cos = MathUtils.cosDeg(degrees);\n    const sin = MathUtils.sinDeg(degrees);\n    mat.a = cos * a - sin * c;\n    mat.c = cos * b - sin * d;\n    mat.b = sin * a + cos * c;\n    mat.d = sin * b + cos * d;\n    this.appliedValid = false;\n  }\n}\n\nexport { Bone };\n//# sourceMappingURL=Bone.mjs.map\n","import { TransformMode, MathUtils } from '@pixi-spine/base';\n\nclass IkConstraint {\n  constructor(data, skeleton) {\n    this.bendDirection = 0;\n    this.compress = false;\n    this.stretch = false;\n    this.mix = 1;\n    this.softness = 0;\n    this.active = false;\n    if (data == null)\n      throw new Error(\"data cannot be null.\");\n    if (skeleton == null)\n      throw new Error(\"skeleton cannot be null.\");\n    this.data = data;\n    this.mix = data.mix;\n    this.softness = data.softness;\n    this.bendDirection = data.bendDirection;\n    this.compress = data.compress;\n    this.stretch = data.stretch;\n    this.bones = new Array();\n    for (let i = 0; i < data.bones.length; i++)\n      this.bones.push(skeleton.findBone(data.bones[i].name));\n    this.target = skeleton.findBone(data.target.name);\n  }\n  isActive() {\n    return this.active;\n  }\n  apply() {\n    this.update();\n  }\n  update() {\n    const target = this.target;\n    const bones = this.bones;\n    switch (bones.length) {\n      case 1:\n        this.apply1(bones[0], target.worldX, target.worldY, this.compress, this.stretch, this.data.uniform, this.mix);\n        break;\n      case 2:\n        this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.stretch, this.softness, this.mix);\n        break;\n    }\n  }\n  /** Adjusts the bone rotation so the tip is as close to the target position as possible. The target is specified in the world\n   * coordinate system. */\n  apply1(bone, targetX, targetY, compress, stretch, uniform, alpha) {\n    if (!bone.appliedValid)\n      bone.updateAppliedTransform();\n    const p = bone.parent.matrix;\n    const pa = p.a;\n    let pb = p.c;\n    const pc = p.b;\n    let pd = p.d;\n    let rotationIK = -bone.ashearX - bone.arotation;\n    let tx = 0;\n    let ty = 0;\n    switch (bone.data.transformMode) {\n      case TransformMode.OnlyTranslation:\n        tx = targetX - bone.worldX;\n        ty = targetY - bone.worldY;\n        break;\n      case TransformMode.NoRotationOrReflection:\n        const s = Math.abs(pa * pd - pb * pc) / (pa * pa + pc * pc);\n        const sa = pa / bone.skeleton.scaleX;\n        const sc = pc / bone.skeleton.scaleY;\n        pb = -sc * s * bone.skeleton.scaleX;\n        pd = sa * s * bone.skeleton.scaleY;\n        rotationIK += Math.atan2(sc, sa) * MathUtils.radDeg;\n      default:\n        const x = targetX - p.tx;\n        const y = targetY - p.ty;\n        const d = pa * pd - pb * pc;\n        tx = (x * pd - y * pb) / d - bone.ax;\n        ty = (y * pa - x * pc) / d - bone.ay;\n    }\n    rotationIK += Math.atan2(ty, tx) * MathUtils.radDeg;\n    if (bone.ascaleX < 0)\n      rotationIK += 180;\n    if (rotationIK > 180)\n      rotationIK -= 360;\n    else if (rotationIK < -180)\n      rotationIK += 360;\n    let sx = bone.ascaleX;\n    let sy = bone.ascaleY;\n    if (compress || stretch) {\n      switch (bone.data.transformMode) {\n        case TransformMode.NoScale:\n        case TransformMode.NoScaleOrReflection:\n          tx = targetX - bone.worldX;\n          ty = targetY - bone.worldY;\n      }\n      const b = bone.data.length * sx;\n      const dd = Math.sqrt(tx * tx + ty * ty);\n      if (compress && dd < b || stretch && dd > b && b > 1e-4) {\n        const s = (dd / b - 1) * alpha + 1;\n        sx *= s;\n        if (uniform)\n          sy *= s;\n      }\n    }\n    bone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, sx, sy, bone.ashearX, bone.ashearY);\n  }\n  /** Adjusts the parent and child bone rotations so the tip of the child is as close to the target position as possible. The\n   * target is specified in the world coordinate system.\n   * @param child A direct descendant of the parent bone. */\n  apply2(parent, child, targetX, targetY, bendDir, stretch, softness, alpha) {\n    if (alpha == 0) {\n      child.updateWorldTransform();\n      return;\n    }\n    if (!parent.appliedValid)\n      parent.updateAppliedTransform();\n    if (!child.appliedValid)\n      child.updateAppliedTransform();\n    const px = parent.ax;\n    const py = parent.ay;\n    let psx = parent.ascaleX;\n    let sx = psx;\n    let psy = parent.ascaleY;\n    let csx = child.ascaleX;\n    const pmat = parent.matrix;\n    let os1 = 0;\n    let os2 = 0;\n    let s2 = 0;\n    if (psx < 0) {\n      psx = -psx;\n      os1 = 180;\n      s2 = -1;\n    } else {\n      os1 = 0;\n      s2 = 1;\n    }\n    if (psy < 0) {\n      psy = -psy;\n      s2 = -s2;\n    }\n    if (csx < 0) {\n      csx = -csx;\n      os2 = 180;\n    } else\n      os2 = 0;\n    const cx = child.ax;\n    let cy = 0;\n    let cwx = 0;\n    let cwy = 0;\n    let a = pmat.a;\n    let b = pmat.c;\n    let c = pmat.b;\n    let d = pmat.d;\n    const u = Math.abs(psx - psy) <= 1e-4;\n    if (!u) {\n      cy = 0;\n      cwx = a * cx + pmat.tx;\n      cwy = c * cx + pmat.ty;\n    } else {\n      cy = child.ay;\n      cwx = a * cx + b * cy + pmat.tx;\n      cwy = c * cx + d * cy + pmat.ty;\n    }\n    const pp = parent.parent.matrix;\n    a = pp.a;\n    b = pp.c;\n    c = pp.b;\n    d = pp.d;\n    const id = 1 / (a * d - b * c);\n    let x = cwx - pp.tx;\n    let y = cwy - pp.ty;\n    const dx = (x * d - y * b) * id - px;\n    const dy = (y * a - x * c) * id - py;\n    const l1 = Math.sqrt(dx * dx + dy * dy);\n    let l2 = child.data.length * csx;\n    let a1;\n    let a2;\n    if (l1 < 1e-4) {\n      this.apply1(parent, targetX, targetY, false, stretch, false, alpha);\n      child.updateWorldTransformWith(cx, cy, 0, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\n      return;\n    }\n    x = targetX - pp.tx;\n    y = targetY - pp.ty;\n    let tx = (x * d - y * b) * id - px;\n    let ty = (y * a - x * c) * id - py;\n    let dd = tx * tx + ty * ty;\n    if (softness != 0) {\n      softness *= psx * (csx + 1) / 2;\n      const td = Math.sqrt(dd);\n      const sd = td - l1 - l2 * psx + softness;\n      if (sd > 0) {\n        let p = Math.min(1, sd / (softness * 2)) - 1;\n        p = (sd - softness * (1 - p * p)) / td;\n        tx -= p * tx;\n        ty -= p * ty;\n        dd = tx * tx + ty * ty;\n      }\n    }\n    outer:\n      if (u) {\n        l2 *= psx;\n        let cos = (dd - l1 * l1 - l2 * l2) / (2 * l1 * l2);\n        if (cos < -1)\n          cos = -1;\n        else if (cos > 1) {\n          cos = 1;\n          if (stretch)\n            sx *= (Math.sqrt(dd) / (l1 + l2) - 1) * alpha + 1;\n        }\n        a2 = Math.acos(cos) * bendDir;\n        a = l1 + l2 * cos;\n        b = l2 * Math.sin(a2);\n        a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);\n      } else {\n        a = psx * l2;\n        b = psy * l2;\n        const aa = a * a;\n        const bb = b * b;\n        const ta = Math.atan2(ty, tx);\n        c = bb * l1 * l1 + aa * dd - aa * bb;\n        const c1 = -2 * bb * l1;\n        const c2 = bb - aa;\n        d = c1 * c1 - 4 * c2 * c;\n        if (d >= 0) {\n          let q = Math.sqrt(d);\n          if (c1 < 0)\n            q = -q;\n          q = -(c1 + q) / 2;\n          const r0 = q / c2;\n          const r1 = c / q;\n          const r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;\n          if (r * r <= dd) {\n            y = Math.sqrt(dd - r * r) * bendDir;\n            a1 = ta - Math.atan2(y, r);\n            a2 = Math.atan2(y / psy, (r - l1) / psx);\n            break outer;\n          }\n        }\n        let minAngle = MathUtils.PI;\n        let minX = l1 - a;\n        let minDist = minX * minX;\n        let minY = 0;\n        let maxAngle = 0;\n        let maxX = l1 + a;\n        let maxDist = maxX * maxX;\n        let maxY = 0;\n        c = -a * l1 / (aa - bb);\n        if (c >= -1 && c <= 1) {\n          c = Math.acos(c);\n          x = a * Math.cos(c) + l1;\n          y = b * Math.sin(c);\n          d = x * x + y * y;\n          if (d < minDist) {\n            minAngle = c;\n            minDist = d;\n            minX = x;\n            minY = y;\n          }\n          if (d > maxDist) {\n            maxAngle = c;\n            maxDist = d;\n            maxX = x;\n            maxY = y;\n          }\n        }\n        if (dd <= (minDist + maxDist) / 2) {\n          a1 = ta - Math.atan2(minY * bendDir, minX);\n          a2 = minAngle * bendDir;\n        } else {\n          a1 = ta - Math.atan2(maxY * bendDir, maxX);\n          a2 = maxAngle * bendDir;\n        }\n      }\n    const os = Math.atan2(cy, cx) * s2;\n    let rotation = parent.arotation;\n    a1 = (a1 - os) * MathUtils.radDeg + os1 - rotation;\n    if (a1 > 180)\n      a1 -= 360;\n    else if (a1 < -180)\n      a1 += 360;\n    parent.updateWorldTransformWith(px, py, rotation + a1 * alpha, sx, parent.ascaleY, 0, 0);\n    rotation = child.arotation;\n    a2 = ((a2 + os) * MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;\n    if (a2 > 180)\n      a2 -= 360;\n    else if (a2 < -180)\n      a2 += 360;\n    child.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\n  }\n}\n\nexport { IkConstraint };\n//# sourceMappingURL=IkConstraint.mjs.map\n","import { Vector2, MathUtils } from '@pixi-spine/base';\n\nclass TransformConstraint {\n  constructor(data, skeleton) {\n    this.rotateMix = 0;\n    this.translateMix = 0;\n    this.scaleMix = 0;\n    this.shearMix = 0;\n    this.temp = new Vector2();\n    this.active = false;\n    if (data == null)\n      throw new Error(\"data cannot be null.\");\n    if (skeleton == null)\n      throw new Error(\"skeleton cannot be null.\");\n    this.data = data;\n    this.rotateMix = data.rotateMix;\n    this.translateMix = data.translateMix;\n    this.scaleMix = data.scaleMix;\n    this.shearMix = data.shearMix;\n    this.bones = new Array();\n    for (let i = 0; i < data.bones.length; i++)\n      this.bones.push(skeleton.findBone(data.bones[i].name));\n    this.target = skeleton.findBone(data.target.name);\n  }\n  isActive() {\n    return this.active;\n  }\n  apply() {\n    this.update();\n  }\n  update() {\n    if (this.data.local) {\n      if (this.data.relative)\n        this.applyRelativeLocal();\n      else\n        this.applyAbsoluteLocal();\n    } else if (this.data.relative)\n      this.applyRelativeWorld();\n    else\n      this.applyAbsoluteWorld();\n  }\n  applyAbsoluteWorld() {\n    const rotateMix = this.rotateMix;\n    const translateMix = this.translateMix;\n    const scaleMix = this.scaleMix;\n    const shearMix = this.shearMix;\n    const target = this.target;\n    const targetMat = target.matrix;\n    const ta = targetMat.a;\n    const tb = targetMat.c;\n    const tc = targetMat.b;\n    const td = targetMat.d;\n    const degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;\n    const offsetRotation = this.data.offsetRotation * degRadReflect;\n    const offsetShearY = this.data.offsetShearY * degRadReflect;\n    const bones = this.bones;\n    for (let i = 0, n = bones.length; i < n; i++) {\n      const bone = bones[i];\n      let modified = false;\n      const mat = bone.matrix;\n      if (rotateMix != 0) {\n        const a = mat.a;\n        const b = mat.c;\n        const c = mat.b;\n        const d = mat.d;\n        let r = Math.atan2(tc, ta) - Math.atan2(c, a) + offsetRotation;\n        if (r > MathUtils.PI)\n          r -= MathUtils.PI2;\n        else if (r < -MathUtils.PI)\n          r += MathUtils.PI2;\n        r *= rotateMix;\n        const cos = Math.cos(r);\n        const sin = Math.sin(r);\n        mat.a = cos * a - sin * c;\n        mat.c = cos * b - sin * d;\n        mat.b = sin * a + cos * c;\n        mat.d = sin * b + cos * d;\n        modified = true;\n      }\n      if (translateMix != 0) {\n        const temp = this.temp;\n        target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\n        mat.tx += (temp.x - mat.tx) * translateMix;\n        mat.ty += (temp.y - mat.ty) * translateMix;\n        modified = true;\n      }\n      if (scaleMix > 0) {\n        let s = Math.sqrt(mat.a * mat.a + mat.b * mat.b);\n        let ts = Math.sqrt(ta * ta + tc * tc);\n        if (s > 1e-5)\n          s = (s + (ts - s + this.data.offsetScaleX) * scaleMix) / s;\n        mat.a *= s;\n        mat.b *= s;\n        s = Math.sqrt(mat.c * mat.c + mat.d * mat.d);\n        ts = Math.sqrt(tb * tb + td * td);\n        if (s > 1e-5)\n          s = (s + (ts - s + this.data.offsetScaleY) * scaleMix) / s;\n        mat.c *= s;\n        mat.d *= s;\n        modified = true;\n      }\n      if (shearMix > 0) {\n        const b = mat.c;\n        const d = mat.d;\n        const by = Math.atan2(d, b);\n        let r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(mat.b, mat.a));\n        if (r > MathUtils.PI)\n          r -= MathUtils.PI2;\n        else if (r < -MathUtils.PI)\n          r += MathUtils.PI2;\n        r = by + (r + offsetShearY) * shearMix;\n        const s = Math.sqrt(b * b + d * d);\n        mat.c = Math.cos(r) * s;\n        mat.d = Math.sin(r) * s;\n        modified = true;\n      }\n      if (modified)\n        bone.appliedValid = false;\n    }\n  }\n  applyRelativeWorld() {\n    const rotateMix = this.rotateMix;\n    const translateMix = this.translateMix;\n    const scaleMix = this.scaleMix;\n    const shearMix = this.shearMix;\n    const target = this.target;\n    const targetMat = target.matrix;\n    const ta = targetMat.a;\n    const tb = targetMat.c;\n    const tc = targetMat.b;\n    const td = targetMat.d;\n    const degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;\n    const offsetRotation = this.data.offsetRotation * degRadReflect;\n    const offsetShearY = this.data.offsetShearY * degRadReflect;\n    const bones = this.bones;\n    for (let i = 0, n = bones.length; i < n; i++) {\n      const bone = bones[i];\n      let modified = false;\n      const mat = bone.matrix;\n      if (rotateMix != 0) {\n        const a = mat.a;\n        const b = mat.c;\n        const c = mat.b;\n        const d = mat.d;\n        let r = Math.atan2(tc, ta) + offsetRotation;\n        if (r > MathUtils.PI)\n          r -= MathUtils.PI2;\n        else if (r < -MathUtils.PI)\n          r += MathUtils.PI2;\n        r *= rotateMix;\n        const cos = Math.cos(r);\n        const sin = Math.sin(r);\n        mat.a = cos * a - sin * c;\n        mat.c = cos * b - sin * d;\n        mat.b = sin * a + cos * c;\n        mat.d = sin * b + cos * d;\n        modified = true;\n      }\n      if (translateMix != 0) {\n        const temp = this.temp;\n        target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\n        mat.tx += temp.x * translateMix;\n        mat.ty += temp.y * translateMix;\n        modified = true;\n      }\n      if (scaleMix > 0) {\n        let s = (Math.sqrt(ta * ta + tc * tc) - 1 + this.data.offsetScaleX) * scaleMix + 1;\n        mat.a *= s;\n        mat.b *= s;\n        s = (Math.sqrt(tb * tb + td * td) - 1 + this.data.offsetScaleY) * scaleMix + 1;\n        mat.c *= s;\n        mat.d *= s;\n        modified = true;\n      }\n      if (shearMix > 0) {\n        let r = Math.atan2(td, tb) - Math.atan2(tc, ta);\n        if (r > MathUtils.PI)\n          r -= MathUtils.PI2;\n        else if (r < -MathUtils.PI)\n          r += MathUtils.PI2;\n        const b = mat.c;\n        const d = mat.d;\n        r = Math.atan2(d, b) + (r - MathUtils.PI / 2 + offsetShearY) * shearMix;\n        const s = Math.sqrt(b * b + d * d);\n        mat.c = Math.cos(r) * s;\n        mat.d = Math.sin(r) * s;\n        modified = true;\n      }\n      if (modified)\n        bone.appliedValid = false;\n    }\n  }\n  applyAbsoluteLocal() {\n    const rotateMix = this.rotateMix;\n    const translateMix = this.translateMix;\n    const scaleMix = this.scaleMix;\n    const shearMix = this.shearMix;\n    const target = this.target;\n    if (!target.appliedValid)\n      target.updateAppliedTransform();\n    const bones = this.bones;\n    for (let i = 0, n = bones.length; i < n; i++) {\n      const bone = bones[i];\n      if (!bone.appliedValid)\n        bone.updateAppliedTransform();\n      let rotation = bone.arotation;\n      if (rotateMix != 0) {\n        let r = target.arotation - rotation + this.data.offsetRotation;\n        r -= (16384 - (16384.499999999996 - r / 360 | 0)) * 360;\n        rotation += r * rotateMix;\n      }\n      let x = bone.ax;\n      let y = bone.ay;\n      if (translateMix != 0) {\n        x += (target.ax - x + this.data.offsetX) * translateMix;\n        y += (target.ay - y + this.data.offsetY) * translateMix;\n      }\n      let scaleX = bone.ascaleX;\n      let scaleY = bone.ascaleY;\n      if (scaleMix > 0) {\n        if (scaleX > 1e-5)\n          scaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * scaleMix) / scaleX;\n        if (scaleY > 1e-5)\n          scaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * scaleMix) / scaleY;\n      }\n      const shearY = bone.ashearY;\n      if (shearMix > 0) {\n        let r = target.ashearY - shearY + this.data.offsetShearY;\n        r -= (16384 - (16384.499999999996 - r / 360 | 0)) * 360;\n        bone.shearY += r * shearMix;\n      }\n      bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\n    }\n  }\n  applyRelativeLocal() {\n    const rotateMix = this.rotateMix;\n    const translateMix = this.translateMix;\n    const scaleMix = this.scaleMix;\n    const shearMix = this.shearMix;\n    const target = this.target;\n    if (!target.appliedValid)\n      target.updateAppliedTransform();\n    const bones = this.bones;\n    for (let i = 0, n = bones.length; i < n; i++) {\n      const bone = bones[i];\n      if (!bone.appliedValid)\n        bone.updateAppliedTransform();\n      let rotation = bone.arotation;\n      if (rotateMix != 0)\n        rotation += (target.arotation + this.data.offsetRotation) * rotateMix;\n      let x = bone.ax;\n      let y = bone.ay;\n      if (translateMix != 0) {\n        x += (target.ax + this.data.offsetX) * translateMix;\n        y += (target.ay + this.data.offsetY) * translateMix;\n      }\n      let scaleX = bone.ascaleX;\n      let scaleY = bone.ascaleY;\n      if (scaleMix > 0) {\n        if (scaleX > 1e-5)\n          scaleX *= (target.ascaleX - 1 + this.data.offsetScaleX) * scaleMix + 1;\n        if (scaleY > 1e-5)\n          scaleY *= (target.ascaleY - 1 + this.data.offsetScaleY) * scaleMix + 1;\n      }\n      let shearY = bone.ashearY;\n      if (shearMix > 0)\n        shearY += (target.ashearY + this.data.offsetShearY) * shearMix;\n      bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\n    }\n  }\n}\n\nexport { TransformConstraint };\n//# sourceMappingURL=TransformConstraint.mjs.map\n","import './attachments/Attachment.mjs';\nimport { Color, Utils } from '@pixi-spine/base';\nimport { MeshAttachment } from './attachments/MeshAttachment.mjs';\nimport { PathAttachment } from './attachments/PathAttachment.mjs';\nimport { RegionAttachment } from './attachments/RegionAttachment.mjs';\nimport { Bone } from './Bone.mjs';\nimport { Slot } from './Slot.mjs';\nimport { IkConstraint } from './IkConstraint.mjs';\nimport { TransformConstraint } from './TransformConstraint.mjs';\nimport { PathConstraint } from './PathConstraint.mjs';\n\nconst _Skeleton = class {\n  constructor(data) {\n    this._updateCache = new Array();\n    this.updateCacheReset = new Array();\n    this.time = 0;\n    this.scaleX = 1;\n    this.scaleY = 1;\n    this.x = 0;\n    this.y = 0;\n    if (data == null)\n      throw new Error(\"data cannot be null.\");\n    this.data = data;\n    this.bones = new Array();\n    for (let i = 0; i < data.bones.length; i++) {\n      const boneData = data.bones[i];\n      let bone;\n      if (boneData.parent == null)\n        bone = new Bone(boneData, this, null);\n      else {\n        const parent = this.bones[boneData.parent.index];\n        bone = new Bone(boneData, this, parent);\n        parent.children.push(bone);\n      }\n      this.bones.push(bone);\n    }\n    this.slots = new Array();\n    this.drawOrder = new Array();\n    for (let i = 0; i < data.slots.length; i++) {\n      const slotData = data.slots[i];\n      const bone = this.bones[slotData.boneData.index];\n      const slot = new Slot(slotData, bone);\n      this.slots.push(slot);\n      this.drawOrder.push(slot);\n    }\n    this.ikConstraints = new Array();\n    for (let i = 0; i < data.ikConstraints.length; i++) {\n      const ikConstraintData = data.ikConstraints[i];\n      this.ikConstraints.push(new IkConstraint(ikConstraintData, this));\n    }\n    this.transformConstraints = new Array();\n    for (let i = 0; i < data.transformConstraints.length; i++) {\n      const transformConstraintData = data.transformConstraints[i];\n      this.transformConstraints.push(new TransformConstraint(transformConstraintData, this));\n    }\n    this.pathConstraints = new Array();\n    for (let i = 0; i < data.pathConstraints.length; i++) {\n      const pathConstraintData = data.pathConstraints[i];\n      this.pathConstraints.push(new PathConstraint(pathConstraintData, this));\n    }\n    this.color = new Color(1, 1, 1, 1);\n    this.updateCache();\n  }\n  updateCache() {\n    const updateCache = this._updateCache;\n    updateCache.length = 0;\n    this.updateCacheReset.length = 0;\n    const bones = this.bones;\n    for (let i = 0, n = bones.length; i < n; i++) {\n      const bone = bones[i];\n      bone.sorted = bone.data.skinRequired;\n      bone.active = !bone.sorted;\n    }\n    if (this.skin != null) {\n      const skinBones = this.skin.bones;\n      for (let i = 0, n = this.skin.bones.length; i < n; i++) {\n        let bone = this.bones[skinBones[i].index];\n        do {\n          bone.sorted = false;\n          bone.active = true;\n          bone = bone.parent;\n        } while (bone != null);\n      }\n    }\n    const ikConstraints = this.ikConstraints;\n    const transformConstraints = this.transformConstraints;\n    const pathConstraints = this.pathConstraints;\n    const ikCount = ikConstraints.length;\n    const transformCount = transformConstraints.length;\n    const pathCount = pathConstraints.length;\n    const constraintCount = ikCount + transformCount + pathCount;\n    outer:\n      for (let i = 0; i < constraintCount; i++) {\n        for (let ii = 0; ii < ikCount; ii++) {\n          const constraint = ikConstraints[ii];\n          if (constraint.data.order == i) {\n            this.sortIkConstraint(constraint);\n            continue outer;\n          }\n        }\n        for (let ii = 0; ii < transformCount; ii++) {\n          const constraint = transformConstraints[ii];\n          if (constraint.data.order == i) {\n            this.sortTransformConstraint(constraint);\n            continue outer;\n          }\n        }\n        for (let ii = 0; ii < pathCount; ii++) {\n          const constraint = pathConstraints[ii];\n          if (constraint.data.order == i) {\n            this.sortPathConstraint(constraint);\n            continue outer;\n          }\n        }\n      }\n    for (let i = 0, n = bones.length; i < n; i++)\n      this.sortBone(bones[i]);\n  }\n  sortIkConstraint(constraint) {\n    constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || this.skin != null && Utils.contains(this.skin.constraints, constraint.data, true));\n    if (!constraint.active)\n      return;\n    const target = constraint.target;\n    this.sortBone(target);\n    const constrained = constraint.bones;\n    const parent = constrained[0];\n    this.sortBone(parent);\n    if (constrained.length > 1) {\n      const child = constrained[constrained.length - 1];\n      if (!(this._updateCache.indexOf(child) > -1))\n        this.updateCacheReset.push(child);\n    }\n    this._updateCache.push(constraint);\n    this.sortReset(parent.children);\n    constrained[constrained.length - 1].sorted = true;\n  }\n  sortPathConstraint(constraint) {\n    constraint.active = constraint.target.bone.isActive() && (!constraint.data.skinRequired || this.skin != null && Utils.contains(this.skin.constraints, constraint.data, true));\n    if (!constraint.active)\n      return;\n    const slot = constraint.target;\n    const slotIndex = slot.data.index;\n    const slotBone = slot.bone;\n    if (this.skin != null)\n      this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);\n    if (this.data.defaultSkin != null && this.data.defaultSkin != this.skin)\n      this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);\n    for (let i = 0, n = this.data.skins.length; i < n; i++)\n      this.sortPathConstraintAttachment(this.data.skins[i], slotIndex, slotBone);\n    const attachment = slot.getAttachment();\n    if (attachment instanceof PathAttachment)\n      this.sortPathConstraintAttachmentWith(attachment, slotBone);\n    const constrained = constraint.bones;\n    const boneCount = constrained.length;\n    for (let i = 0; i < boneCount; i++)\n      this.sortBone(constrained[i]);\n    this._updateCache.push(constraint);\n    for (let i = 0; i < boneCount; i++)\n      this.sortReset(constrained[i].children);\n    for (let i = 0; i < boneCount; i++)\n      constrained[i].sorted = true;\n  }\n  sortTransformConstraint(constraint) {\n    constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || this.skin != null && Utils.contains(this.skin.constraints, constraint.data, true));\n    if (!constraint.active)\n      return;\n    this.sortBone(constraint.target);\n    const constrained = constraint.bones;\n    const boneCount = constrained.length;\n    if (constraint.data.local) {\n      for (let i = 0; i < boneCount; i++) {\n        const child = constrained[i];\n        this.sortBone(child.parent);\n        if (!(this._updateCache.indexOf(child) > -1))\n          this.updateCacheReset.push(child);\n      }\n    } else {\n      for (let i = 0; i < boneCount; i++) {\n        this.sortBone(constrained[i]);\n      }\n    }\n    this._updateCache.push(constraint);\n    for (let ii = 0; ii < boneCount; ii++)\n      this.sortReset(constrained[ii].children);\n    for (let ii = 0; ii < boneCount; ii++)\n      constrained[ii].sorted = true;\n  }\n  sortPathConstraintAttachment(skin, slotIndex, slotBone) {\n    const attachments = skin.attachments[slotIndex];\n    if (!attachments)\n      return;\n    for (const key in attachments) {\n      this.sortPathConstraintAttachmentWith(attachments[key], slotBone);\n    }\n  }\n  sortPathConstraintAttachmentWith(attachment, slotBone) {\n    if (!(attachment instanceof PathAttachment))\n      return;\n    const pathBones = attachment.bones;\n    if (pathBones == null)\n      this.sortBone(slotBone);\n    else {\n      const bones = this.bones;\n      let i = 0;\n      while (i < pathBones.length) {\n        const boneCount = pathBones[i++];\n        for (let n = i + boneCount; i < n; i++) {\n          const boneIndex = pathBones[i];\n          this.sortBone(bones[boneIndex]);\n        }\n      }\n    }\n  }\n  sortBone(bone) {\n    if (bone.sorted)\n      return;\n    const parent = bone.parent;\n    if (parent != null)\n      this.sortBone(parent);\n    bone.sorted = true;\n    this._updateCache.push(bone);\n  }\n  sortReset(bones) {\n    for (let i = 0, n = bones.length; i < n; i++) {\n      const bone = bones[i];\n      if (!bone.active)\n        continue;\n      if (bone.sorted)\n        this.sortReset(bone.children);\n      bone.sorted = false;\n    }\n  }\n  /** Updates the world transform for each bone and applies constraints. */\n  updateWorldTransform() {\n    const updateCacheReset = this.updateCacheReset;\n    for (let i = 0, n = updateCacheReset.length; i < n; i++) {\n      const bone = updateCacheReset[i];\n      bone.ax = bone.x;\n      bone.ay = bone.y;\n      bone.arotation = bone.rotation;\n      bone.ascaleX = bone.scaleX;\n      bone.ascaleY = bone.scaleY;\n      bone.ashearX = bone.shearX;\n      bone.ashearY = bone.shearY;\n      bone.appliedValid = true;\n    }\n    const updateCache = this._updateCache;\n    for (let i = 0, n = updateCache.length; i < n; i++)\n      updateCache[i].update();\n  }\n  /** Sets the bones, constraints, and slots to their setup pose values. */\n  setToSetupPose() {\n    this.setBonesToSetupPose();\n    this.setSlotsToSetupPose();\n  }\n  /** Sets the bones and constraints to their setup pose values. */\n  setBonesToSetupPose() {\n    const bones = this.bones;\n    for (let i = 0, n = bones.length; i < n; i++)\n      bones[i].setToSetupPose();\n    const ikConstraints = this.ikConstraints;\n    for (let i = 0, n = ikConstraints.length; i < n; i++) {\n      const constraint = ikConstraints[i];\n      constraint.mix = constraint.data.mix;\n      constraint.softness = constraint.data.softness;\n      constraint.bendDirection = constraint.data.bendDirection;\n      constraint.compress = constraint.data.compress;\n      constraint.stretch = constraint.data.stretch;\n    }\n    const transformConstraints = this.transformConstraints;\n    for (let i = 0, n = transformConstraints.length; i < n; i++) {\n      const constraint = transformConstraints[i];\n      const data = constraint.data;\n      constraint.rotateMix = data.rotateMix;\n      constraint.translateMix = data.translateMix;\n      constraint.scaleMix = data.scaleMix;\n      constraint.shearMix = data.shearMix;\n    }\n    const pathConstraints = this.pathConstraints;\n    for (let i = 0, n = pathConstraints.length; i < n; i++) {\n      const constraint = pathConstraints[i];\n      const data = constraint.data;\n      constraint.position = data.position;\n      constraint.spacing = data.spacing;\n      constraint.rotateMix = data.rotateMix;\n      constraint.translateMix = data.translateMix;\n    }\n  }\n  setSlotsToSetupPose() {\n    const slots = this.slots;\n    Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);\n    for (let i = 0, n = slots.length; i < n; i++)\n      slots[i].setToSetupPose();\n  }\n  /** @return May return null. */\n  getRootBone() {\n    if (this.bones.length == 0)\n      return null;\n    return this.bones[0];\n  }\n  /** @return May be null. */\n  findBone(boneName) {\n    if (boneName == null)\n      throw new Error(\"boneName cannot be null.\");\n    const bones = this.bones;\n    for (let i = 0, n = bones.length; i < n; i++) {\n      const bone = bones[i];\n      if (bone.data.name == boneName)\n        return bone;\n    }\n    return null;\n  }\n  /** @return -1 if the bone was not found. */\n  findBoneIndex(boneName) {\n    if (boneName == null)\n      throw new Error(\"boneName cannot be null.\");\n    const bones = this.bones;\n    for (let i = 0, n = bones.length; i < n; i++)\n      if (bones[i].data.name == boneName)\n        return i;\n    return -1;\n  }\n  /** @return May be null. */\n  findSlot(slotName) {\n    if (slotName == null)\n      throw new Error(\"slotName cannot be null.\");\n    const slots = this.slots;\n    for (let i = 0, n = slots.length; i < n; i++) {\n      const slot = slots[i];\n      if (slot.data.name == slotName)\n        return slot;\n    }\n    return null;\n  }\n  /** @return -1 if the bone was not found. */\n  findSlotIndex(slotName) {\n    if (slotName == null)\n      throw new Error(\"slotName cannot be null.\");\n    const slots = this.slots;\n    for (let i = 0, n = slots.length; i < n; i++)\n      if (slots[i].data.name == slotName)\n        return i;\n    return -1;\n  }\n  /** Sets a skin by name.\n   * @see #setSkin(Skin) */\n  setSkinByName(skinName) {\n    const skin = this.data.findSkin(skinName);\n    if (skin == null)\n      throw new Error(`Skin not found: ${skinName}`);\n    this.setSkin(skin);\n  }\n  /** Sets the skin used to look up attachments before looking in the {@link SkeletonData#getDefaultSkin() default skin}.\n   * Attachments from the new skin are attached if the corresponding attachment from the old skin was attached. If there was no\n   * old skin, each slot's setup mode attachment is attached from the new skin.\n   * @param newSkin May be null. */\n  setSkin(newSkin) {\n    if (newSkin == this.skin)\n      return;\n    if (newSkin != null) {\n      if (this.skin != null)\n        newSkin.attachAll(this, this.skin);\n      else {\n        const slots = this.slots;\n        for (let i = 0, n = slots.length; i < n; i++) {\n          const slot = slots[i];\n          const name = slot.data.attachmentName;\n          if (name != null) {\n            const attachment = newSkin.getAttachment(i, name);\n            if (attachment != null)\n              slot.setAttachment(attachment);\n          }\n        }\n      }\n    }\n    this.skin = newSkin;\n    this.updateCache();\n  }\n  /** @return May be null. */\n  getAttachmentByName(slotName, attachmentName) {\n    return this.getAttachment(this.data.findSlotIndex(slotName), attachmentName);\n  }\n  /** @return May be null. */\n  getAttachment(slotIndex, attachmentName) {\n    if (attachmentName == null)\n      throw new Error(\"attachmentName cannot be null.\");\n    if (this.skin != null) {\n      const attachment = this.skin.getAttachment(slotIndex, attachmentName);\n      if (attachment != null)\n        return attachment;\n    }\n    if (this.data.defaultSkin != null)\n      return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);\n    return null;\n  }\n  /** @param attachmentName May be null. */\n  setAttachment(slotName, attachmentName) {\n    if (slotName == null)\n      throw new Error(\"slotName cannot be null.\");\n    const slots = this.slots;\n    for (let i = 0, n = slots.length; i < n; i++) {\n      const slot = slots[i];\n      if (slot.data.name == slotName) {\n        let attachment = null;\n        if (attachmentName != null) {\n          attachment = this.getAttachment(i, attachmentName);\n          if (attachment == null)\n            throw new Error(`Attachment not found: ${attachmentName}, for slot: ${slotName}`);\n        }\n        slot.setAttachment(attachment);\n        return;\n      }\n    }\n    throw new Error(`Slot not found: ${slotName}`);\n  }\n  /** @return May be null. */\n  findIkConstraint(constraintName) {\n    if (constraintName == null)\n      throw new Error(\"constraintName cannot be null.\");\n    const ikConstraints = this.ikConstraints;\n    for (let i = 0, n = ikConstraints.length; i < n; i++) {\n      const ikConstraint = ikConstraints[i];\n      if (ikConstraint.data.name == constraintName)\n        return ikConstraint;\n    }\n    return null;\n  }\n  /** @return May be null. */\n  findTransformConstraint(constraintName) {\n    if (constraintName == null)\n      throw new Error(\"constraintName cannot be null.\");\n    const transformConstraints = this.transformConstraints;\n    for (let i = 0, n = transformConstraints.length; i < n; i++) {\n      const constraint = transformConstraints[i];\n      if (constraint.data.name == constraintName)\n        return constraint;\n    }\n    return null;\n  }\n  /** @return May be null. */\n  findPathConstraint(constraintName) {\n    if (constraintName == null)\n      throw new Error(\"constraintName cannot be null.\");\n    const pathConstraints = this.pathConstraints;\n    for (let i = 0, n = pathConstraints.length; i < n; i++) {\n      const constraint = pathConstraints[i];\n      if (constraint.data.name == constraintName)\n        return constraint;\n    }\n    return null;\n  }\n  /** Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose.\n   * @param offset The distance from the skeleton origin to the bottom left corner of the AABB.\n   * @param size The width and height of the AABB.\n   * @param temp Working memory */\n  getBounds(offset, size, temp = new Array(2)) {\n    if (offset == null)\n      throw new Error(\"offset cannot be null.\");\n    if (size == null)\n      throw new Error(\"size cannot be null.\");\n    const drawOrder = this.drawOrder;\n    let minX = Number.POSITIVE_INFINITY;\n    let minY = Number.POSITIVE_INFINITY;\n    let maxX = Number.NEGATIVE_INFINITY;\n    let maxY = Number.NEGATIVE_INFINITY;\n    for (let i = 0, n = drawOrder.length; i < n; i++) {\n      const slot = drawOrder[i];\n      if (!slot.bone.active)\n        continue;\n      let verticesLength = 0;\n      let vertices = null;\n      const attachment = slot.getAttachment();\n      if (attachment instanceof RegionAttachment) {\n        verticesLength = 8;\n        vertices = Utils.setArraySize(temp, verticesLength, 0);\n        attachment.computeWorldVertices(slot.bone, vertices, 0, 2);\n      } else if (attachment instanceof MeshAttachment) {\n        const mesh = attachment;\n        verticesLength = mesh.worldVerticesLength;\n        vertices = Utils.setArraySize(temp, verticesLength, 0);\n        mesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);\n      }\n      if (vertices != null) {\n        for (let ii = 0, nn = vertices.length; ii < nn; ii += 2) {\n          const x = vertices[ii];\n          const y = vertices[ii + 1];\n          minX = Math.min(minX, x);\n          minY = Math.min(minY, y);\n          maxX = Math.max(maxX, x);\n          maxY = Math.max(maxY, y);\n        }\n      }\n    }\n    offset.set(minX, minY);\n    size.set(maxX - minX, maxY - minY);\n  }\n  update(delta) {\n    this.time += delta;\n  }\n  get flipX() {\n    return this.scaleX == -1;\n  }\n  set flipX(value) {\n    if (!_Skeleton.deprecatedWarning1) {\n      _Skeleton.deprecatedWarning1 = true;\n      console.warn(\"Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY\");\n    }\n    this.scaleX = value ? 1 : -1;\n  }\n  get flipY() {\n    return this.scaleY == -1;\n  }\n  set flipY(value) {\n    if (!_Skeleton.deprecatedWarning1) {\n      _Skeleton.deprecatedWarning1 = true;\n      console.warn(\"Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY\");\n    }\n    this.scaleY = value ? 1 : -1;\n  }\n};\nlet Skeleton = _Skeleton;\nSkeleton.deprecatedWarning1 = false;\n\nexport { Skeleton };\n//# sourceMappingURL=Skeleton.mjs.map\n","class Event {\n  constructor(time, data) {\n    if (data == null)\n      throw new Error(\"data cannot be null.\");\n    this.time = time;\n    this.data = data;\n  }\n}\n\nexport { Event };\n//# sourceMappingURL=Event.mjs.map\n","class SkeletonData {\n  constructor() {\n    this.bones = new Array();\n    // Ordered parents first.\n    this.slots = new Array();\n    // Setup pose draw order.\n    this.skins = new Array();\n    this.events = new Array();\n    this.animations = new Array();\n    this.ikConstraints = new Array();\n    this.transformConstraints = new Array();\n    this.pathConstraints = new Array();\n    // Nonessential\n    this.fps = 0;\n  }\n  findBone(boneName) {\n    if (boneName == null)\n      throw new Error(\"boneName cannot be null.\");\n    const bones = this.bones;\n    for (let i = 0, n = bones.length; i < n; i++) {\n      const bone = bones[i];\n      if (bone.name == boneName)\n        return bone;\n    }\n    return null;\n  }\n  findBoneIndex(boneName) {\n    if (boneName == null)\n      throw new Error(\"boneName cannot be null.\");\n    const bones = this.bones;\n    for (let i = 0, n = bones.length; i < n; i++)\n      if (bones[i].name == boneName)\n        return i;\n    return -1;\n  }\n  findSlot(slotName) {\n    if (slotName == null)\n      throw new Error(\"slotName cannot be null.\");\n    const slots = this.slots;\n    for (let i = 0, n = slots.length; i < n; i++) {\n      const slot = slots[i];\n      if (slot.name == slotName)\n        return slot;\n    }\n    return null;\n  }\n  findSlotIndex(slotName) {\n    if (slotName == null)\n      throw new Error(\"slotName cannot be null.\");\n    const slots = this.slots;\n    for (let i = 0, n = slots.length; i < n; i++)\n      if (slots[i].name == slotName)\n        return i;\n    return -1;\n  }\n  findSkin(skinName) {\n    if (skinName == null)\n      throw new Error(\"skinName cannot be null.\");\n    const skins = this.skins;\n    for (let i = 0, n = skins.length; i < n; i++) {\n      const skin = skins[i];\n      if (skin.name == skinName)\n        return skin;\n    }\n    return null;\n  }\n  findEvent(eventDataName) {\n    if (eventDataName == null)\n      throw new Error(\"eventDataName cannot be null.\");\n    const events = this.events;\n    for (let i = 0, n = events.length; i < n; i++) {\n      const event = events[i];\n      if (event.name == eventDataName)\n        return event;\n    }\n    return null;\n  }\n  findAnimation(animationName) {\n    if (animationName == null)\n      throw new Error(\"animationName cannot be null.\");\n    const animations = this.animations;\n    for (let i = 0, n = animations.length; i < n; i++) {\n      const animation = animations[i];\n      if (animation.name == animationName)\n        return animation;\n    }\n    return null;\n  }\n  findIkConstraint(constraintName) {\n    if (constraintName == null)\n      throw new Error(\"constraintName cannot be null.\");\n    const ikConstraints = this.ikConstraints;\n    for (let i = 0, n = ikConstraints.length; i < n; i++) {\n      const constraint = ikConstraints[i];\n      if (constraint.name == constraintName)\n        return constraint;\n    }\n    return null;\n  }\n  findTransformConstraint(constraintName) {\n    if (constraintName == null)\n      throw new Error(\"constraintName cannot be null.\");\n    const transformConstraints = this.transformConstraints;\n    for (let i = 0, n = transformConstraints.length; i < n; i++) {\n      const constraint = transformConstraints[i];\n      if (constraint.name == constraintName)\n        return constraint;\n    }\n    return null;\n  }\n  findPathConstraint(constraintName) {\n    if (constraintName == null)\n      throw new Error(\"constraintName cannot be null.\");\n    const pathConstraints = this.pathConstraints;\n    for (let i = 0, n = pathConstraints.length; i < n; i++) {\n      const constraint = pathConstraints[i];\n      if (constraint.name == constraintName)\n        return constraint;\n    }\n    return null;\n  }\n  findPathConstraintIndex(pathConstraintName) {\n    if (pathConstraintName == null)\n      throw new Error(\"pathConstraintName cannot be null.\");\n    const pathConstraints = this.pathConstraints;\n    for (let i = 0, n = pathConstraints.length; i < n; i++)\n      if (pathConstraints[i].name == pathConstraintName)\n        return i;\n    return -1;\n  }\n}\n\nexport { SkeletonData };\n//# sourceMappingURL=SkeletonData.mjs.map\n","import { Color } from '@pixi-spine/base';\n\nclass SlotData {\n  constructor(index, name, boneData) {\n    this.color = new Color(1, 1, 1, 1);\n    if (index < 0)\n      throw new Error(\"index must be >= 0.\");\n    if (name == null)\n      throw new Error(\"name cannot be null.\");\n    if (boneData == null)\n      throw new Error(\"boneData cannot be null.\");\n    this.index = index;\n    this.name = name;\n    this.boneData = boneData;\n  }\n}\n\nexport { SlotData };\n//# sourceMappingURL=SlotData.mjs.map\n","import { TransformMode, Color } from '@pixi-spine/base';\n\nclass BoneData {\n  constructor(index, name, parent) {\n    this.x = 0;\n    this.y = 0;\n    this.rotation = 0;\n    this.scaleX = 1;\n    this.scaleY = 1;\n    this.shearX = 0;\n    this.shearY = 0;\n    this.transformMode = TransformMode.Normal;\n    this.skinRequired = false;\n    this.inheritRotation = true;\n    this.inheritScale = true;\n    this.color = new Color();\n    if (index < 0)\n      throw new Error(\"index must be >= 0.\");\n    if (name == null)\n      throw new Error(\"name cannot be null.\");\n    this.index = index;\n    this.name = name;\n    this.parent = parent;\n  }\n}\n\nexport { BoneData };\n//# sourceMappingURL=BoneData.mjs.map\n","import { ConstraintData } from './Constraint.mjs';\n\nclass IkConstraintData extends ConstraintData {\n  constructor(name) {\n    super(name, 0, false);\n    this.bones = new Array();\n    this.bendDirection = 1;\n    this.compress = false;\n    this.stretch = false;\n    this.uniform = false;\n    this.mix = 1;\n    this.softness = 0;\n  }\n}\n\nexport { IkConstraintData };\n//# sourceMappingURL=IkConstraintData.mjs.map\n","import { ConstraintData } from './Constraint.mjs';\n\nclass TransformConstraintData extends ConstraintData {\n  constructor(name) {\n    super(name, 0, false);\n    this.bones = new Array();\n    this.rotateMix = 0;\n    this.translateMix = 0;\n    this.scaleMix = 0;\n    this.shearMix = 0;\n    this.offsetRotation = 0;\n    this.offsetX = 0;\n    this.offsetY = 0;\n    this.offsetScaleX = 0;\n    this.offsetScaleY = 0;\n    this.offsetShearY = 0;\n    this.relative = false;\n    this.local = false;\n  }\n}\n\nexport { TransformConstraintData };\n//# sourceMappingURL=TransformConstraintData.mjs.map\n","import './attachments/Attachment.mjs';\nimport '@pixi-spine/base';\nimport { MeshAttachment } from './attachments/MeshAttachment.mjs';\nimport './attachments/RegionAttachment.mjs';\n\nclass SkinEntry {\n  constructor(slotIndex, name, attachment) {\n    this.slotIndex = slotIndex;\n    this.name = name;\n    this.attachment = attachment;\n  }\n}\nclass Skin {\n  constructor(name) {\n    this.attachments = new Array();\n    this.bones = Array();\n    this.constraints = new Array();\n    if (name == null)\n      throw new Error(\"name cannot be null.\");\n    this.name = name;\n  }\n  setAttachment(slotIndex, name, attachment) {\n    if (attachment == null)\n      throw new Error(\"attachment cannot be null.\");\n    const attachments = this.attachments;\n    if (slotIndex >= attachments.length)\n      attachments.length = slotIndex + 1;\n    if (!attachments[slotIndex])\n      attachments[slotIndex] = {};\n    attachments[slotIndex][name] = attachment;\n  }\n  addSkin(skin) {\n    for (let i = 0; i < skin.bones.length; i++) {\n      const bone = skin.bones[i];\n      let contained = false;\n      for (let j = 0; j < this.bones.length; j++) {\n        if (this.bones[j] == bone) {\n          contained = true;\n          break;\n        }\n      }\n      if (!contained)\n        this.bones.push(bone);\n    }\n    for (let i = 0; i < skin.constraints.length; i++) {\n      const constraint = skin.constraints[i];\n      let contained = false;\n      for (let j = 0; j < this.constraints.length; j++) {\n        if (this.constraints[j] == constraint) {\n          contained = true;\n          break;\n        }\n      }\n      if (!contained)\n        this.constraints.push(constraint);\n    }\n    const attachments = skin.getAttachments();\n    for (let i = 0; i < attachments.length; i++) {\n      const attachment = attachments[i];\n      this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\n    }\n  }\n  copySkin(skin) {\n    for (let i = 0; i < skin.bones.length; i++) {\n      const bone = skin.bones[i];\n      let contained = false;\n      for (let j = 0; j < this.bones.length; j++) {\n        if (this.bones[j] == bone) {\n          contained = true;\n          break;\n        }\n      }\n      if (!contained)\n        this.bones.push(bone);\n    }\n    for (let i = 0; i < skin.constraints.length; i++) {\n      const constraint = skin.constraints[i];\n      let contained = false;\n      for (let j = 0; j < this.constraints.length; j++) {\n        if (this.constraints[j] == constraint) {\n          contained = true;\n          break;\n        }\n      }\n      if (!contained)\n        this.constraints.push(constraint);\n    }\n    const attachments = skin.getAttachments();\n    for (let i = 0; i < attachments.length; i++) {\n      const attachment = attachments[i];\n      if (attachment.attachment == null)\n        continue;\n      if (attachment.attachment instanceof MeshAttachment) {\n        attachment.attachment = attachment.attachment.newLinkedMesh();\n        this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\n      } else {\n        attachment.attachment = attachment.attachment.copy();\n        this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\n      }\n    }\n  }\n  /** @return May be null. */\n  getAttachment(slotIndex, name) {\n    const dictionary = this.attachments[slotIndex];\n    return dictionary ? dictionary[name] : null;\n  }\n  removeAttachment(slotIndex, name) {\n    const dictionary = this.attachments[slotIndex];\n    if (dictionary)\n      dictionary[name] = null;\n  }\n  getAttachments() {\n    const entries = new Array();\n    for (let i = 0; i < this.attachments.length; i++) {\n      const slotAttachments = this.attachments[i];\n      if (slotAttachments) {\n        for (const name in slotAttachments) {\n          const attachment = slotAttachments[name];\n          if (attachment)\n            entries.push(new SkinEntry(i, name, attachment));\n        }\n      }\n    }\n    return entries;\n  }\n  getAttachmentsForSlot(slotIndex, attachments) {\n    const slotAttachments = this.attachments[slotIndex];\n    if (slotAttachments) {\n      for (const name in slotAttachments) {\n        const attachment = slotAttachments[name];\n        if (attachment)\n          attachments.push(new SkinEntry(slotIndex, name, attachment));\n      }\n    }\n  }\n  clear() {\n    this.attachments.length = 0;\n    this.bones.length = 0;\n    this.constraints.length = 0;\n  }\n  /** Attach each attachment in this skin if the corresponding attachment in the old skin is currently attached. */\n  attachAll(skeleton, oldSkin) {\n    let slotIndex = 0;\n    for (let i = 0; i < skeleton.slots.length; i++) {\n      const slot = skeleton.slots[i];\n      const slotAttachment = slot.getAttachment();\n      if (slotAttachment && slotIndex < oldSkin.attachments.length) {\n        const dictionary = oldSkin.attachments[slotIndex];\n        for (const key in dictionary) {\n          const skinAttachment = dictionary[key];\n          if (slotAttachment == skinAttachment) {\n            const attachment = this.getAttachment(slotIndex, key);\n            if (attachment != null)\n              slot.setAttachment(attachment);\n            break;\n          }\n        }\n      }\n      slotIndex++;\n    }\n  }\n}\n\nexport { Skin, SkinEntry };\n//# sourceMappingURL=Skin.mjs.map\n","class EventData {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\nexport { EventData };\n//# sourceMappingURL=EventData.mjs.map\n","import { Event } from './Event.mjs';\nimport { SkeletonData } from './SkeletonData.mjs';\nimport { SlotData } from './SlotData.mjs';\nimport { BoneData } from './BoneData.mjs';\nimport { IkConstraintData } from './IkConstraintData.mjs';\nimport { TransformConstraintData } from './TransformConstraintData.mjs';\nimport { SpacingMode, PathConstraintData } from './PathConstraintData.mjs';\nimport { Skin } from './Skin.mjs';\nimport { EventData } from './EventData.mjs';\nimport { ColorTimeline, AttachmentTimeline, ScaleTimeline, ShearTimeline, TranslateTimeline, RotateTimeline, IkConstraintTimeline, TransformConstraintTimeline, PathConstraintMixTimeline, PathConstraintSpacingTimeline, PathConstraintPositionTimeline, DeformTimeline, DrawOrderTimeline, EventTimeline, Animation } from './Animation.mjs';\nimport { TransformMode, PositionMode, RotateMode, BinaryInput, Color, Utils, AttachmentType } from '@pixi-spine/base';\nimport { BLEND_MODES } from '@pixi/core';\n\nconst _SkeletonBinary = class {\n  constructor(attachmentLoader) {\n    this.scale = 1;\n    this.linkedMeshes = new Array();\n    this.attachmentLoader = attachmentLoader;\n  }\n  readSkeletonData(binary) {\n    const scale = this.scale;\n    const skeletonData = new SkeletonData();\n    skeletonData.name = \"\";\n    const input = new BinaryInput(binary);\n    skeletonData.hash = input.readString();\n    skeletonData.version = input.readString();\n    if (skeletonData.version === \"3.8.75\") {\n      const error = `Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine.`;\n      console.error(error);\n    }\n    skeletonData.width = input.readFloat();\n    skeletonData.height = input.readFloat();\n    const nonessential = input.readBoolean();\n    if (nonessential) {\n      skeletonData.imagesPath = input.readString();\n    }\n    let n = 0;\n    n = input.readInt(true);\n    for (let i = 0; i < n; i++) {\n      const name = input.readString();\n      const parent = i == 0 ? null : skeletonData.bones[input.readInt(true)];\n      const data = new BoneData(i, name, parent);\n      data.rotation = input.readFloat();\n      data.x = input.readFloat() * scale;\n      data.y = input.readFloat() * scale;\n      data.scaleX = input.readFloat();\n      data.scaleY = input.readFloat();\n      data.shearX = input.readFloat();\n      data.shearY = input.readFloat();\n      data.length = input.readFloat() * scale;\n      data.inheritRotation = input.readBoolean();\n      data.inheritScale = input.readBoolean();\n      if (nonessential)\n        Color.rgba8888ToColor(data.color, input.readInt32());\n      skeletonData.bones.push(data);\n    }\n    n = input.readInt(true);\n    for (let i = 0; i < n; i++) {\n      const slotName = input.readString();\n      const boneData = skeletonData.bones[input.readInt(true)];\n      const data = new SlotData(i, slotName, boneData);\n      Color.rgba8888ToColor(data.color, input.readInt32());\n      data.attachmentName = input.readString();\n      data.blendMode = _SkeletonBinary.BlendModeValues[input.readInt(true)];\n      skeletonData.slots.push(data);\n    }\n    n = input.readInt(true);\n    for (let i = 0, nn; i < n; i++) {\n      const name = input.readString();\n      const data = new IkConstraintData(name);\n      nn = input.readInt(true);\n      for (let ii = 0; ii < nn; ii++)\n        data.bones.push(skeletonData.bones[input.readInt(true)]);\n      data.target = skeletonData.bones[input.readInt(true)];\n      data.mix = input.readFloat();\n      data.bendDirection = input.readByte();\n      skeletonData.ikConstraints.push(data);\n    }\n    n = input.readInt(true);\n    for (let i = 0, nn; i < n; i++) {\n      const name = input.readString();\n      const data = new TransformConstraintData(name);\n      nn = input.readInt(true);\n      for (let ii = 0; ii < nn; ii++)\n        data.bones.push(skeletonData.bones[input.readInt(true)]);\n      data.target = skeletonData.bones[input.readInt(true)];\n      data.offsetRotation = input.readFloat();\n      data.offsetX = input.readFloat() * scale;\n      data.offsetY = input.readFloat() * scale;\n      data.offsetScaleX = input.readFloat();\n      data.offsetScaleY = input.readFloat();\n      data.offsetShearY = input.readFloat();\n      data.rotateMix = input.readFloat();\n      data.translateMix = input.readFloat();\n      data.scaleMix = input.readFloat();\n      data.shearMix = input.readFloat();\n      skeletonData.transformConstraints.push(data);\n    }\n    n = input.readInt(true);\n    for (let i = 0, nn; i < n; i++) {\n      const name = input.readString();\n      const data = new PathConstraintData(name);\n      nn = input.readInt(true);\n      for (let ii = 0; ii < nn; ii++)\n        data.bones.push(skeletonData.bones[input.readInt(true)]);\n      data.target = skeletonData.slots[input.readInt(true)];\n      data.positionMode = _SkeletonBinary.PositionModeValues[input.readInt(true)];\n      data.spacingMode = _SkeletonBinary.SpacingModeValues[input.readInt(true)];\n      data.rotateMode = _SkeletonBinary.RotateModeValues[input.readInt(true)];\n      data.offsetRotation = input.readFloat();\n      data.position = input.readFloat();\n      if (data.positionMode == PositionMode.Fixed)\n        data.position *= scale;\n      data.spacing = input.readFloat();\n      if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed)\n        data.spacing *= scale;\n      data.rotateMix = input.readFloat();\n      data.translateMix = input.readFloat();\n      skeletonData.pathConstraints.push(data);\n    }\n    const defaultSkin = this.readSkin(input, skeletonData, true, nonessential);\n    if (defaultSkin != null) {\n      skeletonData.defaultSkin = defaultSkin;\n      skeletonData.skins.push(defaultSkin);\n    }\n    {\n      let i = skeletonData.skins.length;\n      Utils.setArraySize(skeletonData.skins, n = i + input.readInt(true));\n      for (; i < n; i++)\n        skeletonData.skins[i] = this.readSkin(input, skeletonData, false, nonessential);\n    }\n    n = this.linkedMeshes.length;\n    for (let i = 0; i < n; i++) {\n      const linkedMesh = this.linkedMeshes[i];\n      const skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\n      if (skin == null)\n        throw new Error(`Skin not found: ${linkedMesh.skin}`);\n      const parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\n      if (parent == null)\n        throw new Error(`Parent mesh not found: ${linkedMesh.parent}`);\n      linkedMesh.mesh.deformAttachment = linkedMesh.inheritDeform ? parent : linkedMesh.mesh;\n      linkedMesh.mesh.setParentMesh(parent);\n    }\n    this.linkedMeshes.length = 0;\n    n = input.readInt(true);\n    for (let i = 0; i < n; i++) {\n      const data = new EventData(input.readStringRef());\n      data.intValue = input.readInt(false);\n      data.floatValue = input.readFloat();\n      data.stringValue = input.readString();\n      data.audioPath = input.readString();\n      if (data.audioPath != null) {\n        data.volume = input.readFloat();\n        data.balance = input.readFloat();\n      }\n      skeletonData.events.push(data);\n    }\n    n = input.readInt(true);\n    for (let i = 0; i < n; i++)\n      skeletonData.animations.push(this.readAnimation(input, input.readString(), skeletonData));\n    return skeletonData;\n  }\n  readSkin(input, skeletonData, defaultSkin, nonessential) {\n    let skin = null;\n    let slotCount = 0;\n    if (defaultSkin) {\n      slotCount = input.readInt(true);\n      if (slotCount == 0)\n        return null;\n      skin = new Skin(\"default\");\n    } else {\n      skin = new Skin(input.readString());\n      skin.bones.length = input.readInt(true);\n      for (let i = 0, n = skin.bones.length; i < n; i++)\n        skin.bones[i] = skeletonData.bones[input.readInt(true)];\n      for (let i = 0, n = input.readInt(true); i < n; i++)\n        skin.constraints.push(skeletonData.ikConstraints[input.readInt(true)]);\n      for (let i = 0, n = input.readInt(true); i < n; i++)\n        skin.constraints.push(skeletonData.transformConstraints[input.readInt(true)]);\n      for (let i = 0, n = input.readInt(true); i < n; i++)\n        skin.constraints.push(skeletonData.pathConstraints[input.readInt(true)]);\n      slotCount = input.readInt(true);\n    }\n    for (let i = 0; i < slotCount; i++) {\n      const slotIndex = input.readInt(true);\n      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n        const name = input.readString();\n        const attachment = this.readAttachment(input, skeletonData, skin, slotIndex, name, nonessential);\n        if (attachment != null)\n          skin.setAttachment(slotIndex, name, attachment);\n      }\n    }\n    return skin;\n  }\n  readAttachment(input, skeletonData, skin, slotIndex, attachmentName, nonessential) {\n    const scale = this.scale;\n    let name = input.readStringRef();\n    if (name == null)\n      name = attachmentName;\n    const typeIndex = input.readByte();\n    const type = _SkeletonBinary.AttachmentTypeValues[typeIndex];\n    switch (type) {\n      case AttachmentType.Region: {\n        let path = input.readString();\n        const rotation = input.readFloat();\n        const x = input.readFloat();\n        const y = input.readFloat();\n        const scaleX = input.readFloat();\n        const scaleY = input.readFloat();\n        const width = input.readFloat();\n        const height = input.readFloat();\n        const color = input.readInt32();\n        if (path == null)\n          path = name;\n        const region = this.attachmentLoader.newRegionAttachment(skin, name, path);\n        if (region == null)\n          return null;\n        region.path = path;\n        region.x = x * scale;\n        region.y = y * scale;\n        region.scaleX = scaleX;\n        region.scaleY = scaleY;\n        region.rotation = rotation;\n        region.width = width * scale;\n        region.height = height * scale;\n        Color.rgba8888ToColor(region.color, color);\n        return region;\n      }\n      case AttachmentType.BoundingBox: {\n        const vertexCount = input.readInt(true);\n        const vertices = this.readVertices(input, vertexCount);\n        const color = nonessential ? input.readInt32() : 0;\n        const box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\n        if (box == null)\n          return null;\n        box.worldVerticesLength = vertexCount << 1;\n        box.vertices = vertices.vertices;\n        box.bones = vertices.bones;\n        box.cVertices = vertices.cVertices;\n        if (nonessential)\n          Color.rgba8888ToColor(box.color, color);\n        return box;\n      }\n      case AttachmentType.Mesh: {\n        let path = input.readStringRef();\n        const color = input.readInt32();\n        const vertexCount = input.readInt(true);\n        const uvs = this.readFloatArray(input, vertexCount << 1, 1);\n        const triangles = this.readShortArray(input);\n        const vertices = this.readVertices(input, vertexCount);\n        const hullLength = input.readInt(true);\n        let edges = null;\n        let width = 0;\n        let height = 0;\n        if (nonessential) {\n          edges = this.readShortArray(input);\n          width = input.readFloat();\n          height = input.readFloat();\n        }\n        if (path == null)\n          path = name;\n        const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\n        if (mesh == null)\n          return null;\n        mesh.path = path;\n        Color.rgba8888ToColor(mesh.color, color);\n        mesh.bones = vertices.bones;\n        mesh.vertices = vertices.vertices;\n        mesh.worldVerticesLength = vertexCount << 1;\n        mesh.triangles = triangles;\n        mesh.regionUVs = new Float32Array(uvs);\n        mesh.cVertices = vertices.cVertices;\n        mesh.hullLength = hullLength << 1;\n        if (nonessential) {\n          mesh.edges = edges;\n          mesh.width = width * scale;\n          mesh.height = height * scale;\n        }\n        return mesh;\n      }\n      case AttachmentType.LinkedMesh: {\n        let path = input.readStringRef();\n        const color = input.readInt32();\n        const skinName = input.readStringRef();\n        const parent = input.readStringRef();\n        const inheritDeform = input.readBoolean();\n        let width = 0;\n        let height = 0;\n        if (nonessential) {\n          width = input.readFloat();\n          height = input.readFloat();\n        }\n        if (path == null)\n          path = name;\n        const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\n        if (mesh == null)\n          return null;\n        mesh.path = path;\n        Color.rgba8888ToColor(mesh.color, color);\n        if (nonessential) {\n          mesh.width = width * scale;\n          mesh.height = height * scale;\n        }\n        this.linkedMeshes.push(new LinkedMesh(mesh, skinName, slotIndex, parent, inheritDeform));\n        return mesh;\n      }\n      case AttachmentType.Path: {\n        const closed = input.readBoolean();\n        const constantSpeed = input.readBoolean();\n        const vertexCount = input.readInt(true);\n        const vertices = this.readVertices(input, vertexCount);\n        const lengths = Utils.newArray(vertexCount / 3, 0);\n        for (let i = 0, n = lengths.length; i < n; i++)\n          lengths[i] = input.readFloat() * scale;\n        const color = nonessential ? input.readInt32() : 0;\n        const path = this.attachmentLoader.newPathAttachment(skin, name);\n        if (path == null)\n          return null;\n        path.closed = closed;\n        path.constantSpeed = constantSpeed;\n        path.worldVerticesLength = vertexCount << 1;\n        path.vertices = vertices.vertices;\n        path.bones = vertices.bones;\n        path.lengths = lengths;\n        path.cVertices = vertices.cVertices;\n        if (nonessential)\n          Color.rgba8888ToColor(path.color, color);\n        return path;\n      }\n      case AttachmentType.Point: {\n        const rotation = input.readFloat();\n        const x = input.readFloat();\n        const y = input.readFloat();\n        const color = nonessential ? input.readInt32() : 0;\n        const point = this.attachmentLoader.newPointAttachment(skin, name);\n        if (point == null)\n          return null;\n        point.x = x * scale;\n        point.y = y * scale;\n        point.rotation = rotation;\n        if (nonessential)\n          Color.rgba8888ToColor(point.color, color);\n        return point;\n      }\n      case AttachmentType.Clipping: {\n        const endSlotIndex = input.readInt(true);\n        const vertexCount = input.readInt(true);\n        const vertices = this.readVertices(input, vertexCount);\n        const color = nonessential ? input.readInt32() : 0;\n        const clip = this.attachmentLoader.newClippingAttachment(skin, name);\n        if (clip == null)\n          return null;\n        clip.endSlot = skeletonData.slots[endSlotIndex];\n        clip.worldVerticesLength = vertexCount << 1;\n        clip.vertices = vertices.vertices;\n        clip.bones = vertices.bones;\n        clip.cVertices = vertices.cVertices;\n        if (nonessential)\n          Color.rgba8888ToColor(clip.color, color);\n        return clip;\n      }\n    }\n    return null;\n  }\n  readVertices(input, vertexCount) {\n    const verticesLength = vertexCount << 1;\n    const vertices = new Vertices();\n    const scale = this.scale;\n    if (!input.readBoolean()) {\n      vertices.vertices = this.readFloatArray(input, verticesLength, scale);\n      return vertices;\n    }\n    const myVertices = new Array();\n    const weights = new Array();\n    const bonesArray = new Array();\n    for (let i = 0; i < vertexCount; i++) {\n      const boneCount = input.readInt(true);\n      bonesArray.push(boneCount);\n      myVertices.push(boneCount);\n      for (let ii = 0; ii < boneCount; ii++) {\n        const bone2 = input.readInt(true);\n        bonesArray.push(bone2);\n        myVertices.push(bone2);\n        const weight1 = input.readFloat() * scale;\n        const weight2 = input.readFloat() * scale;\n        const weight3 = input.readFloat();\n        weights.push(weight1);\n        weights.push(weight2);\n        weights.push(weight3);\n        myVertices.push(weight1);\n        myVertices.push(weight2);\n        myVertices.push(weight3);\n      }\n    }\n    vertices.vertices = Utils.toFloatArray(weights);\n    vertices.bones = bonesArray;\n    vertices.cVertices = myVertices;\n    return vertices;\n  }\n  readFloatArray(input, n, scale) {\n    const array = new Array(n);\n    if (scale == 1) {\n      for (let i = 0; i < n; i++)\n        array[i] = input.readFloat();\n    } else {\n      for (let i = 0; i < n; i++)\n        array[i] = input.readFloat() * scale;\n    }\n    return array;\n  }\n  readShortArray(input) {\n    const n = input.readInt(true);\n    const array = new Array(n);\n    for (let i = 0; i < n; i++)\n      array[i] = input.readShort();\n    return array;\n  }\n  readAnimation(input, name, skeletonData) {\n    const timelines = new Array();\n    const scale = this.scale;\n    let duration = 0;\n    const tempColor1 = new Color();\n    for (let i = 0, n = input.readInt(true); i < n; i++) {\n      const slotIndex = input.readInt(true);\n      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n        const timelineType = input.readByte();\n        const frameCount = input.readInt(true);\n        switch (timelineType) {\n          case _SkeletonBinary.SLOT_ATTACHMENT: {\n            const timeline = new AttachmentTimeline(frameCount);\n            timeline.slotIndex = slotIndex;\n            for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\n              const time = input.readFloat();\n              const attachmentName = input.readString();\n              timeline.setFrame(frameIndex, time, attachmentName);\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[frameCount - 1]);\n            break;\n          }\n          case _SkeletonBinary.SLOT_COLOR: {\n            const timeline = new ColorTimeline(frameCount);\n            timeline.slotIndex = slotIndex;\n            for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\n              const time = input.readFloat();\n              Color.rgba8888ToColor(tempColor1, input.readInt32());\n              timeline.setFrame(frameIndex, time, tempColor1.r, tempColor1.g, tempColor1.b, tempColor1.a);\n              if (frameIndex < frameCount - 1)\n                this.readCurve(input, frameIndex, timeline);\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[(frameCount - 1) * ColorTimeline.ENTRIES]);\n            break;\n          }\n        }\n      }\n    }\n    for (let i = 0, n = input.readInt(true); i < n; i++) {\n      const boneIndex = input.readInt(true);\n      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n        const timelineType = input.readByte();\n        const frameCount = input.readInt(true);\n        switch (timelineType) {\n          case _SkeletonBinary.BONE_ROTATE: {\n            const timeline = new RotateTimeline(frameCount);\n            timeline.boneIndex = boneIndex;\n            for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\n              timeline.setFrame(frameIndex, input.readFloat(), input.readFloat());\n              if (frameIndex < frameCount - 1)\n                this.readCurve(input, frameIndex, timeline);\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[(frameCount - 1) * RotateTimeline.ENTRIES]);\n            break;\n          }\n          case _SkeletonBinary.BONE_TRANSLATE:\n          case _SkeletonBinary.BONE_SCALE:\n          case _SkeletonBinary.BONE_SHEAR: {\n            let timeline;\n            let timelineScale = 1;\n            if (timelineType == _SkeletonBinary.BONE_SCALE)\n              timeline = new ScaleTimeline(frameCount);\n            else if (timelineType == _SkeletonBinary.BONE_SHEAR)\n              timeline = new ShearTimeline(frameCount);\n            else {\n              timeline = new TranslateTimeline(frameCount);\n              timelineScale = scale;\n            }\n            timeline.boneIndex = boneIndex;\n            for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\n              const time = input.readFloat();\n              const x = input.readFloat();\n              const y = input.readFloat();\n              timeline.setFrame(frameIndex, time, x * timelineScale, y * timelineScale);\n              if (frameIndex < frameCount - 1)\n                this.readCurve(input, frameIndex, timeline);\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[(frameCount - 1) * TranslateTimeline.ENTRIES]);\n            break;\n          }\n        }\n      }\n    }\n    for (let i = 0, n = input.readInt(true); i < n; i++) {\n      const index = input.readInt(true);\n      const frameCount = input.readInt(true);\n      const timeline = new IkConstraintTimeline(frameCount);\n      timeline.ikConstraintIndex = index;\n      for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\n        const time = input.readFloat();\n        const mix = input.readFloat();\n        const softness = input.readByte();\n        timeline.setFrame(frameIndex, time, mix, softness);\n        if (frameIndex < frameCount - 1)\n          this.readCurve(input, frameIndex, timeline);\n      }\n      timelines.push(timeline);\n      duration = Math.max(duration, timeline.frames[(frameCount - 1) * IkConstraintTimeline.ENTRIES]);\n    }\n    for (let i = 0, n = input.readInt(true); i < n; i++) {\n      const index = input.readInt(true);\n      const frameCount = input.readInt(true);\n      const timeline = new TransformConstraintTimeline(frameCount);\n      timeline.transformConstraintIndex = index;\n      for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\n        timeline.setFrame(frameIndex, input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat());\n        if (frameIndex < frameCount - 1)\n          this.readCurve(input, frameIndex, timeline);\n      }\n      timelines.push(timeline);\n      duration = Math.max(duration, timeline.frames[(frameCount - 1) * TransformConstraintTimeline.ENTRIES]);\n    }\n    for (let i = 0, n = input.readInt(true); i < n; i++) {\n      const index = input.readInt(true);\n      const data = skeletonData.pathConstraints[index];\n      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n        const timelineType = input.readByte();\n        const frameCount = input.readInt(true);\n        switch (timelineType) {\n          case _SkeletonBinary.PATH_POSITION:\n          case _SkeletonBinary.PATH_SPACING: {\n            let timeline;\n            let timelineScale = 1;\n            if (timelineType == _SkeletonBinary.PATH_SPACING) {\n              timeline = new PathConstraintSpacingTimeline(frameCount);\n              if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed)\n                timelineScale = scale;\n            } else {\n              timeline = new PathConstraintPositionTimeline(frameCount);\n              if (data.positionMode == PositionMode.Fixed)\n                timelineScale = scale;\n            }\n            timeline.pathConstraintIndex = index;\n            for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\n              const time = input.readFloat();\n              const value = input.readFloat() * timelineScale;\n              timeline.setFrame(frameIndex, time, value);\n              if (frameIndex < frameCount - 1)\n                this.readCurve(input, frameIndex, timeline);\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[(frameCount - 1) * PathConstraintPositionTimeline.ENTRIES]);\n            break;\n          }\n          case _SkeletonBinary.PATH_MIX: {\n            const timeline = new PathConstraintMixTimeline(frameCount);\n            timeline.pathConstraintIndex = index;\n            for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\n              const time = input.readFloat();\n              const rotateMix = input.readFloat();\n              const translateMix = input.readFloat();\n              timeline.setFrame(frameIndex, time, rotateMix, translateMix);\n              if (frameIndex < frameCount - 1)\n                this.readCurve(input, frameIndex, timeline);\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[(frameCount - 1) * PathConstraintMixTimeline.ENTRIES]);\n            break;\n          }\n        }\n      }\n    }\n    for (let i = 0, n = input.readInt(true); i < n; i++) {\n      const skin = skeletonData.skins[input.readInt(true)];\n      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n        const slotIndex = input.readInt(true);\n        for (let iii = 0, nnn = input.readInt(true); iii < nnn; iii++) {\n          const attachment = skin?.getAttachment(slotIndex, input.readString());\n          const weighted = attachment.bones != null;\n          const vertices = attachment.vertices;\n          const deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;\n          const frameCount = input.readInt(true);\n          const timeline = new DeformTimeline(frameCount);\n          timeline.slotIndex = slotIndex;\n          timeline.attachment = attachment;\n          for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\n            const time = input.readFloat();\n            let deform;\n            let end = input.readInt(true);\n            if (end == 0)\n              deform = weighted ? Utils.newFloatArray(deformLength) : vertices;\n            else {\n              deform = Utils.newFloatArray(deformLength);\n              const start = input.readInt(true);\n              end += start;\n              if (scale == 1) {\n                for (let v = start; v < end; v++)\n                  deform[v] = input.readFloat();\n              } else {\n                for (let v = start; v < end; v++)\n                  deform[v] = input.readFloat() * scale;\n              }\n              if (!weighted) {\n                for (let v = 0, vn = deform.length; v < vn; v++)\n                  deform[v] += vertices[v];\n              }\n            }\n            timeline.setFrame(frameIndex, time, deform, skin.name);\n            if (frameIndex < frameCount - 1)\n              this.readCurve(input, frameIndex, timeline);\n          }\n          timelines.push(timeline);\n          duration = Math.max(duration, timeline.frames[frameCount - 1]);\n        }\n      }\n    }\n    const drawOrderCount = input.readInt(true);\n    if (drawOrderCount > 0) {\n      const timeline = new DrawOrderTimeline(drawOrderCount);\n      const slotCount = skeletonData.slots.length;\n      for (let i = 0; i < drawOrderCount; i++) {\n        const time = input.readFloat();\n        const offsetCount = input.readInt(true);\n        const drawOrder = Utils.newArray(slotCount, 0);\n        for (let ii = slotCount - 1; ii >= 0; ii--)\n          drawOrder[ii] = -1;\n        const unchanged = Utils.newArray(slotCount - offsetCount, 0);\n        let originalIndex = 0;\n        let unchangedIndex = 0;\n        for (let ii = 0; ii < offsetCount; ii++) {\n          const slotIndex = input.readInt(true);\n          while (originalIndex != slotIndex)\n            unchanged[unchangedIndex++] = originalIndex++;\n          drawOrder[originalIndex + input.readInt(true)] = originalIndex++;\n        }\n        while (originalIndex < slotCount)\n          unchanged[unchangedIndex++] = originalIndex++;\n        for (let ii = slotCount - 1; ii >= 0; ii--)\n          if (drawOrder[ii] == -1)\n            drawOrder[ii] = unchanged[--unchangedIndex];\n        timeline.setFrame(i, time, drawOrder);\n      }\n      timelines.push(timeline);\n      duration = Math.max(duration, timeline.frames[drawOrderCount - 1]);\n    }\n    const eventCount = input.readInt(true);\n    if (eventCount > 0) {\n      const timeline = new EventTimeline(eventCount);\n      for (let i = 0; i < eventCount; i++) {\n        const time = input.readFloat();\n        const eventData = skeletonData.events[input.readInt(true)];\n        const event = new Event(time, eventData);\n        event.intValue = input.readInt(false);\n        event.floatValue = input.readFloat();\n        event.stringValue = input.readBoolean() ? input.readString() : eventData.stringValue;\n        if (event.data.audioPath != null) {\n          event.volume = input.readFloat();\n          event.balance = input.readFloat();\n        }\n        timeline.setFrame(i, event);\n      }\n      timelines.push(timeline);\n      duration = Math.max(duration, timeline.frames[eventCount - 1]);\n    }\n    return new Animation(name, timelines, duration);\n  }\n  readCurve(input, frameIndex, timeline) {\n    switch (input.readByte()) {\n      case _SkeletonBinary.CURVE_STEPPED:\n        timeline.setStepped(frameIndex);\n        break;\n      case _SkeletonBinary.CURVE_BEZIER:\n        this.setCurve(timeline, frameIndex, input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat());\n        break;\n    }\n  }\n  setCurve(timeline, frameIndex, cx1, cy1, cx2, cy2) {\n    timeline.setCurve(frameIndex, cx1, cy1, cx2, cy2);\n  }\n};\nlet SkeletonBinary = _SkeletonBinary;\nSkeletonBinary.AttachmentTypeValues = [\n  0,\n  1,\n  2,\n  3,\n  4,\n  5,\n  6\n];\nSkeletonBinary.TransformModeValues = [\n  TransformMode.Normal,\n  TransformMode.OnlyTranslation,\n  TransformMode.NoRotationOrReflection,\n  TransformMode.NoScale,\n  TransformMode.NoScaleOrReflection\n];\nSkeletonBinary.PositionModeValues = [PositionMode.Fixed, PositionMode.Percent];\nSkeletonBinary.SpacingModeValues = [SpacingMode.Length, SpacingMode.Fixed, SpacingMode.Percent];\nSkeletonBinary.RotateModeValues = [RotateMode.Tangent, RotateMode.Chain, RotateMode.ChainScale];\nSkeletonBinary.BlendModeValues = [BLEND_MODES.NORMAL, BLEND_MODES.ADD, BLEND_MODES.MULTIPLY, BLEND_MODES.SCREEN];\nSkeletonBinary.BONE_ROTATE = 0;\nSkeletonBinary.BONE_TRANSLATE = 1;\nSkeletonBinary.BONE_SCALE = 2;\nSkeletonBinary.BONE_SHEAR = 3;\nSkeletonBinary.SLOT_ATTACHMENT = 0;\nSkeletonBinary.SLOT_COLOR = 1;\nSkeletonBinary.SLOT_TWO_COLOR = 2;\nSkeletonBinary.PATH_POSITION = 0;\nSkeletonBinary.PATH_SPACING = 1;\nSkeletonBinary.PATH_MIX = 2;\nSkeletonBinary.CURVE_LINEAR = 0;\nSkeletonBinary.CURVE_STEPPED = 1;\nSkeletonBinary.CURVE_BEZIER = 2;\nclass LinkedMesh {\n  constructor(mesh, skin, slotIndex, parent, inheritDeform) {\n    this.mesh = mesh;\n    this.skin = skin;\n    this.slotIndex = slotIndex;\n    this.parent = parent;\n    this.inheritDeform = inheritDeform;\n  }\n}\nclass Vertices {\n  constructor(bones = null, vertices = null, cVertices = null) {\n    this.bones = bones;\n    this.vertices = vertices;\n    this.cVertices = cVertices;\n  }\n}\n\nexport { SkeletonBinary };\n//# sourceMappingURL=SkeletonBinary.mjs.map\n","import { Utils } from '@pixi-spine/base';\n\nclass Attachment {\n  constructor(name) {\n    if (name == null)\n      throw new Error(\"name cannot be null.\");\n    this.name = name;\n  }\n}\nconst _VertexAttachment = class extends Attachment {\n  constructor(name) {\n    super(name);\n    this.id = (_VertexAttachment.nextID++ & 65535) << 11;\n    this.worldVerticesLength = 0;\n    this.deformAttachment = this;\n  }\n  computeWorldVerticesOld(slot, worldVertices) {\n    this.computeWorldVertices(slot, 0, this.worldVerticesLength, worldVertices, 0, 2);\n  }\n  /** Transforms local vertices to world coordinates.\n   * @param start The index of the first local vertex value to transform. Each vertex has 2 values, x and y.\n   * @param count The number of world vertex values to output. Must be <= {@link #getWorldVerticesLength()} - start.\n   * @param worldVertices The output world vertices. Must have a length >= offset + count.\n   * @param offset The worldVertices index to begin writing values. */\n  computeWorldVertices(slot, start, count, worldVertices, offset, stride) {\n    count = offset + (count >> 1) * stride;\n    const skeleton = slot.bone.skeleton;\n    const deformArray = slot.deform;\n    let vertices = this.vertices;\n    const bones = this.bones;\n    if (bones == null) {\n      if (deformArray.length > 0)\n        vertices = deformArray;\n      const mat = slot.bone.matrix;\n      const x = mat.tx;\n      const y = mat.ty;\n      const a = mat.a;\n      const b = mat.c;\n      const c = mat.b;\n      const d = mat.d;\n      for (let v2 = start, w = offset; w < count; v2 += 2, w += stride) {\n        const vx = vertices[v2];\n        const vy = vertices[v2 + 1];\n        worldVertices[w] = vx * a + vy * b + x;\n        worldVertices[w + 1] = vx * c + vy * d + y;\n      }\n      return;\n    }\n    let v = 0;\n    let skip = 0;\n    for (let i = 0; i < start; i += 2) {\n      const n = bones[v];\n      v += n + 1;\n      skip += n;\n    }\n    const skeletonBones = skeleton.bones;\n    if (deformArray.length == 0) {\n      for (let w = offset, b = skip * 3; w < count; w += stride) {\n        let wx = 0;\n        let wy = 0;\n        let n = bones[v++];\n        n += v;\n        for (; v < n; v++, b += 3) {\n          const mat = skeletonBones[bones[v]].matrix;\n          const vx = vertices[b];\n          const vy = vertices[b + 1];\n          const weight = vertices[b + 2];\n          wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\n          wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\n        }\n        worldVertices[w] = wx;\n        worldVertices[w + 1] = wy;\n      }\n    } else {\n      const deform = deformArray;\n      for (let w = offset, b = skip * 3, f = skip << 1; w < count; w += stride) {\n        let wx = 0;\n        let wy = 0;\n        let n = bones[v++];\n        n += v;\n        for (; v < n; v++, b += 3, f += 2) {\n          const mat = skeletonBones[bones[v]].matrix;\n          const vx = vertices[b] + deform[f];\n          const vy = vertices[b + 1] + deform[f + 1];\n          const weight = vertices[b + 2];\n          wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\n          wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\n        }\n        worldVertices[w] = wx;\n        worldVertices[w + 1] = wy;\n      }\n    }\n  }\n  copyTo(attachment) {\n    if (this.bones != null) {\n      attachment.bones = new Array(this.bones.length);\n      Utils.arrayCopy(this.bones, 0, attachment.bones, 0, this.bones.length);\n    } else\n      attachment.bones = null;\n    if (this.vertices != null) {\n      attachment.vertices = Utils.newFloatArray(this.vertices.length);\n      Utils.arrayCopy(this.vertices, 0, attachment.vertices, 0, this.vertices.length);\n    } else\n      attachment.vertices = null;\n    attachment.worldVerticesLength = this.worldVerticesLength;\n    attachment.deformAttachment = this.deformAttachment;\n  }\n};\nlet VertexAttachment = _VertexAttachment;\nVertexAttachment.nextID = 0;\n\nexport { Attachment, VertexAttachment };\n//# sourceMappingURL=Attachment.mjs.map\n","import { VertexAttachment } from './Attachment.mjs';\nimport { AttachmentType, Color } from '@pixi-spine/base';\n\nclass BoundingBoxAttachment extends VertexAttachment {\n  constructor(name) {\n    super(name);\n    this.type = AttachmentType.BoundingBox;\n    this.color = new Color(1, 1, 1, 1);\n  }\n  copy() {\n    const copy = new BoundingBoxAttachment(this.name);\n    this.copyTo(copy);\n    copy.color.setFromColor(this.color);\n    return copy;\n  }\n}\n\nexport { BoundingBoxAttachment };\n//# sourceMappingURL=BoundingBoxAttachment.mjs.map\n","import { VertexAttachment } from './Attachment.mjs';\nimport { AttachmentType, Color } from '@pixi-spine/base';\n\nclass ClippingAttachment extends VertexAttachment {\n  // ce3a3aff\n  constructor(name) {\n    super(name);\n    this.type = AttachmentType.Clipping;\n    // Nonessential.\n    this.color = new Color(0.2275, 0.2275, 0.8078, 1);\n  }\n  copy() {\n    const copy = new ClippingAttachment(this.name);\n    this.copyTo(copy);\n    copy.endSlot = this.endSlot;\n    copy.color.setFromColor(this.color);\n    return copy;\n  }\n}\n\nexport { ClippingAttachment };\n//# sourceMappingURL=ClippingAttachment.mjs.map\n","import { VertexAttachment } from './Attachment.mjs';\nimport { AttachmentType, Color, Utils } from '@pixi-spine/base';\n\nclass MeshAttachment extends VertexAttachment {\n  constructor(name) {\n    super(name);\n    this.type = AttachmentType.Mesh;\n    this.color = new Color(1, 1, 1, 1);\n    this.tempColor = new Color(0, 0, 0, 0);\n  }\n  getParentMesh() {\n    return this.parentMesh;\n  }\n  /** @param parentMesh May be null. */\n  setParentMesh(parentMesh) {\n    this.parentMesh = parentMesh;\n    if (parentMesh != null) {\n      this.bones = parentMesh.bones;\n      this.vertices = parentMesh.vertices;\n      this.worldVerticesLength = parentMesh.worldVerticesLength;\n      this.regionUVs = parentMesh.regionUVs;\n      this.triangles = parentMesh.triangles;\n      this.hullLength = parentMesh.hullLength;\n      this.worldVerticesLength = parentMesh.worldVerticesLength;\n    }\n  }\n  copy() {\n    if (this.parentMesh != null)\n      return this.newLinkedMesh();\n    const copy = new MeshAttachment(this.name);\n    copy.region = this.region;\n    copy.path = this.path;\n    copy.color.setFromColor(this.color);\n    this.copyTo(copy);\n    copy.regionUVs = new Float32Array(this.regionUVs.length);\n    Utils.arrayCopy(this.regionUVs, 0, copy.regionUVs, 0, this.regionUVs.length);\n    copy.triangles = new Array(this.triangles.length);\n    Utils.arrayCopy(this.triangles, 0, copy.triangles, 0, this.triangles.length);\n    copy.hullLength = this.hullLength;\n    if (this.edges != null) {\n      copy.edges = new Array(this.edges.length);\n      Utils.arrayCopy(this.edges, 0, copy.edges, 0, this.edges.length);\n    }\n    copy.width = this.width;\n    copy.height = this.height;\n    return copy;\n  }\n  newLinkedMesh() {\n    const copy = new MeshAttachment(this.name);\n    copy.region = this.region;\n    copy.path = this.path;\n    copy.color.setFromColor(this.color);\n    copy.deformAttachment = this.deformAttachment;\n    copy.setParentMesh(this.parentMesh != null ? this.parentMesh : this);\n    return copy;\n  }\n}\n\nexport { MeshAttachment };\n//# sourceMappingURL=MeshAttachment.mjs.map\n","import { VertexAttachment } from './Attachment.mjs';\nimport { AttachmentType, Color, Utils } from '@pixi-spine/base';\n\nclass PathAttachment extends VertexAttachment {\n  constructor(name) {\n    super(name);\n    this.type = AttachmentType.Path;\n    this.closed = false;\n    this.constantSpeed = false;\n    this.color = new Color(1, 1, 1, 1);\n  }\n  copy() {\n    const copy = new PathAttachment(this.name);\n    this.copyTo(copy);\n    copy.lengths = new Array(this.lengths.length);\n    Utils.arrayCopy(this.lengths, 0, copy.lengths, 0, this.lengths.length);\n    copy.closed = closed;\n    copy.constantSpeed = this.constantSpeed;\n    copy.color.setFromColor(this.color);\n    return copy;\n  }\n}\n\nexport { PathAttachment };\n//# sourceMappingURL=PathAttachment.mjs.map\n","import { VertexAttachment } from './Attachment.mjs';\nimport { AttachmentType, Color, MathUtils } from '@pixi-spine/base';\n\nclass PointAttachment extends VertexAttachment {\n  constructor(name) {\n    super(name);\n    this.type = AttachmentType.Point;\n    this.color = new Color(0.38, 0.94, 0, 1);\n  }\n  computeWorldPosition(bone, point) {\n    const mat = bone.matrix;\n    point.x = this.x * mat.a + this.y * mat.c + bone.worldX;\n    point.y = this.x * mat.b + this.y * mat.d + bone.worldY;\n    return point;\n  }\n  computeWorldRotation(bone) {\n    const mat = bone.matrix;\n    const cos = MathUtils.cosDeg(this.rotation);\n    const sin = MathUtils.sinDeg(this.rotation);\n    const x = cos * mat.a + sin * mat.c;\n    const y = cos * mat.b + sin * mat.d;\n    return Math.atan2(y, x) * MathUtils.radDeg;\n  }\n  copy() {\n    const copy = new PointAttachment(this.name);\n    copy.x = this.x;\n    copy.y = this.y;\n    copy.rotation = this.rotation;\n    copy.color.setFromColor(this.color);\n    return copy;\n  }\n}\n\nexport { PointAttachment };\n//# sourceMappingURL=PointAttachment.mjs.map\n","import { Color } from '@pixi-spine/base';\n\nclass Slot {\n  constructor(data, bone) {\n    this.deform = new Array();\n    if (data == null)\n      throw new Error(\"data cannot be null.\");\n    if (bone == null)\n      throw new Error(\"bone cannot be null.\");\n    this.data = data;\n    this.bone = bone;\n    this.color = new Color();\n    this.darkColor = data.darkColor == null ? null : new Color();\n    this.setToSetupPose();\n    this.blendMode = this.data.blendMode;\n  }\n  /** @return May be null. */\n  getAttachment() {\n    return this.attachment;\n  }\n  /** Sets the attachment and if it changed, resets {@link #getAttachmentTime()} and clears {@link #getAttachmentVertices()}.\n   * @param attachment May be null. */\n  setAttachment(attachment) {\n    if (this.attachment == attachment)\n      return;\n    this.attachment = attachment;\n    this.attachmentTime = this.bone.skeleton.time;\n    this.deform.length = 0;\n  }\n  setAttachmentTime(time) {\n    this.attachmentTime = this.bone.skeleton.time - time;\n  }\n  /** Returns the time since the attachment was set. */\n  getAttachmentTime() {\n    return this.bone.skeleton.time - this.attachmentTime;\n  }\n  setToSetupPose() {\n    this.color.setFromColor(this.data.color);\n    if (this.darkColor != null)\n      this.darkColor.setFromColor(this.data.darkColor);\n    if (this.data.attachmentName == null)\n      this.attachment = null;\n    else {\n      this.attachment = null;\n      this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));\n    }\n  }\n}\n\nexport { Slot };\n//# sourceMappingURL=Slot.mjs.map\n","import { Attachment } from './Attachment.mjs';\nimport { AttachmentType, Color, Utils } from '@pixi-spine/base';\nimport { Slot } from '../Slot.mjs';\n\nconst _RegionAttachment = class extends Attachment {\n  constructor(name) {\n    super(name);\n    this.type = AttachmentType.Region;\n    this.x = 0;\n    this.y = 0;\n    this.scaleX = 1;\n    this.scaleY = 1;\n    this.rotation = 0;\n    this.width = 0;\n    this.height = 0;\n    this.color = new Color(1, 1, 1, 1);\n    this.offset = Utils.newFloatArray(8);\n    this.uvs = Utils.newFloatArray(8);\n    this.tempColor = new Color(1, 1, 1, 1);\n  }\n  updateOffset() {\n    const regionScaleX = this.width / this.region.originalWidth * this.scaleX;\n    const regionScaleY = this.height / this.region.originalHeight * this.scaleY;\n    const localX = -this.width / 2 * this.scaleX + this.region.offsetX * regionScaleX;\n    const localY = -this.height / 2 * this.scaleY + this.region.offsetY * regionScaleY;\n    const localX2 = localX + this.region.width * regionScaleX;\n    const localY2 = localY + this.region.height * regionScaleY;\n    const radians = this.rotation * Math.PI / 180;\n    const cos = Math.cos(radians);\n    const sin = Math.sin(radians);\n    const localXCos = localX * cos + this.x;\n    const localXSin = localX * sin;\n    const localYCos = localY * cos + this.y;\n    const localYSin = localY * sin;\n    const localX2Cos = localX2 * cos + this.x;\n    const localX2Sin = localX2 * sin;\n    const localY2Cos = localY2 * cos + this.y;\n    const localY2Sin = localY2 * sin;\n    const offset = this.offset;\n    offset[_RegionAttachment.OX1] = localXCos - localYSin;\n    offset[_RegionAttachment.OY1] = localYCos + localXSin;\n    offset[_RegionAttachment.OX2] = localXCos - localY2Sin;\n    offset[_RegionAttachment.OY2] = localY2Cos + localXSin;\n    offset[_RegionAttachment.OX3] = localX2Cos - localY2Sin;\n    offset[_RegionAttachment.OY3] = localY2Cos + localX2Sin;\n    offset[_RegionAttachment.OX4] = localX2Cos - localYSin;\n    offset[_RegionAttachment.OY4] = localYCos + localX2Sin;\n  }\n  setRegion(region) {\n    this.region = region;\n    const uvs = this.uvs;\n    if (region.rotate) {\n      uvs[2] = region.u;\n      uvs[3] = region.v2;\n      uvs[4] = region.u;\n      uvs[5] = region.v;\n      uvs[6] = region.u2;\n      uvs[7] = region.v;\n      uvs[0] = region.u2;\n      uvs[1] = region.v2;\n    } else {\n      uvs[0] = region.u;\n      uvs[1] = region.v2;\n      uvs[2] = region.u;\n      uvs[3] = region.v;\n      uvs[4] = region.u2;\n      uvs[5] = region.v;\n      uvs[6] = region.u2;\n      uvs[7] = region.v2;\n    }\n  }\n  computeWorldVertices(bone, worldVertices, offset, stride) {\n    const vertexOffset = this.offset;\n    const mat = bone instanceof Slot ? bone.bone.matrix : bone.matrix;\n    const x = mat.tx;\n    const y = mat.ty;\n    const a = mat.a;\n    const b = mat.c;\n    const c = mat.b;\n    const d = mat.d;\n    let offsetX = 0;\n    let offsetY = 0;\n    offsetX = vertexOffset[_RegionAttachment.OX1];\n    offsetY = vertexOffset[_RegionAttachment.OY1];\n    worldVertices[offset] = offsetX * a + offsetY * b + x;\n    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n    offset += stride;\n    offsetX = vertexOffset[_RegionAttachment.OX2];\n    offsetY = vertexOffset[_RegionAttachment.OY2];\n    worldVertices[offset] = offsetX * a + offsetY * b + x;\n    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n    offset += stride;\n    offsetX = vertexOffset[_RegionAttachment.OX3];\n    offsetY = vertexOffset[_RegionAttachment.OY3];\n    worldVertices[offset] = offsetX * a + offsetY * b + x;\n    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n    offset += stride;\n    offsetX = vertexOffset[_RegionAttachment.OX4];\n    offsetY = vertexOffset[_RegionAttachment.OY4];\n    worldVertices[offset] = offsetX * a + offsetY * b + x;\n    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n  }\n  copy() {\n    const copy = new _RegionAttachment(this.name);\n    copy.region = this.region;\n    copy.rendererObject = this.rendererObject;\n    copy.path = this.path;\n    copy.x = this.x;\n    copy.y = this.y;\n    copy.scaleX = this.scaleX;\n    copy.scaleY = this.scaleY;\n    copy.rotation = this.rotation;\n    copy.width = this.width;\n    copy.height = this.height;\n    Utils.arrayCopy(this.uvs, 0, copy.uvs, 0, 8);\n    Utils.arrayCopy(this.offset, 0, copy.offset, 0, 8);\n    copy.color.setFromColor(this.color);\n    return copy;\n  }\n};\nlet RegionAttachment = _RegionAttachment;\nRegionAttachment.OX1 = 0;\nRegionAttachment.OY1 = 1;\nRegionAttachment.OX2 = 2;\nRegionAttachment.OY2 = 3;\nRegionAttachment.OX3 = 4;\nRegionAttachment.OY3 = 5;\nRegionAttachment.OX4 = 6;\nRegionAttachment.OY4 = 7;\nRegionAttachment.X1 = 0;\nRegionAttachment.Y1 = 1;\nRegionAttachment.C1R = 2;\nRegionAttachment.C1G = 3;\nRegionAttachment.C1B = 4;\nRegionAttachment.C1A = 5;\nRegionAttachment.U1 = 6;\nRegionAttachment.V1 = 7;\nRegionAttachment.X2 = 8;\nRegionAttachment.Y2 = 9;\nRegionAttachment.C2R = 10;\nRegionAttachment.C2G = 11;\nRegionAttachment.C2B = 12;\nRegionAttachment.C2A = 13;\nRegionAttachment.U2 = 14;\nRegionAttachment.V2 = 15;\nRegionAttachment.X3 = 16;\nRegionAttachment.Y3 = 17;\nRegionAttachment.C3R = 18;\nRegionAttachment.C3G = 19;\nRegionAttachment.C3B = 20;\nRegionAttachment.C3A = 21;\nRegionAttachment.U3 = 22;\nRegionAttachment.V3 = 23;\nRegionAttachment.X4 = 24;\nRegionAttachment.Y4 = 25;\nRegionAttachment.C4R = 26;\nRegionAttachment.C4G = 27;\nRegionAttachment.C4B = 28;\nRegionAttachment.C4A = 29;\nRegionAttachment.U4 = 30;\nRegionAttachment.V4 = 31;\n\nexport { RegionAttachment };\n//# sourceMappingURL=RegionAttachment.mjs.map\n","import { MathUtils } from '@pixi-spine/base';\n\nclass JitterEffect {\n  constructor(jitterX, jitterY) {\n    this.jitterX = 0;\n    this.jitterY = 0;\n    this.jitterX = jitterX;\n    this.jitterY = jitterY;\n  }\n  begin(skeleton) {\n  }\n  transform(position, uv, light, dark) {\n    position.x += MathUtils.randomTriangular(-this.jitterX, this.jitterY);\n    position.y += MathUtils.randomTriangular(-this.jitterX, this.jitterY);\n  }\n  end() {\n  }\n}\n\nexport { JitterEffect };\n//# sourceMappingURL=JitterEffect.mjs.map\n","import { PowOut, MathUtils } from '@pixi-spine/base';\n\nconst _SwirlEffect = class {\n  constructor(radius) {\n    this.centerX = 0;\n    this.centerY = 0;\n    this.radius = 0;\n    this.angle = 0;\n    this.worldX = 0;\n    this.worldY = 0;\n    this.radius = radius;\n  }\n  begin(skeleton) {\n    this.worldX = skeleton.x + this.centerX;\n    this.worldY = skeleton.y + this.centerY;\n  }\n  transform(position, uv, light, dark) {\n    const radAngle = this.angle * MathUtils.degreesToRadians;\n    const x = position.x - this.worldX;\n    const y = position.y - this.worldY;\n    const dist = Math.sqrt(x * x + y * y);\n    if (dist < this.radius) {\n      const theta = _SwirlEffect.interpolation.apply(0, radAngle, (this.radius - dist) / this.radius);\n      const cos = Math.cos(theta);\n      const sin = Math.sin(theta);\n      position.x = cos * x - sin * y + this.worldX;\n      position.y = sin * x + cos * y + this.worldY;\n    }\n  }\n  end() {\n  }\n};\nlet SwirlEffect = _SwirlEffect;\nSwirlEffect.interpolation = new PowOut(2);\n\nexport { SwirlEffect };\n//# sourceMappingURL=SwirlEffect.mjs.map\n","import { VertexAttachment } from './attachments/Attachment.mjs';\nimport { MixBlend, MixDirection, MathUtils, Utils } from '@pixi-spine/base';\nimport './attachments/RegionAttachment.mjs';\n\nclass Animation {\n  constructor(name, timelines, duration) {\n    if (name == null)\n      throw new Error(\"name cannot be null.\");\n    if (timelines == null)\n      throw new Error(\"timelines cannot be null.\");\n    this.name = name;\n    this.timelines = timelines;\n    this.timelineIds = [];\n    for (let i = 0; i < timelines.length; i++)\n      this.timelineIds[timelines[i].getPropertyId()] = true;\n    this.duration = duration;\n  }\n  hasTimeline(id) {\n    return this.timelineIds[id] == true;\n  }\n  /** Applies all the animation's timelines to the specified skeleton.\n   *\n   * See Timeline {@link Timeline#apply(Skeleton, float, float, Array, float, MixBlend, MixDirection)}.\n   * @param loop If true, the animation repeats after {@link #getDuration()}.\n   * @param events May be null to ignore fired events. */\n  apply(skeleton, lastTime, time, loop, events, alpha, blend, direction) {\n    if (skeleton == null)\n      throw new Error(\"skeleton cannot be null.\");\n    if (loop && this.duration != 0) {\n      time %= this.duration;\n      if (lastTime > 0)\n        lastTime %= this.duration;\n    }\n    const timelines = this.timelines;\n    for (let i = 0, n = timelines.length; i < n; i++)\n      timelines[i].apply(skeleton, lastTime, time, events, alpha, blend, direction);\n  }\n  /** @param target After the first and before the last value.\n   * @returns index of first value greater than the target. */\n  static binarySearch(values, target, step = 1) {\n    let low = 0;\n    let high = values.length / step - 2;\n    if (high == 0)\n      return step;\n    let current = high >>> 1;\n    while (true) {\n      if (values[(current + 1) * step] <= target)\n        low = current + 1;\n      else\n        high = current;\n      if (low == high)\n        return (low + 1) * step;\n      current = low + high >>> 1;\n    }\n  }\n  static linearSearch(values, target, step) {\n    for (let i = 0, last = values.length - step; i <= last; i += step)\n      if (values[i] > target)\n        return i;\n    return -1;\n  }\n}\nvar TimelineType = /* @__PURE__ */ ((TimelineType2) => {\n  TimelineType2[TimelineType2[\"rotate\"] = 0] = \"rotate\";\n  TimelineType2[TimelineType2[\"translate\"] = 1] = \"translate\";\n  TimelineType2[TimelineType2[\"scale\"] = 2] = \"scale\";\n  TimelineType2[TimelineType2[\"shear\"] = 3] = \"shear\";\n  TimelineType2[TimelineType2[\"attachment\"] = 4] = \"attachment\";\n  TimelineType2[TimelineType2[\"color\"] = 5] = \"color\";\n  TimelineType2[TimelineType2[\"deform\"] = 6] = \"deform\";\n  TimelineType2[TimelineType2[\"event\"] = 7] = \"event\";\n  TimelineType2[TimelineType2[\"drawOrder\"] = 8] = \"drawOrder\";\n  TimelineType2[TimelineType2[\"ikConstraint\"] = 9] = \"ikConstraint\";\n  TimelineType2[TimelineType2[\"transformConstraint\"] = 10] = \"transformConstraint\";\n  TimelineType2[TimelineType2[\"pathConstraintPosition\"] = 11] = \"pathConstraintPosition\";\n  TimelineType2[TimelineType2[\"pathConstraintSpacing\"] = 12] = \"pathConstraintSpacing\";\n  TimelineType2[TimelineType2[\"pathConstraintMix\"] = 13] = \"pathConstraintMix\";\n  TimelineType2[TimelineType2[\"twoColor\"] = 14] = \"twoColor\";\n  return TimelineType2;\n})(TimelineType || {});\nconst _CurveTimeline = class {\n  constructor(frameCount) {\n    if (frameCount <= 0)\n      throw new Error(`frameCount must be > 0: ${frameCount}`);\n    this.curves = Utils.newFloatArray((frameCount - 1) * _CurveTimeline.BEZIER_SIZE);\n  }\n  /** The number of key frames for this timeline. */\n  getFrameCount() {\n    return this.curves.length / _CurveTimeline.BEZIER_SIZE + 1;\n  }\n  /** Sets the specified key frame to linear interpolation. */\n  setLinear(frameIndex) {\n    this.curves[frameIndex * _CurveTimeline.BEZIER_SIZE] = _CurveTimeline.LINEAR;\n  }\n  /** Sets the specified key frame to stepped interpolation. */\n  setStepped(frameIndex) {\n    this.curves[frameIndex * _CurveTimeline.BEZIER_SIZE] = _CurveTimeline.STEPPED;\n  }\n  /** Returns the interpolation type for the specified key frame.\n   * @returns Linear is 0, stepped is 1, Bezier is 2. */\n  getCurveType(frameIndex) {\n    const index = frameIndex * _CurveTimeline.BEZIER_SIZE;\n    if (index == this.curves.length)\n      return _CurveTimeline.LINEAR;\n    const type = this.curves[index];\n    if (type == _CurveTimeline.LINEAR)\n      return _CurveTimeline.LINEAR;\n    if (type == _CurveTimeline.STEPPED)\n      return _CurveTimeline.STEPPED;\n    return _CurveTimeline.BEZIER;\n  }\n  /** Sets the specified key frame to Bezier interpolation. `cx1` and `cx2` are from 0 to 1,\n   * representing the percent of time between the two key frames. `cy1` and `cy2` are the percent of the\n   * difference between the key frame's values. */\n  setCurve(frameIndex, cx1, cy1, cx2, cy2) {\n    const tmpx = (-cx1 * 2 + cx2) * 0.03;\n    const tmpy = (-cy1 * 2 + cy2) * 0.03;\n    const dddfx = ((cx1 - cx2) * 3 + 1) * 6e-3;\n    const dddfy = ((cy1 - cy2) * 3 + 1) * 6e-3;\n    let ddfx = tmpx * 2 + dddfx;\n    let ddfy = tmpy * 2 + dddfy;\n    let dfx = cx1 * 0.3 + tmpx + dddfx * 0.16666667;\n    let dfy = cy1 * 0.3 + tmpy + dddfy * 0.16666667;\n    let i = frameIndex * _CurveTimeline.BEZIER_SIZE;\n    const curves = this.curves;\n    curves[i++] = _CurveTimeline.BEZIER;\n    let x = dfx;\n    let y = dfy;\n    for (let n = i + _CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\n      curves[i] = x;\n      curves[i + 1] = y;\n      dfx += ddfx;\n      dfy += ddfy;\n      ddfx += dddfx;\n      ddfy += dddfy;\n      x += dfx;\n      y += dfy;\n    }\n  }\n  /** Returns the interpolated percentage for the specified key frame and linear percentage. */\n  getCurvePercent(frameIndex, percent) {\n    percent = MathUtils.clamp(percent, 0, 1);\n    const curves = this.curves;\n    let i = frameIndex * _CurveTimeline.BEZIER_SIZE;\n    const type = curves[i];\n    if (type == _CurveTimeline.LINEAR)\n      return percent;\n    if (type == _CurveTimeline.STEPPED)\n      return 0;\n    i++;\n    let x = 0;\n    for (let start = i, n = i + _CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\n      x = curves[i];\n      if (x >= percent) {\n        let prevX;\n        let prevY;\n        if (i == start) {\n          prevX = 0;\n          prevY = 0;\n        } else {\n          prevX = curves[i - 2];\n          prevY = curves[i - 1];\n        }\n        return prevY + (curves[i + 1] - prevY) * (percent - prevX) / (x - prevX);\n      }\n    }\n    const y = curves[i - 1];\n    return y + (1 - y) * (percent - x) / (1 - x);\n  }\n};\nlet CurveTimeline = _CurveTimeline;\nCurveTimeline.LINEAR = 0;\nCurveTimeline.STEPPED = 1;\nCurveTimeline.BEZIER = 2;\nCurveTimeline.BEZIER_SIZE = 10 * 2 - 1;\nconst _RotateTimeline = class extends CurveTimeline {\n  // time, degrees, ...\n  constructor(frameCount) {\n    super(frameCount);\n    this.frames = Utils.newFloatArray(frameCount << 1);\n  }\n  getPropertyId() {\n    return (0 /* rotate */ << 24) + this.boneIndex;\n  }\n  /** Sets the time and angle of the specified keyframe. */\n  setFrame(frameIndex, time, degrees) {\n    frameIndex <<= 1;\n    this.frames[frameIndex] = time;\n    this.frames[frameIndex + _RotateTimeline.ROTATION] = degrees;\n  }\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    const frames = this.frames;\n    const bone = skeleton.bones[this.boneIndex];\n    if (!bone.active)\n      return;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.rotation = bone.data.rotation;\n          return;\n        case MixBlend.first:\n          const r2 = bone.data.rotation - bone.rotation;\n          bone.rotation += (r2 - (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360) * alpha;\n      }\n      return;\n    }\n    if (time >= frames[frames.length - _RotateTimeline.ENTRIES]) {\n      let r2 = frames[frames.length + _RotateTimeline.PREV_ROTATION];\n      switch (blend) {\n        case MixBlend.setup:\n          bone.rotation = bone.data.rotation + r2 * alpha;\n          break;\n        case MixBlend.first:\n        case MixBlend.replace:\n          r2 += bone.data.rotation - bone.rotation;\n          r2 -= (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360;\n        case MixBlend.add:\n          bone.rotation += r2 * alpha;\n      }\n      return;\n    }\n    const frame = Animation.binarySearch(frames, time, _RotateTimeline.ENTRIES);\n    const prevRotation = frames[frame + _RotateTimeline.PREV_ROTATION];\n    const frameTime = frames[frame];\n    const percent = this.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + _RotateTimeline.PREV_TIME] - frameTime));\n    let r = frames[frame + _RotateTimeline.ROTATION] - prevRotation;\n    r = prevRotation + (r - (16384 - (16384.499999999996 - r / 360 | 0)) * 360) * percent;\n    switch (blend) {\n      case MixBlend.setup:\n        bone.rotation = bone.data.rotation + (r - (16384 - (16384.499999999996 - r / 360 | 0)) * 360) * alpha;\n        break;\n      case MixBlend.first:\n      case MixBlend.replace:\n        r += bone.data.rotation - bone.rotation;\n      case MixBlend.add:\n        bone.rotation += (r - (16384 - (16384.499999999996 - r / 360 | 0)) * 360) * alpha;\n    }\n  }\n};\nlet RotateTimeline = _RotateTimeline;\nRotateTimeline.ENTRIES = 2;\nRotateTimeline.PREV_TIME = -2;\nRotateTimeline.PREV_ROTATION = -1;\nRotateTimeline.ROTATION = 1;\nconst _TranslateTimeline = class extends CurveTimeline {\n  // time, x, y, ...\n  constructor(frameCount) {\n    super(frameCount);\n    this.frames = Utils.newFloatArray(frameCount * _TranslateTimeline.ENTRIES);\n  }\n  getPropertyId() {\n    return (1 /* translate */ << 24) + this.boneIndex;\n  }\n  /** Sets the time in seconds, x, and y values for the specified key frame. */\n  setFrame(frameIndex, time, x, y) {\n    frameIndex *= _TranslateTimeline.ENTRIES;\n    this.frames[frameIndex] = time;\n    this.frames[frameIndex + _TranslateTimeline.X] = x;\n    this.frames[frameIndex + _TranslateTimeline.Y] = y;\n  }\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    const frames = this.frames;\n    const bone = skeleton.bones[this.boneIndex];\n    if (!bone.active)\n      return;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.x = bone.data.x;\n          bone.y = bone.data.y;\n          return;\n        case MixBlend.first:\n          bone.x += (bone.data.x - bone.x) * alpha;\n          bone.y += (bone.data.y - bone.y) * alpha;\n      }\n      return;\n    }\n    let x = 0;\n    let y = 0;\n    if (time >= frames[frames.length - _TranslateTimeline.ENTRIES]) {\n      x = frames[frames.length + _TranslateTimeline.PREV_X];\n      y = frames[frames.length + _TranslateTimeline.PREV_Y];\n    } else {\n      const frame = Animation.binarySearch(frames, time, _TranslateTimeline.ENTRIES);\n      x = frames[frame + _TranslateTimeline.PREV_X];\n      y = frames[frame + _TranslateTimeline.PREV_Y];\n      const frameTime = frames[frame];\n      const percent = this.getCurvePercent(frame / _TranslateTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + _TranslateTimeline.PREV_TIME] - frameTime));\n      x += (frames[frame + _TranslateTimeline.X] - x) * percent;\n      y += (frames[frame + _TranslateTimeline.Y] - y) * percent;\n    }\n    switch (blend) {\n      case MixBlend.setup:\n        bone.x = bone.data.x + x * alpha;\n        bone.y = bone.data.y + y * alpha;\n        break;\n      case MixBlend.first:\n      case MixBlend.replace:\n        bone.x += (bone.data.x + x - bone.x) * alpha;\n        bone.y += (bone.data.y + y - bone.y) * alpha;\n        break;\n      case MixBlend.add:\n        bone.x += x * alpha;\n        bone.y += y * alpha;\n    }\n  }\n};\nlet TranslateTimeline = _TranslateTimeline;\nTranslateTimeline.ENTRIES = 3;\nTranslateTimeline.PREV_TIME = -3;\nTranslateTimeline.PREV_X = -2;\nTranslateTimeline.PREV_Y = -1;\nTranslateTimeline.X = 1;\nTranslateTimeline.Y = 2;\nclass ScaleTimeline extends TranslateTimeline {\n  constructor(frameCount) {\n    super(frameCount);\n  }\n  getPropertyId() {\n    return (2 /* scale */ << 24) + this.boneIndex;\n  }\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    const frames = this.frames;\n    const bone = skeleton.bones[this.boneIndex];\n    if (!bone.active)\n      return;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.scaleX = bone.data.scaleX;\n          bone.scaleY = bone.data.scaleY;\n          return;\n        case MixBlend.first:\n          bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;\n          bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;\n      }\n      return;\n    }\n    let x = 0;\n    let y = 0;\n    if (time >= frames[frames.length - ScaleTimeline.ENTRIES]) {\n      x = frames[frames.length + ScaleTimeline.PREV_X] * bone.data.scaleX;\n      y = frames[frames.length + ScaleTimeline.PREV_Y] * bone.data.scaleY;\n    } else {\n      const frame = Animation.binarySearch(frames, time, ScaleTimeline.ENTRIES);\n      x = frames[frame + ScaleTimeline.PREV_X];\n      y = frames[frame + ScaleTimeline.PREV_Y];\n      const frameTime = frames[frame];\n      const percent = this.getCurvePercent(frame / ScaleTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ScaleTimeline.PREV_TIME] - frameTime));\n      x = (x + (frames[frame + ScaleTimeline.X] - x) * percent) * bone.data.scaleX;\n      y = (y + (frames[frame + ScaleTimeline.Y] - y) * percent) * bone.data.scaleY;\n    }\n    if (alpha == 1) {\n      if (blend == MixBlend.add) {\n        bone.scaleX += x - bone.data.scaleX;\n        bone.scaleY += y - bone.data.scaleY;\n      } else {\n        bone.scaleX = x;\n        bone.scaleY = y;\n      }\n    } else {\n      let bx = 0;\n      let by = 0;\n      if (direction == MixDirection.mixOut) {\n        switch (blend) {\n          case MixBlend.setup:\n            bx = bone.data.scaleX;\n            by = bone.data.scaleY;\n            bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\n            bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\n            break;\n          case MixBlend.first:\n          case MixBlend.replace:\n            bx = bone.scaleX;\n            by = bone.scaleY;\n            bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\n            bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\n            break;\n          case MixBlend.add:\n            bx = bone.scaleX;\n            by = bone.scaleY;\n            bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bone.data.scaleX) * alpha;\n            bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - bone.data.scaleY) * alpha;\n        }\n      } else {\n        switch (blend) {\n          case MixBlend.setup:\n            bx = Math.abs(bone.data.scaleX) * MathUtils.signum(x);\n            by = Math.abs(bone.data.scaleY) * MathUtils.signum(y);\n            bone.scaleX = bx + (x - bx) * alpha;\n            bone.scaleY = by + (y - by) * alpha;\n            break;\n          case MixBlend.first:\n          case MixBlend.replace:\n            bx = Math.abs(bone.scaleX) * MathUtils.signum(x);\n            by = Math.abs(bone.scaleY) * MathUtils.signum(y);\n            bone.scaleX = bx + (x - bx) * alpha;\n            bone.scaleY = by + (y - by) * alpha;\n            break;\n          case MixBlend.add:\n            bx = MathUtils.signum(x);\n            by = MathUtils.signum(y);\n            bone.scaleX = Math.abs(bone.scaleX) * bx + (x - Math.abs(bone.data.scaleX) * bx) * alpha;\n            bone.scaleY = Math.abs(bone.scaleY) * by + (y - Math.abs(bone.data.scaleY) * by) * alpha;\n        }\n      }\n    }\n  }\n}\nclass ShearTimeline extends TranslateTimeline {\n  constructor(frameCount) {\n    super(frameCount);\n  }\n  getPropertyId() {\n    return (3 /* shear */ << 24) + this.boneIndex;\n  }\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    const frames = this.frames;\n    const bone = skeleton.bones[this.boneIndex];\n    if (!bone.active)\n      return;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.shearX = bone.data.shearX;\n          bone.shearY = bone.data.shearY;\n          return;\n        case MixBlend.first:\n          bone.shearX += (bone.data.shearX - bone.shearX) * alpha;\n          bone.shearY += (bone.data.shearY - bone.shearY) * alpha;\n      }\n      return;\n    }\n    let x = 0;\n    let y = 0;\n    if (time >= frames[frames.length - ShearTimeline.ENTRIES]) {\n      x = frames[frames.length + ShearTimeline.PREV_X];\n      y = frames[frames.length + ShearTimeline.PREV_Y];\n    } else {\n      const frame = Animation.binarySearch(frames, time, ShearTimeline.ENTRIES);\n      x = frames[frame + ShearTimeline.PREV_X];\n      y = frames[frame + ShearTimeline.PREV_Y];\n      const frameTime = frames[frame];\n      const percent = this.getCurvePercent(frame / ShearTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ShearTimeline.PREV_TIME] - frameTime));\n      x = x + (frames[frame + ShearTimeline.X] - x) * percent;\n      y = y + (frames[frame + ShearTimeline.Y] - y) * percent;\n    }\n    switch (blend) {\n      case MixBlend.setup:\n        bone.shearX = bone.data.shearX + x * alpha;\n        bone.shearY = bone.data.shearY + y * alpha;\n        break;\n      case MixBlend.first:\n      case MixBlend.replace:\n        bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;\n        bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;\n        break;\n      case MixBlend.add:\n        bone.shearX += x * alpha;\n        bone.shearY += y * alpha;\n    }\n  }\n}\nconst _ColorTimeline = class extends CurveTimeline {\n  // time, r, g, b, a, ...\n  constructor(frameCount) {\n    super(frameCount);\n    this.frames = Utils.newFloatArray(frameCount * _ColorTimeline.ENTRIES);\n  }\n  getPropertyId() {\n    return (5 /* color */ << 24) + this.slotIndex;\n  }\n  /** Sets the time in seconds, red, green, blue, and alpha for the specified key frame. */\n  setFrame(frameIndex, time, r, g, b, a) {\n    frameIndex *= _ColorTimeline.ENTRIES;\n    this.frames[frameIndex] = time;\n    this.frames[frameIndex + _ColorTimeline.R] = r;\n    this.frames[frameIndex + _ColorTimeline.G] = g;\n    this.frames[frameIndex + _ColorTimeline.B] = b;\n    this.frames[frameIndex + _ColorTimeline.A] = a;\n  }\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    const slot = skeleton.slots[this.slotIndex];\n    if (!slot.bone.active)\n      return;\n    const frames = this.frames;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          slot.color.setFromColor(slot.data.color);\n          return;\n        case MixBlend.first:\n          const color = slot.color;\n          const setup = slot.data.color;\n          color.add((setup.r - color.r) * alpha, (setup.g - color.g) * alpha, (setup.b - color.b) * alpha, (setup.a - color.a) * alpha);\n      }\n      return;\n    }\n    let r = 0;\n    let g = 0;\n    let b = 0;\n    let a = 0;\n    if (time >= frames[frames.length - _ColorTimeline.ENTRIES]) {\n      const i = frames.length;\n      r = frames[i + _ColorTimeline.PREV_R];\n      g = frames[i + _ColorTimeline.PREV_G];\n      b = frames[i + _ColorTimeline.PREV_B];\n      a = frames[i + _ColorTimeline.PREV_A];\n    } else {\n      const frame = Animation.binarySearch(frames, time, _ColorTimeline.ENTRIES);\n      r = frames[frame + _ColorTimeline.PREV_R];\n      g = frames[frame + _ColorTimeline.PREV_G];\n      b = frames[frame + _ColorTimeline.PREV_B];\n      a = frames[frame + _ColorTimeline.PREV_A];\n      const frameTime = frames[frame];\n      const percent = this.getCurvePercent(frame / _ColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + _ColorTimeline.PREV_TIME] - frameTime));\n      r += (frames[frame + _ColorTimeline.R] - r) * percent;\n      g += (frames[frame + _ColorTimeline.G] - g) * percent;\n      b += (frames[frame + _ColorTimeline.B] - b) * percent;\n      a += (frames[frame + _ColorTimeline.A] - a) * percent;\n    }\n    if (alpha == 1)\n      slot.color.set(r, g, b, a);\n    else {\n      const color = slot.color;\n      if (blend == MixBlend.setup)\n        color.setFromColor(slot.data.color);\n      color.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);\n    }\n  }\n};\nlet ColorTimeline = _ColorTimeline;\nColorTimeline.ENTRIES = 5;\nColorTimeline.PREV_TIME = -5;\nColorTimeline.PREV_R = -4;\nColorTimeline.PREV_G = -3;\nColorTimeline.PREV_B = -2;\nColorTimeline.PREV_A = -1;\nColorTimeline.R = 1;\nColorTimeline.G = 2;\nColorTimeline.B = 3;\nColorTimeline.A = 4;\nconst _TwoColorTimeline = class extends CurveTimeline {\n  // time, r, g, b, a, r2, g2, b2, ...\n  constructor(frameCount) {\n    super(frameCount);\n    this.frames = Utils.newFloatArray(frameCount * _TwoColorTimeline.ENTRIES);\n  }\n  getPropertyId() {\n    return (14 /* twoColor */ << 24) + this.slotIndex;\n  }\n  /** Sets the time in seconds, light, and dark colors for the specified key frame. */\n  setFrame(frameIndex, time, r, g, b, a, r2, g2, b2) {\n    frameIndex *= _TwoColorTimeline.ENTRIES;\n    this.frames[frameIndex] = time;\n    this.frames[frameIndex + _TwoColorTimeline.R] = r;\n    this.frames[frameIndex + _TwoColorTimeline.G] = g;\n    this.frames[frameIndex + _TwoColorTimeline.B] = b;\n    this.frames[frameIndex + _TwoColorTimeline.A] = a;\n    this.frames[frameIndex + _TwoColorTimeline.R2] = r2;\n    this.frames[frameIndex + _TwoColorTimeline.G2] = g2;\n    this.frames[frameIndex + _TwoColorTimeline.B2] = b2;\n  }\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    const slot = skeleton.slots[this.slotIndex];\n    if (!slot.bone.active)\n      return;\n    const frames = this.frames;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          slot.color.setFromColor(slot.data.color);\n          slot.darkColor.setFromColor(slot.data.darkColor);\n          return;\n        case MixBlend.first:\n          const light = slot.color;\n          const dark = slot.darkColor;\n          const setupLight = slot.data.color;\n          const setupDark = slot.data.darkColor;\n          light.add((setupLight.r - light.r) * alpha, (setupLight.g - light.g) * alpha, (setupLight.b - light.b) * alpha, (setupLight.a - light.a) * alpha);\n          dark.add((setupDark.r - dark.r) * alpha, (setupDark.g - dark.g) * alpha, (setupDark.b - dark.b) * alpha, 0);\n      }\n      return;\n    }\n    let r = 0;\n    let g = 0;\n    let b = 0;\n    let a = 0;\n    let r2 = 0;\n    let g2 = 0;\n    let b2 = 0;\n    if (time >= frames[frames.length - _TwoColorTimeline.ENTRIES]) {\n      const i = frames.length;\n      r = frames[i + _TwoColorTimeline.PREV_R];\n      g = frames[i + _TwoColorTimeline.PREV_G];\n      b = frames[i + _TwoColorTimeline.PREV_B];\n      a = frames[i + _TwoColorTimeline.PREV_A];\n      r2 = frames[i + _TwoColorTimeline.PREV_R2];\n      g2 = frames[i + _TwoColorTimeline.PREV_G2];\n      b2 = frames[i + _TwoColorTimeline.PREV_B2];\n    } else {\n      const frame = Animation.binarySearch(frames, time, _TwoColorTimeline.ENTRIES);\n      r = frames[frame + _TwoColorTimeline.PREV_R];\n      g = frames[frame + _TwoColorTimeline.PREV_G];\n      b = frames[frame + _TwoColorTimeline.PREV_B];\n      a = frames[frame + _TwoColorTimeline.PREV_A];\n      r2 = frames[frame + _TwoColorTimeline.PREV_R2];\n      g2 = frames[frame + _TwoColorTimeline.PREV_G2];\n      b2 = frames[frame + _TwoColorTimeline.PREV_B2];\n      const frameTime = frames[frame];\n      const percent = this.getCurvePercent(frame / _TwoColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + _TwoColorTimeline.PREV_TIME] - frameTime));\n      r += (frames[frame + _TwoColorTimeline.R] - r) * percent;\n      g += (frames[frame + _TwoColorTimeline.G] - g) * percent;\n      b += (frames[frame + _TwoColorTimeline.B] - b) * percent;\n      a += (frames[frame + _TwoColorTimeline.A] - a) * percent;\n      r2 += (frames[frame + _TwoColorTimeline.R2] - r2) * percent;\n      g2 += (frames[frame + _TwoColorTimeline.G2] - g2) * percent;\n      b2 += (frames[frame + _TwoColorTimeline.B2] - b2) * percent;\n    }\n    if (alpha == 1) {\n      slot.color.set(r, g, b, a);\n      slot.darkColor.set(r2, g2, b2, 1);\n    } else {\n      const light = slot.color;\n      const dark = slot.darkColor;\n      if (blend == MixBlend.setup) {\n        light.setFromColor(slot.data.color);\n        dark.setFromColor(slot.data.darkColor);\n      }\n      light.add((r - light.r) * alpha, (g - light.g) * alpha, (b - light.b) * alpha, (a - light.a) * alpha);\n      dark.add((r2 - dark.r) * alpha, (g2 - dark.g) * alpha, (b2 - dark.b) * alpha, 0);\n    }\n  }\n};\nlet TwoColorTimeline = _TwoColorTimeline;\nTwoColorTimeline.ENTRIES = 8;\nTwoColorTimeline.PREV_TIME = -8;\nTwoColorTimeline.PREV_R = -7;\nTwoColorTimeline.PREV_G = -6;\nTwoColorTimeline.PREV_B = -5;\nTwoColorTimeline.PREV_A = -4;\nTwoColorTimeline.PREV_R2 = -3;\nTwoColorTimeline.PREV_G2 = -2;\nTwoColorTimeline.PREV_B2 = -1;\nTwoColorTimeline.R = 1;\nTwoColorTimeline.G = 2;\nTwoColorTimeline.B = 3;\nTwoColorTimeline.A = 4;\nTwoColorTimeline.R2 = 5;\nTwoColorTimeline.G2 = 6;\nTwoColorTimeline.B2 = 7;\nclass AttachmentTimeline {\n  constructor(frameCount) {\n    this.frames = Utils.newFloatArray(frameCount);\n    this.attachmentNames = new Array(frameCount);\n  }\n  getPropertyId() {\n    return (4 /* attachment */ << 24) + this.slotIndex;\n  }\n  /** The number of key frames for this timeline. */\n  getFrameCount() {\n    return this.frames.length;\n  }\n  /** Sets the time in seconds and the attachment name for the specified key frame. */\n  setFrame(frameIndex, time, attachmentName) {\n    this.frames[frameIndex] = time;\n    this.attachmentNames[frameIndex] = attachmentName;\n  }\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    const slot = skeleton.slots[this.slotIndex];\n    if (!slot.bone.active)\n      return;\n    if (direction == MixDirection.mixOut) {\n      if (blend == MixBlend.setup)\n        this.setAttachment(skeleton, slot, slot.data.attachmentName);\n      return;\n    }\n    const frames = this.frames;\n    if (time < frames[0]) {\n      if (blend == MixBlend.setup || blend == MixBlend.first)\n        this.setAttachment(skeleton, slot, slot.data.attachmentName);\n      return;\n    }\n    let frameIndex = 0;\n    if (time >= frames[frames.length - 1])\n      frameIndex = frames.length - 1;\n    else\n      frameIndex = Animation.binarySearch(frames, time, 1) - 1;\n    const attachmentName = this.attachmentNames[frameIndex];\n    skeleton.slots[this.slotIndex].setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\n  }\n  setAttachment(skeleton, slot, attachmentName) {\n    slot.setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\n  }\n}\nlet zeros = null;\nclass DeformTimeline extends CurveTimeline {\n  constructor(frameCount) {\n    super(frameCount);\n    this.frames = Utils.newFloatArray(frameCount);\n    this.frameVertices = new Array(frameCount);\n    if (zeros == null)\n      zeros = Utils.newFloatArray(64);\n  }\n  getPropertyId() {\n    return (6 /* deform */ << 27) + Number(this.attachment.id) + this.slotIndex;\n  }\n  /** Sets the time in seconds and the vertices for the specified key frame.\n   * @param vertices Vertex positions for an unweighted VertexAttachment, or deform offsets if it has weights. */\n  setFrame(frameIndex, time, vertices) {\n    this.frames[frameIndex] = time;\n    this.frameVertices[frameIndex] = vertices;\n  }\n  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n    const slot = skeleton.slots[this.slotIndex];\n    if (!slot.bone.active)\n      return;\n    const slotAttachment = slot.getAttachment();\n    if (!(slotAttachment instanceof VertexAttachment) || !(slotAttachment.deformAttachment == this.attachment))\n      return;\n    const deformArray = slot.deform;\n    if (deformArray.length == 0)\n      blend = MixBlend.setup;\n    const frameVertices = this.frameVertices;\n    const vertexCount = frameVertices[0].length;\n    const frames = this.frames;\n    if (time < frames[0]) {\n      const vertexAttachment = slotAttachment;\n      switch (blend) {\n        case MixBlend.setup:\n          deformArray.length = 0;\n          return;\n        case MixBlend.first:\n          if (alpha == 1) {\n            deformArray.length = 0;\n            break;\n          }\n          const deform2 = Utils.setArraySize(deformArray, vertexCount);\n          if (vertexAttachment.bones == null) {\n            const setupVertices = vertexAttachment.vertices;\n            for (let i = 0; i < vertexCount; i++)\n              deform2[i] += (setupVertices[i] - deform2[i]) * alpha;\n          } else {\n            alpha = 1 - alpha;\n            for (let i = 0; i < vertexCount; i++)\n              deform2[i] *= alpha;\n          }\n      }\n      return;\n    }\n    const deform = Utils.setArraySize(deformArray, vertexCount);\n    if (time >= frames[frames.length - 1]) {\n      const lastVertices = frameVertices[frames.length - 1];\n      if (alpha == 1) {\n        if (blend == MixBlend.add) {\n          const vertexAttachment = slotAttachment;\n          if (vertexAttachment.bones == null) {\n            const setupVertices = vertexAttachment.vertices;\n            for (let i = 0; i < vertexCount; i++) {\n              deform[i] += lastVertices[i] - setupVertices[i];\n            }\n          } else {\n            for (let i = 0; i < vertexCount; i++)\n              deform[i] += lastVertices[i];\n          }\n        } else {\n          Utils.arrayCopy(lastVertices, 0, deform, 0, vertexCount);\n        }\n      } else {\n        switch (blend) {\n          case MixBlend.setup: {\n            const vertexAttachment2 = slotAttachment;\n            if (vertexAttachment2.bones == null) {\n              const setupVertices = vertexAttachment2.vertices;\n              for (let i = 0; i < vertexCount; i++) {\n                const setup = setupVertices[i];\n                deform[i] = setup + (lastVertices[i] - setup) * alpha;\n              }\n            } else {\n              for (let i = 0; i < vertexCount; i++)\n                deform[i] = lastVertices[i] * alpha;\n            }\n            break;\n          }\n          case MixBlend.first:\n          case MixBlend.replace:\n            for (let i = 0; i < vertexCount; i++)\n              deform[i] += (lastVertices[i] - deform[i]) * alpha;\n            break;\n          case MixBlend.add:\n            const vertexAttachment = slotAttachment;\n            if (vertexAttachment.bones == null) {\n              const setupVertices = vertexAttachment.vertices;\n              for (let i = 0; i < vertexCount; i++) {\n                deform[i] += (lastVertices[i] - setupVertices[i]) * alpha;\n              }\n            } else {\n              for (let i = 0; i < vertexCount; i++)\n                deform[i] += lastVertices[i] * alpha;\n            }\n        }\n      }\n      return;\n    }\n    const frame = Animation.binarySearch(frames, time);\n    const prevVertices = frameVertices[frame - 1];\n    const nextVertices = frameVertices[frame];\n    const frameTime = frames[frame];\n    const percent = this.getCurvePercent(frame - 1, 1 - (time - frameTime) / (frames[frame - 1] - frameTime));\n    if (alpha == 1) {\n      if (blend == MixBlend.add) {\n        const vertexAttachment = slotAttachment;\n        if (vertexAttachment.bones == null) {\n          const setupVertices = vertexAttachment.vertices;\n          for (let i = 0; i < vertexCount; i++) {\n            const prev = prevVertices[i];\n            deform[i] += prev + (nextVertices[i] - prev) * percent - setupVertices[i];\n          }\n        } else {\n          for (let i = 0; i < vertexCount; i++) {\n            const prev = prevVertices[i];\n            deform[i] += prev + (nextVertices[i] - prev) * percent;\n          }\n        }\n      } else {\n        for (let i = 0; i < vertexCount; i++) {\n          const prev = prevVertices[i];\n          deform[i] = prev + (nextVertices[i] - prev) * percent;\n        }\n      }\n    } else {\n      switch (blend) {\n        case MixBlend.setup: {\n          const vertexAttachment2 = slotAttachment;\n          if (vertexAttachment2.bones == null) {\n            const setupVertices = vertexAttachment2.vertices;\n            for (let i = 0; i < vertexCount; i++) {\n              const prev = prevVertices[i];\n              const setup = setupVertices[i];\n              deform[i] = setup + (prev + (nextVertices[i] - prev) * percent - setup) * alpha;\n            }\n          } else {\n            for (let i = 0; i < vertexCount; i++) {\n              const prev = prevVertices[i];\n              deform[i] = (prev + (nextVertices[i] - prev) * percent) * alpha;\n            }\n          }\n          break;\n        }\n        case MixBlend.first:\n        case MixBlend.replace:\n          for (let i = 0; i < vertexCount; i++) {\n            const prev = prevVertices[i];\n            deform[i] += (prev + (nextVertices[i] - prev) * percent - deform[i]) * alpha;\n          }\n          break;\n        case MixBlend.add:\n          const vertexAttachment = slotAttachment;\n          if (vertexAttachment.bones == null) {\n            const setupVertices = vertexAttachment.vertices;\n            for (let i = 0; i < vertexCount; i++) {\n              const prev = prevVertices[i];\n              deform[i] += (prev + (nextVertices[i] - prev) * percent - setupVertices[i]) * alpha;\n            }\n          } else {\n            for (let i = 0; i < vertexCount; i++) {\n              const prev = prevVertices[i];\n              deform[i] += (prev + (nextVertices[i] - prev) * percent) * alpha;\n            }\n          }\n      }\n    }\n  }\n}\nclass EventTimeline {\n  constructor(frameCount) {\n    this.frames = Utils.newFloatArray(frameCount);\n    this.events = new Array(frameCount);\n  }\n  getPropertyId() {\n    return 7 /* event */ << 24;\n  }\n  /** The number of key frames for this timeline. */\n  getFrameCount() {\n    return this.frames.length;\n  }\n  /** Sets the time in seconds and the event for the specified key frame. */\n  setFrame(frameIndex, event) {\n    this.frames[frameIndex] = event.time;\n    this.events[frameIndex] = event;\n  }\n  /** Fires events for frames > `lastTime` and <= `time`. */\n  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n    if (firedEvents == null)\n      return;\n    const frames = this.frames;\n    const frameCount = this.frames.length;\n    if (lastTime > time) {\n      this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, blend, direction);\n      lastTime = -1;\n    } else if (lastTime >= frames[frameCount - 1])\n      return;\n    if (time < frames[0])\n      return;\n    let frame = 0;\n    if (lastTime < frames[0])\n      frame = 0;\n    else {\n      frame = Animation.binarySearch(frames, lastTime);\n      const frameTime = frames[frame];\n      while (frame > 0) {\n        if (frames[frame - 1] != frameTime)\n          break;\n        frame--;\n      }\n    }\n    for (; frame < frameCount && time >= frames[frame]; frame++)\n      firedEvents.push(this.events[frame]);\n  }\n}\nclass DrawOrderTimeline {\n  constructor(frameCount) {\n    this.frames = Utils.newFloatArray(frameCount);\n    this.drawOrders = new Array(frameCount);\n  }\n  getPropertyId() {\n    return 8 /* drawOrder */ << 24;\n  }\n  /** The number of key frames for this timeline. */\n  getFrameCount() {\n    return this.frames.length;\n  }\n  /** Sets the time in seconds and the draw order for the specified key frame.\n   * @param drawOrder For each slot in {@link Skeleton#slots}, the index of the new draw order. May be null to use setup pose\n   *           draw order. */\n  setFrame(frameIndex, time, drawOrder) {\n    this.frames[frameIndex] = time;\n    this.drawOrders[frameIndex] = drawOrder;\n  }\n  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n    const drawOrder = skeleton.drawOrder;\n    const slots = skeleton.slots;\n    if (direction == MixDirection.mixOut && blend == MixBlend.setup) {\n      Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\n      return;\n    }\n    const frames = this.frames;\n    if (time < frames[0]) {\n      if (blend == MixBlend.setup || blend == MixBlend.first)\n        Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\n      return;\n    }\n    let frame = 0;\n    if (time >= frames[frames.length - 1])\n      frame = frames.length - 1;\n    else\n      frame = Animation.binarySearch(frames, time) - 1;\n    const drawOrderToSetupIndex = this.drawOrders[frame];\n    if (drawOrderToSetupIndex == null)\n      Utils.arrayCopy(slots, 0, drawOrder, 0, slots.length);\n    else {\n      for (let i = 0, n = drawOrderToSetupIndex.length; i < n; i++)\n        drawOrder[i] = slots[drawOrderToSetupIndex[i]];\n    }\n  }\n}\nconst _IkConstraintTimeline = class extends CurveTimeline {\n  // time, mix, softness, bendDirection, compress, stretch, ...\n  constructor(frameCount) {\n    super(frameCount);\n    this.frames = Utils.newFloatArray(frameCount * _IkConstraintTimeline.ENTRIES);\n  }\n  getPropertyId() {\n    return (9 /* ikConstraint */ << 24) + this.ikConstraintIndex;\n  }\n  /** Sets the time in seconds, mix, softness, bend direction, compress, and stretch for the specified key frame. */\n  setFrame(frameIndex, time, mix, softness, bendDirection, compress, stretch) {\n    frameIndex *= _IkConstraintTimeline.ENTRIES;\n    this.frames[frameIndex] = time;\n    this.frames[frameIndex + _IkConstraintTimeline.MIX] = mix;\n    this.frames[frameIndex + _IkConstraintTimeline.SOFTNESS] = softness;\n    this.frames[frameIndex + _IkConstraintTimeline.BEND_DIRECTION] = bendDirection;\n    this.frames[frameIndex + _IkConstraintTimeline.COMPRESS] = compress ? 1 : 0;\n    this.frames[frameIndex + _IkConstraintTimeline.STRETCH] = stretch ? 1 : 0;\n  }\n  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n    const frames = this.frames;\n    const constraint = skeleton.ikConstraints[this.ikConstraintIndex];\n    if (!constraint.active)\n      return;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          constraint.mix = constraint.data.mix;\n          constraint.softness = constraint.data.softness;\n          constraint.bendDirection = constraint.data.bendDirection;\n          constraint.compress = constraint.data.compress;\n          constraint.stretch = constraint.data.stretch;\n          return;\n        case MixBlend.first:\n          constraint.mix += (constraint.data.mix - constraint.mix) * alpha;\n          constraint.softness += (constraint.data.softness - constraint.softness) * alpha;\n          constraint.bendDirection = constraint.data.bendDirection;\n          constraint.compress = constraint.data.compress;\n          constraint.stretch = constraint.data.stretch;\n      }\n      return;\n    }\n    if (time >= frames[frames.length - _IkConstraintTimeline.ENTRIES]) {\n      if (blend == MixBlend.setup) {\n        constraint.mix = constraint.data.mix + (frames[frames.length + _IkConstraintTimeline.PREV_MIX] - constraint.data.mix) * alpha;\n        constraint.softness = constraint.data.softness + (frames[frames.length + _IkConstraintTimeline.PREV_SOFTNESS] - constraint.data.softness) * alpha;\n        if (direction == MixDirection.mixOut) {\n          constraint.bendDirection = constraint.data.bendDirection;\n          constraint.compress = constraint.data.compress;\n          constraint.stretch = constraint.data.stretch;\n        } else {\n          constraint.bendDirection = frames[frames.length + _IkConstraintTimeline.PREV_BEND_DIRECTION];\n          constraint.compress = frames[frames.length + _IkConstraintTimeline.PREV_COMPRESS] != 0;\n          constraint.stretch = frames[frames.length + _IkConstraintTimeline.PREV_STRETCH] != 0;\n        }\n      } else {\n        constraint.mix += (frames[frames.length + _IkConstraintTimeline.PREV_MIX] - constraint.mix) * alpha;\n        constraint.softness += (frames[frames.length + _IkConstraintTimeline.PREV_SOFTNESS] - constraint.softness) * alpha;\n        if (direction == MixDirection.mixIn) {\n          constraint.bendDirection = frames[frames.length + _IkConstraintTimeline.PREV_BEND_DIRECTION];\n          constraint.compress = frames[frames.length + _IkConstraintTimeline.PREV_COMPRESS] != 0;\n          constraint.stretch = frames[frames.length + _IkConstraintTimeline.PREV_STRETCH] != 0;\n        }\n      }\n      return;\n    }\n    const frame = Animation.binarySearch(frames, time, _IkConstraintTimeline.ENTRIES);\n    const mix = frames[frame + _IkConstraintTimeline.PREV_MIX];\n    const softness = frames[frame + _IkConstraintTimeline.PREV_SOFTNESS];\n    const frameTime = frames[frame];\n    const percent = this.getCurvePercent(frame / _IkConstraintTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + _IkConstraintTimeline.PREV_TIME] - frameTime));\n    if (blend == MixBlend.setup) {\n      constraint.mix = constraint.data.mix + (mix + (frames[frame + _IkConstraintTimeline.MIX] - mix) * percent - constraint.data.mix) * alpha;\n      constraint.softness = constraint.data.softness + (softness + (frames[frame + _IkConstraintTimeline.SOFTNESS] - softness) * percent - constraint.data.softness) * alpha;\n      if (direction == MixDirection.mixOut) {\n        constraint.bendDirection = constraint.data.bendDirection;\n        constraint.compress = constraint.data.compress;\n        constraint.stretch = constraint.data.stretch;\n      } else {\n        constraint.bendDirection = frames[frame + _IkConstraintTimeline.PREV_BEND_DIRECTION];\n        constraint.compress = frames[frame + _IkConstraintTimeline.PREV_COMPRESS] != 0;\n        constraint.stretch = frames[frame + _IkConstraintTimeline.PREV_STRETCH] != 0;\n      }\n    } else {\n      constraint.mix += (mix + (frames[frame + _IkConstraintTimeline.MIX] - mix) * percent - constraint.mix) * alpha;\n      constraint.softness += (softness + (frames[frame + _IkConstraintTimeline.SOFTNESS] - softness) * percent - constraint.softness) * alpha;\n      if (direction == MixDirection.mixIn) {\n        constraint.bendDirection = frames[frame + _IkConstraintTimeline.PREV_BEND_DIRECTION];\n        constraint.compress = frames[frame + _IkConstraintTimeline.PREV_COMPRESS] != 0;\n        constraint.stretch = frames[frame + _IkConstraintTimeline.PREV_STRETCH] != 0;\n      }\n    }\n  }\n};\nlet IkConstraintTimeline = _IkConstraintTimeline;\nIkConstraintTimeline.ENTRIES = 6;\nIkConstraintTimeline.PREV_TIME = -6;\nIkConstraintTimeline.PREV_MIX = -5;\nIkConstraintTimeline.PREV_SOFTNESS = -4;\nIkConstraintTimeline.PREV_BEND_DIRECTION = -3;\nIkConstraintTimeline.PREV_COMPRESS = -2;\nIkConstraintTimeline.PREV_STRETCH = -1;\nIkConstraintTimeline.MIX = 1;\nIkConstraintTimeline.SOFTNESS = 2;\nIkConstraintTimeline.BEND_DIRECTION = 3;\nIkConstraintTimeline.COMPRESS = 4;\nIkConstraintTimeline.STRETCH = 5;\nconst _TransformConstraintTimeline = class extends CurveTimeline {\n  // time, rotate mix, translate mix, scale mix, shear mix, ...\n  constructor(frameCount) {\n    super(frameCount);\n    this.frames = Utils.newFloatArray(frameCount * _TransformConstraintTimeline.ENTRIES);\n  }\n  getPropertyId() {\n    return (10 /* transformConstraint */ << 24) + this.transformConstraintIndex;\n  }\n  /** The time in seconds, rotate mix, translate mix, scale mix, and shear mix for the specified key frame. */\n  setFrame(frameIndex, time, rotateMix, translateMix, scaleMix, shearMix) {\n    frameIndex *= _TransformConstraintTimeline.ENTRIES;\n    this.frames[frameIndex] = time;\n    this.frames[frameIndex + _TransformConstraintTimeline.ROTATE] = rotateMix;\n    this.frames[frameIndex + _TransformConstraintTimeline.TRANSLATE] = translateMix;\n    this.frames[frameIndex + _TransformConstraintTimeline.SCALE] = scaleMix;\n    this.frames[frameIndex + _TransformConstraintTimeline.SHEAR] = shearMix;\n  }\n  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n    const frames = this.frames;\n    const constraint = skeleton.transformConstraints[this.transformConstraintIndex];\n    if (!constraint.active)\n      return;\n    if (time < frames[0]) {\n      const data = constraint.data;\n      switch (blend) {\n        case MixBlend.setup:\n          constraint.rotateMix = data.rotateMix;\n          constraint.translateMix = data.translateMix;\n          constraint.scaleMix = data.scaleMix;\n          constraint.shearMix = data.shearMix;\n          return;\n        case MixBlend.first:\n          constraint.rotateMix += (data.rotateMix - constraint.rotateMix) * alpha;\n          constraint.translateMix += (data.translateMix - constraint.translateMix) * alpha;\n          constraint.scaleMix += (data.scaleMix - constraint.scaleMix) * alpha;\n          constraint.shearMix += (data.shearMix - constraint.shearMix) * alpha;\n      }\n      return;\n    }\n    let rotate = 0;\n    let translate = 0;\n    let scale = 0;\n    let shear = 0;\n    if (time >= frames[frames.length - _TransformConstraintTimeline.ENTRIES]) {\n      const i = frames.length;\n      rotate = frames[i + _TransformConstraintTimeline.PREV_ROTATE];\n      translate = frames[i + _TransformConstraintTimeline.PREV_TRANSLATE];\n      scale = frames[i + _TransformConstraintTimeline.PREV_SCALE];\n      shear = frames[i + _TransformConstraintTimeline.PREV_SHEAR];\n    } else {\n      const frame = Animation.binarySearch(frames, time, _TransformConstraintTimeline.ENTRIES);\n      rotate = frames[frame + _TransformConstraintTimeline.PREV_ROTATE];\n      translate = frames[frame + _TransformConstraintTimeline.PREV_TRANSLATE];\n      scale = frames[frame + _TransformConstraintTimeline.PREV_SCALE];\n      shear = frames[frame + _TransformConstraintTimeline.PREV_SHEAR];\n      const frameTime = frames[frame];\n      const percent = this.getCurvePercent(\n        frame / _TransformConstraintTimeline.ENTRIES - 1,\n        1 - (time - frameTime) / (frames[frame + _TransformConstraintTimeline.PREV_TIME] - frameTime)\n      );\n      rotate += (frames[frame + _TransformConstraintTimeline.ROTATE] - rotate) * percent;\n      translate += (frames[frame + _TransformConstraintTimeline.TRANSLATE] - translate) * percent;\n      scale += (frames[frame + _TransformConstraintTimeline.SCALE] - scale) * percent;\n      shear += (frames[frame + _TransformConstraintTimeline.SHEAR] - shear) * percent;\n    }\n    if (blend == MixBlend.setup) {\n      const data = constraint.data;\n      constraint.rotateMix = data.rotateMix + (rotate - data.rotateMix) * alpha;\n      constraint.translateMix = data.translateMix + (translate - data.translateMix) * alpha;\n      constraint.scaleMix = data.scaleMix + (scale - data.scaleMix) * alpha;\n      constraint.shearMix = data.shearMix + (shear - data.shearMix) * alpha;\n    } else {\n      constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;\n      constraint.translateMix += (translate - constraint.translateMix) * alpha;\n      constraint.scaleMix += (scale - constraint.scaleMix) * alpha;\n      constraint.shearMix += (shear - constraint.shearMix) * alpha;\n    }\n  }\n};\nlet TransformConstraintTimeline = _TransformConstraintTimeline;\nTransformConstraintTimeline.ENTRIES = 5;\nTransformConstraintTimeline.PREV_TIME = -5;\nTransformConstraintTimeline.PREV_ROTATE = -4;\nTransformConstraintTimeline.PREV_TRANSLATE = -3;\nTransformConstraintTimeline.PREV_SCALE = -2;\nTransformConstraintTimeline.PREV_SHEAR = -1;\nTransformConstraintTimeline.ROTATE = 1;\nTransformConstraintTimeline.TRANSLATE = 2;\nTransformConstraintTimeline.SCALE = 3;\nTransformConstraintTimeline.SHEAR = 4;\nconst _PathConstraintPositionTimeline = class extends CurveTimeline {\n  // time, position, ...\n  constructor(frameCount) {\n    super(frameCount);\n    this.frames = Utils.newFloatArray(frameCount * _PathConstraintPositionTimeline.ENTRIES);\n  }\n  getPropertyId() {\n    return (11 /* pathConstraintPosition */ << 24) + this.pathConstraintIndex;\n  }\n  /** Sets the time in seconds and path constraint position for the specified key frame. */\n  setFrame(frameIndex, time, value) {\n    frameIndex *= _PathConstraintPositionTimeline.ENTRIES;\n    this.frames[frameIndex] = time;\n    this.frames[frameIndex + _PathConstraintPositionTimeline.VALUE] = value;\n  }\n  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n    const frames = this.frames;\n    const constraint = skeleton.pathConstraints[this.pathConstraintIndex];\n    if (!constraint.active)\n      return;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          constraint.position = constraint.data.position;\n          return;\n        case MixBlend.first:\n          constraint.position += (constraint.data.position - constraint.position) * alpha;\n      }\n      return;\n    }\n    let position = 0;\n    if (time >= frames[frames.length - _PathConstraintPositionTimeline.ENTRIES])\n      position = frames[frames.length + _PathConstraintPositionTimeline.PREV_VALUE];\n    else {\n      const frame = Animation.binarySearch(frames, time, _PathConstraintPositionTimeline.ENTRIES);\n      position = frames[frame + _PathConstraintPositionTimeline.PREV_VALUE];\n      const frameTime = frames[frame];\n      const percent = this.getCurvePercent(\n        frame / _PathConstraintPositionTimeline.ENTRIES - 1,\n        1 - (time - frameTime) / (frames[frame + _PathConstraintPositionTimeline.PREV_TIME] - frameTime)\n      );\n      position += (frames[frame + _PathConstraintPositionTimeline.VALUE] - position) * percent;\n    }\n    if (blend == MixBlend.setup)\n      constraint.position = constraint.data.position + (position - constraint.data.position) * alpha;\n    else\n      constraint.position += (position - constraint.position) * alpha;\n  }\n};\nlet PathConstraintPositionTimeline = _PathConstraintPositionTimeline;\nPathConstraintPositionTimeline.ENTRIES = 2;\nPathConstraintPositionTimeline.PREV_TIME = -2;\nPathConstraintPositionTimeline.PREV_VALUE = -1;\nPathConstraintPositionTimeline.VALUE = 1;\nclass PathConstraintSpacingTimeline extends PathConstraintPositionTimeline {\n  constructor(frameCount) {\n    super(frameCount);\n  }\n  getPropertyId() {\n    return (12 /* pathConstraintSpacing */ << 24) + this.pathConstraintIndex;\n  }\n  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n    const frames = this.frames;\n    const constraint = skeleton.pathConstraints[this.pathConstraintIndex];\n    if (!constraint.active)\n      return;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          constraint.spacing = constraint.data.spacing;\n          return;\n        case MixBlend.first:\n          constraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha;\n      }\n      return;\n    }\n    let spacing = 0;\n    if (time >= frames[frames.length - PathConstraintSpacingTimeline.ENTRIES])\n      spacing = frames[frames.length + PathConstraintSpacingTimeline.PREV_VALUE];\n    else {\n      const frame = Animation.binarySearch(frames, time, PathConstraintSpacingTimeline.ENTRIES);\n      spacing = frames[frame + PathConstraintSpacingTimeline.PREV_VALUE];\n      const frameTime = frames[frame];\n      const percent = this.getCurvePercent(\n        frame / PathConstraintSpacingTimeline.ENTRIES - 1,\n        1 - (time - frameTime) / (frames[frame + PathConstraintSpacingTimeline.PREV_TIME] - frameTime)\n      );\n      spacing += (frames[frame + PathConstraintSpacingTimeline.VALUE] - spacing) * percent;\n    }\n    if (blend == MixBlend.setup)\n      constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha;\n    else\n      constraint.spacing += (spacing - constraint.spacing) * alpha;\n  }\n}\nconst _PathConstraintMixTimeline = class extends CurveTimeline {\n  // time, rotate mix, translate mix, ...\n  constructor(frameCount) {\n    super(frameCount);\n    this.frames = Utils.newFloatArray(frameCount * _PathConstraintMixTimeline.ENTRIES);\n  }\n  getPropertyId() {\n    return (13 /* pathConstraintMix */ << 24) + this.pathConstraintIndex;\n  }\n  /** The time in seconds, rotate mix, and translate mix for the specified key frame. */\n  setFrame(frameIndex, time, rotateMix, translateMix) {\n    frameIndex *= _PathConstraintMixTimeline.ENTRIES;\n    this.frames[frameIndex] = time;\n    this.frames[frameIndex + _PathConstraintMixTimeline.ROTATE] = rotateMix;\n    this.frames[frameIndex + _PathConstraintMixTimeline.TRANSLATE] = translateMix;\n  }\n  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n    const frames = this.frames;\n    const constraint = skeleton.pathConstraints[this.pathConstraintIndex];\n    if (!constraint.active)\n      return;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          constraint.rotateMix = constraint.data.rotateMix;\n          constraint.translateMix = constraint.data.translateMix;\n          return;\n        case MixBlend.first:\n          constraint.rotateMix += (constraint.data.rotateMix - constraint.rotateMix) * alpha;\n          constraint.translateMix += (constraint.data.translateMix - constraint.translateMix) * alpha;\n      }\n      return;\n    }\n    let rotate = 0;\n    let translate = 0;\n    if (time >= frames[frames.length - _PathConstraintMixTimeline.ENTRIES]) {\n      rotate = frames[frames.length + _PathConstraintMixTimeline.PREV_ROTATE];\n      translate = frames[frames.length + _PathConstraintMixTimeline.PREV_TRANSLATE];\n    } else {\n      const frame = Animation.binarySearch(frames, time, _PathConstraintMixTimeline.ENTRIES);\n      rotate = frames[frame + _PathConstraintMixTimeline.PREV_ROTATE];\n      translate = frames[frame + _PathConstraintMixTimeline.PREV_TRANSLATE];\n      const frameTime = frames[frame];\n      const percent = this.getCurvePercent(\n        frame / _PathConstraintMixTimeline.ENTRIES - 1,\n        1 - (time - frameTime) / (frames[frame + _PathConstraintMixTimeline.PREV_TIME] - frameTime)\n      );\n      rotate += (frames[frame + _PathConstraintMixTimeline.ROTATE] - rotate) * percent;\n      translate += (frames[frame + _PathConstraintMixTimeline.TRANSLATE] - translate) * percent;\n    }\n    if (blend == MixBlend.setup) {\n      constraint.rotateMix = constraint.data.rotateMix + (rotate - constraint.data.rotateMix) * alpha;\n      constraint.translateMix = constraint.data.translateMix + (translate - constraint.data.translateMix) * alpha;\n    } else {\n      constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;\n      constraint.translateMix += (translate - constraint.translateMix) * alpha;\n    }\n  }\n};\nlet PathConstraintMixTimeline = _PathConstraintMixTimeline;\nPathConstraintMixTimeline.ENTRIES = 3;\nPathConstraintMixTimeline.PREV_TIME = -3;\nPathConstraintMixTimeline.PREV_ROTATE = -2;\nPathConstraintMixTimeline.PREV_TRANSLATE = -1;\nPathConstraintMixTimeline.ROTATE = 1;\nPathConstraintMixTimeline.TRANSLATE = 2;\n\nexport { Animation, AttachmentTimeline, ColorTimeline, CurveTimeline, DeformTimeline, DrawOrderTimeline, EventTimeline, IkConstraintTimeline, PathConstraintMixTimeline, PathConstraintPositionTimeline, PathConstraintSpacingTimeline, RotateTimeline, ScaleTimeline, ShearTimeline, TimelineType, TransformConstraintTimeline, TranslateTimeline, TwoColorTimeline };\n//# sourceMappingURL=Animation.mjs.map\n","import { IntSet, Pool, MixBlend, Utils, MixDirection, MathUtils } from '@pixi-spine/base';\nimport { Animation, AttachmentTimeline, RotateTimeline, DrawOrderTimeline, EventTimeline } from './Animation.mjs';\n\nconst _AnimationState = class {\n  constructor(data) {\n    /** The list of tracks that currently have animations, which may contain null entries. */\n    this.tracks = new Array();\n    /** Multiplier for the delta time when the animation state is updated, causing time for all animations and mixes to play slower\n     * or faster. Defaults to 1.\n     *\n     * See TrackEntry {@link TrackEntry#timeScale} for affecting a single animation. */\n    this.timeScale = 1;\n    this.unkeyedState = 0;\n    this.events = new Array();\n    this.listeners = new Array();\n    this.queue = new EventQueue(this);\n    this.propertyIDs = new IntSet();\n    this.animationsChanged = false;\n    this.trackEntryPool = new Pool(() => new TrackEntry());\n    this.data = data;\n  }\n  /** Increments each track entry {@link TrackEntry#trackTime()}, setting queued animations as current if needed. */\n  update(delta) {\n    delta *= this.timeScale;\n    const tracks = this.tracks;\n    for (let i = 0, n = tracks.length; i < n; i++) {\n      const current = tracks[i];\n      if (current == null)\n        continue;\n      current.animationLast = current.nextAnimationLast;\n      current.trackLast = current.nextTrackLast;\n      let currentDelta = delta * current.timeScale;\n      if (current.delay > 0) {\n        current.delay -= currentDelta;\n        if (current.delay > 0)\n          continue;\n        currentDelta = -current.delay;\n        current.delay = 0;\n      }\n      let next = current.next;\n      if (next != null) {\n        const nextTime = current.trackLast - next.delay;\n        if (nextTime >= 0) {\n          next.delay = 0;\n          next.trackTime += current.timeScale == 0 ? 0 : (nextTime / current.timeScale + delta) * next.timeScale;\n          current.trackTime += currentDelta;\n          this.setCurrent(i, next, true);\n          while (next.mixingFrom != null) {\n            next.mixTime += delta;\n            next = next.mixingFrom;\n          }\n          continue;\n        }\n      } else if (current.trackLast >= current.trackEnd && current.mixingFrom == null) {\n        tracks[i] = null;\n        this.queue.end(current);\n        this.disposeNext(current);\n        continue;\n      }\n      if (current.mixingFrom != null && this.updateMixingFrom(current, delta)) {\n        let from = current.mixingFrom;\n        current.mixingFrom = null;\n        if (from != null)\n          from.mixingTo = null;\n        while (from != null) {\n          this.queue.end(from);\n          from = from.mixingFrom;\n        }\n      }\n      current.trackTime += currentDelta;\n    }\n    this.queue.drain();\n  }\n  /** Returns true when all mixing from entries are complete. */\n  updateMixingFrom(to, delta) {\n    const from = to.mixingFrom;\n    if (from == null)\n      return true;\n    const finished = this.updateMixingFrom(from, delta);\n    from.animationLast = from.nextAnimationLast;\n    from.trackLast = from.nextTrackLast;\n    if (to.mixTime > 0 && to.mixTime >= to.mixDuration) {\n      if (from.totalAlpha == 0 || to.mixDuration == 0) {\n        to.mixingFrom = from.mixingFrom;\n        if (from.mixingFrom != null)\n          from.mixingFrom.mixingTo = to;\n        to.interruptAlpha = from.interruptAlpha;\n        this.queue.end(from);\n      }\n      return finished;\n    }\n    from.trackTime += delta * from.timeScale;\n    to.mixTime += delta;\n    return false;\n  }\n  /** Poses the skeleton using the track entry animations. There are no side effects other than invoking listeners, so the\n   * animation state can be applied to multiple skeletons to pose them identically.\n   * @returns True if any animations were applied. */\n  apply(skeleton) {\n    if (skeleton == null)\n      throw new Error(\"skeleton cannot be null.\");\n    if (this.animationsChanged)\n      this._animationsChanged();\n    const events = this.events;\n    const tracks = this.tracks;\n    let applied = false;\n    for (let i = 0, n = tracks.length; i < n; i++) {\n      const current = tracks[i];\n      if (current == null || current.delay > 0)\n        continue;\n      applied = true;\n      const blend = i == 0 ? MixBlend.first : current.mixBlend;\n      let mix = current.alpha;\n      if (current.mixingFrom != null)\n        mix *= this.applyMixingFrom(current, skeleton, blend);\n      else if (current.trackTime >= current.trackEnd && current.next == null)\n        mix = 0;\n      const animationLast = current.animationLast;\n      const animationTime = current.getAnimationTime();\n      const timelineCount = current.animation.timelines.length;\n      const timelines = current.animation.timelines;\n      if (i == 0 && mix == 1 || blend == MixBlend.add) {\n        for (let ii = 0; ii < timelineCount; ii++) {\n          Utils.webkit602BugfixHelper(mix, blend);\n          const timeline = timelines[ii];\n          if (timeline instanceof AttachmentTimeline)\n            this.applyAttachmentTimeline(timeline, skeleton, animationTime, blend, true);\n          else\n            timeline.apply(skeleton, animationLast, animationTime, events, mix, blend, MixDirection.mixIn);\n        }\n      } else {\n        const timelineMode = current.timelineMode;\n        const firstFrame = current.timelinesRotation.length == 0;\n        if (firstFrame)\n          Utils.setArraySize(current.timelinesRotation, timelineCount << 1, null);\n        const timelinesRotation = current.timelinesRotation;\n        for (let ii = 0; ii < timelineCount; ii++) {\n          const timeline = timelines[ii];\n          const timelineBlend = timelineMode[ii] == _AnimationState.SUBSEQUENT ? blend : MixBlend.setup;\n          if (timeline instanceof RotateTimeline) {\n            this.applyRotateTimeline(timeline, skeleton, animationTime, mix, timelineBlend, timelinesRotation, ii << 1, firstFrame);\n          } else if (timeline instanceof AttachmentTimeline) {\n            this.applyAttachmentTimeline(timeline, skeleton, animationTime, blend, true);\n          } else {\n            Utils.webkit602BugfixHelper(mix, blend);\n            timeline.apply(skeleton, animationLast, animationTime, events, mix, timelineBlend, MixDirection.mixIn);\n          }\n        }\n      }\n      this.queueEvents(current, animationTime);\n      events.length = 0;\n      current.nextAnimationLast = animationTime;\n      current.nextTrackLast = current.trackTime;\n    }\n    const setupState = this.unkeyedState + _AnimationState.SETUP;\n    const slots = skeleton.slots;\n    for (let i = 0, n = skeleton.slots.length; i < n; i++) {\n      const slot = slots[i];\n      if (slot.attachmentState == setupState) {\n        const attachmentName = slot.data.attachmentName;\n        slot.setAttachment(attachmentName == null ? null : skeleton.getAttachment(slot.data.index, attachmentName));\n      }\n    }\n    this.unkeyedState += 2;\n    this.queue.drain();\n    return applied;\n  }\n  applyMixingFrom(to, skeleton, blend) {\n    const from = to.mixingFrom;\n    if (from.mixingFrom != null)\n      this.applyMixingFrom(from, skeleton, blend);\n    let mix = 0;\n    if (to.mixDuration == 0) {\n      mix = 1;\n      if (blend == MixBlend.first)\n        blend = MixBlend.setup;\n    } else {\n      mix = to.mixTime / to.mixDuration;\n      if (mix > 1)\n        mix = 1;\n      if (blend != MixBlend.first)\n        blend = from.mixBlend;\n    }\n    const events = mix < from.eventThreshold ? this.events : null;\n    const attachments = mix < from.attachmentThreshold;\n    const drawOrder = mix < from.drawOrderThreshold;\n    const animationLast = from.animationLast;\n    const animationTime = from.getAnimationTime();\n    const timelineCount = from.animation.timelines.length;\n    const timelines = from.animation.timelines;\n    const alphaHold = from.alpha * to.interruptAlpha;\n    const alphaMix = alphaHold * (1 - mix);\n    if (blend == MixBlend.add) {\n      for (let i = 0; i < timelineCount; i++)\n        timelines[i].apply(skeleton, animationLast, animationTime, events, alphaMix, blend, MixDirection.mixOut);\n    } else {\n      const timelineMode = from.timelineMode;\n      const timelineHoldMix = from.timelineHoldMix;\n      const firstFrame = from.timelinesRotation.length == 0;\n      if (firstFrame)\n        Utils.setArraySize(from.timelinesRotation, timelineCount << 1, null);\n      const timelinesRotation = from.timelinesRotation;\n      from.totalAlpha = 0;\n      for (let i = 0; i < timelineCount; i++) {\n        const timeline = timelines[i];\n        let direction = MixDirection.mixOut;\n        let timelineBlend;\n        let alpha = 0;\n        switch (timelineMode[i]) {\n          case _AnimationState.SUBSEQUENT:\n            if (!drawOrder && timeline instanceof DrawOrderTimeline)\n              continue;\n            timelineBlend = blend;\n            alpha = alphaMix;\n            break;\n          case _AnimationState.FIRST:\n            timelineBlend = MixBlend.setup;\n            alpha = alphaMix;\n            break;\n          case _AnimationState.HOLD_SUBSEQUENT:\n            timelineBlend = blend;\n            alpha = alphaHold;\n            break;\n          case _AnimationState.HOLD_FIRST:\n            timelineBlend = MixBlend.setup;\n            alpha = alphaHold;\n            break;\n          default:\n            timelineBlend = MixBlend.setup;\n            const holdMix = timelineHoldMix[i];\n            alpha = alphaHold * Math.max(0, 1 - holdMix.mixTime / holdMix.mixDuration);\n            break;\n        }\n        from.totalAlpha += alpha;\n        if (timeline instanceof RotateTimeline)\n          this.applyRotateTimeline(timeline, skeleton, animationTime, alpha, timelineBlend, timelinesRotation, i << 1, firstFrame);\n        else if (timeline instanceof AttachmentTimeline)\n          this.applyAttachmentTimeline(timeline, skeleton, animationTime, timelineBlend, attachments);\n        else {\n          Utils.webkit602BugfixHelper(alpha, blend);\n          if (drawOrder && timeline instanceof DrawOrderTimeline && timelineBlend == MixBlend.setup)\n            direction = MixDirection.mixIn;\n          timeline.apply(skeleton, animationLast, animationTime, events, alpha, timelineBlend, direction);\n        }\n      }\n    }\n    if (to.mixDuration > 0)\n      this.queueEvents(from, animationTime);\n    this.events.length = 0;\n    from.nextAnimationLast = animationTime;\n    from.nextTrackLast = from.trackTime;\n    return mix;\n  }\n  applyAttachmentTimeline(timeline, skeleton, time, blend, attachments) {\n    const slot = skeleton.slots[timeline.slotIndex];\n    if (!slot.bone.active)\n      return;\n    const frames = timeline.frames;\n    if (time < frames[0]) {\n      if (blend == MixBlend.setup || blend == MixBlend.first)\n        this.setAttachment(skeleton, slot, slot.data.attachmentName, attachments);\n    } else {\n      let frameIndex;\n      if (time >= frames[frames.length - 1])\n        frameIndex = frames.length - 1;\n      else\n        frameIndex = Animation.binarySearch(frames, time) - 1;\n      this.setAttachment(skeleton, slot, timeline.attachmentNames[frameIndex], attachments);\n    }\n    if (slot.attachmentState <= this.unkeyedState)\n      slot.attachmentState = this.unkeyedState + _AnimationState.SETUP;\n  }\n  setAttachment(skeleton, slot, attachmentName, attachments) {\n    slot.setAttachment(attachmentName == null ? null : skeleton.getAttachment(slot.data.index, attachmentName));\n    if (attachments)\n      slot.attachmentState = this.unkeyedState + _AnimationState.CURRENT;\n  }\n  applyRotateTimeline(timeline, skeleton, time, alpha, blend, timelinesRotation, i, firstFrame) {\n    if (firstFrame)\n      timelinesRotation[i] = 0;\n    if (alpha == 1) {\n      timeline.apply(skeleton, 0, time, null, 1, blend, MixDirection.mixIn);\n      return;\n    }\n    const rotateTimeline = timeline;\n    const frames = rotateTimeline.frames;\n    const bone = skeleton.bones[rotateTimeline.boneIndex];\n    if (!bone.active)\n      return;\n    let r1 = 0;\n    let r2 = 0;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.rotation = bone.data.rotation;\n        default:\n          return;\n        case MixBlend.first:\n          r1 = bone.rotation;\n          r2 = bone.data.rotation;\n      }\n    } else {\n      r1 = blend == MixBlend.setup ? bone.data.rotation : bone.rotation;\n      if (time >= frames[frames.length - RotateTimeline.ENTRIES])\n        r2 = bone.data.rotation + frames[frames.length + RotateTimeline.PREV_ROTATION];\n      else {\n        const frame = Animation.binarySearch(frames, time, RotateTimeline.ENTRIES);\n        const prevRotation = frames[frame + RotateTimeline.PREV_ROTATION];\n        const frameTime = frames[frame];\n        const percent = rotateTimeline.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + RotateTimeline.PREV_TIME] - frameTime));\n        r2 = frames[frame + RotateTimeline.ROTATION] - prevRotation;\n        r2 -= (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360;\n        r2 = prevRotation + r2 * percent + bone.data.rotation;\n        r2 -= (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360;\n      }\n    }\n    let total = 0;\n    let diff = r2 - r1;\n    diff -= (16384 - (16384.499999999996 - diff / 360 | 0)) * 360;\n    if (diff == 0) {\n      total = timelinesRotation[i];\n    } else {\n      let lastTotal = 0;\n      let lastDiff = 0;\n      if (firstFrame) {\n        lastTotal = 0;\n        lastDiff = diff;\n      } else {\n        lastTotal = timelinesRotation[i];\n        lastDiff = timelinesRotation[i + 1];\n      }\n      const current = diff > 0;\n      let dir = lastTotal >= 0;\n      if (MathUtils.signum(lastDiff) != MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {\n        if (Math.abs(lastTotal) > 180)\n          lastTotal += 360 * MathUtils.signum(lastTotal);\n        dir = current;\n      }\n      total = diff + lastTotal - lastTotal % 360;\n      if (dir != current)\n        total += 360 * MathUtils.signum(lastTotal);\n      timelinesRotation[i] = total;\n    }\n    timelinesRotation[i + 1] = diff;\n    r1 += total * alpha;\n    bone.rotation = r1 - (16384 - (16384.499999999996 - r1 / 360 | 0)) * 360;\n  }\n  queueEvents(entry, animationTime) {\n    const animationStart = entry.animationStart;\n    const animationEnd = entry.animationEnd;\n    const duration = animationEnd - animationStart;\n    const trackLastWrapped = entry.trackLast % duration;\n    const events = this.events;\n    let i = 0;\n    const n = events.length;\n    for (; i < n; i++) {\n      const event = events[i];\n      if (event.time < trackLastWrapped)\n        break;\n      if (event.time > animationEnd)\n        continue;\n      this.queue.event(entry, event);\n    }\n    let complete = false;\n    if (entry.loop)\n      complete = duration == 0 || trackLastWrapped > entry.trackTime % duration;\n    else\n      complete = animationTime >= animationEnd && entry.animationLast < animationEnd;\n    if (complete)\n      this.queue.complete(entry);\n    for (; i < n; i++) {\n      const event = events[i];\n      if (event.time < animationStart)\n        continue;\n      this.queue.event(entry, events[i]);\n    }\n  }\n  /** Removes all animations from all tracks, leaving skeletons in their current pose.\n   *\n   * It may be desired to use {@link AnimationState#setEmptyAnimation()} to mix the skeletons back to the setup pose,\n   * rather than leaving them in their current pose. */\n  clearTracks() {\n    const oldDrainDisabled = this.queue.drainDisabled;\n    this.queue.drainDisabled = true;\n    for (let i = 0, n = this.tracks.length; i < n; i++)\n      this.clearTrack(i);\n    this.tracks.length = 0;\n    this.queue.drainDisabled = oldDrainDisabled;\n    this.queue.drain();\n  }\n  /** Removes all animations from the track, leaving skeletons in their current pose.\n   *\n   * It may be desired to use {@link AnimationState#setEmptyAnimation()} to mix the skeletons back to the setup pose,\n   * rather than leaving them in their current pose. */\n  clearTrack(trackIndex) {\n    if (trackIndex >= this.tracks.length)\n      return;\n    const current = this.tracks[trackIndex];\n    if (current == null)\n      return;\n    this.queue.end(current);\n    this.disposeNext(current);\n    let entry = current;\n    while (true) {\n      const from = entry.mixingFrom;\n      if (from == null)\n        break;\n      this.queue.end(from);\n      entry.mixingFrom = null;\n      entry.mixingTo = null;\n      entry = from;\n    }\n    this.tracks[current.trackIndex] = null;\n    this.queue.drain();\n  }\n  setCurrent(index, current, interrupt) {\n    const from = this.expandToIndex(index);\n    this.tracks[index] = current;\n    if (from != null) {\n      if (interrupt)\n        this.queue.interrupt(from);\n      current.mixingFrom = from;\n      from.mixingTo = current;\n      current.mixTime = 0;\n      if (from.mixingFrom != null && from.mixDuration > 0)\n        current.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);\n      from.timelinesRotation.length = 0;\n    }\n    this.queue.start(current);\n  }\n  /** Sets an animation by name.\n   *\n   * {@link #setAnimationWith(}. */\n  setAnimation(trackIndex, animationName, loop) {\n    const animation = this.data.skeletonData.findAnimation(animationName);\n    if (animation == null)\n      throw new Error(`Animation not found: ${animationName}`);\n    return this.setAnimationWith(trackIndex, animation, loop);\n  }\n  /** Sets the current animation for a track, discarding any queued animations. If the formerly current track entry was never\n   * applied to a skeleton, it is replaced (not mixed from).\n   * @param loop If true, the animation will repeat. If false it will not, instead its last frame is applied if played beyond its\n   *           duration. In either case {@link TrackEntry#trackEnd} determines when the track is cleared.\n   * @returns A track entry to allow further customization of animation playback. References to the track entry must not be kept\n   *         after the {@link AnimationStateListener#dispose()} event occurs. */\n  setAnimationWith(trackIndex, animation, loop) {\n    if (animation == null)\n      throw new Error(\"animation cannot be null.\");\n    let interrupt = true;\n    let current = this.expandToIndex(trackIndex);\n    if (current != null) {\n      if (current.nextTrackLast == -1) {\n        this.tracks[trackIndex] = current.mixingFrom;\n        this.queue.interrupt(current);\n        this.queue.end(current);\n        this.disposeNext(current);\n        current = current.mixingFrom;\n        interrupt = false;\n      } else\n        this.disposeNext(current);\n    }\n    const entry = this.trackEntry(trackIndex, animation, loop, current);\n    this.setCurrent(trackIndex, entry, interrupt);\n    this.queue.drain();\n    return entry;\n  }\n  /** Queues an animation by name.\n   *\n   * See {@link #addAnimationWith()}. */\n  addAnimation(trackIndex, animationName, loop, delay) {\n    const animation = this.data.skeletonData.findAnimation(animationName);\n    if (animation == null)\n      throw new Error(`Animation not found: ${animationName}`);\n    return this.addAnimationWith(trackIndex, animation, loop, delay);\n  }\n  /** Adds an animation to be played after the current or last queued animation for a track. If the track is empty, it is\n   * equivalent to calling {@link #setAnimationWith()}.\n   * @param delay If > 0, sets {@link TrackEntry#delay}. If <= 0, the delay set is the duration of the previous track entry\n   *           minus any mix duration (from the {@link AnimationStateData}) plus the specified `delay` (ie the mix\n   *           ends at (`delay` = 0) or before (`delay` < 0) the previous track entry duration). If the\n   *           previous entry is looping, its next loop completion is used instead of its duration.\n   * @returns A track entry to allow further customization of animation playback. References to the track entry must not be kept\n   *         after the {@link AnimationStateListener#dispose()} event occurs. */\n  addAnimationWith(trackIndex, animation, loop, delay) {\n    if (animation == null)\n      throw new Error(\"animation cannot be null.\");\n    let last = this.expandToIndex(trackIndex);\n    if (last != null) {\n      while (last.next != null)\n        last = last.next;\n    }\n    const entry = this.trackEntry(trackIndex, animation, loop, last);\n    if (last == null) {\n      this.setCurrent(trackIndex, entry, true);\n      this.queue.drain();\n    } else {\n      last.next = entry;\n      if (delay <= 0) {\n        const duration = last.animationEnd - last.animationStart;\n        if (duration != 0) {\n          if (last.loop)\n            delay += duration * (1 + (last.trackTime / duration | 0));\n          else\n            delay += Math.max(duration, last.trackTime);\n          delay -= this.data.getMix(last.animation, animation);\n        } else\n          delay = last.trackTime;\n      }\n    }\n    entry.delay = delay;\n    return entry;\n  }\n  /** Sets an empty animation for a track, discarding any queued animations, and sets the track entry's\n   * {@link TrackEntry#mixduration}. An empty animation has no timelines and serves as a placeholder for mixing in or out.\n   *\n   * Mixing out is done by setting an empty animation with a mix duration using either {@link #setEmptyAnimation()},\n   * {@link #setEmptyAnimations()}, or {@link #addEmptyAnimation()}. Mixing to an empty animation causes\n   * the previous animation to be applied less and less over the mix duration. Properties keyed in the previous animation\n   * transition to the value from lower tracks or to the setup pose value if no lower tracks key the property. A mix duration of\n   * 0 still mixes out over one frame.\n   *\n   * Mixing in is done by first setting an empty animation, then adding an animation using\n   * {@link #addAnimation()} and on the returned track entry, set the\n   * {@link TrackEntry#setMixDuration()}. Mixing from an empty animation causes the new animation to be applied more and\n   * more over the mix duration. Properties keyed in the new animation transition from the value from lower tracks or from the\n   * setup pose value if no lower tracks key the property to the value keyed in the new animation. */\n  setEmptyAnimation(trackIndex, mixDuration) {\n    const entry = this.setAnimationWith(trackIndex, _AnimationState.emptyAnimation, false);\n    entry.mixDuration = mixDuration;\n    entry.trackEnd = mixDuration;\n    return entry;\n  }\n  /** Adds an empty animation to be played after the current or last queued animation for a track, and sets the track entry's\n   * {@link TrackEntry#mixDuration}. If the track is empty, it is equivalent to calling\n   * {@link #setEmptyAnimation()}.\n   *\n   * See {@link #setEmptyAnimation()}.\n   * @param delay If > 0, sets {@link TrackEntry#delay}. If <= 0, the delay set is the duration of the previous track entry\n   *           minus any mix duration plus the specified `delay` (ie the mix ends at (`delay` = 0) or\n   *           before (`delay` < 0) the previous track entry duration). If the previous entry is looping, its next\n   *           loop completion is used instead of its duration.\n   * @return A track entry to allow further customization of animation playback. References to the track entry must not be kept\n   *         after the {@link AnimationStateListener#dispose()} event occurs. */\n  addEmptyAnimation(trackIndex, mixDuration, delay) {\n    if (delay <= 0)\n      delay -= mixDuration;\n    const entry = this.addAnimationWith(trackIndex, _AnimationState.emptyAnimation, false, delay);\n    entry.mixDuration = mixDuration;\n    entry.trackEnd = mixDuration;\n    return entry;\n  }\n  /** Sets an empty animation for every track, discarding any queued animations, and mixes to it over the specified mix\n   * duration. */\n  setEmptyAnimations(mixDuration) {\n    const oldDrainDisabled = this.queue.drainDisabled;\n    this.queue.drainDisabled = true;\n    for (let i = 0, n = this.tracks.length; i < n; i++) {\n      const current = this.tracks[i];\n      if (current != null)\n        this.setEmptyAnimation(current.trackIndex, mixDuration);\n    }\n    this.queue.drainDisabled = oldDrainDisabled;\n    this.queue.drain();\n  }\n  expandToIndex(index) {\n    if (index < this.tracks.length)\n      return this.tracks[index];\n    Utils.ensureArrayCapacity(this.tracks, index + 1, null);\n    this.tracks.length = index + 1;\n    return null;\n  }\n  /** @param last May be null. */\n  trackEntry(trackIndex, animation, loop, last) {\n    const entry = this.trackEntryPool.obtain();\n    entry.trackIndex = trackIndex;\n    entry.animation = animation;\n    entry.loop = loop;\n    entry.holdPrevious = false;\n    entry.eventThreshold = 0;\n    entry.attachmentThreshold = 0;\n    entry.drawOrderThreshold = 0;\n    entry.animationStart = 0;\n    entry.animationEnd = animation.duration;\n    entry.animationLast = -1;\n    entry.nextAnimationLast = -1;\n    entry.delay = 0;\n    entry.trackTime = 0;\n    entry.trackLast = -1;\n    entry.nextTrackLast = -1;\n    entry.trackEnd = Number.MAX_VALUE;\n    entry.timeScale = 1;\n    entry.alpha = 1;\n    entry.interruptAlpha = 1;\n    entry.mixTime = 0;\n    entry.mixDuration = last == null ? 0 : this.data.getMix(last.animation, animation);\n    entry.mixBlend = MixBlend.replace;\n    return entry;\n  }\n  disposeNext(entry) {\n    let next = entry.next;\n    while (next != null) {\n      this.queue.dispose(next);\n      next = next.next;\n    }\n    entry.next = null;\n  }\n  _animationsChanged() {\n    this.animationsChanged = false;\n    this.propertyIDs.clear();\n    for (let i = 0, n = this.tracks.length; i < n; i++) {\n      let entry = this.tracks[i];\n      if (entry == null)\n        continue;\n      while (entry.mixingFrom != null)\n        entry = entry.mixingFrom;\n      do {\n        if (entry.mixingFrom == null || entry.mixBlend != MixBlend.add)\n          this.computeHold(entry);\n        entry = entry.mixingTo;\n      } while (entry != null);\n    }\n  }\n  computeHold(entry) {\n    const to = entry.mixingTo;\n    const timelines = entry.animation.timelines;\n    const timelinesCount = entry.animation.timelines.length;\n    const timelineMode = Utils.setArraySize(entry.timelineMode, timelinesCount);\n    entry.timelineHoldMix.length = 0;\n    const timelineDipMix = Utils.setArraySize(entry.timelineHoldMix, timelinesCount);\n    const propertyIDs = this.propertyIDs;\n    if (to != null && to.holdPrevious) {\n      for (let i = 0; i < timelinesCount; i++) {\n        timelineMode[i] = propertyIDs.add(timelines[i].getPropertyId()) ? _AnimationState.HOLD_FIRST : _AnimationState.HOLD_SUBSEQUENT;\n      }\n      return;\n    }\n    outer:\n      for (let i = 0; i < timelinesCount; i++) {\n        const timeline = timelines[i];\n        const id = timeline.getPropertyId();\n        if (!propertyIDs.add(id))\n          timelineMode[i] = _AnimationState.SUBSEQUENT;\n        else if (to == null || timeline instanceof AttachmentTimeline || timeline instanceof DrawOrderTimeline || timeline instanceof EventTimeline || !to.animation.hasTimeline(id)) {\n          timelineMode[i] = _AnimationState.FIRST;\n        } else {\n          for (let next = to.mixingTo; next != null; next = next.mixingTo) {\n            if (next.animation.hasTimeline(id))\n              continue;\n            if (entry.mixDuration > 0) {\n              timelineMode[i] = _AnimationState.HOLD_MIX;\n              timelineDipMix[i] = next;\n              continue outer;\n            }\n            break;\n          }\n          timelineMode[i] = _AnimationState.HOLD_FIRST;\n        }\n      }\n  }\n  /** Returns the track entry for the animation currently playing on the track, or null if no animation is currently playing. */\n  getCurrent(trackIndex) {\n    if (trackIndex >= this.tracks.length)\n      return null;\n    return this.tracks[trackIndex];\n  }\n  /** Adds a listener to receive events for all track entries. */\n  addListener(listener) {\n    if (listener == null)\n      throw new Error(\"listener cannot be null.\");\n    this.listeners.push(listener);\n  }\n  /** Removes the listener added with {@link #addListener()}. */\n  removeListener(listener) {\n    const index = this.listeners.indexOf(listener);\n    if (index >= 0)\n      this.listeners.splice(index, 1);\n  }\n  /** Removes all listeners added with {@link #addListener()}. */\n  clearListeners() {\n    this.listeners.length = 0;\n  }\n  /** Discards all listener notifications that have not yet been delivered. This can be useful to call from an\n   * {@link AnimationStateListener} when it is known that further notifications that may have been already queued for delivery\n   * are not wanted because new animations are being set. */\n  clearListenerNotifications() {\n    this.queue.clear();\n  }\n  setAnimationByName(trackIndex, animationName, loop) {\n    if (!_AnimationState.deprecatedWarning1) {\n      _AnimationState.deprecatedWarning1 = true;\n      console.warn(\"Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.\");\n    }\n    this.setAnimation(trackIndex, animationName, loop);\n  }\n  addAnimationByName(trackIndex, animationName, loop, delay) {\n    if (!_AnimationState.deprecatedWarning2) {\n      _AnimationState.deprecatedWarning2 = true;\n      console.warn(\"Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.\");\n    }\n    this.addAnimation(trackIndex, animationName, loop, delay);\n  }\n  hasAnimation(animationName) {\n    const animation = this.data.skeletonData.findAnimation(animationName);\n    return animation !== null;\n  }\n  hasAnimationByName(animationName) {\n    if (!_AnimationState.deprecatedWarning3) {\n      _AnimationState.deprecatedWarning3 = true;\n      console.warn(\"Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.\");\n    }\n    return this.hasAnimation(animationName);\n  }\n};\nlet AnimationState = _AnimationState;\nAnimationState.emptyAnimation = new Animation(\"<empty>\", [], 0);\n/** 1. A previously applied timeline has set this property.\n *\n * Result: Mix from the current pose to the timeline pose. */\nAnimationState.SUBSEQUENT = 0;\n/** 1. This is the first timeline to set this property.\n * 2. The next track entry applied after this one does not have a timeline to set this property.\n *\n * Result: Mix from the setup pose to the timeline pose. */\nAnimationState.FIRST = 1;\n/** 1) A previously applied timeline has set this property.<br>\n * 2) The next track entry to be applied does have a timeline to set this property.<br>\n * 3) The next track entry after that one does not have a timeline to set this property.<br>\n * Result: Mix from the current pose to the timeline pose, but do not mix out. This avoids \"dipping\" when crossfading\n * animations that key the same property. A subsequent timeline will set this property using a mix. */\nAnimationState.HOLD_SUBSEQUENT = 2;\n/** 1) This is the first timeline to set this property.<br>\n * 2) The next track entry to be applied does have a timeline to set this property.<br>\n * 3) The next track entry after that one does not have a timeline to set this property.<br>\n * Result: Mix from the setup pose to the timeline pose, but do not mix out. This avoids \"dipping\" when crossfading animations\n * that key the same property. A subsequent timeline will set this property using a mix. */\nAnimationState.HOLD_FIRST = 3;\n/** 1. This is the first timeline to set this property.\n * 2. The next track entry to be applied does have a timeline to set this property.\n * 3. The next track entry after that one does have a timeline to set this property.\n * 4. timelineHoldMix stores the first subsequent track entry that does not have a timeline to set this property.\n *\n * Result: The same as HOLD except the mix percentage from the timelineHoldMix track entry is used. This handles when more than\n * 2 track entries in a row have a timeline that sets the same property.\n *\n * Eg, A -> B -> C -> D where A, B, and C have a timeline setting same property, but D does not. When A is applied, to avoid\n * \"dipping\" A is not mixed out, however D (the first entry that doesn't set the property) mixing in is used to mix out A\n * (which affects B and C). Without using D to mix out, A would be applied fully until mixing completes, then snap into\n * place. */\nAnimationState.HOLD_MIX = 4;\nAnimationState.SETUP = 1;\nAnimationState.CURRENT = 2;\nAnimationState.deprecatedWarning1 = false;\nAnimationState.deprecatedWarning2 = false;\nAnimationState.deprecatedWarning3 = false;\nconst _TrackEntry = class {\n  constructor() {\n    /** Controls how properties keyed in the animation are mixed with lower tracks. Defaults to {@link MixBlend#replace}, which\n     * replaces the values from the lower tracks with the animation values. {@link MixBlend#add} adds the animation values to\n     * the values from the lower tracks.\n     *\n     * The `mixBlend` can be set for a new track entry only before {@link AnimationState#apply()} is first\n     * called. */\n    this.mixBlend = MixBlend.replace;\n    this.timelineMode = new Array();\n    this.timelineHoldMix = new Array();\n    this.timelinesRotation = new Array();\n  }\n  reset() {\n    this.next = null;\n    this.mixingFrom = null;\n    this.mixingTo = null;\n    this.animation = null;\n    this.listener = null;\n    this.timelineMode.length = 0;\n    this.timelineHoldMix.length = 0;\n    this.timelinesRotation.length = 0;\n  }\n  /** Uses {@link #trackTime} to compute the `animationTime`, which is between {@link #animationStart}\n   * and {@link #animationEnd}. When the `trackTime` is 0, the `animationTime` is equal to the\n   * `animationStart` time. */\n  getAnimationTime() {\n    if (this.loop) {\n      const duration = this.animationEnd - this.animationStart;\n      if (duration == 0)\n        return this.animationStart;\n      return this.trackTime % duration + this.animationStart;\n    }\n    return Math.min(this.trackTime + this.animationStart, this.animationEnd);\n  }\n  setAnimationLast(animationLast) {\n    this.animationLast = animationLast;\n    this.nextAnimationLast = animationLast;\n  }\n  /** Returns true if at least one loop has been completed.\n   *\n   * See {@link AnimationStateListener#complete()}. */\n  isComplete() {\n    return this.trackTime >= this.animationEnd - this.animationStart;\n  }\n  /** Resets the rotation directions for mixing this entry's rotate timelines. This can be useful to avoid bones rotating the\n   * long way around when using {@link #alpha} and starting animations on other tracks.\n   *\n   * Mixing with {@link MixBlend#replace} involves finding a rotation between two others, which has two possible solutions:\n   * the short way or the long way around. The two rotations likely change over time, so which direction is the short or long\n   * way also changes. If the short way was always chosen, bones would flip to the other side when that direction became the\n   * long way. TrackEntry chooses the short way the first time it is applied and remembers that direction. */\n  resetRotationDirections() {\n    this.timelinesRotation.length = 0;\n  }\n  get time() {\n    if (!_TrackEntry.deprecatedWarning1) {\n      _TrackEntry.deprecatedWarning1 = true;\n      console.warn(\"Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.\");\n    }\n    return this.trackTime;\n  }\n  set time(value) {\n    if (!_TrackEntry.deprecatedWarning1) {\n      _TrackEntry.deprecatedWarning1 = true;\n      console.warn(\"Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.\");\n    }\n    this.trackTime = value;\n  }\n  get endTime() {\n    if (!_TrackEntry.deprecatedWarning2) {\n      _TrackEntry.deprecatedWarning2 = true;\n      console.warn(\"Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.\");\n    }\n    return this.trackTime;\n  }\n  set endTime(value) {\n    if (!_TrackEntry.deprecatedWarning2) {\n      _TrackEntry.deprecatedWarning2 = true;\n      console.warn(\"Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.\");\n    }\n    this.trackTime = value;\n  }\n  loopsCount() {\n    return Math.floor(this.trackTime / this.trackEnd);\n  }\n};\nlet TrackEntry = _TrackEntry;\nTrackEntry.deprecatedWarning1 = false;\nTrackEntry.deprecatedWarning2 = false;\nconst _EventQueue = class {\n  constructor(animState) {\n    this.objects = [];\n    this.drainDisabled = false;\n    this.animState = animState;\n  }\n  start(entry) {\n    this.objects.push(EventType.start);\n    this.objects.push(entry);\n    this.animState.animationsChanged = true;\n  }\n  interrupt(entry) {\n    this.objects.push(EventType.interrupt);\n    this.objects.push(entry);\n  }\n  end(entry) {\n    this.objects.push(EventType.end);\n    this.objects.push(entry);\n    this.animState.animationsChanged = true;\n  }\n  dispose(entry) {\n    this.objects.push(EventType.dispose);\n    this.objects.push(entry);\n  }\n  complete(entry) {\n    this.objects.push(EventType.complete);\n    this.objects.push(entry);\n  }\n  event(entry, event) {\n    this.objects.push(EventType.event);\n    this.objects.push(entry);\n    this.objects.push(event);\n  }\n  deprecateStuff() {\n    if (!_EventQueue.deprecatedWarning1) {\n      _EventQueue.deprecatedWarning1 = true;\n      console.warn(\n        \"Spine Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'\"\n      );\n    }\n    return true;\n  }\n  drain() {\n    if (this.drainDisabled)\n      return;\n    this.drainDisabled = true;\n    const objects = this.objects;\n    const listeners = this.animState.listeners;\n    for (let i = 0; i < objects.length; i += 2) {\n      const type = objects[i];\n      const entry = objects[i + 1];\n      switch (type) {\n        case EventType.start:\n          if (entry.listener != null && entry.listener.start)\n            entry.listener.start(entry);\n          for (let ii = 0; ii < listeners.length; ii++)\n            if (listeners[ii].start)\n              listeners[ii].start(entry);\n          entry.onStart && this.deprecateStuff() && entry.onStart(entry.trackIndex);\n          this.animState.onStart && this.deprecateStuff() && this.deprecateStuff && this.animState.onStart(entry.trackIndex);\n          break;\n        case EventType.interrupt:\n          if (entry.listener != null && entry.listener.interrupt)\n            entry.listener.interrupt(entry);\n          for (let ii = 0; ii < listeners.length; ii++)\n            if (listeners[ii].interrupt)\n              listeners[ii].interrupt(entry);\n          break;\n        case EventType.end:\n          if (entry.listener != null && entry.listener.end)\n            entry.listener.end(entry);\n          for (let ii = 0; ii < listeners.length; ii++)\n            if (listeners[ii].end)\n              listeners[ii].end(entry);\n          entry.onEnd && this.deprecateStuff() && entry.onEnd(entry.trackIndex);\n          this.animState.onEnd && this.deprecateStuff() && this.animState.onEnd(entry.trackIndex);\n        case EventType.dispose:\n          if (entry.listener != null && entry.listener.dispose)\n            entry.listener.dispose(entry);\n          for (let ii = 0; ii < listeners.length; ii++)\n            if (listeners[ii].dispose)\n              listeners[ii].dispose(entry);\n          this.animState.trackEntryPool.free(entry);\n          break;\n        case EventType.complete:\n          if (entry.listener != null && entry.listener.complete)\n            entry.listener.complete(entry);\n          for (let ii = 0; ii < listeners.length; ii++)\n            if (listeners[ii].complete)\n              listeners[ii].complete(entry);\n          const count = MathUtils.toInt(entry.loopsCount());\n          entry.onComplete && this.deprecateStuff() && entry.onComplete(entry.trackIndex, count);\n          this.animState.onComplete && this.deprecateStuff() && this.animState.onComplete(entry.trackIndex, count);\n          break;\n        case EventType.event:\n          const event = objects[i++ + 2];\n          if (entry.listener != null && entry.listener.event)\n            entry.listener.event(entry, event);\n          for (let ii = 0; ii < listeners.length; ii++)\n            if (listeners[ii].event)\n              listeners[ii].event(entry, event);\n          entry.onEvent && this.deprecateStuff() && entry.onEvent(entry.trackIndex, event);\n          this.animState.onEvent && this.deprecateStuff() && this.animState.onEvent(entry.trackIndex, event);\n          break;\n      }\n    }\n    this.clear();\n    this.drainDisabled = false;\n  }\n  clear() {\n    this.objects.length = 0;\n  }\n};\nlet EventQueue = _EventQueue;\nEventQueue.deprecatedWarning1 = false;\nvar EventType = /* @__PURE__ */ ((EventType2) => {\n  EventType2[EventType2[\"start\"] = 0] = \"start\";\n  EventType2[EventType2[\"interrupt\"] = 1] = \"interrupt\";\n  EventType2[EventType2[\"end\"] = 2] = \"end\";\n  EventType2[EventType2[\"dispose\"] = 3] = \"dispose\";\n  EventType2[EventType2[\"complete\"] = 4] = \"complete\";\n  EventType2[EventType2[\"event\"] = 5] = \"event\";\n  return EventType2;\n})(EventType || {});\nclass AnimationStateAdapter {\n  start(entry) {\n  }\n  interrupt(entry) {\n  }\n  end(entry) {\n  }\n  dispose(entry) {\n  }\n  complete(entry) {\n  }\n  event(entry, event) {\n  }\n}\n\nexport { AnimationState, AnimationStateAdapter, EventQueue, EventType, TrackEntry };\n//# sourceMappingURL=AnimationState.mjs.map\n","const _AnimationStateData = class {\n  constructor(skeletonData) {\n    this.animationToMixTime = {};\n    this.defaultMix = 0;\n    if (skeletonData == null)\n      throw new Error(\"skeletonData cannot be null.\");\n    this.skeletonData = skeletonData;\n  }\n  setMix(fromName, toName, duration) {\n    const from = this.skeletonData.findAnimation(fromName);\n    if (from == null)\n      throw new Error(`Animation not found: ${fromName}`);\n    const to = this.skeletonData.findAnimation(toName);\n    if (to == null)\n      throw new Error(`Animation not found: ${toName}`);\n    this.setMixWith(from, to, duration);\n  }\n  setMixByName(fromName, toName, duration) {\n    if (!_AnimationStateData.deprecatedWarning1) {\n      _AnimationStateData.deprecatedWarning1 = true;\n      console.warn(\"Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.\");\n    }\n    this.setMix(fromName, toName, duration);\n  }\n  setMixWith(from, to, duration) {\n    if (from == null)\n      throw new Error(\"from cannot be null.\");\n    if (to == null)\n      throw new Error(\"to cannot be null.\");\n    const key = `${from.name}.${to.name}`;\n    this.animationToMixTime[key] = duration;\n  }\n  getMix(from, to) {\n    const key = `${from.name}.${to.name}`;\n    const value = this.animationToMixTime[key];\n    return value === void 0 ? this.defaultMix : value;\n  }\n};\nlet AnimationStateData = _AnimationStateData;\nAnimationStateData.deprecatedWarning1 = false;\n\nexport { AnimationStateData };\n//# sourceMappingURL=AnimationStateData.mjs.map\n","import './attachments/Attachment.mjs';\nimport { BoundingBoxAttachment } from './attachments/BoundingBoxAttachment.mjs';\nimport { ClippingAttachment } from './attachments/ClippingAttachment.mjs';\nimport { MeshAttachment } from './attachments/MeshAttachment.mjs';\nimport { PathAttachment } from './attachments/PathAttachment.mjs';\nimport { PointAttachment } from './attachments/PointAttachment.mjs';\nimport { RegionAttachment } from './attachments/RegionAttachment.mjs';\n\nclass AtlasAttachmentLoader {\n  constructor(atlas) {\n    this.atlas = atlas;\n  }\n  /** @return May be null to not load an attachment. */\n  newRegionAttachment(skin, name, path) {\n    const region = this.atlas.findRegion(path);\n    if (region == null)\n      throw new Error(`Region not found in atlas: ${path} (region attachment: ${name})`);\n    const attachment = new RegionAttachment(name);\n    attachment.region = region;\n    return attachment;\n  }\n  /** @return May be null to not load an attachment. */\n  newMeshAttachment(skin, name, path) {\n    const region = this.atlas.findRegion(path);\n    if (region == null)\n      throw new Error(`Region not found in atlas: ${path} (mesh attachment: ${name})`);\n    const attachment = new MeshAttachment(name);\n    attachment.region = region;\n    return attachment;\n  }\n  /** @return May be null to not load an attachment. */\n  newBoundingBoxAttachment(skin, name) {\n    return new BoundingBoxAttachment(name);\n  }\n  /** @return May be null to not load an attachment */\n  newPathAttachment(skin, name) {\n    return new PathAttachment(name);\n  }\n  newPointAttachment(skin, name) {\n    return new PointAttachment(name);\n  }\n  newClippingAttachment(skin, name) {\n    return new ClippingAttachment(name);\n  }\n}\n\nexport { AtlasAttachmentLoader };\n//# sourceMappingURL=AtlasAttachmentLoader.mjs.map\n","import { Matrix } from '@pixi/core';\nimport { settings, MathUtils, TransformMode } from '@pixi-spine/base';\n\nclass Bone {\n  /** @param parent May be null. */\n  constructor(data, skeleton, parent) {\n    // be careful! Spine b,c is c,b in pixi matrix\n    this.matrix = new Matrix();\n    this.children = new Array();\n    this.x = 0;\n    this.y = 0;\n    this.rotation = 0;\n    this.scaleX = 0;\n    this.scaleY = 0;\n    this.shearX = 0;\n    this.shearY = 0;\n    this.ax = 0;\n    this.ay = 0;\n    this.arotation = 0;\n    this.ascaleX = 0;\n    this.ascaleY = 0;\n    this.ashearX = 0;\n    this.ashearY = 0;\n    this.appliedValid = false;\n    this.sorted = false;\n    this.active = false;\n    if (data == null)\n      throw new Error(\"data cannot be null.\");\n    if (skeleton == null)\n      throw new Error(\"skeleton cannot be null.\");\n    this.data = data;\n    this.skeleton = skeleton;\n    this.parent = parent;\n    this.setToSetupPose();\n  }\n  get worldX() {\n    return this.matrix.tx;\n  }\n  get worldY() {\n    return this.matrix.ty;\n  }\n  isActive() {\n    return this.active;\n  }\n  /** Same as {@link #updateWorldTransform()}. This method exists for Bone to implement {@link Updatable}. */\n  update() {\n    this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\n  }\n  /** Computes the world transform using the parent bone and this bone's local transform. */\n  updateWorldTransform() {\n    this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\n  }\n  /** Computes the world transform using the parent bone and the specified local transform. */\n  updateWorldTransformWith(x, y, rotation, scaleX, scaleY, shearX, shearY) {\n    this.ax = x;\n    this.ay = y;\n    this.arotation = rotation;\n    this.ascaleX = scaleX;\n    this.ascaleY = scaleY;\n    this.ashearX = shearX;\n    this.ashearY = shearY;\n    this.appliedValid = true;\n    const parent = this.parent;\n    const m = this.matrix;\n    const sx = this.skeleton.scaleX;\n    const sy = settings.yDown ? -this.skeleton.scaleY : this.skeleton.scaleY;\n    if (parent == null) {\n      const skeleton = this.skeleton;\n      const rotationY = rotation + 90 + shearY;\n      m.a = MathUtils.cosDeg(rotation + shearX) * scaleX * sx;\n      m.c = MathUtils.cosDeg(rotationY) * scaleY * sx;\n      m.b = MathUtils.sinDeg(rotation + shearX) * scaleX * sy;\n      m.d = MathUtils.sinDeg(rotationY) * scaleY * sy;\n      m.tx = x * sx + skeleton.x;\n      m.ty = y * sy + skeleton.y;\n      return;\n    }\n    let pa = parent.matrix.a;\n    let pb = parent.matrix.c;\n    let pc = parent.matrix.b;\n    let pd = parent.matrix.d;\n    m.tx = pa * x + pb * y + parent.matrix.tx;\n    m.ty = pc * x + pd * y + parent.matrix.ty;\n    switch (this.data.transformMode) {\n      case TransformMode.Normal: {\n        const rotationY = rotation + 90 + shearY;\n        const la = MathUtils.cosDeg(rotation + shearX) * scaleX;\n        const lb = MathUtils.cosDeg(rotationY) * scaleY;\n        const lc = MathUtils.sinDeg(rotation + shearX) * scaleX;\n        const ld = MathUtils.sinDeg(rotationY) * scaleY;\n        m.a = pa * la + pb * lc;\n        m.c = pa * lb + pb * ld;\n        m.b = pc * la + pd * lc;\n        m.d = pc * lb + pd * ld;\n        return;\n      }\n      case TransformMode.OnlyTranslation: {\n        const rotationY = rotation + 90 + shearY;\n        m.a = MathUtils.cosDeg(rotation + shearX) * scaleX;\n        m.c = MathUtils.cosDeg(rotationY) * scaleY;\n        m.b = MathUtils.sinDeg(rotation + shearX) * scaleX;\n        m.d = MathUtils.sinDeg(rotationY) * scaleY;\n        break;\n      }\n      case TransformMode.NoRotationOrReflection: {\n        let s = pa * pa + pc * pc;\n        let prx = 0;\n        if (s > 1e-4) {\n          s = Math.abs(pa * pd - pb * pc) / s;\n          pa /= this.skeleton.scaleX;\n          pc /= this.skeleton.scaleY;\n          pb = pc * s;\n          pd = pa * s;\n          prx = Math.atan2(pc, pa) * MathUtils.radDeg;\n        } else {\n          pa = 0;\n          pc = 0;\n          prx = 90 - Math.atan2(pd, pb) * MathUtils.radDeg;\n        }\n        const rx = rotation + shearX - prx;\n        const ry = rotation + shearY - prx + 90;\n        const la = MathUtils.cosDeg(rx) * scaleX;\n        const lb = MathUtils.cosDeg(ry) * scaleY;\n        const lc = MathUtils.sinDeg(rx) * scaleX;\n        const ld = MathUtils.sinDeg(ry) * scaleY;\n        m.a = pa * la - pb * lc;\n        m.c = pa * lb - pb * ld;\n        m.b = pc * la + pd * lc;\n        m.d = pc * lb + pd * ld;\n        break;\n      }\n      case TransformMode.NoScale:\n      case TransformMode.NoScaleOrReflection: {\n        const cos = MathUtils.cosDeg(rotation);\n        const sin = MathUtils.sinDeg(rotation);\n        let za = (pa * cos + pb * sin) / sx;\n        let zc = (pc * cos + pd * sin) / sy;\n        let s = Math.sqrt(za * za + zc * zc);\n        if (s > 1e-5)\n          s = 1 / s;\n        za *= s;\n        zc *= s;\n        s = Math.sqrt(za * za + zc * zc);\n        if (this.data.transformMode == TransformMode.NoScale && pa * pd - pb * pc < 0 != (settings.yDown ? this.skeleton.scaleX < 0 != this.skeleton.scaleY > 0 : this.skeleton.scaleX < 0 != this.skeleton.scaleY < 0))\n          s = -s;\n        const r = Math.PI / 2 + Math.atan2(zc, za);\n        const zb = Math.cos(r) * s;\n        const zd = Math.sin(r) * s;\n        const la = MathUtils.cosDeg(shearX) * scaleX;\n        const lb = MathUtils.cosDeg(90 + shearY) * scaleY;\n        const lc = MathUtils.sinDeg(shearX) * scaleX;\n        const ld = MathUtils.sinDeg(90 + shearY) * scaleY;\n        m.a = za * la + zb * lc;\n        m.c = za * lb + zb * ld;\n        m.b = zc * la + zd * lc;\n        m.d = zc * lb + zd * ld;\n        break;\n      }\n    }\n    m.a *= sx;\n    m.c *= sx;\n    m.b *= sy;\n    m.d *= sy;\n  }\n  setToSetupPose() {\n    const data = this.data;\n    this.x = data.x;\n    this.y = data.y;\n    this.rotation = data.rotation;\n    this.scaleX = data.scaleX;\n    this.scaleY = data.scaleY;\n    this.shearX = data.shearX;\n    this.shearY = data.shearY;\n  }\n  getWorldRotationX() {\n    return Math.atan2(this.matrix.b, this.matrix.a) * MathUtils.radDeg;\n  }\n  getWorldRotationY() {\n    return Math.atan2(this.matrix.d, this.matrix.c) * MathUtils.radDeg;\n  }\n  getWorldScaleX() {\n    const m = this.matrix;\n    return Math.sqrt(m.a * m.a + m.c * m.c);\n  }\n  getWorldScaleY() {\n    const m = this.matrix;\n    return Math.sqrt(m.b * m.b + m.d * m.d);\n  }\n  /** Computes the individual applied transform values from the world transform. This can be useful to perform processing using\n   * the applied transform after the world transform has been modified directly (eg, by a constraint).\n   * <p>\n   * Some information is ambiguous in the world transform, such as -1,-1 scale versus 180 rotation. */\n  updateAppliedTransform() {\n    this.appliedValid = true;\n    const parent = this.parent;\n    const m = this.matrix;\n    if (parent == null) {\n      this.ax = m.tx;\n      this.ay = m.ty;\n      this.arotation = Math.atan2(m.b, m.a) * MathUtils.radDeg;\n      this.ascaleX = Math.sqrt(m.a * m.a + m.b * m.b);\n      this.ascaleY = Math.sqrt(m.c * m.c + m.d * m.d);\n      this.ashearX = 0;\n      this.ashearY = Math.atan2(m.a * m.c + m.b * m.d, m.a * m.d - m.b * m.c) * MathUtils.radDeg;\n      return;\n    }\n    const pm = parent.matrix;\n    const pid = 1 / (pm.a * pm.d - pm.b * pm.c);\n    const dx = m.tx - pm.tx;\n    const dy = m.ty - pm.ty;\n    this.ax = dx * pm.d * pid - dy * pm.c * pid;\n    this.ay = dy * pm.a * pid - dx * pm.b * pid;\n    const ia = pid * pm.d;\n    const id = pid * pm.a;\n    const ib = pid * pm.c;\n    const ic = pid * pm.b;\n    const ra = ia * m.a - ib * m.b;\n    const rb = ia * m.c - ib * m.d;\n    const rc = id * m.b - ic * m.a;\n    const rd = id * m.d - ic * m.c;\n    this.ashearX = 0;\n    this.ascaleX = Math.sqrt(ra * ra + rc * rc);\n    if (this.ascaleX > 1e-4) {\n      const det = ra * rd - rb * rc;\n      this.ascaleY = det / this.ascaleX;\n      this.ashearY = Math.atan2(ra * rb + rc * rd, det) * MathUtils.radDeg;\n      this.arotation = Math.atan2(rc, ra) * MathUtils.radDeg;\n    } else {\n      this.ascaleX = 0;\n      this.ascaleY = Math.sqrt(rb * rb + rd * rd);\n      this.ashearY = 0;\n      this.arotation = 90 - Math.atan2(rd, rb) * MathUtils.radDeg;\n    }\n  }\n  worldToLocal(world) {\n    const m = this.matrix;\n    const a = m.a;\n    const b = m.c;\n    const c = m.b;\n    const d = m.d;\n    const invDet = 1 / (a * d - b * c);\n    const x = world.x - m.tx;\n    const y = world.y - m.ty;\n    world.x = x * d * invDet - y * b * invDet;\n    world.y = y * a * invDet - x * c * invDet;\n    return world;\n  }\n  localToWorld(local) {\n    const m = this.matrix;\n    const x = local.x;\n    const y = local.y;\n    local.x = x * m.a + y * m.c + m.tx;\n    local.y = x * m.b + y * m.d + m.ty;\n    return local;\n  }\n  worldToLocalRotation(worldRotation) {\n    const sin = MathUtils.sinDeg(worldRotation);\n    const cos = MathUtils.cosDeg(worldRotation);\n    const mat = this.matrix;\n    return Math.atan2(mat.a * sin - mat.b * cos, mat.d * cos - mat.c * sin) * MathUtils.radDeg;\n  }\n  localToWorldRotation(localRotation) {\n    const sin = MathUtils.sinDeg(localRotation);\n    const cos = MathUtils.cosDeg(localRotation);\n    const mat = this.matrix;\n    return Math.atan2(cos * mat.b + sin * mat.d, cos * mat.a + sin * mat.c) * MathUtils.radDeg;\n  }\n  rotateWorld(degrees) {\n    const mat = this.matrix;\n    const a = mat.a;\n    const b = mat.c;\n    const c = mat.b;\n    const d = mat.d;\n    const cos = MathUtils.cosDeg(degrees);\n    const sin = MathUtils.sinDeg(degrees);\n    mat.a = cos * a - sin * c;\n    mat.c = cos * b - sin * d;\n    mat.b = sin * a + cos * c;\n    mat.d = sin * b + cos * d;\n    this.appliedValid = false;\n  }\n}\n\nexport { Bone };\n//# sourceMappingURL=Bone.mjs.map\n","import { TransformMode, Color } from '@pixi-spine/base';\n\nclass BoneData {\n  constructor(index, name, parent) {\n    this.x = 0;\n    this.y = 0;\n    this.rotation = 0;\n    this.scaleX = 1;\n    this.scaleY = 1;\n    this.shearX = 0;\n    this.shearY = 0;\n    this.transformMode = TransformMode.Normal;\n    this.skinRequired = false;\n    this.color = new Color();\n    if (index < 0)\n      throw new Error(\"index must be >= 0.\");\n    if (name == null)\n      throw new Error(\"name cannot be null.\");\n    this.index = index;\n    this.name = name;\n    this.parent = parent;\n  }\n}\n\nexport { BoneData };\n//# sourceMappingURL=BoneData.mjs.map\n","class ConstraintData {\n  constructor(name, order, skinRequired) {\n    this.name = name;\n    this.order = order;\n    this.skinRequired = skinRequired;\n  }\n}\n\nexport { ConstraintData };\n//# sourceMappingURL=Constraint.mjs.map\n","class Event {\n  constructor(time, data) {\n    if (data == null)\n      throw new Error(\"data cannot be null.\");\n    this.time = time;\n    this.data = data;\n  }\n}\n\nexport { Event };\n//# sourceMappingURL=Event.mjs.map\n","class EventData {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\nexport { EventData };\n//# sourceMappingURL=EventData.mjs.map\n","import { TransformMode, MathUtils } from '@pixi-spine/base';\n\nclass IkConstraint {\n  constructor(data, skeleton) {\n    this.bendDirection = 0;\n    this.compress = false;\n    this.stretch = false;\n    this.mix = 1;\n    this.softness = 0;\n    this.active = false;\n    if (data == null)\n      throw new Error(\"data cannot be null.\");\n    if (skeleton == null)\n      throw new Error(\"skeleton cannot be null.\");\n    this.data = data;\n    this.mix = data.mix;\n    this.softness = data.softness;\n    this.bendDirection = data.bendDirection;\n    this.compress = data.compress;\n    this.stretch = data.stretch;\n    this.bones = new Array();\n    for (let i = 0; i < data.bones.length; i++)\n      this.bones.push(skeleton.findBone(data.bones[i].name));\n    this.target = skeleton.findBone(data.target.name);\n  }\n  isActive() {\n    return this.active;\n  }\n  apply() {\n    this.update();\n  }\n  update() {\n    const target = this.target;\n    const bones = this.bones;\n    switch (bones.length) {\n      case 1:\n        this.apply1(bones[0], target.worldX, target.worldY, this.compress, this.stretch, this.data.uniform, this.mix);\n        break;\n      case 2:\n        this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.stretch, this.softness, this.mix);\n        break;\n    }\n  }\n  /** Adjusts the bone rotation so the tip is as close to the target position as possible. The target is specified in the world\n   * coordinate system. */\n  apply1(bone, targetX, targetY, compress, stretch, uniform, alpha) {\n    if (!bone.appliedValid)\n      bone.updateAppliedTransform();\n    const p = bone.parent.matrix;\n    const pa = p.a;\n    let pb = p.c;\n    const pc = p.b;\n    let pd = p.d;\n    let rotationIK = -bone.ashearX - bone.arotation;\n    let tx = 0;\n    let ty = 0;\n    switch (bone.data.transformMode) {\n      case TransformMode.OnlyTranslation:\n        tx = targetX - bone.worldX;\n        ty = targetY - bone.worldY;\n        break;\n      case TransformMode.NoRotationOrReflection:\n        const s = Math.abs(pa * pd - pb * pc) / (pa * pa + pc * pc);\n        const sa = pa / bone.skeleton.scaleX;\n        const sc = pc / bone.skeleton.scaleY;\n        pb = -sc * s * bone.skeleton.scaleX;\n        pd = sa * s * bone.skeleton.scaleY;\n        rotationIK += Math.atan2(sc, sa) * MathUtils.radDeg;\n      default:\n        const x = targetX - p.tx;\n        const y = targetY - p.ty;\n        const d = pa * pd - pb * pc;\n        tx = (x * pd - y * pb) / d - bone.ax;\n        ty = (y * pa - x * pc) / d - bone.ay;\n    }\n    rotationIK += Math.atan2(ty, tx) * MathUtils.radDeg;\n    if (bone.ascaleX < 0)\n      rotationIK += 180;\n    if (rotationIK > 180)\n      rotationIK -= 360;\n    else if (rotationIK < -180)\n      rotationIK += 360;\n    let sx = bone.ascaleX;\n    let sy = bone.ascaleY;\n    if (compress || stretch) {\n      switch (bone.data.transformMode) {\n        case TransformMode.NoScale:\n        case TransformMode.NoScaleOrReflection:\n          tx = targetX - bone.worldX;\n          ty = targetY - bone.worldY;\n      }\n      const b = bone.data.length * sx;\n      const dd = Math.sqrt(tx * tx + ty * ty);\n      if (compress && dd < b || stretch && dd > b && b > 1e-4) {\n        const s = (dd / b - 1) * alpha + 1;\n        sx *= s;\n        if (uniform)\n          sy *= s;\n      }\n    }\n    bone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, sx, sy, bone.ashearX, bone.ashearY);\n  }\n  /** Adjusts the parent and child bone rotations so the tip of the child is as close to the target position as possible. The\n   * target is specified in the world coordinate system.\n   * @param child A direct descendant of the parent bone. */\n  apply2(parent, child, targetX, targetY, bendDir, stretch, softness, alpha) {\n    if (alpha == 0) {\n      child.updateWorldTransform();\n      return;\n    }\n    if (!parent.appliedValid)\n      parent.updateAppliedTransform();\n    if (!child.appliedValid)\n      child.updateAppliedTransform();\n    const px = parent.ax;\n    const py = parent.ay;\n    let psx = parent.ascaleX;\n    let sx = psx;\n    let psy = parent.ascaleY;\n    let csx = child.ascaleX;\n    const pmat = parent.matrix;\n    let os1 = 0;\n    let os2 = 0;\n    let s2 = 0;\n    if (psx < 0) {\n      psx = -psx;\n      os1 = 180;\n      s2 = -1;\n    } else {\n      os1 = 0;\n      s2 = 1;\n    }\n    if (psy < 0) {\n      psy = -psy;\n      s2 = -s2;\n    }\n    if (csx < 0) {\n      csx = -csx;\n      os2 = 180;\n    } else\n      os2 = 0;\n    const cx = child.ax;\n    let cy = 0;\n    let cwx = 0;\n    let cwy = 0;\n    let a = pmat.a;\n    let b = pmat.c;\n    let c = pmat.b;\n    let d = pmat.d;\n    const u = Math.abs(psx - psy) <= 1e-4;\n    if (!u) {\n      cy = 0;\n      cwx = a * cx + pmat.tx;\n      cwy = c * cx + pmat.ty;\n    } else {\n      cy = child.ay;\n      cwx = a * cx + b * cy + pmat.tx;\n      cwy = c * cx + d * cy + pmat.ty;\n    }\n    const pp = parent.parent.matrix;\n    a = pp.a;\n    b = pp.c;\n    c = pp.b;\n    d = pp.d;\n    const id = 1 / (a * d - b * c);\n    let x = cwx - pp.tx;\n    let y = cwy - pp.ty;\n    const dx = (x * d - y * b) * id - px;\n    const dy = (y * a - x * c) * id - py;\n    const l1 = Math.sqrt(dx * dx + dy * dy);\n    let l2 = child.data.length * csx;\n    let a1;\n    let a2;\n    if (l1 < 1e-4) {\n      this.apply1(parent, targetX, targetY, false, stretch, false, alpha);\n      child.updateWorldTransformWith(cx, cy, 0, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\n      return;\n    }\n    x = targetX - pp.tx;\n    y = targetY - pp.ty;\n    let tx = (x * d - y * b) * id - px;\n    let ty = (y * a - x * c) * id - py;\n    let dd = tx * tx + ty * ty;\n    if (softness != 0) {\n      softness *= psx * (csx + 1) / 2;\n      const td = Math.sqrt(dd);\n      const sd = td - l1 - l2 * psx + softness;\n      if (sd > 0) {\n        let p = Math.min(1, sd / (softness * 2)) - 1;\n        p = (sd - softness * (1 - p * p)) / td;\n        tx -= p * tx;\n        ty -= p * ty;\n        dd = tx * tx + ty * ty;\n      }\n    }\n    outer:\n      if (u) {\n        l2 *= psx;\n        let cos = (dd - l1 * l1 - l2 * l2) / (2 * l1 * l2);\n        if (cos < -1)\n          cos = -1;\n        else if (cos > 1) {\n          cos = 1;\n          if (stretch)\n            sx *= (Math.sqrt(dd) / (l1 + l2) - 1) * alpha + 1;\n        }\n        a2 = Math.acos(cos) * bendDir;\n        a = l1 + l2 * cos;\n        b = l2 * Math.sin(a2);\n        a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);\n      } else {\n        a = psx * l2;\n        b = psy * l2;\n        const aa = a * a;\n        const bb = b * b;\n        const ta = Math.atan2(ty, tx);\n        c = bb * l1 * l1 + aa * dd - aa * bb;\n        const c1 = -2 * bb * l1;\n        const c2 = bb - aa;\n        d = c1 * c1 - 4 * c2 * c;\n        if (d >= 0) {\n          let q = Math.sqrt(d);\n          if (c1 < 0)\n            q = -q;\n          q = -(c1 + q) / 2;\n          const r0 = q / c2;\n          const r1 = c / q;\n          const r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;\n          if (r * r <= dd) {\n            y = Math.sqrt(dd - r * r) * bendDir;\n            a1 = ta - Math.atan2(y, r);\n            a2 = Math.atan2(y / psy, (r - l1) / psx);\n            break outer;\n          }\n        }\n        let minAngle = MathUtils.PI;\n        let minX = l1 - a;\n        let minDist = minX * minX;\n        let minY = 0;\n        let maxAngle = 0;\n        let maxX = l1 + a;\n        let maxDist = maxX * maxX;\n        let maxY = 0;\n        c = -a * l1 / (aa - bb);\n        if (c >= -1 && c <= 1) {\n          c = Math.acos(c);\n          x = a * Math.cos(c) + l1;\n          y = b * Math.sin(c);\n          d = x * x + y * y;\n          if (d < minDist) {\n            minAngle = c;\n            minDist = d;\n            minX = x;\n            minY = y;\n          }\n          if (d > maxDist) {\n            maxAngle = c;\n            maxDist = d;\n            maxX = x;\n            maxY = y;\n          }\n        }\n        if (dd <= (minDist + maxDist) / 2) {\n          a1 = ta - Math.atan2(minY * bendDir, minX);\n          a2 = minAngle * bendDir;\n        } else {\n          a1 = ta - Math.atan2(maxY * bendDir, maxX);\n          a2 = maxAngle * bendDir;\n        }\n      }\n    const os = Math.atan2(cy, cx) * s2;\n    let rotation = parent.arotation;\n    a1 = (a1 - os) * MathUtils.radDeg + os1 - rotation;\n    if (a1 > 180)\n      a1 -= 360;\n    else if (a1 < -180)\n      a1 += 360;\n    parent.updateWorldTransformWith(px, py, rotation + a1 * alpha, sx, parent.ascaleY, 0, 0);\n    rotation = child.arotation;\n    a2 = ((a2 + os) * MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;\n    if (a2 > 180)\n      a2 -= 360;\n    else if (a2 < -180)\n      a2 += 360;\n    child.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\n  }\n}\n\nexport { IkConstraint };\n//# sourceMappingURL=IkConstraint.mjs.map\n","import { ConstraintData } from './Constraint.mjs';\n\nclass IkConstraintData extends ConstraintData {\n  constructor(name) {\n    super(name, 0, false);\n    this.bones = new Array();\n    this.bendDirection = 1;\n    this.compress = false;\n    this.stretch = false;\n    this.uniform = false;\n    this.mix = 1;\n    this.softness = 0;\n  }\n}\n\nexport { IkConstraintData };\n//# sourceMappingURL=IkConstraintData.mjs.map\n","import { ConstraintData } from './Constraint.mjs';\n\nclass PathConstraintData extends ConstraintData {\n  constructor(name) {\n    super(name, 0, false);\n    this.bones = new Array();\n  }\n}\nvar SpacingMode = /* @__PURE__ */ ((SpacingMode2) => {\n  SpacingMode2[SpacingMode2[\"Length\"] = 0] = \"Length\";\n  SpacingMode2[SpacingMode2[\"Fixed\"] = 1] = \"Fixed\";\n  SpacingMode2[SpacingMode2[\"Percent\"] = 2] = \"Percent\";\n  return SpacingMode2;\n})(SpacingMode || {});\n\nexport { PathConstraintData, SpacingMode };\n//# sourceMappingURL=PathConstraintData.mjs.map\n","import './attachments/Attachment.mjs';\nimport { RotateMode, Utils, PositionMode, MathUtils } from '@pixi-spine/base';\nimport { PathAttachment } from './attachments/PathAttachment.mjs';\nimport './attachments/RegionAttachment.mjs';\nimport { SpacingMode } from './PathConstraintData.mjs';\n\nconst _PathConstraint = class {\n  constructor(data, skeleton) {\n    this.position = 0;\n    this.spacing = 0;\n    this.rotateMix = 0;\n    this.translateMix = 0;\n    this.spaces = new Array();\n    this.positions = new Array();\n    this.world = new Array();\n    this.curves = new Array();\n    this.lengths = new Array();\n    this.segments = new Array();\n    this.active = false;\n    if (data == null)\n      throw new Error(\"data cannot be null.\");\n    if (skeleton == null)\n      throw new Error(\"skeleton cannot be null.\");\n    this.data = data;\n    this.bones = new Array();\n    for (let i = 0, n = data.bones.length; i < n; i++)\n      this.bones.push(skeleton.findBone(data.bones[i].name));\n    this.target = skeleton.findSlot(data.target.name);\n    this.position = data.position;\n    this.spacing = data.spacing;\n    this.rotateMix = data.rotateMix;\n    this.translateMix = data.translateMix;\n  }\n  isActive() {\n    return this.active;\n  }\n  apply() {\n    this.update();\n  }\n  update() {\n    const attachment = this.target.getAttachment();\n    if (!(attachment instanceof PathAttachment))\n      return;\n    const rotateMix = this.rotateMix;\n    const translateMix = this.translateMix;\n    const translate = translateMix > 0;\n    const rotate = rotateMix > 0;\n    if (!translate && !rotate)\n      return;\n    const data = this.data;\n    const spacingMode = data.spacingMode;\n    const lengthSpacing = spacingMode == SpacingMode.Length;\n    const rotateMode = data.rotateMode;\n    const tangents = rotateMode == RotateMode.Tangent;\n    const scale = rotateMode == RotateMode.ChainScale;\n    const boneCount = this.bones.length;\n    const spacesCount = tangents ? boneCount : boneCount + 1;\n    const bones = this.bones;\n    const spaces = Utils.setArraySize(this.spaces, spacesCount);\n    let lengths = null;\n    const spacing = this.spacing;\n    if (scale || lengthSpacing) {\n      if (scale)\n        lengths = Utils.setArraySize(this.lengths, boneCount);\n      for (let i = 0, n = spacesCount - 1; i < n; ) {\n        const bone = bones[i];\n        const setupLength = bone.data.length;\n        if (setupLength < _PathConstraint.epsilon) {\n          if (scale)\n            lengths[i] = 0;\n          spaces[++i] = 0;\n        } else {\n          const x = setupLength * bone.matrix.a;\n          const y = setupLength * bone.matrix.b;\n          const length = Math.sqrt(x * x + y * y);\n          if (scale)\n            lengths[i] = length;\n          spaces[++i] = (lengthSpacing ? setupLength + spacing : spacing) * length / setupLength;\n        }\n      }\n    } else {\n      for (let i = 1; i < spacesCount; i++)\n        spaces[i] = spacing;\n    }\n    const positions = this.computeWorldPositions(\n      attachment,\n      spacesCount,\n      tangents,\n      data.positionMode == PositionMode.Percent,\n      spacingMode == SpacingMode.Percent\n    );\n    let boneX = positions[0];\n    let boneY = positions[1];\n    let offsetRotation = data.offsetRotation;\n    let tip = false;\n    if (offsetRotation == 0)\n      tip = rotateMode == RotateMode.Chain;\n    else {\n      tip = false;\n      const p = this.target.bone.matrix;\n      offsetRotation *= p.a * p.d - p.b * p.c > 0 ? MathUtils.degRad : -MathUtils.degRad;\n    }\n    for (let i = 0, p = 3; i < boneCount; i++, p += 3) {\n      const bone = bones[i];\n      const mat = bone.matrix;\n      mat.tx += (boneX - mat.tx) * translateMix;\n      mat.ty += (boneY - mat.ty) * translateMix;\n      const x = positions[p];\n      const y = positions[p + 1];\n      const dx = x - boneX;\n      const dy = y - boneY;\n      if (scale) {\n        const length = lengths[i];\n        if (length != 0) {\n          const s = (Math.sqrt(dx * dx + dy * dy) / length - 1) * rotateMix + 1;\n          mat.a *= s;\n          mat.b *= s;\n        }\n      }\n      boneX = x;\n      boneY = y;\n      if (rotate) {\n        const a = mat.a;\n        const b = mat.c;\n        const c = mat.b;\n        const d = mat.d;\n        let r = 0;\n        let cos = 0;\n        let sin = 0;\n        if (tangents)\n          if (tangents)\n            r = positions[p - 1];\n          else if (spaces[i + 1] == 0)\n            r = positions[p + 2];\n          else\n            r = Math.atan2(dy, dx);\n        r -= Math.atan2(c, a);\n        if (tip) {\n          cos = Math.cos(r);\n          sin = Math.sin(r);\n          const length = bone.data.length;\n          boneX += (length * (cos * a - sin * c) - dx) * rotateMix;\n          boneY += (length * (sin * a + cos * c) - dy) * rotateMix;\n        } else {\n          r += offsetRotation;\n        }\n        if (r > MathUtils.PI)\n          r -= MathUtils.PI2;\n        else if (r < -MathUtils.PI)\n          r += MathUtils.PI2;\n        r *= rotateMix;\n        cos = Math.cos(r);\n        sin = Math.sin(r);\n        mat.a = cos * a - sin * c;\n        mat.c = cos * b - sin * d;\n        mat.b = sin * a + cos * c;\n        mat.d = sin * b + cos * d;\n      }\n      bone.appliedValid = false;\n    }\n  }\n  computeWorldPositions(path, spacesCount, tangents, percentPosition, percentSpacing) {\n    const target = this.target;\n    let position = this.position;\n    const spaces = this.spaces;\n    const out = Utils.setArraySize(this.positions, spacesCount * 3 + 2);\n    let world = null;\n    const closed = path.closed;\n    let verticesLength = path.worldVerticesLength;\n    let curveCount = verticesLength / 6;\n    let prevCurve = _PathConstraint.NONE;\n    if (!path.constantSpeed) {\n      const lengths = path.lengths;\n      curveCount -= closed ? 1 : 2;\n      const pathLength2 = lengths[curveCount];\n      if (percentPosition)\n        position *= pathLength2;\n      if (percentSpacing) {\n        for (let i = 0; i < spacesCount; i++)\n          spaces[i] *= pathLength2;\n      }\n      world = Utils.setArraySize(this.world, 8);\n      for (let i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {\n        const space = spaces[i];\n        position += space;\n        let p = position;\n        if (closed) {\n          p %= pathLength2;\n          if (p < 0)\n            p += pathLength2;\n          curve = 0;\n        } else if (p < 0) {\n          if (prevCurve != _PathConstraint.BEFORE) {\n            prevCurve = _PathConstraint.BEFORE;\n            path.computeWorldVertices(target, 2, 4, world, 0, 2);\n          }\n          this.addBeforePosition(p, world, 0, out, o);\n          continue;\n        } else if (p > pathLength2) {\n          if (prevCurve != _PathConstraint.AFTER) {\n            prevCurve = _PathConstraint.AFTER;\n            path.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2);\n          }\n          this.addAfterPosition(p - pathLength2, world, 0, out, o);\n          continue;\n        }\n        for (; ; curve++) {\n          const length = lengths[curve];\n          if (p > length)\n            continue;\n          if (curve == 0)\n            p /= length;\n          else {\n            const prev = lengths[curve - 1];\n            p = (p - prev) / (length - prev);\n          }\n          break;\n        }\n        if (curve != prevCurve) {\n          prevCurve = curve;\n          if (closed && curve == curveCount) {\n            path.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);\n            path.computeWorldVertices(target, 0, 4, world, 4, 2);\n          } else\n            path.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2);\n        }\n        this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o, tangents || i > 0 && space == 0);\n      }\n      return out;\n    }\n    if (closed) {\n      verticesLength += 2;\n      world = Utils.setArraySize(this.world, verticesLength);\n      path.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);\n      path.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);\n      world[verticesLength - 2] = world[0];\n      world[verticesLength - 1] = world[1];\n    } else {\n      curveCount--;\n      verticesLength -= 4;\n      world = Utils.setArraySize(this.world, verticesLength);\n      path.computeWorldVertices(target, 2, verticesLength, world, 0, 2);\n    }\n    const curves = Utils.setArraySize(this.curves, curveCount);\n    let pathLength = 0;\n    let x1 = world[0];\n    let y1 = world[1];\n    let cx1 = 0;\n    let cy1 = 0;\n    let cx2 = 0;\n    let cy2 = 0;\n    let x2 = 0;\n    let y2 = 0;\n    let tmpx = 0;\n    let tmpy = 0;\n    let dddfx = 0;\n    let dddfy = 0;\n    let ddfx = 0;\n    let ddfy = 0;\n    let dfx = 0;\n    let dfy = 0;\n    for (let i = 0, w = 2; i < curveCount; i++, w += 6) {\n      cx1 = world[w];\n      cy1 = world[w + 1];\n      cx2 = world[w + 2];\n      cy2 = world[w + 3];\n      x2 = world[w + 4];\n      y2 = world[w + 5];\n      tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;\n      tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;\n      dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;\n      dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;\n      ddfx = tmpx * 2 + dddfx;\n      ddfy = tmpy * 2 + dddfy;\n      dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;\n      dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;\n      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n      dfx += ddfx;\n      dfy += ddfy;\n      ddfx += dddfx;\n      ddfy += dddfy;\n      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n      dfx += ddfx;\n      dfy += ddfy;\n      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n      dfx += ddfx + dddfx;\n      dfy += ddfy + dddfy;\n      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n      curves[i] = pathLength;\n      x1 = x2;\n      y1 = y2;\n    }\n    if (percentPosition)\n      position *= pathLength;\n    if (percentSpacing) {\n      for (let i = 0; i < spacesCount; i++)\n        spaces[i] *= pathLength;\n    }\n    const segments = this.segments;\n    let curveLength = 0;\n    for (let i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {\n      const space = spaces[i];\n      position += space;\n      let p = position;\n      if (closed) {\n        p %= pathLength;\n        if (p < 0)\n          p += pathLength;\n        curve = 0;\n      } else if (p < 0) {\n        this.addBeforePosition(p, world, 0, out, o);\n        continue;\n      } else if (p > pathLength) {\n        this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);\n        continue;\n      }\n      for (; ; curve++) {\n        const length = curves[curve];\n        if (p > length)\n          continue;\n        if (curve == 0)\n          p /= length;\n        else {\n          const prev = curves[curve - 1];\n          p = (p - prev) / (length - prev);\n        }\n        break;\n      }\n      if (curve != prevCurve) {\n        prevCurve = curve;\n        let ii = curve * 6;\n        x1 = world[ii];\n        y1 = world[ii + 1];\n        cx1 = world[ii + 2];\n        cy1 = world[ii + 3];\n        cx2 = world[ii + 4];\n        cy2 = world[ii + 5];\n        x2 = world[ii + 6];\n        y2 = world[ii + 7];\n        tmpx = (x1 - cx1 * 2 + cx2) * 0.03;\n        tmpy = (y1 - cy1 * 2 + cy2) * 0.03;\n        dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 6e-3;\n        dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 6e-3;\n        ddfx = tmpx * 2 + dddfx;\n        ddfy = tmpy * 2 + dddfy;\n        dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;\n        dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;\n        curveLength = Math.sqrt(dfx * dfx + dfy * dfy);\n        segments[0] = curveLength;\n        for (ii = 1; ii < 8; ii++) {\n          dfx += ddfx;\n          dfy += ddfy;\n          ddfx += dddfx;\n          ddfy += dddfy;\n          curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n          segments[ii] = curveLength;\n        }\n        dfx += ddfx;\n        dfy += ddfy;\n        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n        segments[8] = curveLength;\n        dfx += ddfx + dddfx;\n        dfy += ddfy + dddfy;\n        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n        segments[9] = curveLength;\n        segment = 0;\n      }\n      p *= curveLength;\n      for (; ; segment++) {\n        const length = segments[segment];\n        if (p > length)\n          continue;\n        if (segment == 0)\n          p /= length;\n        else {\n          const prev = segments[segment - 1];\n          p = segment + (p - prev) / (length - prev);\n        }\n        break;\n      }\n      this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || i > 0 && space == 0);\n    }\n    return out;\n  }\n  addBeforePosition(p, temp, i, out, o) {\n    const x1 = temp[i];\n    const y1 = temp[i + 1];\n    const dx = temp[i + 2] - x1;\n    const dy = temp[i + 3] - y1;\n    const r = Math.atan2(dy, dx);\n    out[o] = x1 + p * Math.cos(r);\n    out[o + 1] = y1 + p * Math.sin(r);\n    out[o + 2] = r;\n  }\n  addAfterPosition(p, temp, i, out, o) {\n    const x1 = temp[i + 2];\n    const y1 = temp[i + 3];\n    const dx = x1 - temp[i];\n    const dy = y1 - temp[i + 1];\n    const r = Math.atan2(dy, dx);\n    out[o] = x1 + p * Math.cos(r);\n    out[o + 1] = y1 + p * Math.sin(r);\n    out[o + 2] = r;\n  }\n  addCurvePosition(p, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents) {\n    if (p == 0 || isNaN(p))\n      p = 1e-4;\n    const tt = p * p;\n    const ttt = tt * p;\n    const u = 1 - p;\n    const uu = u * u;\n    const uuu = uu * u;\n    const ut = u * p;\n    const ut3 = ut * 3;\n    const uut3 = u * ut3;\n    const utt3 = ut3 * p;\n    const x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt;\n    const y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;\n    out[o] = x;\n    out[o + 1] = y;\n    if (tangents)\n      out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));\n  }\n};\nlet PathConstraint = _PathConstraint;\nPathConstraint.NONE = -1;\nPathConstraint.BEFORE = -2;\nPathConstraint.AFTER = -3;\nPathConstraint.epsilon = 1e-5;\n\nexport { PathConstraint };\n//# sourceMappingURL=PathConstraint.mjs.map\n","import { Vector2, MathUtils } from '@pixi-spine/base';\n\nclass TransformConstraint {\n  constructor(data, skeleton) {\n    this.rotateMix = 0;\n    this.translateMix = 0;\n    this.scaleMix = 0;\n    this.shearMix = 0;\n    this.temp = new Vector2();\n    this.active = false;\n    if (data == null)\n      throw new Error(\"data cannot be null.\");\n    if (skeleton == null)\n      throw new Error(\"skeleton cannot be null.\");\n    this.data = data;\n    this.rotateMix = data.rotateMix;\n    this.translateMix = data.translateMix;\n    this.scaleMix = data.scaleMix;\n    this.shearMix = data.shearMix;\n    this.bones = new Array();\n    for (let i = 0; i < data.bones.length; i++)\n      this.bones.push(skeleton.findBone(data.bones[i].name));\n    this.target = skeleton.findBone(data.target.name);\n  }\n  isActive() {\n    return this.active;\n  }\n  apply() {\n    this.update();\n  }\n  update() {\n    if (this.data.local) {\n      if (this.data.relative)\n        this.applyRelativeLocal();\n      else\n        this.applyAbsoluteLocal();\n    } else if (this.data.relative)\n      this.applyRelativeWorld();\n    else\n      this.applyAbsoluteWorld();\n  }\n  applyAbsoluteWorld() {\n    const rotateMix = this.rotateMix;\n    const translateMix = this.translateMix;\n    const scaleMix = this.scaleMix;\n    const shearMix = this.shearMix;\n    const target = this.target;\n    const targetMat = target.matrix;\n    const ta = targetMat.a;\n    const tb = targetMat.c;\n    const tc = targetMat.b;\n    const td = targetMat.d;\n    const degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;\n    const offsetRotation = this.data.offsetRotation * degRadReflect;\n    const offsetShearY = this.data.offsetShearY * degRadReflect;\n    const bones = this.bones;\n    for (let i = 0, n = bones.length; i < n; i++) {\n      const bone = bones[i];\n      let modified = false;\n      const mat = bone.matrix;\n      if (rotateMix != 0) {\n        const a = mat.a;\n        const b = mat.c;\n        const c = mat.b;\n        const d = mat.d;\n        let r = Math.atan2(tc, ta) - Math.atan2(c, a) + offsetRotation;\n        if (r > MathUtils.PI)\n          r -= MathUtils.PI2;\n        else if (r < -MathUtils.PI)\n          r += MathUtils.PI2;\n        r *= rotateMix;\n        const cos = Math.cos(r);\n        const sin = Math.sin(r);\n        mat.a = cos * a - sin * c;\n        mat.c = cos * b - sin * d;\n        mat.b = sin * a + cos * c;\n        mat.d = sin * b + cos * d;\n        modified = true;\n      }\n      if (translateMix != 0) {\n        const temp = this.temp;\n        target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\n        mat.tx += (temp.x - mat.tx) * translateMix;\n        mat.ty += (temp.y - mat.ty) * translateMix;\n        modified = true;\n      }\n      if (scaleMix > 0) {\n        let s = Math.sqrt(mat.a * mat.a + mat.b * mat.b);\n        let ts = Math.sqrt(ta * ta + tc * tc);\n        if (s > 1e-5)\n          s = (s + (ts - s + this.data.offsetScaleX) * scaleMix) / s;\n        mat.a *= s;\n        mat.b *= s;\n        s = Math.sqrt(mat.c * mat.c + mat.d * mat.d);\n        ts = Math.sqrt(tb * tb + td * td);\n        if (s > 1e-5)\n          s = (s + (ts - s + this.data.offsetScaleY) * scaleMix) / s;\n        mat.c *= s;\n        mat.d *= s;\n        modified = true;\n      }\n      if (shearMix > 0) {\n        const b = mat.c;\n        const d = mat.d;\n        const by = Math.atan2(d, b);\n        let r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(mat.b, mat.a));\n        if (r > MathUtils.PI)\n          r -= MathUtils.PI2;\n        else if (r < -MathUtils.PI)\n          r += MathUtils.PI2;\n        r = by + (r + offsetShearY) * shearMix;\n        const s = Math.sqrt(b * b + d * d);\n        mat.c = Math.cos(r) * s;\n        mat.d = Math.sin(r) * s;\n        modified = true;\n      }\n      if (modified)\n        bone.appliedValid = false;\n    }\n  }\n  applyRelativeWorld() {\n    const rotateMix = this.rotateMix;\n    const translateMix = this.translateMix;\n    const scaleMix = this.scaleMix;\n    const shearMix = this.shearMix;\n    const target = this.target;\n    const targetMat = target.matrix;\n    const ta = targetMat.a;\n    const tb = targetMat.c;\n    const tc = targetMat.b;\n    const td = targetMat.d;\n    const degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;\n    const offsetRotation = this.data.offsetRotation * degRadReflect;\n    const offsetShearY = this.data.offsetShearY * degRadReflect;\n    const bones = this.bones;\n    for (let i = 0, n = bones.length; i < n; i++) {\n      const bone = bones[i];\n      let modified = false;\n      const mat = bone.matrix;\n      if (rotateMix != 0) {\n        const a = mat.a;\n        const b = mat.c;\n        const c = mat.b;\n        const d = mat.d;\n        let r = Math.atan2(tc, ta) + offsetRotation;\n        if (r > MathUtils.PI)\n          r -= MathUtils.PI2;\n        else if (r < -MathUtils.PI)\n          r += MathUtils.PI2;\n        r *= rotateMix;\n        const cos = Math.cos(r);\n        const sin = Math.sin(r);\n        mat.a = cos * a - sin * c;\n        mat.c = cos * b - sin * d;\n        mat.b = sin * a + cos * c;\n        mat.d = sin * b + cos * d;\n        modified = true;\n      }\n      if (translateMix != 0) {\n        const temp = this.temp;\n        target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\n        mat.tx += temp.x * translateMix;\n        mat.ty += temp.y * translateMix;\n        modified = true;\n      }\n      if (scaleMix > 0) {\n        let s = (Math.sqrt(ta * ta + tc * tc) - 1 + this.data.offsetScaleX) * scaleMix + 1;\n        mat.a *= s;\n        mat.b *= s;\n        s = (Math.sqrt(tb * tb + td * td) - 1 + this.data.offsetScaleY) * scaleMix + 1;\n        mat.c *= s;\n        mat.d *= s;\n        modified = true;\n      }\n      if (shearMix > 0) {\n        let r = Math.atan2(td, tb) - Math.atan2(tc, ta);\n        if (r > MathUtils.PI)\n          r -= MathUtils.PI2;\n        else if (r < -MathUtils.PI)\n          r += MathUtils.PI2;\n        const b = mat.c;\n        const d = mat.d;\n        r = Math.atan2(d, b) + (r - MathUtils.PI / 2 + offsetShearY) * shearMix;\n        const s = Math.sqrt(b * b + d * d);\n        mat.c = Math.cos(r) * s;\n        mat.d = Math.sin(r) * s;\n        modified = true;\n      }\n      if (modified)\n        bone.appliedValid = false;\n    }\n  }\n  applyAbsoluteLocal() {\n    const rotateMix = this.rotateMix;\n    const translateMix = this.translateMix;\n    const scaleMix = this.scaleMix;\n    const shearMix = this.shearMix;\n    const target = this.target;\n    if (!target.appliedValid)\n      target.updateAppliedTransform();\n    const bones = this.bones;\n    for (let i = 0, n = bones.length; i < n; i++) {\n      const bone = bones[i];\n      if (!bone.appliedValid)\n        bone.updateAppliedTransform();\n      let rotation = bone.arotation;\n      if (rotateMix != 0) {\n        let r = target.arotation - rotation + this.data.offsetRotation;\n        r -= (16384 - (16384.499999999996 - r / 360 | 0)) * 360;\n        rotation += r * rotateMix;\n      }\n      let x = bone.ax;\n      let y = bone.ay;\n      if (translateMix != 0) {\n        x += (target.ax - x + this.data.offsetX) * translateMix;\n        y += (target.ay - y + this.data.offsetY) * translateMix;\n      }\n      let scaleX = bone.ascaleX;\n      let scaleY = bone.ascaleY;\n      if (scaleMix > 0) {\n        if (scaleX > 1e-5)\n          scaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * scaleMix) / scaleX;\n        if (scaleY > 1e-5)\n          scaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * scaleMix) / scaleY;\n      }\n      const shearY = bone.ashearY;\n      if (shearMix > 0) {\n        let r = target.ashearY - shearY + this.data.offsetShearY;\n        r -= (16384 - (16384.499999999996 - r / 360 | 0)) * 360;\n        bone.shearY += r * shearMix;\n      }\n      bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\n    }\n  }\n  applyRelativeLocal() {\n    const rotateMix = this.rotateMix;\n    const translateMix = this.translateMix;\n    const scaleMix = this.scaleMix;\n    const shearMix = this.shearMix;\n    const target = this.target;\n    if (!target.appliedValid)\n      target.updateAppliedTransform();\n    const bones = this.bones;\n    for (let i = 0, n = bones.length; i < n; i++) {\n      const bone = bones[i];\n      if (!bone.appliedValid)\n        bone.updateAppliedTransform();\n      let rotation = bone.arotation;\n      if (rotateMix != 0)\n        rotation += (target.arotation + this.data.offsetRotation) * rotateMix;\n      let x = bone.ax;\n      let y = bone.ay;\n      if (translateMix != 0) {\n        x += (target.ax + this.data.offsetX) * translateMix;\n        y += (target.ay + this.data.offsetY) * translateMix;\n      }\n      let scaleX = bone.ascaleX;\n      let scaleY = bone.ascaleY;\n      if (scaleMix > 0) {\n        if (scaleX > 1e-5)\n          scaleX *= (target.ascaleX - 1 + this.data.offsetScaleX) * scaleMix + 1;\n        if (scaleY > 1e-5)\n          scaleY *= (target.ascaleY - 1 + this.data.offsetScaleY) * scaleMix + 1;\n      }\n      let shearY = bone.ashearY;\n      if (shearMix > 0)\n        shearY += (target.ashearY + this.data.offsetShearY) * shearMix;\n      bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\n    }\n  }\n}\n\nexport { TransformConstraint };\n//# sourceMappingURL=TransformConstraint.mjs.map\n","import './attachments/Attachment.mjs';\nimport { Color, Utils } from '@pixi-spine/base';\nimport { MeshAttachment } from './attachments/MeshAttachment.mjs';\nimport { PathAttachment } from './attachments/PathAttachment.mjs';\nimport { RegionAttachment } from './attachments/RegionAttachment.mjs';\nimport { Bone } from './Bone.mjs';\nimport { Slot } from './Slot.mjs';\nimport { IkConstraint } from './IkConstraint.mjs';\nimport { TransformConstraint } from './TransformConstraint.mjs';\nimport { PathConstraint } from './PathConstraint.mjs';\n\nconst _Skeleton = class {\n  constructor(data) {\n    this._updateCache = new Array();\n    this.updateCacheReset = new Array();\n    this.time = 0;\n    this.scaleX = 1;\n    this.scaleY = 1;\n    this.x = 0;\n    this.y = 0;\n    if (data == null)\n      throw new Error(\"data cannot be null.\");\n    this.data = data;\n    this.bones = new Array();\n    for (let i = 0; i < data.bones.length; i++) {\n      const boneData = data.bones[i];\n      let bone;\n      if (boneData.parent == null)\n        bone = new Bone(boneData, this, null);\n      else {\n        const parent = this.bones[boneData.parent.index];\n        bone = new Bone(boneData, this, parent);\n        parent.children.push(bone);\n      }\n      this.bones.push(bone);\n    }\n    this.slots = new Array();\n    this.drawOrder = new Array();\n    for (let i = 0; i < data.slots.length; i++) {\n      const slotData = data.slots[i];\n      const bone = this.bones[slotData.boneData.index];\n      const slot = new Slot(slotData, bone);\n      this.slots.push(slot);\n      this.drawOrder.push(slot);\n    }\n    this.ikConstraints = new Array();\n    for (let i = 0; i < data.ikConstraints.length; i++) {\n      const ikConstraintData = data.ikConstraints[i];\n      this.ikConstraints.push(new IkConstraint(ikConstraintData, this));\n    }\n    this.transformConstraints = new Array();\n    for (let i = 0; i < data.transformConstraints.length; i++) {\n      const transformConstraintData = data.transformConstraints[i];\n      this.transformConstraints.push(new TransformConstraint(transformConstraintData, this));\n    }\n    this.pathConstraints = new Array();\n    for (let i = 0; i < data.pathConstraints.length; i++) {\n      const pathConstraintData = data.pathConstraints[i];\n      this.pathConstraints.push(new PathConstraint(pathConstraintData, this));\n    }\n    this.color = new Color(1, 1, 1, 1);\n    this.updateCache();\n  }\n  updateCache() {\n    const updateCache = this._updateCache;\n    updateCache.length = 0;\n    this.updateCacheReset.length = 0;\n    const bones = this.bones;\n    for (let i = 0, n = bones.length; i < n; i++) {\n      const bone = bones[i];\n      bone.sorted = bone.data.skinRequired;\n      bone.active = !bone.sorted;\n    }\n    if (this.skin != null) {\n      const skinBones = this.skin.bones;\n      for (let i = 0, n = this.skin.bones.length; i < n; i++) {\n        let bone = this.bones[skinBones[i].index];\n        do {\n          bone.sorted = false;\n          bone.active = true;\n          bone = bone.parent;\n        } while (bone != null);\n      }\n    }\n    const ikConstraints = this.ikConstraints;\n    const transformConstraints = this.transformConstraints;\n    const pathConstraints = this.pathConstraints;\n    const ikCount = ikConstraints.length;\n    const transformCount = transformConstraints.length;\n    const pathCount = pathConstraints.length;\n    const constraintCount = ikCount + transformCount + pathCount;\n    outer:\n      for (let i = 0; i < constraintCount; i++) {\n        for (let ii = 0; ii < ikCount; ii++) {\n          const constraint = ikConstraints[ii];\n          if (constraint.data.order == i) {\n            this.sortIkConstraint(constraint);\n            continue outer;\n          }\n        }\n        for (let ii = 0; ii < transformCount; ii++) {\n          const constraint = transformConstraints[ii];\n          if (constraint.data.order == i) {\n            this.sortTransformConstraint(constraint);\n            continue outer;\n          }\n        }\n        for (let ii = 0; ii < pathCount; ii++) {\n          const constraint = pathConstraints[ii];\n          if (constraint.data.order == i) {\n            this.sortPathConstraint(constraint);\n            continue outer;\n          }\n        }\n      }\n    for (let i = 0, n = bones.length; i < n; i++)\n      this.sortBone(bones[i]);\n  }\n  sortIkConstraint(constraint) {\n    constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || this.skin != null && Utils.contains(this.skin.constraints, constraint.data, true));\n    if (!constraint.active)\n      return;\n    const target = constraint.target;\n    this.sortBone(target);\n    const constrained = constraint.bones;\n    const parent = constrained[0];\n    this.sortBone(parent);\n    if (constrained.length > 1) {\n      const child = constrained[constrained.length - 1];\n      if (!(this._updateCache.indexOf(child) > -1))\n        this.updateCacheReset.push(child);\n    }\n    this._updateCache.push(constraint);\n    this.sortReset(parent.children);\n    constrained[constrained.length - 1].sorted = true;\n  }\n  sortPathConstraint(constraint) {\n    constraint.active = constraint.target.bone.isActive() && (!constraint.data.skinRequired || this.skin != null && Utils.contains(this.skin.constraints, constraint.data, true));\n    if (!constraint.active)\n      return;\n    const slot = constraint.target;\n    const slotIndex = slot.data.index;\n    const slotBone = slot.bone;\n    if (this.skin != null)\n      this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);\n    if (this.data.defaultSkin != null && this.data.defaultSkin != this.skin)\n      this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);\n    for (let i = 0, n = this.data.skins.length; i < n; i++)\n      this.sortPathConstraintAttachment(this.data.skins[i], slotIndex, slotBone);\n    const attachment = slot.getAttachment();\n    if (attachment instanceof PathAttachment)\n      this.sortPathConstraintAttachmentWith(attachment, slotBone);\n    const constrained = constraint.bones;\n    const boneCount = constrained.length;\n    for (let i = 0; i < boneCount; i++)\n      this.sortBone(constrained[i]);\n    this._updateCache.push(constraint);\n    for (let i = 0; i < boneCount; i++)\n      this.sortReset(constrained[i].children);\n    for (let i = 0; i < boneCount; i++)\n      constrained[i].sorted = true;\n  }\n  sortTransformConstraint(constraint) {\n    constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || this.skin != null && Utils.contains(this.skin.constraints, constraint.data, true));\n    if (!constraint.active)\n      return;\n    this.sortBone(constraint.target);\n    const constrained = constraint.bones;\n    const boneCount = constrained.length;\n    if (constraint.data.local) {\n      for (let i = 0; i < boneCount; i++) {\n        const child = constrained[i];\n        this.sortBone(child.parent);\n        if (!(this._updateCache.indexOf(child) > -1))\n          this.updateCacheReset.push(child);\n      }\n    } else {\n      for (let i = 0; i < boneCount; i++) {\n        this.sortBone(constrained[i]);\n      }\n    }\n    this._updateCache.push(constraint);\n    for (let ii = 0; ii < boneCount; ii++)\n      this.sortReset(constrained[ii].children);\n    for (let ii = 0; ii < boneCount; ii++)\n      constrained[ii].sorted = true;\n  }\n  sortPathConstraintAttachment(skin, slotIndex, slotBone) {\n    const attachments = skin.attachments[slotIndex];\n    if (!attachments)\n      return;\n    for (const key in attachments) {\n      this.sortPathConstraintAttachmentWith(attachments[key], slotBone);\n    }\n  }\n  sortPathConstraintAttachmentWith(attachment, slotBone) {\n    if (!(attachment instanceof PathAttachment))\n      return;\n    const pathBones = attachment.bones;\n    if (pathBones == null)\n      this.sortBone(slotBone);\n    else {\n      const bones = this.bones;\n      let i = 0;\n      while (i < pathBones.length) {\n        const boneCount = pathBones[i++];\n        for (let n = i + boneCount; i < n; i++) {\n          const boneIndex = pathBones[i];\n          this.sortBone(bones[boneIndex]);\n        }\n      }\n    }\n  }\n  sortBone(bone) {\n    if (bone.sorted)\n      return;\n    const parent = bone.parent;\n    if (parent != null)\n      this.sortBone(parent);\n    bone.sorted = true;\n    this._updateCache.push(bone);\n  }\n  sortReset(bones) {\n    for (let i = 0, n = bones.length; i < n; i++) {\n      const bone = bones[i];\n      if (!bone.active)\n        continue;\n      if (bone.sorted)\n        this.sortReset(bone.children);\n      bone.sorted = false;\n    }\n  }\n  /** Updates the world transform for each bone and applies constraints. */\n  updateWorldTransform() {\n    const updateCacheReset = this.updateCacheReset;\n    for (let i = 0, n = updateCacheReset.length; i < n; i++) {\n      const bone = updateCacheReset[i];\n      bone.ax = bone.x;\n      bone.ay = bone.y;\n      bone.arotation = bone.rotation;\n      bone.ascaleX = bone.scaleX;\n      bone.ascaleY = bone.scaleY;\n      bone.ashearX = bone.shearX;\n      bone.ashearY = bone.shearY;\n      bone.appliedValid = true;\n    }\n    const updateCache = this._updateCache;\n    for (let i = 0, n = updateCache.length; i < n; i++)\n      updateCache[i].update();\n  }\n  /** Sets the bones, constraints, and slots to their setup pose values. */\n  setToSetupPose() {\n    this.setBonesToSetupPose();\n    this.setSlotsToSetupPose();\n  }\n  /** Sets the bones and constraints to their setup pose values. */\n  setBonesToSetupPose() {\n    const bones = this.bones;\n    for (let i = 0, n = bones.length; i < n; i++)\n      bones[i].setToSetupPose();\n    const ikConstraints = this.ikConstraints;\n    for (let i = 0, n = ikConstraints.length; i < n; i++) {\n      const constraint = ikConstraints[i];\n      constraint.mix = constraint.data.mix;\n      constraint.softness = constraint.data.softness;\n      constraint.bendDirection = constraint.data.bendDirection;\n      constraint.compress = constraint.data.compress;\n      constraint.stretch = constraint.data.stretch;\n    }\n    const transformConstraints = this.transformConstraints;\n    for (let i = 0, n = transformConstraints.length; i < n; i++) {\n      const constraint = transformConstraints[i];\n      const data = constraint.data;\n      constraint.rotateMix = data.rotateMix;\n      constraint.translateMix = data.translateMix;\n      constraint.scaleMix = data.scaleMix;\n      constraint.shearMix = data.shearMix;\n    }\n    const pathConstraints = this.pathConstraints;\n    for (let i = 0, n = pathConstraints.length; i < n; i++) {\n      const constraint = pathConstraints[i];\n      const data = constraint.data;\n      constraint.position = data.position;\n      constraint.spacing = data.spacing;\n      constraint.rotateMix = data.rotateMix;\n      constraint.translateMix = data.translateMix;\n    }\n  }\n  setSlotsToSetupPose() {\n    const slots = this.slots;\n    Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);\n    for (let i = 0, n = slots.length; i < n; i++)\n      slots[i].setToSetupPose();\n  }\n  /** @return May return null. */\n  getRootBone() {\n    if (this.bones.length == 0)\n      return null;\n    return this.bones[0];\n  }\n  /** @return May be null. */\n  findBone(boneName) {\n    if (boneName == null)\n      throw new Error(\"boneName cannot be null.\");\n    const bones = this.bones;\n    for (let i = 0, n = bones.length; i < n; i++) {\n      const bone = bones[i];\n      if (bone.data.name == boneName)\n        return bone;\n    }\n    return null;\n  }\n  /** @return -1 if the bone was not found. */\n  findBoneIndex(boneName) {\n    if (boneName == null)\n      throw new Error(\"boneName cannot be null.\");\n    const bones = this.bones;\n    for (let i = 0, n = bones.length; i < n; i++)\n      if (bones[i].data.name == boneName)\n        return i;\n    return -1;\n  }\n  /** @return May be null. */\n  findSlot(slotName) {\n    if (slotName == null)\n      throw new Error(\"slotName cannot be null.\");\n    const slots = this.slots;\n    for (let i = 0, n = slots.length; i < n; i++) {\n      const slot = slots[i];\n      if (slot.data.name == slotName)\n        return slot;\n    }\n    return null;\n  }\n  /** @return -1 if the bone was not found. */\n  findSlotIndex(slotName) {\n    if (slotName == null)\n      throw new Error(\"slotName cannot be null.\");\n    const slots = this.slots;\n    for (let i = 0, n = slots.length; i < n; i++)\n      if (slots[i].data.name == slotName)\n        return i;\n    return -1;\n  }\n  /** Sets a skin by name.\n   * @see #setSkin(Skin) */\n  setSkinByName(skinName) {\n    const skin = this.data.findSkin(skinName);\n    if (skin == null)\n      throw new Error(`Skin not found: ${skinName}`);\n    this.setSkin(skin);\n  }\n  /** Sets the skin used to look up attachments before looking in the {@link SkeletonData#getDefaultSkin() default skin}.\n   * Attachments from the new skin are attached if the corresponding attachment from the old skin was attached. If there was no\n   * old skin, each slot's setup mode attachment is attached from the new skin.\n   * @param newSkin May be null. */\n  setSkin(newSkin) {\n    if (newSkin == this.skin)\n      return;\n    if (newSkin != null) {\n      if (this.skin != null)\n        newSkin.attachAll(this, this.skin);\n      else {\n        const slots = this.slots;\n        for (let i = 0, n = slots.length; i < n; i++) {\n          const slot = slots[i];\n          const name = slot.data.attachmentName;\n          if (name != null) {\n            const attachment = newSkin.getAttachment(i, name);\n            if (attachment != null)\n              slot.setAttachment(attachment);\n          }\n        }\n      }\n    }\n    this.skin = newSkin;\n    this.updateCache();\n  }\n  /** @return May be null. */\n  getAttachmentByName(slotName, attachmentName) {\n    return this.getAttachment(this.data.findSlotIndex(slotName), attachmentName);\n  }\n  /** @return May be null. */\n  getAttachment(slotIndex, attachmentName) {\n    if (attachmentName == null)\n      throw new Error(\"attachmentName cannot be null.\");\n    if (this.skin != null) {\n      const attachment = this.skin.getAttachment(slotIndex, attachmentName);\n      if (attachment != null)\n        return attachment;\n    }\n    if (this.data.defaultSkin != null)\n      return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);\n    return null;\n  }\n  /** @param attachmentName May be null. */\n  setAttachment(slotName, attachmentName) {\n    if (slotName == null)\n      throw new Error(\"slotName cannot be null.\");\n    const slots = this.slots;\n    for (let i = 0, n = slots.length; i < n; i++) {\n      const slot = slots[i];\n      if (slot.data.name == slotName) {\n        let attachment = null;\n        if (attachmentName != null) {\n          attachment = this.getAttachment(i, attachmentName);\n          if (attachment == null)\n            throw new Error(`Attachment not found: ${attachmentName}, for slot: ${slotName}`);\n        }\n        slot.setAttachment(attachment);\n        return;\n      }\n    }\n    throw new Error(`Slot not found: ${slotName}`);\n  }\n  /** @return May be null. */\n  findIkConstraint(constraintName) {\n    if (constraintName == null)\n      throw new Error(\"constraintName cannot be null.\");\n    const ikConstraints = this.ikConstraints;\n    for (let i = 0, n = ikConstraints.length; i < n; i++) {\n      const ikConstraint = ikConstraints[i];\n      if (ikConstraint.data.name == constraintName)\n        return ikConstraint;\n    }\n    return null;\n  }\n  /** @return May be null. */\n  findTransformConstraint(constraintName) {\n    if (constraintName == null)\n      throw new Error(\"constraintName cannot be null.\");\n    const transformConstraints = this.transformConstraints;\n    for (let i = 0, n = transformConstraints.length; i < n; i++) {\n      const constraint = transformConstraints[i];\n      if (constraint.data.name == constraintName)\n        return constraint;\n    }\n    return null;\n  }\n  /** @return May be null. */\n  findPathConstraint(constraintName) {\n    if (constraintName == null)\n      throw new Error(\"constraintName cannot be null.\");\n    const pathConstraints = this.pathConstraints;\n    for (let i = 0, n = pathConstraints.length; i < n; i++) {\n      const constraint = pathConstraints[i];\n      if (constraint.data.name == constraintName)\n        return constraint;\n    }\n    return null;\n  }\n  /** Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose.\n   * @param offset The distance from the skeleton origin to the bottom left corner of the AABB.\n   * @param size The width and height of the AABB.\n   * @param temp Working memory */\n  getBounds(offset, size, temp = new Array(2)) {\n    if (offset == null)\n      throw new Error(\"offset cannot be null.\");\n    if (size == null)\n      throw new Error(\"size cannot be null.\");\n    const drawOrder = this.drawOrder;\n    let minX = Number.POSITIVE_INFINITY;\n    let minY = Number.POSITIVE_INFINITY;\n    let maxX = Number.NEGATIVE_INFINITY;\n    let maxY = Number.NEGATIVE_INFINITY;\n    for (let i = 0, n = drawOrder.length; i < n; i++) {\n      const slot = drawOrder[i];\n      if (!slot.bone.active)\n        continue;\n      let verticesLength = 0;\n      let vertices = null;\n      const attachment = slot.getAttachment();\n      if (attachment instanceof RegionAttachment) {\n        verticesLength = 8;\n        vertices = Utils.setArraySize(temp, verticesLength, 0);\n        attachment.computeWorldVertices(slot.bone, vertices, 0, 2);\n      } else if (attachment instanceof MeshAttachment) {\n        const mesh = attachment;\n        verticesLength = mesh.worldVerticesLength;\n        vertices = Utils.setArraySize(temp, verticesLength, 0);\n        mesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);\n      }\n      if (vertices != null) {\n        for (let ii = 0, nn = vertices.length; ii < nn; ii += 2) {\n          const x = vertices[ii];\n          const y = vertices[ii + 1];\n          minX = Math.min(minX, x);\n          minY = Math.min(minY, y);\n          maxX = Math.max(maxX, x);\n          maxY = Math.max(maxY, y);\n        }\n      }\n    }\n    offset.set(minX, minY);\n    size.set(maxX - minX, maxY - minY);\n  }\n  update(delta) {\n    this.time += delta;\n  }\n  get flipX() {\n    return this.scaleX == -1;\n  }\n  set flipX(value) {\n    if (!_Skeleton.deprecatedWarning1) {\n      _Skeleton.deprecatedWarning1 = true;\n      console.warn(\"Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY\");\n    }\n    this.scaleX = value ? 1 : -1;\n  }\n  get flipY() {\n    return this.scaleY == -1;\n  }\n  set flipY(value) {\n    if (!_Skeleton.deprecatedWarning1) {\n      _Skeleton.deprecatedWarning1 = true;\n      console.warn(\"Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY\");\n    }\n    this.scaleY = value ? 1 : -1;\n  }\n};\nlet Skeleton = _Skeleton;\nSkeleton.deprecatedWarning1 = false;\n\nexport { Skeleton };\n//# sourceMappingURL=Skeleton.mjs.map\n","class SkeletonData {\n  constructor() {\n    this.bones = new Array();\n    // Ordered parents first.\n    this.slots = new Array();\n    // Setup pose draw order.\n    this.skins = new Array();\n    this.events = new Array();\n    this.animations = new Array();\n    this.ikConstraints = new Array();\n    this.transformConstraints = new Array();\n    this.pathConstraints = new Array();\n    // Nonessential\n    this.fps = 0;\n  }\n  findBone(boneName) {\n    if (boneName == null)\n      throw new Error(\"boneName cannot be null.\");\n    const bones = this.bones;\n    for (let i = 0, n = bones.length; i < n; i++) {\n      const bone = bones[i];\n      if (bone.name == boneName)\n        return bone;\n    }\n    return null;\n  }\n  findBoneIndex(boneName) {\n    if (boneName == null)\n      throw new Error(\"boneName cannot be null.\");\n    const bones = this.bones;\n    for (let i = 0, n = bones.length; i < n; i++)\n      if (bones[i].name == boneName)\n        return i;\n    return -1;\n  }\n  findSlot(slotName) {\n    if (slotName == null)\n      throw new Error(\"slotName cannot be null.\");\n    const slots = this.slots;\n    for (let i = 0, n = slots.length; i < n; i++) {\n      const slot = slots[i];\n      if (slot.name == slotName)\n        return slot;\n    }\n    return null;\n  }\n  findSlotIndex(slotName) {\n    if (slotName == null)\n      throw new Error(\"slotName cannot be null.\");\n    const slots = this.slots;\n    for (let i = 0, n = slots.length; i < n; i++)\n      if (slots[i].name == slotName)\n        return i;\n    return -1;\n  }\n  findSkin(skinName) {\n    if (skinName == null)\n      throw new Error(\"skinName cannot be null.\");\n    const skins = this.skins;\n    for (let i = 0, n = skins.length; i < n; i++) {\n      const skin = skins[i];\n      if (skin.name == skinName)\n        return skin;\n    }\n    return null;\n  }\n  findEvent(eventDataName) {\n    if (eventDataName == null)\n      throw new Error(\"eventDataName cannot be null.\");\n    const events = this.events;\n    for (let i = 0, n = events.length; i < n; i++) {\n      const event = events[i];\n      if (event.name == eventDataName)\n        return event;\n    }\n    return null;\n  }\n  findAnimation(animationName) {\n    if (animationName == null)\n      throw new Error(\"animationName cannot be null.\");\n    const animations = this.animations;\n    for (let i = 0, n = animations.length; i < n; i++) {\n      const animation = animations[i];\n      if (animation.name == animationName)\n        return animation;\n    }\n    return null;\n  }\n  findIkConstraint(constraintName) {\n    if (constraintName == null)\n      throw new Error(\"constraintName cannot be null.\");\n    const ikConstraints = this.ikConstraints;\n    for (let i = 0, n = ikConstraints.length; i < n; i++) {\n      const constraint = ikConstraints[i];\n      if (constraint.name == constraintName)\n        return constraint;\n    }\n    return null;\n  }\n  findTransformConstraint(constraintName) {\n    if (constraintName == null)\n      throw new Error(\"constraintName cannot be null.\");\n    const transformConstraints = this.transformConstraints;\n    for (let i = 0, n = transformConstraints.length; i < n; i++) {\n      const constraint = transformConstraints[i];\n      if (constraint.name == constraintName)\n        return constraint;\n    }\n    return null;\n  }\n  findPathConstraint(constraintName) {\n    if (constraintName == null)\n      throw new Error(\"constraintName cannot be null.\");\n    const pathConstraints = this.pathConstraints;\n    for (let i = 0, n = pathConstraints.length; i < n; i++) {\n      const constraint = pathConstraints[i];\n      if (constraint.name == constraintName)\n        return constraint;\n    }\n    return null;\n  }\n  findPathConstraintIndex(pathConstraintName) {\n    if (pathConstraintName == null)\n      throw new Error(\"pathConstraintName cannot be null.\");\n    const pathConstraints = this.pathConstraints;\n    for (let i = 0, n = pathConstraints.length; i < n; i++)\n      if (pathConstraints[i].name == pathConstraintName)\n        return i;\n    return -1;\n  }\n}\n\nexport { SkeletonData };\n//# sourceMappingURL=SkeletonData.mjs.map\n","import { Color } from '@pixi-spine/base';\n\nclass SlotData {\n  constructor(index, name, boneData) {\n    this.color = new Color(1, 1, 1, 1);\n    if (index < 0)\n      throw new Error(\"index must be >= 0.\");\n    if (name == null)\n      throw new Error(\"name cannot be null.\");\n    if (boneData == null)\n      throw new Error(\"boneData cannot be null.\");\n    this.index = index;\n    this.name = name;\n    this.boneData = boneData;\n  }\n}\n\nexport { SlotData };\n//# sourceMappingURL=SlotData.mjs.map\n","import { ConstraintData } from './Constraint.mjs';\n\nclass TransformConstraintData extends ConstraintData {\n  constructor(name) {\n    super(name, 0, false);\n    this.bones = new Array();\n    this.rotateMix = 0;\n    this.translateMix = 0;\n    this.scaleMix = 0;\n    this.shearMix = 0;\n    this.offsetRotation = 0;\n    this.offsetX = 0;\n    this.offsetY = 0;\n    this.offsetScaleX = 0;\n    this.offsetScaleY = 0;\n    this.offsetShearY = 0;\n    this.relative = false;\n    this.local = false;\n  }\n}\n\nexport { TransformConstraintData };\n//# sourceMappingURL=TransformConstraintData.mjs.map\n","import './attachments/Attachment.mjs';\nimport '@pixi-spine/base';\nimport { MeshAttachment } from './attachments/MeshAttachment.mjs';\nimport './attachments/RegionAttachment.mjs';\n\nclass SkinEntry {\n  constructor(slotIndex, name, attachment) {\n    this.slotIndex = slotIndex;\n    this.name = name;\n    this.attachment = attachment;\n  }\n}\nclass Skin {\n  constructor(name) {\n    this.attachments = new Array();\n    this.bones = Array();\n    this.constraints = new Array();\n    if (name == null)\n      throw new Error(\"name cannot be null.\");\n    this.name = name;\n  }\n  setAttachment(slotIndex, name, attachment) {\n    if (attachment == null)\n      throw new Error(\"attachment cannot be null.\");\n    const attachments = this.attachments;\n    if (slotIndex >= attachments.length)\n      attachments.length = slotIndex + 1;\n    if (!attachments[slotIndex])\n      attachments[slotIndex] = {};\n    attachments[slotIndex][name] = attachment;\n  }\n  addSkin(skin) {\n    for (let i = 0; i < skin.bones.length; i++) {\n      const bone = skin.bones[i];\n      let contained = false;\n      for (let j = 0; j < this.bones.length; j++) {\n        if (this.bones[j] == bone) {\n          contained = true;\n          break;\n        }\n      }\n      if (!contained)\n        this.bones.push(bone);\n    }\n    for (let i = 0; i < skin.constraints.length; i++) {\n      const constraint = skin.constraints[i];\n      let contained = false;\n      for (let j = 0; j < this.constraints.length; j++) {\n        if (this.constraints[j] == constraint) {\n          contained = true;\n          break;\n        }\n      }\n      if (!contained)\n        this.constraints.push(constraint);\n    }\n    const attachments = skin.getAttachments();\n    for (let i = 0; i < attachments.length; i++) {\n      const attachment = attachments[i];\n      this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\n    }\n  }\n  copySkin(skin) {\n    for (let i = 0; i < skin.bones.length; i++) {\n      const bone = skin.bones[i];\n      let contained = false;\n      for (let j = 0; j < this.bones.length; j++) {\n        if (this.bones[j] == bone) {\n          contained = true;\n          break;\n        }\n      }\n      if (!contained)\n        this.bones.push(bone);\n    }\n    for (let i = 0; i < skin.constraints.length; i++) {\n      const constraint = skin.constraints[i];\n      let contained = false;\n      for (let j = 0; j < this.constraints.length; j++) {\n        if (this.constraints[j] == constraint) {\n          contained = true;\n          break;\n        }\n      }\n      if (!contained)\n        this.constraints.push(constraint);\n    }\n    const attachments = skin.getAttachments();\n    for (let i = 0; i < attachments.length; i++) {\n      const attachment = attachments[i];\n      if (attachment.attachment == null)\n        continue;\n      if (attachment.attachment instanceof MeshAttachment) {\n        attachment.attachment = attachment.attachment.newLinkedMesh();\n        this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\n      } else {\n        attachment.attachment = attachment.attachment.copy();\n        this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\n      }\n    }\n  }\n  /** @return May be null. */\n  getAttachment(slotIndex, name) {\n    const dictionary = this.attachments[slotIndex];\n    return dictionary ? dictionary[name] : null;\n  }\n  removeAttachment(slotIndex, name) {\n    const dictionary = this.attachments[slotIndex];\n    if (dictionary)\n      dictionary[name] = null;\n  }\n  getAttachments() {\n    const entries = new Array();\n    for (let i = 0; i < this.attachments.length; i++) {\n      const slotAttachments = this.attachments[i];\n      if (slotAttachments) {\n        for (const name in slotAttachments) {\n          const attachment = slotAttachments[name];\n          if (attachment)\n            entries.push(new SkinEntry(i, name, attachment));\n        }\n      }\n    }\n    return entries;\n  }\n  getAttachmentsForSlot(slotIndex, attachments) {\n    const slotAttachments = this.attachments[slotIndex];\n    if (slotAttachments) {\n      for (const name in slotAttachments) {\n        const attachment = slotAttachments[name];\n        if (attachment)\n          attachments.push(new SkinEntry(slotIndex, name, attachment));\n      }\n    }\n  }\n  clear() {\n    this.attachments.length = 0;\n    this.bones.length = 0;\n    this.constraints.length = 0;\n  }\n  /** Attach each attachment in this skin if the corresponding attachment in the old skin is currently attached. */\n  attachAll(skeleton, oldSkin) {\n    let slotIndex = 0;\n    for (let i = 0; i < skeleton.slots.length; i++) {\n      const slot = skeleton.slots[i];\n      const slotAttachment = slot.getAttachment();\n      if (slotAttachment && slotIndex < oldSkin.attachments.length) {\n        const dictionary = oldSkin.attachments[slotIndex];\n        for (const key in dictionary) {\n          const skinAttachment = dictionary[key];\n          if (slotAttachment == skinAttachment) {\n            const attachment = this.getAttachment(slotIndex, key);\n            if (attachment != null)\n              slot.setAttachment(attachment);\n            break;\n          }\n        }\n      }\n      slotIndex++;\n    }\n  }\n}\n\nexport { Skin, SkinEntry };\n//# sourceMappingURL=Skin.mjs.map\n","import { Event } from './Event.mjs';\nimport { SkeletonData } from './SkeletonData.mjs';\nimport { SlotData } from './SlotData.mjs';\nimport { BoneData } from './BoneData.mjs';\nimport { IkConstraintData } from './IkConstraintData.mjs';\nimport { TransformConstraintData } from './TransformConstraintData.mjs';\nimport { SpacingMode, PathConstraintData } from './PathConstraintData.mjs';\nimport { Skin } from './Skin.mjs';\nimport { EventData } from './EventData.mjs';\nimport { TwoColorTimeline, ColorTimeline, AttachmentTimeline, ScaleTimeline, ShearTimeline, TranslateTimeline, RotateTimeline, IkConstraintTimeline, TransformConstraintTimeline, PathConstraintMixTimeline, PathConstraintSpacingTimeline, PathConstraintPositionTimeline, DeformTimeline, DrawOrderTimeline, EventTimeline, Animation } from './Animation.mjs';\nimport { TransformMode, PositionMode, RotateMode, BinaryInput, Color, Utils, AttachmentType } from '@pixi-spine/base';\nimport { BLEND_MODES } from '@pixi/core';\n\nconst _SkeletonBinary = class {\n  constructor(attachmentLoader) {\n    this.scale = 1;\n    this.linkedMeshes = new Array();\n    this.attachmentLoader = attachmentLoader;\n  }\n  readSkeletonData(binary) {\n    const scale = this.scale;\n    const skeletonData = new SkeletonData();\n    skeletonData.name = \"\";\n    const input = new BinaryInput(binary);\n    skeletonData.hash = input.readString();\n    skeletonData.version = input.readString();\n    if (skeletonData.version === \"3.8.75\") {\n      const error = `Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine.`;\n      console.error(error);\n    }\n    skeletonData.x = input.readFloat();\n    skeletonData.y = input.readFloat();\n    skeletonData.width = input.readFloat();\n    skeletonData.height = input.readFloat();\n    const nonessential = input.readBoolean();\n    if (nonessential) {\n      skeletonData.fps = input.readFloat();\n      skeletonData.imagesPath = input.readString();\n      skeletonData.audioPath = input.readString();\n    }\n    let n = 0;\n    n = input.readInt(true);\n    for (let i = 0; i < n; i++)\n      input.strings.push(input.readString());\n    n = input.readInt(true);\n    for (let i = 0; i < n; i++) {\n      const name = input.readString();\n      const parent = i == 0 ? null : skeletonData.bones[input.readInt(true)];\n      const data = new BoneData(i, name, parent);\n      data.rotation = input.readFloat();\n      data.x = input.readFloat() * scale;\n      data.y = input.readFloat() * scale;\n      data.scaleX = input.readFloat();\n      data.scaleY = input.readFloat();\n      data.shearX = input.readFloat();\n      data.shearY = input.readFloat();\n      data.length = input.readFloat() * scale;\n      data.transformMode = _SkeletonBinary.TransformModeValues[input.readInt(true)];\n      data.skinRequired = input.readBoolean();\n      if (nonessential)\n        Color.rgba8888ToColor(data.color, input.readInt32());\n      skeletonData.bones.push(data);\n    }\n    n = input.readInt(true);\n    for (let i = 0; i < n; i++) {\n      const slotName = input.readString();\n      const boneData = skeletonData.bones[input.readInt(true)];\n      const data = new SlotData(i, slotName, boneData);\n      Color.rgba8888ToColor(data.color, input.readInt32());\n      const darkColor = input.readInt32();\n      if (darkColor != -1)\n        Color.rgb888ToColor(data.darkColor = new Color(), darkColor);\n      data.attachmentName = input.readStringRef();\n      data.blendMode = _SkeletonBinary.BlendModeValues[input.readInt(true)];\n      skeletonData.slots.push(data);\n    }\n    n = input.readInt(true);\n    for (let i = 0, nn; i < n; i++) {\n      const data = new IkConstraintData(input.readString());\n      data.order = input.readInt(true);\n      data.skinRequired = input.readBoolean();\n      nn = input.readInt(true);\n      for (let ii = 0; ii < nn; ii++)\n        data.bones.push(skeletonData.bones[input.readInt(true)]);\n      data.target = skeletonData.bones[input.readInt(true)];\n      data.mix = input.readFloat();\n      data.softness = input.readFloat() * scale;\n      data.bendDirection = input.readByte();\n      data.compress = input.readBoolean();\n      data.stretch = input.readBoolean();\n      data.uniform = input.readBoolean();\n      skeletonData.ikConstraints.push(data);\n    }\n    n = input.readInt(true);\n    for (let i = 0, nn; i < n; i++) {\n      const data = new TransformConstraintData(input.readString());\n      data.order = input.readInt(true);\n      data.skinRequired = input.readBoolean();\n      nn = input.readInt(true);\n      for (let ii = 0; ii < nn; ii++)\n        data.bones.push(skeletonData.bones[input.readInt(true)]);\n      data.target = skeletonData.bones[input.readInt(true)];\n      data.local = input.readBoolean();\n      data.relative = input.readBoolean();\n      data.offsetRotation = input.readFloat();\n      data.offsetX = input.readFloat() * scale;\n      data.offsetY = input.readFloat() * scale;\n      data.offsetScaleX = input.readFloat();\n      data.offsetScaleY = input.readFloat();\n      data.offsetShearY = input.readFloat();\n      data.rotateMix = input.readFloat();\n      data.translateMix = input.readFloat();\n      data.scaleMix = input.readFloat();\n      data.shearMix = input.readFloat();\n      skeletonData.transformConstraints.push(data);\n    }\n    n = input.readInt(true);\n    for (let i = 0, nn; i < n; i++) {\n      const data = new PathConstraintData(input.readString());\n      data.order = input.readInt(true);\n      data.skinRequired = input.readBoolean();\n      nn = input.readInt(true);\n      for (let ii = 0; ii < nn; ii++)\n        data.bones.push(skeletonData.bones[input.readInt(true)]);\n      data.target = skeletonData.slots[input.readInt(true)];\n      data.positionMode = _SkeletonBinary.PositionModeValues[input.readInt(true)];\n      data.spacingMode = _SkeletonBinary.SpacingModeValues[input.readInt(true)];\n      data.rotateMode = _SkeletonBinary.RotateModeValues[input.readInt(true)];\n      data.offsetRotation = input.readFloat();\n      data.position = input.readFloat();\n      if (data.positionMode == PositionMode.Fixed)\n        data.position *= scale;\n      data.spacing = input.readFloat();\n      if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed)\n        data.spacing *= scale;\n      data.rotateMix = input.readFloat();\n      data.translateMix = input.readFloat();\n      skeletonData.pathConstraints.push(data);\n    }\n    const defaultSkin = this.readSkin(input, skeletonData, true, nonessential);\n    if (defaultSkin != null) {\n      skeletonData.defaultSkin = defaultSkin;\n      skeletonData.skins.push(defaultSkin);\n    }\n    {\n      let i = skeletonData.skins.length;\n      Utils.setArraySize(skeletonData.skins, n = i + input.readInt(true));\n      for (; i < n; i++)\n        skeletonData.skins[i] = this.readSkin(input, skeletonData, false, nonessential);\n    }\n    n = this.linkedMeshes.length;\n    for (let i = 0; i < n; i++) {\n      const linkedMesh = this.linkedMeshes[i];\n      const skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\n      if (skin == null)\n        throw new Error(`Skin not found: ${linkedMesh.skin}`);\n      const parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\n      if (parent == null)\n        throw new Error(`Parent mesh not found: ${linkedMesh.parent}`);\n      linkedMesh.mesh.deformAttachment = linkedMesh.inheritDeform ? parent : linkedMesh.mesh;\n      linkedMesh.mesh.setParentMesh(parent);\n    }\n    this.linkedMeshes.length = 0;\n    n = input.readInt(true);\n    for (let i = 0; i < n; i++) {\n      const data = new EventData(input.readStringRef());\n      data.intValue = input.readInt(false);\n      data.floatValue = input.readFloat();\n      data.stringValue = input.readString();\n      data.audioPath = input.readString();\n      if (data.audioPath != null) {\n        data.volume = input.readFloat();\n        data.balance = input.readFloat();\n      }\n      skeletonData.events.push(data);\n    }\n    n = input.readInt(true);\n    for (let i = 0; i < n; i++)\n      skeletonData.animations.push(this.readAnimation(input, input.readString(), skeletonData));\n    return skeletonData;\n  }\n  readSkin(input, skeletonData, defaultSkin, nonessential) {\n    let skin = null;\n    let slotCount = 0;\n    if (defaultSkin) {\n      slotCount = input.readInt(true);\n      if (slotCount == 0)\n        return null;\n      skin = new Skin(\"default\");\n    } else {\n      skin = new Skin(input.readStringRef());\n      skin.bones.length = input.readInt(true);\n      for (let i = 0, n = skin.bones.length; i < n; i++)\n        skin.bones[i] = skeletonData.bones[input.readInt(true)];\n      for (let i = 0, n = input.readInt(true); i < n; i++)\n        skin.constraints.push(skeletonData.ikConstraints[input.readInt(true)]);\n      for (let i = 0, n = input.readInt(true); i < n; i++)\n        skin.constraints.push(skeletonData.transformConstraints[input.readInt(true)]);\n      for (let i = 0, n = input.readInt(true); i < n; i++)\n        skin.constraints.push(skeletonData.pathConstraints[input.readInt(true)]);\n      slotCount = input.readInt(true);\n    }\n    for (let i = 0; i < slotCount; i++) {\n      const slotIndex = input.readInt(true);\n      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n        const name = input.readStringRef();\n        const attachment = this.readAttachment(input, skeletonData, skin, slotIndex, name, nonessential);\n        if (attachment != null)\n          skin.setAttachment(slotIndex, name, attachment);\n      }\n    }\n    return skin;\n  }\n  readAttachment(input, skeletonData, skin, slotIndex, attachmentName, nonessential) {\n    const scale = this.scale;\n    let name = input.readStringRef();\n    if (name == null)\n      name = attachmentName;\n    const typeIndex = input.readByte();\n    const type = _SkeletonBinary.AttachmentTypeValues[typeIndex];\n    switch (type) {\n      case AttachmentType.Region: {\n        let path = input.readStringRef();\n        const rotation = input.readFloat();\n        const x = input.readFloat();\n        const y = input.readFloat();\n        const scaleX = input.readFloat();\n        const scaleY = input.readFloat();\n        const width = input.readFloat();\n        const height = input.readFloat();\n        const color = input.readInt32();\n        if (path == null)\n          path = name;\n        const region = this.attachmentLoader.newRegionAttachment(skin, name, path);\n        if (region == null)\n          return null;\n        region.path = path;\n        region.x = x * scale;\n        region.y = y * scale;\n        region.scaleX = scaleX;\n        region.scaleY = scaleY;\n        region.rotation = rotation;\n        region.width = width * scale;\n        region.height = height * scale;\n        Color.rgba8888ToColor(region.color, color);\n        return region;\n      }\n      case AttachmentType.BoundingBox: {\n        const vertexCount = input.readInt(true);\n        const vertices = this.readVertices(input, vertexCount);\n        const color = nonessential ? input.readInt32() : 0;\n        const box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\n        if (box == null)\n          return null;\n        box.worldVerticesLength = vertexCount << 1;\n        box.vertices = vertices.vertices;\n        box.bones = vertices.bones;\n        if (nonessential)\n          Color.rgba8888ToColor(box.color, color);\n        return box;\n      }\n      case AttachmentType.Mesh: {\n        let path = input.readStringRef();\n        const color = input.readInt32();\n        const vertexCount = input.readInt(true);\n        const uvs = this.readFloatArray(input, vertexCount << 1, 1);\n        const triangles = this.readShortArray(input);\n        const vertices = this.readVertices(input, vertexCount);\n        const hullLength = input.readInt(true);\n        let edges = null;\n        let width = 0;\n        let height = 0;\n        if (nonessential) {\n          edges = this.readShortArray(input);\n          width = input.readFloat();\n          height = input.readFloat();\n        }\n        if (path == null)\n          path = name;\n        const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\n        if (mesh == null)\n          return null;\n        mesh.path = path;\n        Color.rgba8888ToColor(mesh.color, color);\n        mesh.bones = vertices.bones;\n        mesh.vertices = vertices.vertices;\n        mesh.worldVerticesLength = vertexCount << 1;\n        mesh.triangles = triangles;\n        mesh.regionUVs = new Float32Array(uvs);\n        mesh.hullLength = hullLength << 1;\n        if (nonessential) {\n          mesh.edges = edges;\n          mesh.width = width * scale;\n          mesh.height = height * scale;\n        }\n        return mesh;\n      }\n      case AttachmentType.LinkedMesh: {\n        let path = input.readStringRef();\n        const color = input.readInt32();\n        const skinName = input.readStringRef();\n        const parent = input.readStringRef();\n        const inheritDeform = input.readBoolean();\n        let width = 0;\n        let height = 0;\n        if (nonessential) {\n          width = input.readFloat();\n          height = input.readFloat();\n        }\n        if (path == null)\n          path = name;\n        const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\n        if (mesh == null)\n          return null;\n        mesh.path = path;\n        Color.rgba8888ToColor(mesh.color, color);\n        if (nonessential) {\n          mesh.width = width * scale;\n          mesh.height = height * scale;\n        }\n        this.linkedMeshes.push(new LinkedMesh(mesh, skinName, slotIndex, parent, inheritDeform));\n        return mesh;\n      }\n      case AttachmentType.Path: {\n        const closed = input.readBoolean();\n        const constantSpeed = input.readBoolean();\n        const vertexCount = input.readInt(true);\n        const vertices = this.readVertices(input, vertexCount);\n        const lengths = Utils.newArray(vertexCount / 3, 0);\n        for (let i = 0, n = lengths.length; i < n; i++)\n          lengths[i] = input.readFloat() * scale;\n        const color = nonessential ? input.readInt32() : 0;\n        const path = this.attachmentLoader.newPathAttachment(skin, name);\n        if (path == null)\n          return null;\n        path.closed = closed;\n        path.constantSpeed = constantSpeed;\n        path.worldVerticesLength = vertexCount << 1;\n        path.vertices = vertices.vertices;\n        path.bones = vertices.bones;\n        path.lengths = lengths;\n        if (nonessential)\n          Color.rgba8888ToColor(path.color, color);\n        return path;\n      }\n      case AttachmentType.Point: {\n        const rotation = input.readFloat();\n        const x = input.readFloat();\n        const y = input.readFloat();\n        const color = nonessential ? input.readInt32() : 0;\n        const point = this.attachmentLoader.newPointAttachment(skin, name);\n        if (point == null)\n          return null;\n        point.x = x * scale;\n        point.y = y * scale;\n        point.rotation = rotation;\n        if (nonessential)\n          Color.rgba8888ToColor(point.color, color);\n        return point;\n      }\n      case AttachmentType.Clipping: {\n        const endSlotIndex = input.readInt(true);\n        const vertexCount = input.readInt(true);\n        const vertices = this.readVertices(input, vertexCount);\n        const color = nonessential ? input.readInt32() : 0;\n        const clip = this.attachmentLoader.newClippingAttachment(skin, name);\n        if (clip == null)\n          return null;\n        clip.endSlot = skeletonData.slots[endSlotIndex];\n        clip.worldVerticesLength = vertexCount << 1;\n        clip.vertices = vertices.vertices;\n        clip.bones = vertices.bones;\n        if (nonessential)\n          Color.rgba8888ToColor(clip.color, color);\n        return clip;\n      }\n    }\n    return null;\n  }\n  readVertices(input, vertexCount) {\n    const verticesLength = vertexCount << 1;\n    const vertices = new Vertices();\n    const scale = this.scale;\n    if (!input.readBoolean()) {\n      vertices.vertices = this.readFloatArray(input, verticesLength, scale);\n      return vertices;\n    }\n    const weights = new Array();\n    const bonesArray = new Array();\n    for (let i = 0; i < vertexCount; i++) {\n      const boneCount = input.readInt(true);\n      bonesArray.push(boneCount);\n      for (let ii = 0; ii < boneCount; ii++) {\n        bonesArray.push(input.readInt(true));\n        weights.push(input.readFloat() * scale);\n        weights.push(input.readFloat() * scale);\n        weights.push(input.readFloat());\n      }\n    }\n    vertices.vertices = Utils.toFloatArray(weights);\n    vertices.bones = bonesArray;\n    return vertices;\n  }\n  readFloatArray(input, n, scale) {\n    const array = new Array(n);\n    if (scale == 1) {\n      for (let i = 0; i < n; i++)\n        array[i] = input.readFloat();\n    } else {\n      for (let i = 0; i < n; i++)\n        array[i] = input.readFloat() * scale;\n    }\n    return array;\n  }\n  readShortArray(input) {\n    const n = input.readInt(true);\n    const array = new Array(n);\n    for (let i = 0; i < n; i++)\n      array[i] = input.readShort();\n    return array;\n  }\n  readAnimation(input, name, skeletonData) {\n    const timelines = new Array();\n    const scale = this.scale;\n    let duration = 0;\n    const tempColor1 = new Color();\n    const tempColor2 = new Color();\n    for (let i = 0, n = input.readInt(true); i < n; i++) {\n      const slotIndex = input.readInt(true);\n      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n        const timelineType = input.readByte();\n        const frameCount = input.readInt(true);\n        switch (timelineType) {\n          case _SkeletonBinary.SLOT_ATTACHMENT: {\n            const timeline = new AttachmentTimeline(frameCount);\n            timeline.slotIndex = slotIndex;\n            for (let frameIndex = 0; frameIndex < frameCount; frameIndex++)\n              timeline.setFrame(frameIndex, input.readFloat(), input.readStringRef());\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[frameCount - 1]);\n            break;\n          }\n          case _SkeletonBinary.SLOT_COLOR: {\n            const timeline = new ColorTimeline(frameCount);\n            timeline.slotIndex = slotIndex;\n            for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\n              const time = input.readFloat();\n              Color.rgba8888ToColor(tempColor1, input.readInt32());\n              timeline.setFrame(frameIndex, time, tempColor1.r, tempColor1.g, tempColor1.b, tempColor1.a);\n              if (frameIndex < frameCount - 1)\n                this.readCurve(input, frameIndex, timeline);\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[(frameCount - 1) * ColorTimeline.ENTRIES]);\n            break;\n          }\n          case _SkeletonBinary.SLOT_TWO_COLOR: {\n            const timeline = new TwoColorTimeline(frameCount);\n            timeline.slotIndex = slotIndex;\n            for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\n              const time = input.readFloat();\n              Color.rgba8888ToColor(tempColor1, input.readInt32());\n              Color.rgb888ToColor(tempColor2, input.readInt32());\n              timeline.setFrame(frameIndex, time, tempColor1.r, tempColor1.g, tempColor1.b, tempColor1.a, tempColor2.r, tempColor2.g, tempColor2.b);\n              if (frameIndex < frameCount - 1)\n                this.readCurve(input, frameIndex, timeline);\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[(frameCount - 1) * TwoColorTimeline.ENTRIES]);\n            break;\n          }\n        }\n      }\n    }\n    for (let i = 0, n = input.readInt(true); i < n; i++) {\n      const boneIndex = input.readInt(true);\n      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n        const timelineType = input.readByte();\n        const frameCount = input.readInt(true);\n        switch (timelineType) {\n          case _SkeletonBinary.BONE_ROTATE: {\n            const timeline = new RotateTimeline(frameCount);\n            timeline.boneIndex = boneIndex;\n            for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\n              timeline.setFrame(frameIndex, input.readFloat(), input.readFloat());\n              if (frameIndex < frameCount - 1)\n                this.readCurve(input, frameIndex, timeline);\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[(frameCount - 1) * RotateTimeline.ENTRIES]);\n            break;\n          }\n          case _SkeletonBinary.BONE_TRANSLATE:\n          case _SkeletonBinary.BONE_SCALE:\n          case _SkeletonBinary.BONE_SHEAR: {\n            let timeline;\n            let timelineScale = 1;\n            if (timelineType == _SkeletonBinary.BONE_SCALE)\n              timeline = new ScaleTimeline(frameCount);\n            else if (timelineType == _SkeletonBinary.BONE_SHEAR)\n              timeline = new ShearTimeline(frameCount);\n            else {\n              timeline = new TranslateTimeline(frameCount);\n              timelineScale = scale;\n            }\n            timeline.boneIndex = boneIndex;\n            for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\n              timeline.setFrame(frameIndex, input.readFloat(), input.readFloat() * timelineScale, input.readFloat() * timelineScale);\n              if (frameIndex < frameCount - 1)\n                this.readCurve(input, frameIndex, timeline);\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[(frameCount - 1) * TranslateTimeline.ENTRIES]);\n            break;\n          }\n        }\n      }\n    }\n    for (let i = 0, n = input.readInt(true); i < n; i++) {\n      const index = input.readInt(true);\n      const frameCount = input.readInt(true);\n      const timeline = new IkConstraintTimeline(frameCount);\n      timeline.ikConstraintIndex = index;\n      for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\n        timeline.setFrame(frameIndex, input.readFloat(), input.readFloat(), input.readFloat() * scale, input.readByte(), input.readBoolean(), input.readBoolean());\n        if (frameIndex < frameCount - 1)\n          this.readCurve(input, frameIndex, timeline);\n      }\n      timelines.push(timeline);\n      duration = Math.max(duration, timeline.frames[(frameCount - 1) * IkConstraintTimeline.ENTRIES]);\n    }\n    for (let i = 0, n = input.readInt(true); i < n; i++) {\n      const index = input.readInt(true);\n      const frameCount = input.readInt(true);\n      const timeline = new TransformConstraintTimeline(frameCount);\n      timeline.transformConstraintIndex = index;\n      for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\n        timeline.setFrame(frameIndex, input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat());\n        if (frameIndex < frameCount - 1)\n          this.readCurve(input, frameIndex, timeline);\n      }\n      timelines.push(timeline);\n      duration = Math.max(duration, timeline.frames[(frameCount - 1) * TransformConstraintTimeline.ENTRIES]);\n    }\n    for (let i = 0, n = input.readInt(true); i < n; i++) {\n      const index = input.readInt(true);\n      const data = skeletonData.pathConstraints[index];\n      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n        const timelineType = input.readByte();\n        const frameCount = input.readInt(true);\n        switch (timelineType) {\n          case _SkeletonBinary.PATH_POSITION:\n          case _SkeletonBinary.PATH_SPACING: {\n            let timeline;\n            let timelineScale = 1;\n            if (timelineType == _SkeletonBinary.PATH_SPACING) {\n              timeline = new PathConstraintSpacingTimeline(frameCount);\n              if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed)\n                timelineScale = scale;\n            } else {\n              timeline = new PathConstraintPositionTimeline(frameCount);\n              if (data.positionMode == PositionMode.Fixed)\n                timelineScale = scale;\n            }\n            timeline.pathConstraintIndex = index;\n            for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\n              timeline.setFrame(frameIndex, input.readFloat(), input.readFloat() * timelineScale);\n              if (frameIndex < frameCount - 1)\n                this.readCurve(input, frameIndex, timeline);\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[(frameCount - 1) * PathConstraintPositionTimeline.ENTRIES]);\n            break;\n          }\n          case _SkeletonBinary.PATH_MIX: {\n            const timeline = new PathConstraintMixTimeline(frameCount);\n            timeline.pathConstraintIndex = index;\n            for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\n              timeline.setFrame(frameIndex, input.readFloat(), input.readFloat(), input.readFloat());\n              if (frameIndex < frameCount - 1)\n                this.readCurve(input, frameIndex, timeline);\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[(frameCount - 1) * PathConstraintMixTimeline.ENTRIES]);\n            break;\n          }\n        }\n      }\n    }\n    for (let i = 0, n = input.readInt(true); i < n; i++) {\n      const skin = skeletonData.skins[input.readInt(true)];\n      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n        const slotIndex = input.readInt(true);\n        for (let iii = 0, nnn = input.readInt(true); iii < nnn; iii++) {\n          const attachment = skin.getAttachment(slotIndex, input.readStringRef());\n          const weighted = attachment.bones != null;\n          const vertices = attachment.vertices;\n          const deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;\n          const frameCount = input.readInt(true);\n          const timeline = new DeformTimeline(frameCount);\n          timeline.slotIndex = slotIndex;\n          timeline.attachment = attachment;\n          for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\n            const time = input.readFloat();\n            let deform;\n            let end = input.readInt(true);\n            if (end == 0)\n              deform = weighted ? Utils.newFloatArray(deformLength) : vertices;\n            else {\n              deform = Utils.newFloatArray(deformLength);\n              const start = input.readInt(true);\n              end += start;\n              if (scale == 1) {\n                for (let v = start; v < end; v++)\n                  deform[v] = input.readFloat();\n              } else {\n                for (let v = start; v < end; v++)\n                  deform[v] = input.readFloat() * scale;\n              }\n              if (!weighted) {\n                for (let v = 0, vn = deform.length; v < vn; v++)\n                  deform[v] += vertices[v];\n              }\n            }\n            timeline.setFrame(frameIndex, time, deform);\n            if (frameIndex < frameCount - 1)\n              this.readCurve(input, frameIndex, timeline);\n          }\n          timelines.push(timeline);\n          duration = Math.max(duration, timeline.frames[frameCount - 1]);\n        }\n      }\n    }\n    const drawOrderCount = input.readInt(true);\n    if (drawOrderCount > 0) {\n      const timeline = new DrawOrderTimeline(drawOrderCount);\n      const slotCount = skeletonData.slots.length;\n      for (let i = 0; i < drawOrderCount; i++) {\n        const time = input.readFloat();\n        const offsetCount = input.readInt(true);\n        const drawOrder = Utils.newArray(slotCount, 0);\n        for (let ii = slotCount - 1; ii >= 0; ii--)\n          drawOrder[ii] = -1;\n        const unchanged = Utils.newArray(slotCount - offsetCount, 0);\n        let originalIndex = 0;\n        let unchangedIndex = 0;\n        for (let ii = 0; ii < offsetCount; ii++) {\n          const slotIndex = input.readInt(true);\n          while (originalIndex != slotIndex)\n            unchanged[unchangedIndex++] = originalIndex++;\n          drawOrder[originalIndex + input.readInt(true)] = originalIndex++;\n        }\n        while (originalIndex < slotCount)\n          unchanged[unchangedIndex++] = originalIndex++;\n        for (let ii = slotCount - 1; ii >= 0; ii--)\n          if (drawOrder[ii] == -1)\n            drawOrder[ii] = unchanged[--unchangedIndex];\n        timeline.setFrame(i, time, drawOrder);\n      }\n      timelines.push(timeline);\n      duration = Math.max(duration, timeline.frames[drawOrderCount - 1]);\n    }\n    const eventCount = input.readInt(true);\n    if (eventCount > 0) {\n      const timeline = new EventTimeline(eventCount);\n      for (let i = 0; i < eventCount; i++) {\n        const time = input.readFloat();\n        const eventData = skeletonData.events[input.readInt(true)];\n        const event = new Event(time, eventData);\n        event.intValue = input.readInt(false);\n        event.floatValue = input.readFloat();\n        event.stringValue = input.readBoolean() ? input.readString() : eventData.stringValue;\n        if (event.data.audioPath != null) {\n          event.volume = input.readFloat();\n          event.balance = input.readFloat();\n        }\n        timeline.setFrame(i, event);\n      }\n      timelines.push(timeline);\n      duration = Math.max(duration, timeline.frames[eventCount - 1]);\n    }\n    return new Animation(name, timelines, duration);\n  }\n  readCurve(input, frameIndex, timeline) {\n    switch (input.readByte()) {\n      case _SkeletonBinary.CURVE_STEPPED:\n        timeline.setStepped(frameIndex);\n        break;\n      case _SkeletonBinary.CURVE_BEZIER:\n        this.setCurve(timeline, frameIndex, input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat());\n        break;\n    }\n  }\n  setCurve(timeline, frameIndex, cx1, cy1, cx2, cy2) {\n    timeline.setCurve(frameIndex, cx1, cy1, cx2, cy2);\n  }\n};\nlet SkeletonBinary = _SkeletonBinary;\nSkeletonBinary.AttachmentTypeValues = [\n  0,\n  1,\n  2,\n  3,\n  4,\n  5,\n  6\n];\nSkeletonBinary.TransformModeValues = [\n  TransformMode.Normal,\n  TransformMode.OnlyTranslation,\n  TransformMode.NoRotationOrReflection,\n  TransformMode.NoScale,\n  TransformMode.NoScaleOrReflection\n];\nSkeletonBinary.PositionModeValues = [PositionMode.Fixed, PositionMode.Percent];\nSkeletonBinary.SpacingModeValues = [SpacingMode.Length, SpacingMode.Fixed, SpacingMode.Percent];\nSkeletonBinary.RotateModeValues = [RotateMode.Tangent, RotateMode.Chain, RotateMode.ChainScale];\nSkeletonBinary.BlendModeValues = [BLEND_MODES.NORMAL, BLEND_MODES.ADD, BLEND_MODES.MULTIPLY, BLEND_MODES.SCREEN];\nSkeletonBinary.BONE_ROTATE = 0;\nSkeletonBinary.BONE_TRANSLATE = 1;\nSkeletonBinary.BONE_SCALE = 2;\nSkeletonBinary.BONE_SHEAR = 3;\nSkeletonBinary.SLOT_ATTACHMENT = 0;\nSkeletonBinary.SLOT_COLOR = 1;\nSkeletonBinary.SLOT_TWO_COLOR = 2;\nSkeletonBinary.PATH_POSITION = 0;\nSkeletonBinary.PATH_SPACING = 1;\nSkeletonBinary.PATH_MIX = 2;\nSkeletonBinary.CURVE_LINEAR = 0;\nSkeletonBinary.CURVE_STEPPED = 1;\nSkeletonBinary.CURVE_BEZIER = 2;\nclass LinkedMesh {\n  constructor(mesh, skin, slotIndex, parent, inheritDeform) {\n    this.mesh = mesh;\n    this.skin = skin;\n    this.slotIndex = slotIndex;\n    this.parent = parent;\n    this.inheritDeform = inheritDeform;\n  }\n}\nclass Vertices {\n  constructor(bones = null, vertices = null) {\n    this.bones = bones;\n    this.vertices = vertices;\n  }\n}\n\nexport { SkeletonBinary };\n//# sourceMappingURL=SkeletonBinary.mjs.map\n","import { SkeletonBoundsBase } from '@pixi-spine/base';\n\nclass SkeletonBounds extends SkeletonBoundsBase {\n}\n\nexport { SkeletonBounds };\n//# sourceMappingURL=SkeletonBounds.mjs.map\n","import { Event } from './Event.mjs';\nimport { SkeletonData } from './SkeletonData.mjs';\nimport { SlotData } from './SlotData.mjs';\nimport { BoneData } from './BoneData.mjs';\nimport { IkConstraintData } from './IkConstraintData.mjs';\nimport { TransformConstraintData } from './TransformConstraintData.mjs';\nimport { PathConstraintData, SpacingMode } from './PathConstraintData.mjs';\nimport { Skin } from './Skin.mjs';\nimport { EventData } from './EventData.mjs';\nimport { AttachmentTimeline, ColorTimeline, TwoColorTimeline, RotateTimeline, ScaleTimeline, ShearTimeline, TranslateTimeline, IkConstraintTimeline, TransformConstraintTimeline, PathConstraintSpacingTimeline, PathConstraintPositionTimeline, PathConstraintMixTimeline, DeformTimeline, DrawOrderTimeline, EventTimeline, Animation } from './Animation.mjs';\nimport { Color, PositionMode, Utils, settings, RotateMode, TransformMode } from '@pixi-spine/base';\nimport { BLEND_MODES } from '@pixi/core';\n\nclass SkeletonJson {\n  constructor(attachmentLoader) {\n    this.scale = 1;\n    this.linkedMeshes = new Array();\n    this.attachmentLoader = attachmentLoader;\n  }\n  readSkeletonData(json) {\n    const scale = this.scale;\n    const skeletonData = new SkeletonData();\n    const root = typeof json === \"string\" ? JSON.parse(json) : json;\n    const skeletonMap = root.skeleton;\n    if (skeletonMap != null) {\n      skeletonData.hash = skeletonMap.hash;\n      skeletonData.version = skeletonMap.spine;\n      if (skeletonData.version.substr(0, 3) !== \"3.8\") {\n        const error = `Spine 3.8 loader cant load version ${skeletonMap.spine}. Please configure your pixi-spine bundle`;\n        console.error(error);\n      }\n      if (skeletonData.version === \"3.8.75\") {\n        const error = `Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine.`;\n        console.error(error);\n      }\n      skeletonData.x = skeletonMap.x;\n      skeletonData.y = skeletonMap.y;\n      skeletonData.width = skeletonMap.width;\n      skeletonData.height = skeletonMap.height;\n      skeletonData.fps = skeletonMap.fps;\n      skeletonData.imagesPath = skeletonMap.images;\n    }\n    if (root.bones) {\n      for (let i = 0; i < root.bones.length; i++) {\n        const boneMap = root.bones[i];\n        let parent = null;\n        const parentName = this.getValue(boneMap, \"parent\", null);\n        if (parentName != null) {\n          parent = skeletonData.findBone(parentName);\n          if (parent == null)\n            throw new Error(`Parent bone not found: ${parentName}`);\n        }\n        const data = new BoneData(skeletonData.bones.length, boneMap.name, parent);\n        data.length = this.getValue(boneMap, \"length\", 0) * scale;\n        data.x = this.getValue(boneMap, \"x\", 0) * scale;\n        data.y = this.getValue(boneMap, \"y\", 0) * scale;\n        data.rotation = this.getValue(boneMap, \"rotation\", 0);\n        data.scaleX = this.getValue(boneMap, \"scaleX\", 1);\n        data.scaleY = this.getValue(boneMap, \"scaleY\", 1);\n        data.shearX = this.getValue(boneMap, \"shearX\", 0);\n        data.shearY = this.getValue(boneMap, \"shearY\", 0);\n        data.transformMode = SkeletonJson.transformModeFromString(this.getValue(boneMap, \"transform\", \"normal\"));\n        data.skinRequired = this.getValue(boneMap, \"skin\", false);\n        skeletonData.bones.push(data);\n      }\n    }\n    if (root.slots) {\n      for (let i = 0; i < root.slots.length; i++) {\n        const slotMap = root.slots[i];\n        const slotName = slotMap.name;\n        const boneName = slotMap.bone;\n        const boneData = skeletonData.findBone(boneName);\n        if (boneData == null)\n          throw new Error(`Slot bone not found: ${boneName}`);\n        const data = new SlotData(skeletonData.slots.length, slotName, boneData);\n        const color = this.getValue(slotMap, \"color\", null);\n        if (color != null)\n          data.color.setFromString(color);\n        const dark = this.getValue(slotMap, \"dark\", null);\n        if (dark != null) {\n          data.darkColor = new Color(1, 1, 1, 1);\n          data.darkColor.setFromString(dark);\n        }\n        data.attachmentName = this.getValue(slotMap, \"attachment\", null);\n        data.blendMode = SkeletonJson.blendModeFromString(this.getValue(slotMap, \"blend\", \"normal\"));\n        skeletonData.slots.push(data);\n      }\n    }\n    if (root.ik) {\n      for (let i = 0; i < root.ik.length; i++) {\n        const constraintMap = root.ik[i];\n        const data = new IkConstraintData(constraintMap.name);\n        data.order = this.getValue(constraintMap, \"order\", 0);\n        data.skinRequired = this.getValue(constraintMap, \"skin\", false);\n        for (let j = 0; j < constraintMap.bones.length; j++) {\n          const boneName = constraintMap.bones[j];\n          const bone = skeletonData.findBone(boneName);\n          if (bone == null)\n            throw new Error(`IK bone not found: ${boneName}`);\n          data.bones.push(bone);\n        }\n        const targetName = constraintMap.target;\n        data.target = skeletonData.findBone(targetName);\n        if (data.target == null)\n          throw new Error(`IK target bone not found: ${targetName}`);\n        data.mix = this.getValue(constraintMap, \"mix\", 1);\n        data.softness = this.getValue(constraintMap, \"softness\", 0) * scale;\n        data.bendDirection = this.getValue(constraintMap, \"bendPositive\", true) ? 1 : -1;\n        data.compress = this.getValue(constraintMap, \"compress\", false);\n        data.stretch = this.getValue(constraintMap, \"stretch\", false);\n        data.uniform = this.getValue(constraintMap, \"uniform\", false);\n        skeletonData.ikConstraints.push(data);\n      }\n    }\n    if (root.transform) {\n      for (let i = 0; i < root.transform.length; i++) {\n        const constraintMap = root.transform[i];\n        const data = new TransformConstraintData(constraintMap.name);\n        data.order = this.getValue(constraintMap, \"order\", 0);\n        data.skinRequired = this.getValue(constraintMap, \"skin\", false);\n        for (let j = 0; j < constraintMap.bones.length; j++) {\n          const boneName = constraintMap.bones[j];\n          const bone = skeletonData.findBone(boneName);\n          if (bone == null)\n            throw new Error(`Transform constraint bone not found: ${boneName}`);\n          data.bones.push(bone);\n        }\n        const targetName = constraintMap.target;\n        data.target = skeletonData.findBone(targetName);\n        if (data.target == null)\n          throw new Error(`Transform constraint target bone not found: ${targetName}`);\n        data.local = this.getValue(constraintMap, \"local\", false);\n        data.relative = this.getValue(constraintMap, \"relative\", false);\n        data.offsetRotation = this.getValue(constraintMap, \"rotation\", 0);\n        data.offsetX = this.getValue(constraintMap, \"x\", 0) * scale;\n        data.offsetY = this.getValue(constraintMap, \"y\", 0) * scale;\n        data.offsetScaleX = this.getValue(constraintMap, \"scaleX\", 0);\n        data.offsetScaleY = this.getValue(constraintMap, \"scaleY\", 0);\n        data.offsetShearY = this.getValue(constraintMap, \"shearY\", 0);\n        data.rotateMix = this.getValue(constraintMap, \"rotateMix\", 1);\n        data.translateMix = this.getValue(constraintMap, \"translateMix\", 1);\n        data.scaleMix = this.getValue(constraintMap, \"scaleMix\", 1);\n        data.shearMix = this.getValue(constraintMap, \"shearMix\", 1);\n        skeletonData.transformConstraints.push(data);\n      }\n    }\n    if (root.path) {\n      for (let i = 0; i < root.path.length; i++) {\n        const constraintMap = root.path[i];\n        const data = new PathConstraintData(constraintMap.name);\n        data.order = this.getValue(constraintMap, \"order\", 0);\n        data.skinRequired = this.getValue(constraintMap, \"skin\", false);\n        for (let j = 0; j < constraintMap.bones.length; j++) {\n          const boneName = constraintMap.bones[j];\n          const bone = skeletonData.findBone(boneName);\n          if (bone == null)\n            throw new Error(`Transform constraint bone not found: ${boneName}`);\n          data.bones.push(bone);\n        }\n        const targetName = constraintMap.target;\n        data.target = skeletonData.findSlot(targetName);\n        if (data.target == null)\n          throw new Error(`Path target slot not found: ${targetName}`);\n        data.positionMode = SkeletonJson.positionModeFromString(this.getValue(constraintMap, \"positionMode\", \"percent\"));\n        data.spacingMode = SkeletonJson.spacingModeFromString(this.getValue(constraintMap, \"spacingMode\", \"length\"));\n        data.rotateMode = SkeletonJson.rotateModeFromString(this.getValue(constraintMap, \"rotateMode\", \"tangent\"));\n        data.offsetRotation = this.getValue(constraintMap, \"rotation\", 0);\n        data.position = this.getValue(constraintMap, \"position\", 0);\n        if (data.positionMode == PositionMode.Fixed)\n          data.position *= scale;\n        data.spacing = this.getValue(constraintMap, \"spacing\", 0);\n        if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed)\n          data.spacing *= scale;\n        data.rotateMix = this.getValue(constraintMap, \"rotateMix\", 1);\n        data.translateMix = this.getValue(constraintMap, \"translateMix\", 1);\n        skeletonData.pathConstraints.push(data);\n      }\n    }\n    if (root.skins) {\n      for (let i = 0; i < root.skins.length; i++) {\n        const skinMap = root.skins[i];\n        const skin = new Skin(skinMap.name);\n        if (skinMap.bones) {\n          for (let ii = 0; ii < skinMap.bones.length; ii++) {\n            const bone = skeletonData.findBone(skinMap.bones[ii]);\n            if (bone == null)\n              throw new Error(`Skin bone not found: ${skinMap.bones[i]}`);\n            skin.bones.push(bone);\n          }\n        }\n        if (skinMap.ik) {\n          for (let ii = 0; ii < skinMap.ik.length; ii++) {\n            const constraint = skeletonData.findIkConstraint(skinMap.ik[ii]);\n            if (constraint == null)\n              throw new Error(`Skin IK constraint not found: ${skinMap.ik[i]}`);\n            skin.constraints.push(constraint);\n          }\n        }\n        if (skinMap.transform) {\n          for (let ii = 0; ii < skinMap.transform.length; ii++) {\n            const constraint = skeletonData.findTransformConstraint(skinMap.transform[ii]);\n            if (constraint == null)\n              throw new Error(`Skin transform constraint not found: ${skinMap.transform[i]}`);\n            skin.constraints.push(constraint);\n          }\n        }\n        if (skinMap.path) {\n          for (let ii = 0; ii < skinMap.path.length; ii++) {\n            const constraint = skeletonData.findPathConstraint(skinMap.path[ii]);\n            if (constraint == null)\n              throw new Error(`Skin path constraint not found: ${skinMap.path[i]}`);\n            skin.constraints.push(constraint);\n          }\n        }\n        for (const slotName in skinMap.attachments) {\n          const slot = skeletonData.findSlot(slotName);\n          if (slot == null)\n            throw new Error(`Slot not found: ${slotName}`);\n          const slotMap = skinMap.attachments[slotName];\n          for (const entryName in slotMap) {\n            const attachment = this.readAttachment(slotMap[entryName], skin, slot.index, entryName, skeletonData);\n            if (attachment != null)\n              skin.setAttachment(slot.index, entryName, attachment);\n          }\n        }\n        skeletonData.skins.push(skin);\n        if (skin.name == \"default\")\n          skeletonData.defaultSkin = skin;\n      }\n    }\n    for (let i = 0, n = this.linkedMeshes.length; i < n; i++) {\n      const linkedMesh = this.linkedMeshes[i];\n      const skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\n      if (skin == null)\n        throw new Error(`Skin not found: ${linkedMesh.skin}`);\n      const parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\n      if (parent == null)\n        throw new Error(`Parent mesh not found: ${linkedMesh.parent}`);\n      linkedMesh.mesh.deformAttachment = linkedMesh.inheritDeform ? parent : linkedMesh.mesh;\n      linkedMesh.mesh.setParentMesh(parent);\n    }\n    this.linkedMeshes.length = 0;\n    if (root.events) {\n      for (const eventName in root.events) {\n        const eventMap = root.events[eventName];\n        const data = new EventData(eventName);\n        data.intValue = this.getValue(eventMap, \"int\", 0);\n        data.floatValue = this.getValue(eventMap, \"float\", 0);\n        data.stringValue = this.getValue(eventMap, \"string\", \"\");\n        data.audioPath = this.getValue(eventMap, \"audio\", null);\n        if (data.audioPath != null) {\n          data.volume = this.getValue(eventMap, \"volume\", 1);\n          data.balance = this.getValue(eventMap, \"balance\", 0);\n        }\n        skeletonData.events.push(data);\n      }\n    }\n    if (root.animations) {\n      for (const animationName in root.animations) {\n        const animationMap = root.animations[animationName];\n        this.readAnimation(animationMap, animationName, skeletonData);\n      }\n    }\n    return skeletonData;\n  }\n  readAttachment(map, skin, slotIndex, name, skeletonData) {\n    const scale = this.scale;\n    name = this.getValue(map, \"name\", name);\n    const type = this.getValue(map, \"type\", \"region\");\n    switch (type) {\n      case \"region\": {\n        const path = this.getValue(map, \"path\", name);\n        const region = this.attachmentLoader.newRegionAttachment(skin, name, path);\n        if (region == null)\n          return null;\n        region.path = path;\n        region.x = this.getValue(map, \"x\", 0) * scale;\n        region.y = this.getValue(map, \"y\", 0) * scale;\n        region.scaleX = this.getValue(map, \"scaleX\", 1);\n        region.scaleY = this.getValue(map, \"scaleY\", 1);\n        region.rotation = this.getValue(map, \"rotation\", 0);\n        region.width = map.width * scale;\n        region.height = map.height * scale;\n        const color = this.getValue(map, \"color\", null);\n        if (color != null)\n          region.color.setFromString(color);\n        return region;\n      }\n      case \"boundingbox\": {\n        const box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\n        if (box == null)\n          return null;\n        this.readVertices(map, box, map.vertexCount << 1);\n        const color = this.getValue(map, \"color\", null);\n        if (color != null)\n          box.color.setFromString(color);\n        return box;\n      }\n      case \"mesh\":\n      case \"linkedmesh\": {\n        const path = this.getValue(map, \"path\", name);\n        const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\n        if (mesh == null)\n          return null;\n        mesh.path = path;\n        const color = this.getValue(map, \"color\", null);\n        if (color != null)\n          mesh.color.setFromString(color);\n        mesh.width = this.getValue(map, \"width\", 0) * scale;\n        mesh.height = this.getValue(map, \"height\", 0) * scale;\n        const parent = this.getValue(map, \"parent\", null);\n        if (parent != null) {\n          this.linkedMeshes.push(new LinkedMesh(mesh, this.getValue(map, \"skin\", null), slotIndex, parent, this.getValue(map, \"deform\", true)));\n          return mesh;\n        }\n        const uvs = map.uvs;\n        this.readVertices(map, mesh, uvs.length);\n        mesh.triangles = map.triangles;\n        mesh.regionUVs = new Float32Array(uvs);\n        mesh.edges = this.getValue(map, \"edges\", null);\n        mesh.hullLength = this.getValue(map, \"hull\", 0) * 2;\n        return mesh;\n      }\n      case \"path\": {\n        const path = this.attachmentLoader.newPathAttachment(skin, name);\n        if (path == null)\n          return null;\n        path.closed = this.getValue(map, \"closed\", false);\n        path.constantSpeed = this.getValue(map, \"constantSpeed\", true);\n        const vertexCount = map.vertexCount;\n        this.readVertices(map, path, vertexCount << 1);\n        const lengths = Utils.newArray(vertexCount / 3, 0);\n        for (let i = 0; i < map.lengths.length; i++)\n          lengths[i] = map.lengths[i] * scale;\n        path.lengths = lengths;\n        const color = this.getValue(map, \"color\", null);\n        if (color != null)\n          path.color.setFromString(color);\n        return path;\n      }\n      case \"point\": {\n        const point = this.attachmentLoader.newPointAttachment(skin, name);\n        if (point == null)\n          return null;\n        point.x = this.getValue(map, \"x\", 0) * scale;\n        point.y = this.getValue(map, \"y\", 0) * scale;\n        point.rotation = this.getValue(map, \"rotation\", 0);\n        const color = this.getValue(map, \"color\", null);\n        if (color != null)\n          point.color.setFromString(color);\n        return point;\n      }\n      case \"clipping\": {\n        const clip = this.attachmentLoader.newClippingAttachment(skin, name);\n        if (clip == null)\n          return null;\n        const end = this.getValue(map, \"end\", null);\n        if (end != null) {\n          const slot = skeletonData.findSlot(end);\n          if (slot == null)\n            throw new Error(`Clipping end slot not found: ${end}`);\n          clip.endSlot = slot;\n        }\n        const vertexCount = map.vertexCount;\n        this.readVertices(map, clip, vertexCount << 1);\n        const color = this.getValue(map, \"color\", null);\n        if (color != null)\n          clip.color.setFromString(color);\n        return clip;\n      }\n    }\n    return null;\n  }\n  readVertices(map, attachment, verticesLength) {\n    const scale = this.scale;\n    attachment.worldVerticesLength = verticesLength;\n    const vertices = map.vertices;\n    if (verticesLength == vertices.length) {\n      const scaledVertices = Utils.toFloatArray(vertices);\n      if (scale != 1) {\n        for (let i = 0, n = vertices.length; i < n; i++)\n          scaledVertices[i] *= scale;\n      }\n      attachment.vertices = scaledVertices;\n      return;\n    }\n    const weights = new Array();\n    const bones = new Array();\n    for (let i = 0, n = vertices.length; i < n; ) {\n      const boneCount = vertices[i++];\n      bones.push(boneCount);\n      for (let nn = i + boneCount * 4; i < nn; i += 4) {\n        bones.push(vertices[i]);\n        weights.push(vertices[i + 1] * scale);\n        weights.push(vertices[i + 2] * scale);\n        weights.push(vertices[i + 3]);\n      }\n    }\n    attachment.bones = bones;\n    attachment.vertices = Utils.toFloatArray(weights);\n  }\n  readAnimation(map, name, skeletonData) {\n    const scale = this.scale;\n    const timelines = new Array();\n    let duration = 0;\n    if (map.slots) {\n      for (const slotName in map.slots) {\n        const slotMap = map.slots[slotName];\n        const slotIndex = skeletonData.findSlotIndex(slotName);\n        if (slotIndex == -1)\n          throw new Error(`Slot not found: ${slotName}`);\n        for (const timelineName in slotMap) {\n          const timelineMap = slotMap[timelineName];\n          if (timelineName == \"attachment\") {\n            const timeline = new AttachmentTimeline(timelineMap.length);\n            timeline.slotIndex = slotIndex;\n            let frameIndex = 0;\n            for (let i = 0; i < timelineMap.length; i++) {\n              const valueMap = timelineMap[i];\n              timeline.setFrame(frameIndex++, this.getValue(valueMap, \"time\", 0), valueMap.name);\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n          } else if (timelineName == \"color\") {\n            const timeline = new ColorTimeline(timelineMap.length);\n            timeline.slotIndex = slotIndex;\n            let frameIndex = 0;\n            for (let i = 0; i < timelineMap.length; i++) {\n              const valueMap = timelineMap[i];\n              const color = new Color();\n              color.setFromString(valueMap.color || \"ffffffff\");\n              timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), color.r, color.g, color.b, color.a);\n              this.readCurve(valueMap, timeline, frameIndex);\n              frameIndex++;\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * ColorTimeline.ENTRIES]);\n          } else if (timelineName == \"twoColor\") {\n            const timeline = new TwoColorTimeline(timelineMap.length);\n            timeline.slotIndex = slotIndex;\n            let frameIndex = 0;\n            for (let i = 0; i < timelineMap.length; i++) {\n              const valueMap = timelineMap[i];\n              const light = new Color();\n              const dark = new Color();\n              light.setFromString(valueMap.light);\n              dark.setFromString(valueMap.dark);\n              timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), light.r, light.g, light.b, light.a, dark.r, dark.g, dark.b);\n              this.readCurve(valueMap, timeline, frameIndex);\n              frameIndex++;\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TwoColorTimeline.ENTRIES]);\n          } else\n            throw new Error(`Invalid timeline type for a slot: ${timelineName} (${slotName})`);\n        }\n      }\n    }\n    if (map.bones) {\n      for (const boneName in map.bones) {\n        const boneMap = map.bones[boneName];\n        const boneIndex = skeletonData.findBoneIndex(boneName);\n        if (boneIndex == -1)\n          throw new Error(`Bone not found: ${boneName}`);\n        for (const timelineName in boneMap) {\n          const timelineMap = boneMap[timelineName];\n          if (timelineName === \"rotate\") {\n            const timeline = new RotateTimeline(timelineMap.length);\n            timeline.boneIndex = boneIndex;\n            let frameIndex = 0;\n            for (let i = 0; i < timelineMap.length; i++) {\n              const valueMap = timelineMap[i];\n              timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), this.getValue(valueMap, \"angle\", 0));\n              this.readCurve(valueMap, timeline, frameIndex);\n              frameIndex++;\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * RotateTimeline.ENTRIES]);\n          } else if (timelineName === \"translate\" || timelineName === \"scale\" || timelineName === \"shear\") {\n            let timeline = null;\n            let timelineScale = 1;\n            let defaultValue = 0;\n            if (timelineName === \"scale\") {\n              timeline = new ScaleTimeline(timelineMap.length);\n              defaultValue = 1;\n            } else if (timelineName === \"shear\")\n              timeline = new ShearTimeline(timelineMap.length);\n            else {\n              timeline = new TranslateTimeline(timelineMap.length);\n              timelineScale = scale;\n            }\n            timeline.boneIndex = boneIndex;\n            let frameIndex = 0;\n            for (let i = 0; i < timelineMap.length; i++) {\n              const valueMap = timelineMap[i];\n              const x = this.getValue(valueMap, \"x\", defaultValue);\n              const y = this.getValue(valueMap, \"y\", defaultValue);\n              timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), x * timelineScale, y * timelineScale);\n              this.readCurve(valueMap, timeline, frameIndex);\n              frameIndex++;\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TranslateTimeline.ENTRIES]);\n          } else\n            throw new Error(`Invalid timeline type for a bone: ${timelineName} (${boneName})`);\n        }\n      }\n    }\n    if (map.ik) {\n      for (const constraintName in map.ik) {\n        const constraintMap = map.ik[constraintName];\n        const constraint = skeletonData.findIkConstraint(constraintName);\n        const timeline = new IkConstraintTimeline(constraintMap.length);\n        timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(constraint);\n        let frameIndex = 0;\n        for (let i = 0; i < constraintMap.length; i++) {\n          const valueMap = constraintMap[i];\n          timeline.setFrame(\n            frameIndex,\n            this.getValue(valueMap, \"time\", 0),\n            this.getValue(valueMap, \"mix\", 1),\n            this.getValue(valueMap, \"softness\", 0) * scale,\n            this.getValue(valueMap, \"bendPositive\", true) ? 1 : -1,\n            this.getValue(valueMap, \"compress\", false),\n            this.getValue(valueMap, \"stretch\", false)\n          );\n          this.readCurve(valueMap, timeline, frameIndex);\n          frameIndex++;\n        }\n        timelines.push(timeline);\n        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * IkConstraintTimeline.ENTRIES]);\n      }\n    }\n    if (map.transform) {\n      for (const constraintName in map.transform) {\n        const constraintMap = map.transform[constraintName];\n        const constraint = skeletonData.findTransformConstraint(constraintName);\n        const timeline = new TransformConstraintTimeline(constraintMap.length);\n        timeline.transformConstraintIndex = skeletonData.transformConstraints.indexOf(constraint);\n        let frameIndex = 0;\n        for (let i = 0; i < constraintMap.length; i++) {\n          const valueMap = constraintMap[i];\n          timeline.setFrame(\n            frameIndex,\n            this.getValue(valueMap, \"time\", 0),\n            this.getValue(valueMap, \"rotateMix\", 1),\n            this.getValue(valueMap, \"translateMix\", 1),\n            this.getValue(valueMap, \"scaleMix\", 1),\n            this.getValue(valueMap, \"shearMix\", 1)\n          );\n          this.readCurve(valueMap, timeline, frameIndex);\n          frameIndex++;\n        }\n        timelines.push(timeline);\n        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TransformConstraintTimeline.ENTRIES]);\n      }\n    }\n    if (map.path) {\n      for (const constraintName in map.path) {\n        const constraintMap = map.path[constraintName];\n        const index = skeletonData.findPathConstraintIndex(constraintName);\n        if (index == -1)\n          throw new Error(`Path constraint not found: ${constraintName}`);\n        const data = skeletonData.pathConstraints[index];\n        for (const timelineName in constraintMap) {\n          const timelineMap = constraintMap[timelineName];\n          if (timelineName === \"position\" || timelineName === \"spacing\") {\n            let timeline = null;\n            let timelineScale = 1;\n            if (timelineName === \"spacing\") {\n              timeline = new PathConstraintSpacingTimeline(timelineMap.length);\n              if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed)\n                timelineScale = scale;\n            } else {\n              timeline = new PathConstraintPositionTimeline(timelineMap.length);\n              if (data.positionMode == PositionMode.Fixed)\n                timelineScale = scale;\n            }\n            timeline.pathConstraintIndex = index;\n            let frameIndex = 0;\n            for (let i = 0; i < timelineMap.length; i++) {\n              const valueMap = timelineMap[i];\n              timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), this.getValue(valueMap, timelineName, 0) * timelineScale);\n              this.readCurve(valueMap, timeline, frameIndex);\n              frameIndex++;\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * PathConstraintPositionTimeline.ENTRIES]);\n          } else if (timelineName === \"mix\") {\n            const timeline = new PathConstraintMixTimeline(timelineMap.length);\n            timeline.pathConstraintIndex = index;\n            let frameIndex = 0;\n            for (let i = 0; i < timelineMap.length; i++) {\n              const valueMap = timelineMap[i];\n              timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), this.getValue(valueMap, \"rotateMix\", 1), this.getValue(valueMap, \"translateMix\", 1));\n              this.readCurve(valueMap, timeline, frameIndex);\n              frameIndex++;\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * PathConstraintMixTimeline.ENTRIES]);\n          }\n        }\n      }\n    }\n    if (map.deform) {\n      for (const deformName in map.deform) {\n        const deformMap = map.deform[deformName];\n        const skin = skeletonData.findSkin(deformName);\n        if (skin == null) {\n          if (settings.FAIL_ON_NON_EXISTING_SKIN) {\n            throw new Error(`Skin not found: ${deformName}`);\n          } else {\n            continue;\n          }\n        }\n        for (const slotName in deformMap) {\n          const slotMap = deformMap[slotName];\n          const slotIndex = skeletonData.findSlotIndex(slotName);\n          if (slotIndex == -1)\n            throw new Error(`Slot not found: ${slotMap.name}`);\n          for (const timelineName in slotMap) {\n            const timelineMap = slotMap[timelineName];\n            const attachment = skin.getAttachment(slotIndex, timelineName);\n            if (attachment == null)\n              throw new Error(`Deform attachment not found: ${timelineMap.name}`);\n            const weighted = attachment.bones != null;\n            const vertices = attachment.vertices;\n            const deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;\n            const timeline = new DeformTimeline(timelineMap.length);\n            timeline.slotIndex = slotIndex;\n            timeline.attachment = attachment;\n            let frameIndex = 0;\n            for (let j = 0; j < timelineMap.length; j++) {\n              const valueMap = timelineMap[j];\n              let deform;\n              const verticesValue = this.getValue(valueMap, \"vertices\", null);\n              if (verticesValue == null)\n                deform = weighted ? Utils.newFloatArray(deformLength) : vertices;\n              else {\n                deform = Utils.newFloatArray(deformLength);\n                const start = this.getValue(valueMap, \"offset\", 0);\n                Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);\n                if (scale != 1) {\n                  for (let i = start, n = i + verticesValue.length; i < n; i++)\n                    deform[i] *= scale;\n                }\n                if (!weighted) {\n                  for (let i = 0; i < deformLength; i++)\n                    deform[i] += vertices[i];\n                }\n              }\n              timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), deform);\n              this.readCurve(valueMap, timeline, frameIndex);\n              frameIndex++;\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n          }\n        }\n      }\n    }\n    let drawOrderNode = map.drawOrder;\n    if (drawOrderNode == null)\n      drawOrderNode = map.draworder;\n    if (drawOrderNode != null) {\n      const timeline = new DrawOrderTimeline(drawOrderNode.length);\n      const slotCount = skeletonData.slots.length;\n      let frameIndex = 0;\n      for (let j = 0; j < drawOrderNode.length; j++) {\n        const drawOrderMap = drawOrderNode[j];\n        let drawOrder = null;\n        const offsets = this.getValue(drawOrderMap, \"offsets\", null);\n        if (offsets != null) {\n          drawOrder = Utils.newArray(slotCount, -1);\n          const unchanged = Utils.newArray(slotCount - offsets.length, 0);\n          let originalIndex = 0;\n          let unchangedIndex = 0;\n          for (let i = 0; i < offsets.length; i++) {\n            const offsetMap = offsets[i];\n            const slotIndex = skeletonData.findSlotIndex(offsetMap.slot);\n            if (slotIndex == -1)\n              throw new Error(`Slot not found: ${offsetMap.slot}`);\n            while (originalIndex != slotIndex)\n              unchanged[unchangedIndex++] = originalIndex++;\n            drawOrder[originalIndex + offsetMap.offset] = originalIndex++;\n          }\n          while (originalIndex < slotCount)\n            unchanged[unchangedIndex++] = originalIndex++;\n          for (let i = slotCount - 1; i >= 0; i--)\n            if (drawOrder[i] == -1)\n              drawOrder[i] = unchanged[--unchangedIndex];\n        }\n        timeline.setFrame(frameIndex++, this.getValue(drawOrderMap, \"time\", 0), drawOrder);\n      }\n      timelines.push(timeline);\n      duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n    }\n    if (map.events) {\n      const timeline = new EventTimeline(map.events.length);\n      let frameIndex = 0;\n      for (let i = 0; i < map.events.length; i++) {\n        const eventMap = map.events[i];\n        const eventData = skeletonData.findEvent(eventMap.name);\n        if (eventData == null)\n          throw new Error(`Event not found: ${eventMap.name}`);\n        const event = new Event(Utils.toSinglePrecision(this.getValue(eventMap, \"time\", 0)), eventData);\n        event.intValue = this.getValue(eventMap, \"int\", eventData.intValue);\n        event.floatValue = this.getValue(eventMap, \"float\", eventData.floatValue);\n        event.stringValue = this.getValue(eventMap, \"string\", eventData.stringValue);\n        if (event.data.audioPath != null) {\n          event.volume = this.getValue(eventMap, \"volume\", 1);\n          event.balance = this.getValue(eventMap, \"balance\", 0);\n        }\n        timeline.setFrame(frameIndex++, event);\n      }\n      timelines.push(timeline);\n      duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n    }\n    if (isNaN(duration)) {\n      throw new Error(\"Error while parsing animation, duration is NaN\");\n    }\n    skeletonData.animations.push(new Animation(name, timelines, duration));\n  }\n  readCurve(map, timeline, frameIndex) {\n    if (!map.hasOwnProperty(\"curve\"))\n      return;\n    if (map.curve === \"stepped\")\n      timeline.setStepped(frameIndex);\n    else {\n      const curve = map.curve;\n      timeline.setCurve(frameIndex, curve, this.getValue(map, \"c2\", 0), this.getValue(map, \"c3\", 1), this.getValue(map, \"c4\", 1));\n    }\n  }\n  getValue(map, prop, defaultValue) {\n    return map[prop] !== void 0 ? map[prop] : defaultValue;\n  }\n  static blendModeFromString(str) {\n    str = str.toLowerCase();\n    if (str == \"normal\")\n      return BLEND_MODES.NORMAL;\n    if (str == \"additive\")\n      return BLEND_MODES.ADD;\n    if (str == \"multiply\")\n      return BLEND_MODES.MULTIPLY;\n    if (str == \"screen\")\n      return BLEND_MODES.SCREEN;\n    throw new Error(`Unknown blend mode: ${str}`);\n  }\n  static positionModeFromString(str) {\n    str = str.toLowerCase();\n    if (str == \"fixed\")\n      return PositionMode.Fixed;\n    if (str == \"percent\")\n      return PositionMode.Percent;\n    throw new Error(`Unknown position mode: ${str}`);\n  }\n  static spacingModeFromString(str) {\n    str = str.toLowerCase();\n    if (str == \"length\")\n      return SpacingMode.Length;\n    if (str == \"fixed\")\n      return SpacingMode.Fixed;\n    if (str == \"percent\")\n      return SpacingMode.Percent;\n    throw new Error(`Unknown position mode: ${str}`);\n  }\n  static rotateModeFromString(str) {\n    str = str.toLowerCase();\n    if (str == \"tangent\")\n      return RotateMode.Tangent;\n    if (str == \"chain\")\n      return RotateMode.Chain;\n    if (str == \"chainscale\")\n      return RotateMode.ChainScale;\n    throw new Error(`Unknown rotate mode: ${str}`);\n  }\n  static transformModeFromString(str) {\n    str = str.toLowerCase();\n    if (str == \"normal\")\n      return TransformMode.Normal;\n    if (str == \"onlytranslation\")\n      return TransformMode.OnlyTranslation;\n    if (str == \"norotationorreflection\")\n      return TransformMode.NoRotationOrReflection;\n    if (str == \"noscale\")\n      return TransformMode.NoScale;\n    if (str == \"noscaleorreflection\")\n      return TransformMode.NoScaleOrReflection;\n    throw new Error(`Unknown transform mode: ${str}`);\n  }\n}\nclass LinkedMesh {\n  constructor(mesh, skin, slotIndex, parent, inheritDeform) {\n    this.mesh = mesh;\n    this.skin = skin;\n    this.slotIndex = slotIndex;\n    this.parent = parent;\n    this.inheritDeform = inheritDeform;\n  }\n}\n\nexport { SkeletonJson };\n//# sourceMappingURL=SkeletonJson.mjs.map\n","import { SpineBase } from '@pixi-spine/base';\nimport { Skeleton } from './core/Skeleton.mjs';\nimport { AnimationState } from './core/AnimationState.mjs';\nimport { AnimationStateData } from './core/AnimationStateData.mjs';\n\nclass Spine extends SpineBase {\n  createSkeleton(spineData) {\n    this.skeleton = new Skeleton(spineData);\n    this.skeleton.updateWorldTransform();\n    this.stateData = new AnimationStateData(spineData);\n    this.state = new AnimationState(this.stateData);\n  }\n}\n\nexport { Spine };\n//# sourceMappingURL=Spine.mjs.map\n","class Attachment {\n  constructor(name) {\n    if (name == null)\n      throw new Error(\"name cannot be null.\");\n    this.name = name;\n  }\n}\nconst _VertexAttachment = class extends Attachment {\n  constructor(name) {\n    super(name);\n    this.id = (_VertexAttachment.nextID++ & 65535) << 11;\n    this.worldVerticesLength = 0;\n  }\n  computeWorldVerticesOld(slot, worldVertices) {\n    this.computeWorldVertices(slot, 0, this.worldVerticesLength, worldVertices, 0, 2);\n  }\n  /** Transforms local vertices to world coordinates.\n   * @param start The index of the first local vertex value to transform. Each vertex has 2 values, x and y.\n   * @param count The number of world vertex values to output. Must be <= {@link #getWorldVerticesLength()} - start.\n   * @param worldVertices The output world vertices. Must have a length >= offset + count.\n   * @param offset The worldVertices index to begin writing values. */\n  computeWorldVertices(slot, start, count, worldVertices, offset, stride) {\n    count = offset + (count >> 1) * stride;\n    const skeleton = slot.bone.skeleton;\n    const deformArray = slot.attachmentVertices;\n    let vertices = this.vertices;\n    const bones = this.bones;\n    if (bones == null) {\n      if (deformArray.length > 0)\n        vertices = deformArray;\n      const mat = slot.bone.matrix;\n      const x = mat.tx;\n      const y = mat.ty;\n      const a = mat.a;\n      const b = mat.c;\n      const c = mat.b;\n      const d = mat.d;\n      for (let v2 = start, w = offset; w < count; v2 += 2, w += stride) {\n        const vx = vertices[v2];\n        const vy = vertices[v2 + 1];\n        worldVertices[w] = vx * a + vy * b + x;\n        worldVertices[w + 1] = vx * c + vy * d + y;\n      }\n      return;\n    }\n    let v = 0;\n    let skip = 0;\n    for (let i = 0; i < start; i += 2) {\n      const n = bones[v];\n      v += n + 1;\n      skip += n;\n    }\n    const skeletonBones = skeleton.bones;\n    if (deformArray.length == 0) {\n      for (let w = offset, b = skip * 3; w < count; w += stride) {\n        let wx = 0;\n        let wy = 0;\n        let n = bones[v++];\n        n += v;\n        for (; v < n; v++, b += 3) {\n          const mat = skeletonBones[bones[v]].matrix;\n          const vx = vertices[b];\n          const vy = vertices[b + 1];\n          const weight = vertices[b + 2];\n          wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\n          wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\n        }\n        worldVertices[w] = wx;\n        worldVertices[w + 1] = wy;\n      }\n    } else {\n      const deform = deformArray;\n      for (let w = offset, b = skip * 3, f = skip << 1; w < count; w += stride) {\n        let wx = 0;\n        let wy = 0;\n        let n = bones[v++];\n        n += v;\n        for (; v < n; v++, b += 3, f += 2) {\n          const mat = skeletonBones[bones[v]].matrix;\n          const vx = vertices[b] + deform[f];\n          const vy = vertices[b + 1] + deform[f + 1];\n          const weight = vertices[b + 2];\n          wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\n          wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\n        }\n        worldVertices[w] = wx;\n        worldVertices[w + 1] = wy;\n      }\n    }\n  }\n  /** Returns true if a deform originally applied to the specified attachment should be applied to this attachment. */\n  applyDeform(sourceAttachment) {\n    return this == sourceAttachment;\n  }\n};\nlet VertexAttachment = _VertexAttachment;\nVertexAttachment.nextID = 0;\n\nexport { Attachment, VertexAttachment };\n//# sourceMappingURL=Attachment.mjs.map\n","import { VertexAttachment } from './Attachment.mjs';\nimport { AttachmentType, Color } from '@pixi-spine/base';\n\nclass BoundingBoxAttachment extends VertexAttachment {\n  constructor(name) {\n    super(name);\n    this.type = AttachmentType.BoundingBox;\n    this.color = new Color(1, 1, 1, 1);\n  }\n}\n\nexport { BoundingBoxAttachment };\n//# sourceMappingURL=BoundingBoxAttachment.mjs.map\n","import { VertexAttachment } from './Attachment.mjs';\nimport { AttachmentType, Color } from '@pixi-spine/base';\n\nclass ClippingAttachment extends VertexAttachment {\n  // ce3a3aff\n  constructor(name) {\n    super(name);\n    this.type = AttachmentType.Clipping;\n    // Nonessential.\n    this.color = new Color(0.2275, 0.2275, 0.8078, 1);\n  }\n}\n\nexport { ClippingAttachment };\n//# sourceMappingURL=ClippingAttachment.mjs.map\n","import { VertexAttachment } from './Attachment.mjs';\nimport { AttachmentType, Color } from '@pixi-spine/base';\n\nclass MeshAttachment extends VertexAttachment {\n  constructor(name) {\n    super(name);\n    this.type = AttachmentType.Mesh;\n    this.color = new Color(1, 1, 1, 1);\n    this.inheritDeform = false;\n    this.tempColor = new Color(0, 0, 0, 0);\n  }\n  applyDeform(sourceAttachment) {\n    return this == sourceAttachment || this.inheritDeform && this.parentMesh == sourceAttachment;\n  }\n  getParentMesh() {\n    return this.parentMesh;\n  }\n  /** @param parentMesh May be null. */\n  setParentMesh(parentMesh) {\n    this.parentMesh = parentMesh;\n    if (parentMesh != null) {\n      this.bones = parentMesh.bones;\n      this.vertices = parentMesh.vertices;\n      this.worldVerticesLength = parentMesh.worldVerticesLength;\n      this.regionUVs = parentMesh.regionUVs;\n      this.triangles = parentMesh.triangles;\n      this.hullLength = parentMesh.hullLength;\n      this.worldVerticesLength = parentMesh.worldVerticesLength;\n    }\n  }\n  // computeWorldVerticesWith(slot, 0, this.worldVerticesLength, worldVertices, 0);\n}\n\nexport { MeshAttachment };\n//# sourceMappingURL=MeshAttachment.mjs.map\n","import { VertexAttachment } from './Attachment.mjs';\nimport { AttachmentType, Color } from '@pixi-spine/base';\n\nclass PathAttachment extends VertexAttachment {\n  constructor(name) {\n    super(name);\n    this.type = AttachmentType.Path;\n    this.closed = false;\n    this.constantSpeed = false;\n    this.color = new Color(1, 1, 1, 1);\n  }\n}\n\nexport { PathAttachment };\n//# sourceMappingURL=PathAttachment.mjs.map\n","import { VertexAttachment } from './Attachment.mjs';\nimport { AttachmentType, Color, MathUtils } from '@pixi-spine/base';\n\nclass PointAttachment extends VertexAttachment {\n  constructor(name) {\n    super(name);\n    this.type = AttachmentType.Point;\n    this.color = new Color(0.38, 0.94, 0, 1);\n  }\n  computeWorldPosition(bone, point) {\n    const mat = bone.matrix;\n    point.x = this.x * mat.a + this.y * mat.c + bone.worldX;\n    point.y = this.x * mat.b + this.y * mat.d + bone.worldY;\n    return point;\n  }\n  computeWorldRotation(bone) {\n    const mat = bone.matrix;\n    const cos = MathUtils.cosDeg(this.rotation);\n    const sin = MathUtils.sinDeg(this.rotation);\n    const x = cos * mat.a + sin * mat.c;\n    const y = cos * mat.b + sin * mat.d;\n    return Math.atan2(y, x) * MathUtils.radDeg;\n  }\n}\n\nexport { PointAttachment };\n//# sourceMappingURL=PointAttachment.mjs.map\n","import { Color } from '@pixi-spine/base';\n\nclass Slot {\n  constructor(data, bone) {\n    this.attachmentVertices = new Array();\n    if (data == null)\n      throw new Error(\"data cannot be null.\");\n    if (bone == null)\n      throw new Error(\"bone cannot be null.\");\n    this.data = data;\n    this.bone = bone;\n    this.color = new Color();\n    this.darkColor = data.darkColor == null ? null : new Color();\n    this.setToSetupPose();\n    this.blendMode = this.data.blendMode;\n  }\n  /** @return May be null. */\n  getAttachment() {\n    return this.attachment;\n  }\n  /** Sets the attachment and if it changed, resets {@link #getAttachmentTime()} and clears {@link #getAttachmentVertices()}.\n   * @param attachment May be null. */\n  setAttachment(attachment) {\n    if (this.attachment == attachment)\n      return;\n    this.attachment = attachment;\n    this.attachmentTime = this.bone.skeleton.time;\n    this.attachmentVertices.length = 0;\n  }\n  setAttachmentTime(time) {\n    this.attachmentTime = this.bone.skeleton.time - time;\n  }\n  /** Returns the time since the attachment was set. */\n  getAttachmentTime() {\n    return this.bone.skeleton.time - this.attachmentTime;\n  }\n  setToSetupPose() {\n    this.color.setFromColor(this.data.color);\n    if (this.darkColor != null)\n      this.darkColor.setFromColor(this.data.darkColor);\n    if (this.data.attachmentName == null)\n      this.attachment = null;\n    else {\n      this.attachment = null;\n      this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));\n    }\n  }\n}\n\nexport { Slot };\n//# sourceMappingURL=Slot.mjs.map\n","import { Attachment } from './Attachment.mjs';\nimport { AttachmentType, Color, Utils } from '@pixi-spine/base';\nimport { Slot } from '../Slot.mjs';\n\nconst _RegionAttachment = class extends Attachment {\n  constructor(name) {\n    super(name);\n    this.type = AttachmentType.Region;\n    this.x = 0;\n    this.y = 0;\n    this.scaleX = 1;\n    this.scaleY = 1;\n    this.rotation = 0;\n    this.width = 0;\n    this.height = 0;\n    this.color = new Color(1, 1, 1, 1);\n    this.offset = Utils.newFloatArray(8);\n    this.uvs = Utils.newFloatArray(8);\n    this.tempColor = new Color(1, 1, 1, 1);\n  }\n  updateOffset() {\n    const regionScaleX = this.width / this.region.originalWidth * this.scaleX;\n    const regionScaleY = this.height / this.region.originalHeight * this.scaleY;\n    const localX = -this.width / 2 * this.scaleX + this.region.offsetX * regionScaleX;\n    const localY = -this.height / 2 * this.scaleY + this.region.offsetY * regionScaleY;\n    const localX2 = localX + this.region.width * regionScaleX;\n    const localY2 = localY + this.region.height * regionScaleY;\n    const radians = this.rotation * Math.PI / 180;\n    const cos = Math.cos(radians);\n    const sin = Math.sin(radians);\n    const localXCos = localX * cos + this.x;\n    const localXSin = localX * sin;\n    const localYCos = localY * cos + this.y;\n    const localYSin = localY * sin;\n    const localX2Cos = localX2 * cos + this.x;\n    const localX2Sin = localX2 * sin;\n    const localY2Cos = localY2 * cos + this.y;\n    const localY2Sin = localY2 * sin;\n    const offset = this.offset;\n    offset[_RegionAttachment.OX1] = localXCos - localYSin;\n    offset[_RegionAttachment.OY1] = localYCos + localXSin;\n    offset[_RegionAttachment.OX2] = localXCos - localY2Sin;\n    offset[_RegionAttachment.OY2] = localY2Cos + localXSin;\n    offset[_RegionAttachment.OX3] = localX2Cos - localY2Sin;\n    offset[_RegionAttachment.OY3] = localY2Cos + localX2Sin;\n    offset[_RegionAttachment.OX4] = localX2Cos - localYSin;\n    offset[_RegionAttachment.OY4] = localYCos + localX2Sin;\n  }\n  setRegion(region) {\n    this.region = region;\n    const uvs = this.uvs;\n    if (region.rotate) {\n      uvs[2] = region.u;\n      uvs[3] = region.v2;\n      uvs[4] = region.u;\n      uvs[5] = region.v;\n      uvs[6] = region.u2;\n      uvs[7] = region.v;\n      uvs[0] = region.u2;\n      uvs[1] = region.v2;\n    } else {\n      uvs[0] = region.u;\n      uvs[1] = region.v2;\n      uvs[2] = region.u;\n      uvs[3] = region.v;\n      uvs[4] = region.u2;\n      uvs[5] = region.v;\n      uvs[6] = region.u2;\n      uvs[7] = region.v2;\n    }\n  }\n  computeWorldVertices(bone, worldVertices, offset, stride) {\n    const vertexOffset = this.offset;\n    const mat = bone instanceof Slot ? bone.bone.matrix : bone.matrix;\n    const x = mat.tx;\n    const y = mat.ty;\n    const a = mat.a;\n    const b = mat.c;\n    const c = mat.b;\n    const d = mat.d;\n    let offsetX = 0;\n    let offsetY = 0;\n    offsetX = vertexOffset[_RegionAttachment.OX1];\n    offsetY = vertexOffset[_RegionAttachment.OY1];\n    worldVertices[offset] = offsetX * a + offsetY * b + x;\n    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n    offset += stride;\n    offsetX = vertexOffset[_RegionAttachment.OX2];\n    offsetY = vertexOffset[_RegionAttachment.OY2];\n    worldVertices[offset] = offsetX * a + offsetY * b + x;\n    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n    offset += stride;\n    offsetX = vertexOffset[_RegionAttachment.OX3];\n    offsetY = vertexOffset[_RegionAttachment.OY3];\n    worldVertices[offset] = offsetX * a + offsetY * b + x;\n    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n    offset += stride;\n    offsetX = vertexOffset[_RegionAttachment.OX4];\n    offsetY = vertexOffset[_RegionAttachment.OY4];\n    worldVertices[offset] = offsetX * a + offsetY * b + x;\n    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n  }\n};\nlet RegionAttachment = _RegionAttachment;\nRegionAttachment.OX1 = 0;\nRegionAttachment.OY1 = 1;\nRegionAttachment.OX2 = 2;\nRegionAttachment.OY2 = 3;\nRegionAttachment.OX3 = 4;\nRegionAttachment.OY3 = 5;\nRegionAttachment.OX4 = 6;\nRegionAttachment.OY4 = 7;\nRegionAttachment.X1 = 0;\nRegionAttachment.Y1 = 1;\nRegionAttachment.C1R = 2;\nRegionAttachment.C1G = 3;\nRegionAttachment.C1B = 4;\nRegionAttachment.C1A = 5;\nRegionAttachment.U1 = 6;\nRegionAttachment.V1 = 7;\nRegionAttachment.X2 = 8;\nRegionAttachment.Y2 = 9;\nRegionAttachment.C2R = 10;\nRegionAttachment.C2G = 11;\nRegionAttachment.C2B = 12;\nRegionAttachment.C2A = 13;\nRegionAttachment.U2 = 14;\nRegionAttachment.V2 = 15;\nRegionAttachment.X3 = 16;\nRegionAttachment.Y3 = 17;\nRegionAttachment.C3R = 18;\nRegionAttachment.C3G = 19;\nRegionAttachment.C3B = 20;\nRegionAttachment.C3A = 21;\nRegionAttachment.U3 = 22;\nRegionAttachment.V3 = 23;\nRegionAttachment.X4 = 24;\nRegionAttachment.Y4 = 25;\nRegionAttachment.C4R = 26;\nRegionAttachment.C4G = 27;\nRegionAttachment.C4B = 28;\nRegionAttachment.C4A = 29;\nRegionAttachment.U4 = 30;\nRegionAttachment.V4 = 31;\n\nexport { RegionAttachment };\n//# sourceMappingURL=RegionAttachment.mjs.map\n","import { MathUtils } from '@pixi-spine/base';\n\nclass JitterEffect {\n  constructor(jitterX, jitterY) {\n    this.jitterX = 0;\n    this.jitterY = 0;\n    this.jitterX = jitterX;\n    this.jitterY = jitterY;\n  }\n  begin(skeleton) {\n  }\n  transform(position, uv, light, dark) {\n    position.x += MathUtils.randomTriangular(-this.jitterX, this.jitterY);\n    position.y += MathUtils.randomTriangular(-this.jitterX, this.jitterY);\n  }\n  end() {\n  }\n}\n\nexport { JitterEffect };\n//# sourceMappingURL=JitterEffect.mjs.map\n","import { PowOut, MathUtils } from '@pixi-spine/base';\n\nconst _SwirlEffect = class {\n  constructor(radius) {\n    this.centerX = 0;\n    this.centerY = 0;\n    this.radius = 0;\n    this.angle = 0;\n    this.worldX = 0;\n    this.worldY = 0;\n    this.radius = radius;\n  }\n  begin(skeleton) {\n    this.worldX = skeleton.x + this.centerX;\n    this.worldY = skeleton.y + this.centerY;\n  }\n  transform(position, uv, light, dark) {\n    const radAngle = this.angle * MathUtils.degreesToRadians;\n    const x = position.x - this.worldX;\n    const y = position.y - this.worldY;\n    const dist = Math.sqrt(x * x + y * y);\n    if (dist < this.radius) {\n      const theta = _SwirlEffect.interpolation.apply(0, radAngle, (this.radius - dist) / this.radius);\n      const cos = Math.cos(theta);\n      const sin = Math.sin(theta);\n      position.x = cos * x - sin * y + this.worldX;\n      position.y = sin * x + cos * y + this.worldY;\n    }\n  }\n  end() {\n  }\n};\nlet SwirlEffect = _SwirlEffect;\nSwirlEffect.interpolation = new PowOut(2);\n\nexport { SwirlEffect };\n//# sourceMappingURL=SwirlEffect.mjs.map\n","import { VertexAttachment } from './attachments/Attachment.mjs';\nimport { MixBlend, MixDirection, MathUtils, Utils } from '@pixi-spine/base';\nimport './attachments/RegionAttachment.mjs';\n\nclass Animation {\n  constructor(name, timelines, duration) {\n    if (name == null)\n      throw new Error(\"name cannot be null.\");\n    if (timelines == null)\n      throw new Error(\"timelines cannot be null.\");\n    this.name = name;\n    this.timelines = timelines;\n    this.duration = duration;\n  }\n  apply(skeleton, lastTime, time, loop, events, alpha, blend, direction) {\n    if (skeleton == null)\n      throw new Error(\"skeleton cannot be null.\");\n    if (loop && this.duration != 0) {\n      time %= this.duration;\n      if (lastTime > 0)\n        lastTime %= this.duration;\n    }\n    const timelines = this.timelines;\n    for (let i = 0, n = timelines.length; i < n; i++)\n      timelines[i].apply(skeleton, lastTime, time, events, alpha, blend, direction);\n  }\n  static binarySearch(values, target, step = 1) {\n    let low = 0;\n    let high = values.length / step - 2;\n    if (high == 0)\n      return step;\n    let current = high >>> 1;\n    while (true) {\n      if (values[(current + 1) * step] <= target)\n        low = current + 1;\n      else\n        high = current;\n      if (low == high)\n        return (low + 1) * step;\n      current = low + high >>> 1;\n    }\n  }\n  static linearSearch(values, target, step) {\n    for (let i = 0, last = values.length - step; i <= last; i += step)\n      if (values[i] > target)\n        return i;\n    return -1;\n  }\n}\nvar TimelineType = /* @__PURE__ */ ((TimelineType2) => {\n  TimelineType2[TimelineType2[\"rotate\"] = 0] = \"rotate\";\n  TimelineType2[TimelineType2[\"translate\"] = 1] = \"translate\";\n  TimelineType2[TimelineType2[\"scale\"] = 2] = \"scale\";\n  TimelineType2[TimelineType2[\"shear\"] = 3] = \"shear\";\n  TimelineType2[TimelineType2[\"attachment\"] = 4] = \"attachment\";\n  TimelineType2[TimelineType2[\"color\"] = 5] = \"color\";\n  TimelineType2[TimelineType2[\"deform\"] = 6] = \"deform\";\n  TimelineType2[TimelineType2[\"event\"] = 7] = \"event\";\n  TimelineType2[TimelineType2[\"drawOrder\"] = 8] = \"drawOrder\";\n  TimelineType2[TimelineType2[\"ikConstraint\"] = 9] = \"ikConstraint\";\n  TimelineType2[TimelineType2[\"transformConstraint\"] = 10] = \"transformConstraint\";\n  TimelineType2[TimelineType2[\"pathConstraintPosition\"] = 11] = \"pathConstraintPosition\";\n  TimelineType2[TimelineType2[\"pathConstraintSpacing\"] = 12] = \"pathConstraintSpacing\";\n  TimelineType2[TimelineType2[\"pathConstraintMix\"] = 13] = \"pathConstraintMix\";\n  TimelineType2[TimelineType2[\"twoColor\"] = 14] = \"twoColor\";\n  return TimelineType2;\n})(TimelineType || {});\nconst _CurveTimeline = class {\n  constructor(frameCount) {\n    if (frameCount <= 0)\n      throw new Error(`frameCount must be > 0: ${frameCount}`);\n    this.curves = Utils.newFloatArray((frameCount - 1) * _CurveTimeline.BEZIER_SIZE);\n  }\n  getFrameCount() {\n    return this.curves.length / _CurveTimeline.BEZIER_SIZE + 1;\n  }\n  setLinear(frameIndex) {\n    this.curves[frameIndex * _CurveTimeline.BEZIER_SIZE] = _CurveTimeline.LINEAR;\n  }\n  setStepped(frameIndex) {\n    this.curves[frameIndex * _CurveTimeline.BEZIER_SIZE] = _CurveTimeline.STEPPED;\n  }\n  getCurveType(frameIndex) {\n    const index = frameIndex * _CurveTimeline.BEZIER_SIZE;\n    if (index == this.curves.length)\n      return _CurveTimeline.LINEAR;\n    const type = this.curves[index];\n    if (type == _CurveTimeline.LINEAR)\n      return _CurveTimeline.LINEAR;\n    if (type == _CurveTimeline.STEPPED)\n      return _CurveTimeline.STEPPED;\n    return _CurveTimeline.BEZIER;\n  }\n  /** Sets the control handle positions for an interpolation bezier curve used to transition from this keyframe to the next.\n   * cx1 and cx2 are from 0 to 1, representing the percent of time between the two keyframes. cy1 and cy2 are the percent of\n   * the difference between the keyframe's values. */\n  setCurve(frameIndex, cx1, cy1, cx2, cy2) {\n    const tmpx = (-cx1 * 2 + cx2) * 0.03;\n    const tmpy = (-cy1 * 2 + cy2) * 0.03;\n    const dddfx = ((cx1 - cx2) * 3 + 1) * 6e-3;\n    const dddfy = ((cy1 - cy2) * 3 + 1) * 6e-3;\n    let ddfx = tmpx * 2 + dddfx;\n    let ddfy = tmpy * 2 + dddfy;\n    let dfx = cx1 * 0.3 + tmpx + dddfx * 0.16666667;\n    let dfy = cy1 * 0.3 + tmpy + dddfy * 0.16666667;\n    let i = frameIndex * _CurveTimeline.BEZIER_SIZE;\n    const curves = this.curves;\n    curves[i++] = _CurveTimeline.BEZIER;\n    let x = dfx;\n    let y = dfy;\n    for (let n = i + _CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\n      curves[i] = x;\n      curves[i + 1] = y;\n      dfx += ddfx;\n      dfy += ddfy;\n      ddfx += dddfx;\n      ddfy += dddfy;\n      x += dfx;\n      y += dfy;\n    }\n  }\n  getCurvePercent(frameIndex, percent) {\n    percent = MathUtils.clamp(percent, 0, 1);\n    const curves = this.curves;\n    let i = frameIndex * _CurveTimeline.BEZIER_SIZE;\n    const type = curves[i];\n    if (type == _CurveTimeline.LINEAR)\n      return percent;\n    if (type == _CurveTimeline.STEPPED)\n      return 0;\n    i++;\n    let x = 0;\n    for (let start = i, n = i + _CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\n      x = curves[i];\n      if (x >= percent) {\n        let prevX;\n        let prevY;\n        if (i == start) {\n          prevX = 0;\n          prevY = 0;\n        } else {\n          prevX = curves[i - 2];\n          prevY = curves[i - 1];\n        }\n        return prevY + (curves[i + 1] - prevY) * (percent - prevX) / (x - prevX);\n      }\n    }\n    const y = curves[i - 1];\n    return y + (1 - y) * (percent - x) / (1 - x);\n  }\n};\nlet CurveTimeline = _CurveTimeline;\nCurveTimeline.LINEAR = 0;\nCurveTimeline.STEPPED = 1;\nCurveTimeline.BEZIER = 2;\nCurveTimeline.BEZIER_SIZE = 10 * 2 - 1;\nconst _RotateTimeline = class extends CurveTimeline {\n  // time, degrees, ...\n  constructor(frameCount) {\n    super(frameCount);\n    this.frames = Utils.newFloatArray(frameCount << 1);\n  }\n  getPropertyId() {\n    return (0 /* rotate */ << 24) + this.boneIndex;\n  }\n  /** Sets the time and angle of the specified keyframe. */\n  setFrame(frameIndex, time, degrees) {\n    frameIndex <<= 1;\n    this.frames[frameIndex] = time;\n    this.frames[frameIndex + _RotateTimeline.ROTATION] = degrees;\n  }\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    const frames = this.frames;\n    const bone = skeleton.bones[this.boneIndex];\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.rotation = bone.data.rotation;\n          return;\n        case MixBlend.first:\n          const r2 = bone.data.rotation - bone.rotation;\n          bone.rotation += (r2 - (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360) * alpha;\n      }\n      return;\n    }\n    if (time >= frames[frames.length - _RotateTimeline.ENTRIES]) {\n      let r2 = frames[frames.length + _RotateTimeline.PREV_ROTATION];\n      switch (blend) {\n        case MixBlend.setup:\n          bone.rotation = bone.data.rotation + r2 * alpha;\n          break;\n        case MixBlend.first:\n        case MixBlend.replace:\n          r2 += bone.data.rotation - bone.rotation;\n          r2 -= (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360;\n        case MixBlend.add:\n          bone.rotation += r2 * alpha;\n      }\n      return;\n    }\n    const frame = Animation.binarySearch(frames, time, _RotateTimeline.ENTRIES);\n    const prevRotation = frames[frame + _RotateTimeline.PREV_ROTATION];\n    const frameTime = frames[frame];\n    const percent = this.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + _RotateTimeline.PREV_TIME] - frameTime));\n    let r = frames[frame + _RotateTimeline.ROTATION] - prevRotation;\n    r = prevRotation + (r - (16384 - (16384.499999999996 - r / 360 | 0)) * 360) * percent;\n    switch (blend) {\n      case MixBlend.setup:\n        bone.rotation = bone.data.rotation + (r - (16384 - (16384.499999999996 - r / 360 | 0)) * 360) * alpha;\n        break;\n      case MixBlend.first:\n      case MixBlend.replace:\n        r += bone.data.rotation - bone.rotation;\n      case MixBlend.add:\n        bone.rotation += (r - (16384 - (16384.499999999996 - r / 360 | 0)) * 360) * alpha;\n    }\n  }\n};\nlet RotateTimeline = _RotateTimeline;\nRotateTimeline.ENTRIES = 2;\nRotateTimeline.PREV_TIME = -2;\nRotateTimeline.PREV_ROTATION = -1;\nRotateTimeline.ROTATION = 1;\nconst _TranslateTimeline = class extends CurveTimeline {\n  // time, x, y, ...\n  constructor(frameCount) {\n    super(frameCount);\n    this.frames = Utils.newFloatArray(frameCount * _TranslateTimeline.ENTRIES);\n  }\n  getPropertyId() {\n    return (1 /* translate */ << 24) + this.boneIndex;\n  }\n  /** Sets the time and value of the specified keyframe. */\n  setFrame(frameIndex, time, x, y) {\n    frameIndex *= _TranslateTimeline.ENTRIES;\n    this.frames[frameIndex] = time;\n    this.frames[frameIndex + _TranslateTimeline.X] = x;\n    this.frames[frameIndex + _TranslateTimeline.Y] = y;\n  }\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    const frames = this.frames;\n    const bone = skeleton.bones[this.boneIndex];\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.x = bone.data.x;\n          bone.y = bone.data.y;\n          return;\n        case MixBlend.first:\n          bone.x += (bone.data.x - bone.x) * alpha;\n          bone.y += (bone.data.y - bone.y) * alpha;\n      }\n      return;\n    }\n    let x = 0;\n    let y = 0;\n    if (time >= frames[frames.length - _TranslateTimeline.ENTRIES]) {\n      x = frames[frames.length + _TranslateTimeline.PREV_X];\n      y = frames[frames.length + _TranslateTimeline.PREV_Y];\n    } else {\n      const frame = Animation.binarySearch(frames, time, _TranslateTimeline.ENTRIES);\n      x = frames[frame + _TranslateTimeline.PREV_X];\n      y = frames[frame + _TranslateTimeline.PREV_Y];\n      const frameTime = frames[frame];\n      const percent = this.getCurvePercent(frame / _TranslateTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + _TranslateTimeline.PREV_TIME] - frameTime));\n      x += (frames[frame + _TranslateTimeline.X] - x) * percent;\n      y += (frames[frame + _TranslateTimeline.Y] - y) * percent;\n    }\n    switch (blend) {\n      case MixBlend.setup:\n        bone.x = bone.data.x + x * alpha;\n        bone.y = bone.data.y + y * alpha;\n        break;\n      case MixBlend.first:\n      case MixBlend.replace:\n        bone.x += (bone.data.x + x - bone.x) * alpha;\n        bone.y += (bone.data.y + y - bone.y) * alpha;\n        break;\n      case MixBlend.add:\n        bone.x += x * alpha;\n        bone.y += y * alpha;\n    }\n  }\n};\nlet TranslateTimeline = _TranslateTimeline;\nTranslateTimeline.ENTRIES = 3;\nTranslateTimeline.PREV_TIME = -3;\nTranslateTimeline.PREV_X = -2;\nTranslateTimeline.PREV_Y = -1;\nTranslateTimeline.X = 1;\nTranslateTimeline.Y = 2;\nclass ScaleTimeline extends TranslateTimeline {\n  constructor(frameCount) {\n    super(frameCount);\n  }\n  getPropertyId() {\n    return (2 /* scale */ << 24) + this.boneIndex;\n  }\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    const frames = this.frames;\n    const bone = skeleton.bones[this.boneIndex];\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.scaleX = bone.data.scaleX;\n          bone.scaleY = bone.data.scaleY;\n          return;\n        case MixBlend.first:\n          bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;\n          bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;\n      }\n      return;\n    }\n    let x = 0;\n    let y = 0;\n    if (time >= frames[frames.length - ScaleTimeline.ENTRIES]) {\n      x = frames[frames.length + ScaleTimeline.PREV_X] * bone.data.scaleX;\n      y = frames[frames.length + ScaleTimeline.PREV_Y] * bone.data.scaleY;\n    } else {\n      const frame = Animation.binarySearch(frames, time, ScaleTimeline.ENTRIES);\n      x = frames[frame + ScaleTimeline.PREV_X];\n      y = frames[frame + ScaleTimeline.PREV_Y];\n      const frameTime = frames[frame];\n      const percent = this.getCurvePercent(frame / ScaleTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ScaleTimeline.PREV_TIME] - frameTime));\n      x = (x + (frames[frame + ScaleTimeline.X] - x) * percent) * bone.data.scaleX;\n      y = (y + (frames[frame + ScaleTimeline.Y] - y) * percent) * bone.data.scaleY;\n    }\n    if (alpha == 1) {\n      if (blend == MixBlend.add) {\n        bone.scaleX += x - bone.data.scaleX;\n        bone.scaleY += y - bone.data.scaleY;\n      } else {\n        bone.scaleX = x;\n        bone.scaleY = y;\n      }\n    } else {\n      let bx = 0;\n      let by = 0;\n      if (direction == MixDirection.mixOut) {\n        switch (blend) {\n          case MixBlend.setup:\n            bx = bone.data.scaleX;\n            by = bone.data.scaleY;\n            bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\n            bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\n            break;\n          case MixBlend.first:\n          case MixBlend.replace:\n            bx = bone.scaleX;\n            by = bone.scaleY;\n            bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\n            bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\n            break;\n          case MixBlend.add:\n            bx = bone.scaleX;\n            by = bone.scaleY;\n            bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bone.data.scaleX) * alpha;\n            bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - bone.data.scaleY) * alpha;\n        }\n      } else {\n        switch (blend) {\n          case MixBlend.setup:\n            bx = Math.abs(bone.data.scaleX) * MathUtils.signum(x);\n            by = Math.abs(bone.data.scaleY) * MathUtils.signum(y);\n            bone.scaleX = bx + (x - bx) * alpha;\n            bone.scaleY = by + (y - by) * alpha;\n            break;\n          case MixBlend.first:\n          case MixBlend.replace:\n            bx = Math.abs(bone.scaleX) * MathUtils.signum(x);\n            by = Math.abs(bone.scaleY) * MathUtils.signum(y);\n            bone.scaleX = bx + (x - bx) * alpha;\n            bone.scaleY = by + (y - by) * alpha;\n            break;\n          case MixBlend.add:\n            bx = MathUtils.signum(x);\n            by = MathUtils.signum(y);\n            bone.scaleX = Math.abs(bone.scaleX) * bx + (x - Math.abs(bone.data.scaleX) * bx) * alpha;\n            bone.scaleY = Math.abs(bone.scaleY) * by + (y - Math.abs(bone.data.scaleY) * by) * alpha;\n        }\n      }\n    }\n  }\n}\nclass ShearTimeline extends TranslateTimeline {\n  constructor(frameCount) {\n    super(frameCount);\n  }\n  getPropertyId() {\n    return (3 /* shear */ << 24) + this.boneIndex;\n  }\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    const frames = this.frames;\n    const bone = skeleton.bones[this.boneIndex];\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.shearX = bone.data.shearX;\n          bone.shearY = bone.data.shearY;\n          return;\n        case MixBlend.first:\n          bone.shearX += (bone.data.shearX - bone.shearX) * alpha;\n          bone.shearY += (bone.data.shearY - bone.shearY) * alpha;\n      }\n      return;\n    }\n    let x = 0;\n    let y = 0;\n    if (time >= frames[frames.length - ShearTimeline.ENTRIES]) {\n      x = frames[frames.length + ShearTimeline.PREV_X];\n      y = frames[frames.length + ShearTimeline.PREV_Y];\n    } else {\n      const frame = Animation.binarySearch(frames, time, ShearTimeline.ENTRIES);\n      x = frames[frame + ShearTimeline.PREV_X];\n      y = frames[frame + ShearTimeline.PREV_Y];\n      const frameTime = frames[frame];\n      const percent = this.getCurvePercent(frame / ShearTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ShearTimeline.PREV_TIME] - frameTime));\n      x = x + (frames[frame + ShearTimeline.X] - x) * percent;\n      y = y + (frames[frame + ShearTimeline.Y] - y) * percent;\n    }\n    switch (blend) {\n      case MixBlend.setup:\n        bone.shearX = bone.data.shearX + x * alpha;\n        bone.shearY = bone.data.shearY + y * alpha;\n        break;\n      case MixBlend.first:\n      case MixBlend.replace:\n        bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;\n        bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;\n        break;\n      case MixBlend.add:\n        bone.shearX += x * alpha;\n        bone.shearY += y * alpha;\n    }\n  }\n}\nconst _ColorTimeline = class extends CurveTimeline {\n  // time, r, g, b, a, ...\n  constructor(frameCount) {\n    super(frameCount);\n    this.frames = Utils.newFloatArray(frameCount * _ColorTimeline.ENTRIES);\n  }\n  getPropertyId() {\n    return (5 /* color */ << 24) + this.slotIndex;\n  }\n  /** Sets the time and value of the specified keyframe. */\n  setFrame(frameIndex, time, r, g, b, a) {\n    frameIndex *= _ColorTimeline.ENTRIES;\n    this.frames[frameIndex] = time;\n    this.frames[frameIndex + _ColorTimeline.R] = r;\n    this.frames[frameIndex + _ColorTimeline.G] = g;\n    this.frames[frameIndex + _ColorTimeline.B] = b;\n    this.frames[frameIndex + _ColorTimeline.A] = a;\n  }\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    const slot = skeleton.slots[this.slotIndex];\n    const frames = this.frames;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          slot.color.setFromColor(slot.data.color);\n          return;\n        case MixBlend.first:\n          const color = slot.color;\n          const setup = slot.data.color;\n          color.add((setup.r - color.r) * alpha, (setup.g - color.g) * alpha, (setup.b - color.b) * alpha, (setup.a - color.a) * alpha);\n      }\n      return;\n    }\n    let r = 0;\n    let g = 0;\n    let b = 0;\n    let a = 0;\n    if (time >= frames[frames.length - _ColorTimeline.ENTRIES]) {\n      const i = frames.length;\n      r = frames[i + _ColorTimeline.PREV_R];\n      g = frames[i + _ColorTimeline.PREV_G];\n      b = frames[i + _ColorTimeline.PREV_B];\n      a = frames[i + _ColorTimeline.PREV_A];\n    } else {\n      const frame = Animation.binarySearch(frames, time, _ColorTimeline.ENTRIES);\n      r = frames[frame + _ColorTimeline.PREV_R];\n      g = frames[frame + _ColorTimeline.PREV_G];\n      b = frames[frame + _ColorTimeline.PREV_B];\n      a = frames[frame + _ColorTimeline.PREV_A];\n      const frameTime = frames[frame];\n      const percent = this.getCurvePercent(frame / _ColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + _ColorTimeline.PREV_TIME] - frameTime));\n      r += (frames[frame + _ColorTimeline.R] - r) * percent;\n      g += (frames[frame + _ColorTimeline.G] - g) * percent;\n      b += (frames[frame + _ColorTimeline.B] - b) * percent;\n      a += (frames[frame + _ColorTimeline.A] - a) * percent;\n    }\n    if (alpha == 1)\n      slot.color.set(r, g, b, a);\n    else {\n      const color = slot.color;\n      if (blend == MixBlend.setup)\n        color.setFromColor(slot.data.color);\n      color.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);\n    }\n  }\n};\nlet ColorTimeline = _ColorTimeline;\nColorTimeline.ENTRIES = 5;\nColorTimeline.PREV_TIME = -5;\nColorTimeline.PREV_R = -4;\nColorTimeline.PREV_G = -3;\nColorTimeline.PREV_B = -2;\nColorTimeline.PREV_A = -1;\nColorTimeline.R = 1;\nColorTimeline.G = 2;\nColorTimeline.B = 3;\nColorTimeline.A = 4;\nconst _TwoColorTimeline = class extends CurveTimeline {\n  // time, r, g, b, a, r2, g2, b2, ...\n  constructor(frameCount) {\n    super(frameCount);\n    this.frames = Utils.newFloatArray(frameCount * _TwoColorTimeline.ENTRIES);\n  }\n  getPropertyId() {\n    return (14 /* twoColor */ << 24) + this.slotIndex;\n  }\n  /** Sets the time and value of the specified keyframe. */\n  setFrame(frameIndex, time, r, g, b, a, r2, g2, b2) {\n    frameIndex *= _TwoColorTimeline.ENTRIES;\n    this.frames[frameIndex] = time;\n    this.frames[frameIndex + _TwoColorTimeline.R] = r;\n    this.frames[frameIndex + _TwoColorTimeline.G] = g;\n    this.frames[frameIndex + _TwoColorTimeline.B] = b;\n    this.frames[frameIndex + _TwoColorTimeline.A] = a;\n    this.frames[frameIndex + _TwoColorTimeline.R2] = r2;\n    this.frames[frameIndex + _TwoColorTimeline.G2] = g2;\n    this.frames[frameIndex + _TwoColorTimeline.B2] = b2;\n  }\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    const slot = skeleton.slots[this.slotIndex];\n    const frames = this.frames;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          slot.color.setFromColor(slot.data.color);\n          slot.darkColor.setFromColor(slot.data.darkColor);\n          return;\n        case MixBlend.first:\n          const light = slot.color;\n          const dark = slot.darkColor;\n          const setupLight = slot.data.color;\n          const setupDark = slot.data.darkColor;\n          light.add((setupLight.r - light.r) * alpha, (setupLight.g - light.g) * alpha, (setupLight.b - light.b) * alpha, (setupLight.a - light.a) * alpha);\n          dark.add((setupDark.r - dark.r) * alpha, (setupDark.g - dark.g) * alpha, (setupDark.b - dark.b) * alpha, 0);\n      }\n      return;\n    }\n    let r = 0;\n    let g = 0;\n    let b = 0;\n    let a = 0;\n    let r2 = 0;\n    let g2 = 0;\n    let b2 = 0;\n    if (time >= frames[frames.length - _TwoColorTimeline.ENTRIES]) {\n      const i = frames.length;\n      r = frames[i + _TwoColorTimeline.PREV_R];\n      g = frames[i + _TwoColorTimeline.PREV_G];\n      b = frames[i + _TwoColorTimeline.PREV_B];\n      a = frames[i + _TwoColorTimeline.PREV_A];\n      r2 = frames[i + _TwoColorTimeline.PREV_R2];\n      g2 = frames[i + _TwoColorTimeline.PREV_G2];\n      b2 = frames[i + _TwoColorTimeline.PREV_B2];\n    } else {\n      const frame = Animation.binarySearch(frames, time, _TwoColorTimeline.ENTRIES);\n      r = frames[frame + _TwoColorTimeline.PREV_R];\n      g = frames[frame + _TwoColorTimeline.PREV_G];\n      b = frames[frame + _TwoColorTimeline.PREV_B];\n      a = frames[frame + _TwoColorTimeline.PREV_A];\n      r2 = frames[frame + _TwoColorTimeline.PREV_R2];\n      g2 = frames[frame + _TwoColorTimeline.PREV_G2];\n      b2 = frames[frame + _TwoColorTimeline.PREV_B2];\n      const frameTime = frames[frame];\n      const percent = this.getCurvePercent(frame / _TwoColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + _TwoColorTimeline.PREV_TIME] - frameTime));\n      r += (frames[frame + _TwoColorTimeline.R] - r) * percent;\n      g += (frames[frame + _TwoColorTimeline.G] - g) * percent;\n      b += (frames[frame + _TwoColorTimeline.B] - b) * percent;\n      a += (frames[frame + _TwoColorTimeline.A] - a) * percent;\n      r2 += (frames[frame + _TwoColorTimeline.R2] - r2) * percent;\n      g2 += (frames[frame + _TwoColorTimeline.G2] - g2) * percent;\n      b2 += (frames[frame + _TwoColorTimeline.B2] - b2) * percent;\n    }\n    if (alpha == 1) {\n      slot.color.set(r, g, b, a);\n      slot.darkColor.set(r2, g2, b2, 1);\n    } else {\n      const light = slot.color;\n      const dark = slot.darkColor;\n      if (blend == MixBlend.setup) {\n        light.setFromColor(slot.data.color);\n        dark.setFromColor(slot.data.darkColor);\n      }\n      light.add((r - light.r) * alpha, (g - light.g) * alpha, (b - light.b) * alpha, (a - light.a) * alpha);\n      dark.add((r2 - dark.r) * alpha, (g2 - dark.g) * alpha, (b2 - dark.b) * alpha, 0);\n    }\n  }\n};\nlet TwoColorTimeline = _TwoColorTimeline;\nTwoColorTimeline.ENTRIES = 8;\nTwoColorTimeline.PREV_TIME = -8;\nTwoColorTimeline.PREV_R = -7;\nTwoColorTimeline.PREV_G = -6;\nTwoColorTimeline.PREV_B = -5;\nTwoColorTimeline.PREV_A = -4;\nTwoColorTimeline.PREV_R2 = -3;\nTwoColorTimeline.PREV_G2 = -2;\nTwoColorTimeline.PREV_B2 = -1;\nTwoColorTimeline.R = 1;\nTwoColorTimeline.G = 2;\nTwoColorTimeline.B = 3;\nTwoColorTimeline.A = 4;\nTwoColorTimeline.R2 = 5;\nTwoColorTimeline.G2 = 6;\nTwoColorTimeline.B2 = 7;\nclass AttachmentTimeline {\n  constructor(frameCount) {\n    this.frames = Utils.newFloatArray(frameCount);\n    this.attachmentNames = new Array(frameCount);\n  }\n  getPropertyId() {\n    return (4 /* attachment */ << 24) + this.slotIndex;\n  }\n  getFrameCount() {\n    return this.frames.length;\n  }\n  /** Sets the time and value of the specified keyframe. */\n  setFrame(frameIndex, time, attachmentName) {\n    this.frames[frameIndex] = time;\n    this.attachmentNames[frameIndex] = attachmentName;\n  }\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    const slot = skeleton.slots[this.slotIndex];\n    if (direction == MixDirection.mixOut && blend == MixBlend.setup) {\n      const attachmentName2 = slot.data.attachmentName;\n      slot.setAttachment(attachmentName2 == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName2));\n      return;\n    }\n    const frames = this.frames;\n    if (time < frames[0]) {\n      if (blend == MixBlend.setup || blend == MixBlend.first) {\n        const attachmentName2 = slot.data.attachmentName;\n        slot.setAttachment(attachmentName2 == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName2));\n      }\n      return;\n    }\n    let frameIndex = 0;\n    if (time >= frames[frames.length - 1])\n      frameIndex = frames.length - 1;\n    else\n      frameIndex = Animation.binarySearch(frames, time, 1) - 1;\n    const attachmentName = this.attachmentNames[frameIndex];\n    skeleton.slots[this.slotIndex].setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\n  }\n}\nlet zeros = null;\nclass DeformTimeline extends CurveTimeline {\n  constructor(frameCount) {\n    super(frameCount);\n    this.frames = Utils.newFloatArray(frameCount);\n    this.frameVertices = new Array(frameCount);\n    if (zeros == null)\n      zeros = Utils.newFloatArray(64);\n  }\n  getPropertyId() {\n    return (6 /* deform */ << 27) + Number(this.attachment.id) + this.slotIndex;\n  }\n  /** Sets the time of the specified keyframe. */\n  setFrame(frameIndex, time, vertices) {\n    this.frames[frameIndex] = time;\n    this.frameVertices[frameIndex] = vertices;\n  }\n  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n    const slot = skeleton.slots[this.slotIndex];\n    const slotAttachment = slot.getAttachment();\n    if (!(slotAttachment instanceof VertexAttachment) || !slotAttachment.applyDeform(this.attachment))\n      return;\n    const verticesArray = slot.attachmentVertices;\n    if (verticesArray.length == 0)\n      blend = MixBlend.setup;\n    const frameVertices = this.frameVertices;\n    const vertexCount = frameVertices[0].length;\n    const frames = this.frames;\n    if (time < frames[0]) {\n      const vertexAttachment = slotAttachment;\n      switch (blend) {\n        case MixBlend.setup:\n          verticesArray.length = 0;\n          return;\n        case MixBlend.first:\n          if (alpha == 1) {\n            verticesArray.length = 0;\n            break;\n          }\n          const vertices2 = Utils.setArraySize(verticesArray, vertexCount);\n          if (vertexAttachment.bones == null) {\n            const setupVertices = vertexAttachment.vertices;\n            for (let i = 0; i < vertexCount; i++)\n              vertices2[i] += (setupVertices[i] - vertices2[i]) * alpha;\n          } else {\n            alpha = 1 - alpha;\n            for (let i = 0; i < vertexCount; i++)\n              vertices2[i] *= alpha;\n          }\n      }\n      return;\n    }\n    const vertices = Utils.setArraySize(verticesArray, vertexCount);\n    if (time >= frames[frames.length - 1]) {\n      const lastVertices = frameVertices[frames.length - 1];\n      if (alpha == 1) {\n        if (blend == MixBlend.add) {\n          const vertexAttachment = slotAttachment;\n          if (vertexAttachment.bones == null) {\n            const setupVertices = vertexAttachment.vertices;\n            for (let i = 0; i < vertexCount; i++) {\n              vertices[i] += lastVertices[i] - setupVertices[i];\n            }\n          } else {\n            for (let i = 0; i < vertexCount; i++)\n              vertices[i] += lastVertices[i];\n          }\n        } else {\n          Utils.arrayCopy(lastVertices, 0, vertices, 0, vertexCount);\n        }\n      } else {\n        switch (blend) {\n          case MixBlend.setup: {\n            const vertexAttachment2 = slotAttachment;\n            if (vertexAttachment2.bones == null) {\n              const setupVertices = vertexAttachment2.vertices;\n              for (let i = 0; i < vertexCount; i++) {\n                const setup = setupVertices[i];\n                vertices[i] = setup + (lastVertices[i] - setup) * alpha;\n              }\n            } else {\n              for (let i = 0; i < vertexCount; i++)\n                vertices[i] = lastVertices[i] * alpha;\n            }\n            break;\n          }\n          case MixBlend.first:\n          case MixBlend.replace:\n            for (let i = 0; i < vertexCount; i++)\n              vertices[i] += (lastVertices[i] - vertices[i]) * alpha;\n          case MixBlend.add:\n            const vertexAttachment = slotAttachment;\n            if (vertexAttachment.bones == null) {\n              const setupVertices = vertexAttachment.vertices;\n              for (let i = 0; i < vertexCount; i++) {\n                vertices[i] += (lastVertices[i] - setupVertices[i]) * alpha;\n              }\n            } else {\n              for (let i = 0; i < vertexCount; i++)\n                vertices[i] += lastVertices[i] * alpha;\n            }\n        }\n      }\n      return;\n    }\n    const frame = Animation.binarySearch(frames, time);\n    const prevVertices = frameVertices[frame - 1];\n    const nextVertices = frameVertices[frame];\n    const frameTime = frames[frame];\n    const percent = this.getCurvePercent(frame - 1, 1 - (time - frameTime) / (frames[frame - 1] - frameTime));\n    if (alpha == 1) {\n      if (blend == MixBlend.add) {\n        const vertexAttachment = slotAttachment;\n        if (vertexAttachment.bones == null) {\n          const setupVertices = vertexAttachment.vertices;\n          for (let i = 0; i < vertexCount; i++) {\n            const prev = prevVertices[i];\n            vertices[i] += prev + (nextVertices[i] - prev) * percent - setupVertices[i];\n          }\n        } else {\n          for (let i = 0; i < vertexCount; i++) {\n            const prev = prevVertices[i];\n            vertices[i] += prev + (nextVertices[i] - prev) * percent;\n          }\n        }\n      } else {\n        for (let i = 0; i < vertexCount; i++) {\n          const prev = prevVertices[i];\n          vertices[i] = prev + (nextVertices[i] - prev) * percent;\n        }\n      }\n    } else {\n      switch (blend) {\n        case MixBlend.setup: {\n          const vertexAttachment2 = slotAttachment;\n          if (vertexAttachment2.bones == null) {\n            const setupVertices = vertexAttachment2.vertices;\n            for (let i = 0; i < vertexCount; i++) {\n              const prev = prevVertices[i];\n              const setup = setupVertices[i];\n              vertices[i] = setup + (prev + (nextVertices[i] - prev) * percent - setup) * alpha;\n            }\n          } else {\n            for (let i = 0; i < vertexCount; i++) {\n              const prev = prevVertices[i];\n              vertices[i] = (prev + (nextVertices[i] - prev) * percent) * alpha;\n            }\n          }\n          break;\n        }\n        case MixBlend.first:\n        case MixBlend.replace:\n          for (let i = 0; i < vertexCount; i++) {\n            const prev = prevVertices[i];\n            vertices[i] += (prev + (nextVertices[i] - prev) * percent - vertices[i]) * alpha;\n          }\n          break;\n        case MixBlend.add:\n          const vertexAttachment = slotAttachment;\n          if (vertexAttachment.bones == null) {\n            const setupVertices = vertexAttachment.vertices;\n            for (let i = 0; i < vertexCount; i++) {\n              const prev = prevVertices[i];\n              vertices[i] += (prev + (nextVertices[i] - prev) * percent - setupVertices[i]) * alpha;\n            }\n          } else {\n            for (let i = 0; i < vertexCount; i++) {\n              const prev = prevVertices[i];\n              vertices[i] += (prev + (nextVertices[i] - prev) * percent) * alpha;\n            }\n          }\n      }\n    }\n  }\n}\nclass EventTimeline {\n  constructor(frameCount) {\n    this.frames = Utils.newFloatArray(frameCount);\n    this.events = new Array(frameCount);\n  }\n  getPropertyId() {\n    return 7 /* event */ << 24;\n  }\n  getFrameCount() {\n    return this.frames.length;\n  }\n  /** Sets the time of the specified keyframe. */\n  setFrame(frameIndex, event) {\n    this.frames[frameIndex] = event.time;\n    this.events[frameIndex] = event;\n  }\n  /** Fires events for frames > lastTime and <= time. */\n  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n    if (firedEvents == null)\n      return;\n    const frames = this.frames;\n    const frameCount = this.frames.length;\n    if (lastTime > time) {\n      this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, blend, direction);\n      lastTime = -1;\n    } else if (lastTime >= frames[frameCount - 1])\n      return;\n    if (time < frames[0])\n      return;\n    let frame = 0;\n    if (lastTime < frames[0])\n      frame = 0;\n    else {\n      frame = Animation.binarySearch(frames, lastTime);\n      const frameTime = frames[frame];\n      while (frame > 0) {\n        if (frames[frame - 1] != frameTime)\n          break;\n        frame--;\n      }\n    }\n    for (; frame < frameCount && time >= frames[frame]; frame++)\n      firedEvents.push(this.events[frame]);\n  }\n}\nclass DrawOrderTimeline {\n  constructor(frameCount) {\n    this.frames = Utils.newFloatArray(frameCount);\n    this.drawOrders = new Array(frameCount);\n  }\n  getPropertyId() {\n    return 8 /* drawOrder */ << 24;\n  }\n  getFrameCount() {\n    return this.frames.length;\n  }\n  /** Sets the time of the specified keyframe.\n   * @param drawOrder May be null to use bind pose draw order. */\n  setFrame(frameIndex, time, drawOrder) {\n    this.frames[frameIndex] = time;\n    this.drawOrders[frameIndex] = drawOrder;\n  }\n  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n    const drawOrder = skeleton.drawOrder;\n    const slots = skeleton.slots;\n    if (direction == MixDirection.mixOut && blend == MixBlend.setup) {\n      Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\n      return;\n    }\n    const frames = this.frames;\n    if (time < frames[0]) {\n      if (blend == MixBlend.setup || blend == MixBlend.first)\n        Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\n      return;\n    }\n    let frame = 0;\n    if (time >= frames[frames.length - 1])\n      frame = frames.length - 1;\n    else\n      frame = Animation.binarySearch(frames, time) - 1;\n    const drawOrderToSetupIndex = this.drawOrders[frame];\n    if (drawOrderToSetupIndex == null)\n      Utils.arrayCopy(slots, 0, drawOrder, 0, slots.length);\n    else {\n      for (let i = 0, n = drawOrderToSetupIndex.length; i < n; i++)\n        drawOrder[i] = slots[drawOrderToSetupIndex[i]];\n    }\n  }\n}\nconst _IkConstraintTimeline = class extends CurveTimeline {\n  // time, mix, bendDirection, compress, stretch, ...\n  constructor(frameCount) {\n    super(frameCount);\n    this.frames = Utils.newFloatArray(frameCount * _IkConstraintTimeline.ENTRIES);\n  }\n  getPropertyId() {\n    return (9 /* ikConstraint */ << 24) + this.ikConstraintIndex;\n  }\n  /** Sets the time, mix and bend direction of the specified keyframe. */\n  setFrame(frameIndex, time, mix, bendDirection, compress, stretch) {\n    frameIndex *= _IkConstraintTimeline.ENTRIES;\n    this.frames[frameIndex] = time;\n    this.frames[frameIndex + _IkConstraintTimeline.MIX] = mix;\n    this.frames[frameIndex + _IkConstraintTimeline.BEND_DIRECTION] = bendDirection;\n    this.frames[frameIndex + _IkConstraintTimeline.COMPRESS] = compress ? 1 : 0;\n    this.frames[frameIndex + _IkConstraintTimeline.STRETCH] = stretch ? 1 : 0;\n  }\n  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n    const frames = this.frames;\n    const constraint = skeleton.ikConstraints[this.ikConstraintIndex];\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          constraint.mix = constraint.data.mix;\n          constraint.bendDirection = constraint.data.bendDirection;\n          constraint.compress = constraint.data.compress;\n          constraint.stretch = constraint.data.stretch;\n          return;\n        case MixBlend.first:\n          constraint.mix += (constraint.data.mix - constraint.mix) * alpha;\n          constraint.bendDirection = constraint.data.bendDirection;\n          constraint.compress = constraint.data.compress;\n          constraint.stretch = constraint.data.stretch;\n      }\n      return;\n    }\n    if (time >= frames[frames.length - _IkConstraintTimeline.ENTRIES]) {\n      if (blend == MixBlend.setup) {\n        constraint.mix = constraint.data.mix + (frames[frames.length + _IkConstraintTimeline.PREV_MIX] - constraint.data.mix) * alpha;\n        if (direction == MixDirection.mixOut) {\n          constraint.bendDirection = constraint.data.bendDirection;\n          constraint.compress = constraint.data.compress;\n          constraint.stretch = constraint.data.stretch;\n        } else {\n          constraint.bendDirection = frames[frames.length + _IkConstraintTimeline.PREV_BEND_DIRECTION];\n          constraint.compress = frames[frames.length + _IkConstraintTimeline.PREV_COMPRESS] != 0;\n          constraint.stretch = frames[frames.length + _IkConstraintTimeline.PREV_STRETCH] != 0;\n        }\n      } else {\n        constraint.mix += (frames[frames.length + _IkConstraintTimeline.PREV_MIX] - constraint.mix) * alpha;\n        if (direction == MixDirection.mixIn) {\n          constraint.bendDirection = frames[frames.length + _IkConstraintTimeline.PREV_BEND_DIRECTION];\n          constraint.compress = frames[frames.length + _IkConstraintTimeline.PREV_COMPRESS] != 0;\n          constraint.stretch = frames[frames.length + _IkConstraintTimeline.PREV_STRETCH] != 0;\n        }\n      }\n      return;\n    }\n    const frame = Animation.binarySearch(frames, time, _IkConstraintTimeline.ENTRIES);\n    const mix = frames[frame + _IkConstraintTimeline.PREV_MIX];\n    const frameTime = frames[frame];\n    const percent = this.getCurvePercent(frame / _IkConstraintTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + _IkConstraintTimeline.PREV_TIME] - frameTime));\n    if (blend == MixBlend.setup) {\n      constraint.mix = constraint.data.mix + (mix + (frames[frame + _IkConstraintTimeline.MIX] - mix) * percent - constraint.data.mix) * alpha;\n      if (direction == MixDirection.mixOut) {\n        constraint.bendDirection = constraint.data.bendDirection;\n        constraint.compress = constraint.data.compress;\n        constraint.stretch = constraint.data.stretch;\n      } else {\n        constraint.bendDirection = frames[frame + _IkConstraintTimeline.PREV_BEND_DIRECTION];\n        constraint.compress = frames[frame + _IkConstraintTimeline.PREV_COMPRESS] != 0;\n        constraint.stretch = frames[frame + _IkConstraintTimeline.PREV_STRETCH] != 0;\n      }\n    } else {\n      constraint.mix += (mix + (frames[frame + _IkConstraintTimeline.MIX] - mix) * percent - constraint.mix) * alpha;\n      if (direction == MixDirection.mixIn) {\n        constraint.bendDirection = frames[frame + _IkConstraintTimeline.PREV_BEND_DIRECTION];\n        constraint.compress = frames[frame + _IkConstraintTimeline.PREV_COMPRESS] != 0;\n        constraint.stretch = frames[frame + _IkConstraintTimeline.PREV_STRETCH] != 0;\n      }\n    }\n  }\n};\nlet IkConstraintTimeline = _IkConstraintTimeline;\nIkConstraintTimeline.ENTRIES = 5;\nIkConstraintTimeline.PREV_TIME = -5;\nIkConstraintTimeline.PREV_MIX = -4;\nIkConstraintTimeline.PREV_BEND_DIRECTION = -3;\nIkConstraintTimeline.PREV_COMPRESS = -2;\nIkConstraintTimeline.PREV_STRETCH = -1;\nIkConstraintTimeline.MIX = 1;\nIkConstraintTimeline.BEND_DIRECTION = 2;\nIkConstraintTimeline.COMPRESS = 3;\nIkConstraintTimeline.STRETCH = 4;\nconst _TransformConstraintTimeline = class extends CurveTimeline {\n  // time, rotate mix, translate mix, scale mix, shear mix, ...\n  constructor(frameCount) {\n    super(frameCount);\n    this.frames = Utils.newFloatArray(frameCount * _TransformConstraintTimeline.ENTRIES);\n  }\n  getPropertyId() {\n    return (10 /* transformConstraint */ << 24) + this.transformConstraintIndex;\n  }\n  /** Sets the time and mixes of the specified keyframe. */\n  setFrame(frameIndex, time, rotateMix, translateMix, scaleMix, shearMix) {\n    frameIndex *= _TransformConstraintTimeline.ENTRIES;\n    this.frames[frameIndex] = time;\n    this.frames[frameIndex + _TransformConstraintTimeline.ROTATE] = rotateMix;\n    this.frames[frameIndex + _TransformConstraintTimeline.TRANSLATE] = translateMix;\n    this.frames[frameIndex + _TransformConstraintTimeline.SCALE] = scaleMix;\n    this.frames[frameIndex + _TransformConstraintTimeline.SHEAR] = shearMix;\n  }\n  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n    const frames = this.frames;\n    const constraint = skeleton.transformConstraints[this.transformConstraintIndex];\n    if (time < frames[0]) {\n      const data = constraint.data;\n      switch (blend) {\n        case MixBlend.setup:\n          constraint.rotateMix = data.rotateMix;\n          constraint.translateMix = data.translateMix;\n          constraint.scaleMix = data.scaleMix;\n          constraint.shearMix = data.shearMix;\n          return;\n        case MixBlend.first:\n          constraint.rotateMix += (data.rotateMix - constraint.rotateMix) * alpha;\n          constraint.translateMix += (data.translateMix - constraint.translateMix) * alpha;\n          constraint.scaleMix += (data.scaleMix - constraint.scaleMix) * alpha;\n          constraint.shearMix += (data.shearMix - constraint.shearMix) * alpha;\n      }\n      return;\n    }\n    let rotate = 0;\n    let translate = 0;\n    let scale = 0;\n    let shear = 0;\n    if (time >= frames[frames.length - _TransformConstraintTimeline.ENTRIES]) {\n      const i = frames.length;\n      rotate = frames[i + _TransformConstraintTimeline.PREV_ROTATE];\n      translate = frames[i + _TransformConstraintTimeline.PREV_TRANSLATE];\n      scale = frames[i + _TransformConstraintTimeline.PREV_SCALE];\n      shear = frames[i + _TransformConstraintTimeline.PREV_SHEAR];\n    } else {\n      const frame = Animation.binarySearch(frames, time, _TransformConstraintTimeline.ENTRIES);\n      rotate = frames[frame + _TransformConstraintTimeline.PREV_ROTATE];\n      translate = frames[frame + _TransformConstraintTimeline.PREV_TRANSLATE];\n      scale = frames[frame + _TransformConstraintTimeline.PREV_SCALE];\n      shear = frames[frame + _TransformConstraintTimeline.PREV_SHEAR];\n      const frameTime = frames[frame];\n      const percent = this.getCurvePercent(\n        frame / _TransformConstraintTimeline.ENTRIES - 1,\n        1 - (time - frameTime) / (frames[frame + _TransformConstraintTimeline.PREV_TIME] - frameTime)\n      );\n      rotate += (frames[frame + _TransformConstraintTimeline.ROTATE] - rotate) * percent;\n      translate += (frames[frame + _TransformConstraintTimeline.TRANSLATE] - translate) * percent;\n      scale += (frames[frame + _TransformConstraintTimeline.SCALE] - scale) * percent;\n      shear += (frames[frame + _TransformConstraintTimeline.SHEAR] - shear) * percent;\n    }\n    if (blend == MixBlend.setup) {\n      const data = constraint.data;\n      constraint.rotateMix = data.rotateMix + (rotate - data.rotateMix) * alpha;\n      constraint.translateMix = data.translateMix + (translate - data.translateMix) * alpha;\n      constraint.scaleMix = data.scaleMix + (scale - data.scaleMix) * alpha;\n      constraint.shearMix = data.shearMix + (shear - data.shearMix) * alpha;\n    } else {\n      constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;\n      constraint.translateMix += (translate - constraint.translateMix) * alpha;\n      constraint.scaleMix += (scale - constraint.scaleMix) * alpha;\n      constraint.shearMix += (shear - constraint.shearMix) * alpha;\n    }\n  }\n};\nlet TransformConstraintTimeline = _TransformConstraintTimeline;\nTransformConstraintTimeline.ENTRIES = 5;\nTransformConstraintTimeline.PREV_TIME = -5;\nTransformConstraintTimeline.PREV_ROTATE = -4;\nTransformConstraintTimeline.PREV_TRANSLATE = -3;\nTransformConstraintTimeline.PREV_SCALE = -2;\nTransformConstraintTimeline.PREV_SHEAR = -1;\nTransformConstraintTimeline.ROTATE = 1;\nTransformConstraintTimeline.TRANSLATE = 2;\nTransformConstraintTimeline.SCALE = 3;\nTransformConstraintTimeline.SHEAR = 4;\nconst _PathConstraintPositionTimeline = class extends CurveTimeline {\n  // time, position, ...\n  constructor(frameCount) {\n    super(frameCount);\n    this.frames = Utils.newFloatArray(frameCount * _PathConstraintPositionTimeline.ENTRIES);\n  }\n  getPropertyId() {\n    return (11 /* pathConstraintPosition */ << 24) + this.pathConstraintIndex;\n  }\n  /** Sets the time and value of the specified keyframe. */\n  setFrame(frameIndex, time, value) {\n    frameIndex *= _PathConstraintPositionTimeline.ENTRIES;\n    this.frames[frameIndex] = time;\n    this.frames[frameIndex + _PathConstraintPositionTimeline.VALUE] = value;\n  }\n  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n    const frames = this.frames;\n    const constraint = skeleton.pathConstraints[this.pathConstraintIndex];\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          constraint.position = constraint.data.position;\n          return;\n        case MixBlend.first:\n          constraint.position += (constraint.data.position - constraint.position) * alpha;\n      }\n      return;\n    }\n    let position = 0;\n    if (time >= frames[frames.length - _PathConstraintPositionTimeline.ENTRIES])\n      position = frames[frames.length + _PathConstraintPositionTimeline.PREV_VALUE];\n    else {\n      const frame = Animation.binarySearch(frames, time, _PathConstraintPositionTimeline.ENTRIES);\n      position = frames[frame + _PathConstraintPositionTimeline.PREV_VALUE];\n      const frameTime = frames[frame];\n      const percent = this.getCurvePercent(\n        frame / _PathConstraintPositionTimeline.ENTRIES - 1,\n        1 - (time - frameTime) / (frames[frame + _PathConstraintPositionTimeline.PREV_TIME] - frameTime)\n      );\n      position += (frames[frame + _PathConstraintPositionTimeline.VALUE] - position) * percent;\n    }\n    if (blend == MixBlend.setup)\n      constraint.position = constraint.data.position + (position - constraint.data.position) * alpha;\n    else\n      constraint.position += (position - constraint.position) * alpha;\n  }\n};\nlet PathConstraintPositionTimeline = _PathConstraintPositionTimeline;\nPathConstraintPositionTimeline.ENTRIES = 2;\nPathConstraintPositionTimeline.PREV_TIME = -2;\nPathConstraintPositionTimeline.PREV_VALUE = -1;\nPathConstraintPositionTimeline.VALUE = 1;\nclass PathConstraintSpacingTimeline extends PathConstraintPositionTimeline {\n  constructor(frameCount) {\n    super(frameCount);\n  }\n  getPropertyId() {\n    return (12 /* pathConstraintSpacing */ << 24) + this.pathConstraintIndex;\n  }\n  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n    const frames = this.frames;\n    const constraint = skeleton.pathConstraints[this.pathConstraintIndex];\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          constraint.spacing = constraint.data.spacing;\n          return;\n        case MixBlend.first:\n          constraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha;\n      }\n      return;\n    }\n    let spacing = 0;\n    if (time >= frames[frames.length - PathConstraintSpacingTimeline.ENTRIES])\n      spacing = frames[frames.length + PathConstraintSpacingTimeline.PREV_VALUE];\n    else {\n      const frame = Animation.binarySearch(frames, time, PathConstraintSpacingTimeline.ENTRIES);\n      spacing = frames[frame + PathConstraintSpacingTimeline.PREV_VALUE];\n      const frameTime = frames[frame];\n      const percent = this.getCurvePercent(\n        frame / PathConstraintSpacingTimeline.ENTRIES - 1,\n        1 - (time - frameTime) / (frames[frame + PathConstraintSpacingTimeline.PREV_TIME] - frameTime)\n      );\n      spacing += (frames[frame + PathConstraintSpacingTimeline.VALUE] - spacing) * percent;\n    }\n    if (blend == MixBlend.setup)\n      constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha;\n    else\n      constraint.spacing += (spacing - constraint.spacing) * alpha;\n  }\n}\nconst _PathConstraintMixTimeline = class extends CurveTimeline {\n  // time, rotate mix, translate mix, ...\n  constructor(frameCount) {\n    super(frameCount);\n    this.frames = Utils.newFloatArray(frameCount * _PathConstraintMixTimeline.ENTRIES);\n  }\n  getPropertyId() {\n    return (13 /* pathConstraintMix */ << 24) + this.pathConstraintIndex;\n  }\n  /** Sets the time and mixes of the specified keyframe. */\n  setFrame(frameIndex, time, rotateMix, translateMix) {\n    frameIndex *= _PathConstraintMixTimeline.ENTRIES;\n    this.frames[frameIndex] = time;\n    this.frames[frameIndex + _PathConstraintMixTimeline.ROTATE] = rotateMix;\n    this.frames[frameIndex + _PathConstraintMixTimeline.TRANSLATE] = translateMix;\n  }\n  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n    const frames = this.frames;\n    const constraint = skeleton.pathConstraints[this.pathConstraintIndex];\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          constraint.rotateMix = constraint.data.rotateMix;\n          constraint.translateMix = constraint.data.translateMix;\n          return;\n        case MixBlend.first:\n          constraint.rotateMix += (constraint.data.rotateMix - constraint.rotateMix) * alpha;\n          constraint.translateMix += (constraint.data.translateMix - constraint.translateMix) * alpha;\n      }\n      return;\n    }\n    let rotate = 0;\n    let translate = 0;\n    if (time >= frames[frames.length - _PathConstraintMixTimeline.ENTRIES]) {\n      rotate = frames[frames.length + _PathConstraintMixTimeline.PREV_ROTATE];\n      translate = frames[frames.length + _PathConstraintMixTimeline.PREV_TRANSLATE];\n    } else {\n      const frame = Animation.binarySearch(frames, time, _PathConstraintMixTimeline.ENTRIES);\n      rotate = frames[frame + _PathConstraintMixTimeline.PREV_ROTATE];\n      translate = frames[frame + _PathConstraintMixTimeline.PREV_TRANSLATE];\n      const frameTime = frames[frame];\n      const percent = this.getCurvePercent(\n        frame / _PathConstraintMixTimeline.ENTRIES - 1,\n        1 - (time - frameTime) / (frames[frame + _PathConstraintMixTimeline.PREV_TIME] - frameTime)\n      );\n      rotate += (frames[frame + _PathConstraintMixTimeline.ROTATE] - rotate) * percent;\n      translate += (frames[frame + _PathConstraintMixTimeline.TRANSLATE] - translate) * percent;\n    }\n    if (blend == MixBlend.setup) {\n      constraint.rotateMix = constraint.data.rotateMix + (rotate - constraint.data.rotateMix) * alpha;\n      constraint.translateMix = constraint.data.translateMix + (translate - constraint.data.translateMix) * alpha;\n    } else {\n      constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;\n      constraint.translateMix += (translate - constraint.translateMix) * alpha;\n    }\n  }\n};\nlet PathConstraintMixTimeline = _PathConstraintMixTimeline;\nPathConstraintMixTimeline.ENTRIES = 3;\nPathConstraintMixTimeline.PREV_TIME = -3;\nPathConstraintMixTimeline.PREV_ROTATE = -2;\nPathConstraintMixTimeline.PREV_TRANSLATE = -1;\nPathConstraintMixTimeline.ROTATE = 1;\nPathConstraintMixTimeline.TRANSLATE = 2;\n\nexport { Animation, AttachmentTimeline, ColorTimeline, CurveTimeline, DeformTimeline, DrawOrderTimeline, EventTimeline, IkConstraintTimeline, PathConstraintMixTimeline, PathConstraintPositionTimeline, PathConstraintSpacingTimeline, RotateTimeline, ScaleTimeline, ShearTimeline, TimelineType, TransformConstraintTimeline, TranslateTimeline, TwoColorTimeline };\n//# sourceMappingURL=Animation.mjs.map\n","import { IntSet, Pool, MixBlend, Utils, MixDirection, MathUtils } from '@pixi-spine/base';\nimport { Animation, RotateTimeline, AttachmentTimeline, DrawOrderTimeline } from './Animation.mjs';\n\nconst _AnimationState = class {\n  constructor(data) {\n    this.tracks = new Array();\n    this.events = new Array();\n    this.listeners = new Array();\n    this.queue = new EventQueue(this);\n    this.propertyIDs = new IntSet();\n    this.animationsChanged = false;\n    this.timeScale = 1;\n    this.trackEntryPool = new Pool(() => new TrackEntry());\n    this.data = data;\n  }\n  update(delta) {\n    delta *= this.timeScale;\n    const tracks = this.tracks;\n    for (let i = 0, n = tracks.length; i < n; i++) {\n      const current = tracks[i];\n      if (current == null)\n        continue;\n      current.animationLast = current.nextAnimationLast;\n      current.trackLast = current.nextTrackLast;\n      let currentDelta = delta * current.timeScale;\n      if (current.delay > 0) {\n        current.delay -= currentDelta;\n        if (current.delay > 0)\n          continue;\n        currentDelta = -current.delay;\n        current.delay = 0;\n      }\n      let next = current.next;\n      if (next != null) {\n        const nextTime = current.trackLast - next.delay;\n        if (nextTime >= 0) {\n          next.delay = 0;\n          next.trackTime = current.timeScale == 0 ? 0 : (nextTime / current.timeScale + delta) * next.timeScale;\n          current.trackTime += currentDelta;\n          this.setCurrent(i, next, true);\n          while (next.mixingFrom != null) {\n            next.mixTime += delta;\n            next = next.mixingFrom;\n          }\n          continue;\n        }\n      } else if (current.trackLast >= current.trackEnd && current.mixingFrom == null) {\n        tracks[i] = null;\n        this.queue.end(current);\n        this.disposeNext(current);\n        continue;\n      }\n      if (current.mixingFrom != null && this.updateMixingFrom(current, delta)) {\n        let from = current.mixingFrom;\n        current.mixingFrom = null;\n        if (from != null)\n          from.mixingTo = null;\n        while (from != null) {\n          this.queue.end(from);\n          from = from.mixingFrom;\n        }\n      }\n      current.trackTime += currentDelta;\n    }\n    this.queue.drain();\n  }\n  updateMixingFrom(to, delta) {\n    const from = to.mixingFrom;\n    if (from == null)\n      return true;\n    const finished = this.updateMixingFrom(from, delta);\n    from.animationLast = from.nextAnimationLast;\n    from.trackLast = from.nextTrackLast;\n    if (to.mixTime > 0 && to.mixTime >= to.mixDuration) {\n      if (from.totalAlpha == 0 || to.mixDuration == 0) {\n        to.mixingFrom = from.mixingFrom;\n        if (from.mixingFrom != null)\n          from.mixingFrom.mixingTo = to;\n        to.interruptAlpha = from.interruptAlpha;\n        this.queue.end(from);\n      }\n      return finished;\n    }\n    from.trackTime += delta * from.timeScale;\n    to.mixTime += delta;\n    return false;\n  }\n  apply(skeleton) {\n    if (skeleton == null)\n      throw new Error(\"skeleton cannot be null.\");\n    if (this.animationsChanged)\n      this._animationsChanged();\n    const events = this.events;\n    const tracks = this.tracks;\n    let applied = false;\n    for (let i = 0, n = tracks.length; i < n; i++) {\n      const current = tracks[i];\n      if (current == null || current.delay > 0)\n        continue;\n      applied = true;\n      const blend = i == 0 ? MixBlend.first : current.mixBlend;\n      let mix = current.alpha;\n      if (current.mixingFrom != null)\n        mix *= this.applyMixingFrom(current, skeleton, blend);\n      else if (current.trackTime >= current.trackEnd && current.next == null)\n        mix = 0;\n      const animationLast = current.animationLast;\n      const animationTime = current.getAnimationTime();\n      const timelineCount = current.animation.timelines.length;\n      const timelines = current.animation.timelines;\n      if (i == 0 && mix == 1 || blend == MixBlend.add) {\n        for (let ii = 0; ii < timelineCount; ii++) {\n          Utils.webkit602BugfixHelper(mix, blend);\n          timelines[ii].apply(skeleton, animationLast, animationTime, events, mix, blend, MixDirection.mixIn);\n        }\n      } else {\n        const timelineMode = current.timelineMode;\n        const firstFrame = current.timelinesRotation.length == 0;\n        if (firstFrame)\n          Utils.setArraySize(current.timelinesRotation, timelineCount << 1, null);\n        const timelinesRotation = current.timelinesRotation;\n        for (let ii = 0; ii < timelineCount; ii++) {\n          const timeline = timelines[ii];\n          const timelineBlend = timelineMode[ii] == _AnimationState.SUBSEQUENT ? blend : MixBlend.setup;\n          if (timeline instanceof RotateTimeline) {\n            this.applyRotateTimeline(timeline, skeleton, animationTime, mix, timelineBlend, timelinesRotation, ii << 1, firstFrame);\n          } else {\n            Utils.webkit602BugfixHelper(mix, blend);\n            timeline.apply(skeleton, animationLast, animationTime, events, mix, timelineBlend, MixDirection.mixIn);\n          }\n        }\n      }\n      this.queueEvents(current, animationTime);\n      events.length = 0;\n      current.nextAnimationLast = animationTime;\n      current.nextTrackLast = current.trackTime;\n    }\n    this.queue.drain();\n    return applied;\n  }\n  applyMixingFrom(to, skeleton, blend) {\n    const from = to.mixingFrom;\n    if (from.mixingFrom != null)\n      this.applyMixingFrom(from, skeleton, blend);\n    let mix = 0;\n    if (to.mixDuration == 0) {\n      mix = 1;\n      if (blend == MixBlend.first)\n        blend = MixBlend.setup;\n    } else {\n      mix = to.mixTime / to.mixDuration;\n      if (mix > 1)\n        mix = 1;\n      if (blend != MixBlend.first)\n        blend = from.mixBlend;\n    }\n    const events = mix < from.eventThreshold ? this.events : null;\n    const attachments = mix < from.attachmentThreshold;\n    const drawOrder = mix < from.drawOrderThreshold;\n    const animationLast = from.animationLast;\n    const animationTime = from.getAnimationTime();\n    const timelineCount = from.animation.timelines.length;\n    const timelines = from.animation.timelines;\n    const alphaHold = from.alpha * to.interruptAlpha;\n    const alphaMix = alphaHold * (1 - mix);\n    if (blend == MixBlend.add) {\n      for (let i = 0; i < timelineCount; i++)\n        timelines[i].apply(skeleton, animationLast, animationTime, events, alphaMix, blend, MixDirection.mixOut);\n    } else {\n      const timelineMode = from.timelineMode;\n      const timelineHoldMix = from.timelineHoldMix;\n      const firstFrame = from.timelinesRotation.length == 0;\n      if (firstFrame)\n        Utils.setArraySize(from.timelinesRotation, timelineCount << 1, null);\n      const timelinesRotation = from.timelinesRotation;\n      from.totalAlpha = 0;\n      for (let i = 0; i < timelineCount; i++) {\n        const timeline = timelines[i];\n        let direction = MixDirection.mixOut;\n        let timelineBlend;\n        let alpha = 0;\n        switch (timelineMode[i]) {\n          case _AnimationState.SUBSEQUENT:\n            if (!attachments && timeline instanceof AttachmentTimeline)\n              continue;\n            if (!drawOrder && timeline instanceof DrawOrderTimeline)\n              continue;\n            timelineBlend = blend;\n            alpha = alphaMix;\n            break;\n          case _AnimationState.FIRST:\n            timelineBlend = MixBlend.setup;\n            alpha = alphaMix;\n            break;\n          case _AnimationState.HOLD:\n            timelineBlend = MixBlend.setup;\n            alpha = alphaHold;\n            break;\n          default:\n            timelineBlend = MixBlend.setup;\n            const holdMix = timelineHoldMix[i];\n            alpha = alphaHold * Math.max(0, 1 - holdMix.mixTime / holdMix.mixDuration);\n            break;\n        }\n        from.totalAlpha += alpha;\n        if (timeline instanceof RotateTimeline)\n          this.applyRotateTimeline(timeline, skeleton, animationTime, alpha, timelineBlend, timelinesRotation, i << 1, firstFrame);\n        else {\n          Utils.webkit602BugfixHelper(alpha, blend);\n          if (timelineBlend == MixBlend.setup) {\n            if (timeline instanceof AttachmentTimeline) {\n              if (attachments)\n                direction = MixDirection.mixOut;\n            } else if (timeline instanceof DrawOrderTimeline) {\n              if (drawOrder)\n                direction = MixDirection.mixOut;\n            }\n          }\n          timeline.apply(skeleton, animationLast, animationTime, events, alpha, timelineBlend, direction);\n        }\n      }\n    }\n    if (to.mixDuration > 0)\n      this.queueEvents(from, animationTime);\n    this.events.length = 0;\n    from.nextAnimationLast = animationTime;\n    from.nextTrackLast = from.trackTime;\n    return mix;\n  }\n  applyRotateTimeline(timeline, skeleton, time, alpha, blend, timelinesRotation, i, firstFrame) {\n    if (firstFrame)\n      timelinesRotation[i] = 0;\n    if (alpha == 1) {\n      timeline.apply(skeleton, 0, time, null, 1, blend, MixDirection.mixIn);\n      return;\n    }\n    const rotateTimeline = timeline;\n    const frames = rotateTimeline.frames;\n    const bone = skeleton.bones[rotateTimeline.boneIndex];\n    let r1 = 0;\n    let r2 = 0;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.rotation = bone.data.rotation;\n        default:\n          return;\n        case MixBlend.first:\n          r1 = bone.rotation;\n          r2 = bone.data.rotation;\n      }\n    } else {\n      r1 = blend == MixBlend.setup ? bone.data.rotation : bone.rotation;\n      if (time >= frames[frames.length - RotateTimeline.ENTRIES])\n        r2 = bone.data.rotation + frames[frames.length + RotateTimeline.PREV_ROTATION];\n      else {\n        const frame = Animation.binarySearch(frames, time, RotateTimeline.ENTRIES);\n        const prevRotation = frames[frame + RotateTimeline.PREV_ROTATION];\n        const frameTime = frames[frame];\n        const percent = rotateTimeline.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + RotateTimeline.PREV_TIME] - frameTime));\n        r2 = frames[frame + RotateTimeline.ROTATION] - prevRotation;\n        r2 -= (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360;\n        r2 = prevRotation + r2 * percent + bone.data.rotation;\n        r2 -= (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360;\n      }\n    }\n    let total = 0;\n    let diff = r2 - r1;\n    diff -= (16384 - (16384.499999999996 - diff / 360 | 0)) * 360;\n    if (diff == 0) {\n      total = timelinesRotation[i];\n    } else {\n      let lastTotal = 0;\n      let lastDiff = 0;\n      if (firstFrame) {\n        lastTotal = 0;\n        lastDiff = diff;\n      } else {\n        lastTotal = timelinesRotation[i];\n        lastDiff = timelinesRotation[i + 1];\n      }\n      const current = diff > 0;\n      let dir = lastTotal >= 0;\n      if (MathUtils.signum(lastDiff) != MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {\n        if (Math.abs(lastTotal) > 180)\n          lastTotal += 360 * MathUtils.signum(lastTotal);\n        dir = current;\n      }\n      total = diff + lastTotal - lastTotal % 360;\n      if (dir != current)\n        total += 360 * MathUtils.signum(lastTotal);\n      timelinesRotation[i] = total;\n    }\n    timelinesRotation[i + 1] = diff;\n    r1 += total * alpha;\n    bone.rotation = r1 - (16384 - (16384.499999999996 - r1 / 360 | 0)) * 360;\n  }\n  queueEvents(entry, animationTime) {\n    const animationStart = entry.animationStart;\n    const animationEnd = entry.animationEnd;\n    const duration = animationEnd - animationStart;\n    const trackLastWrapped = entry.trackLast % duration;\n    const events = this.events;\n    let i = 0;\n    const n = events.length;\n    for (; i < n; i++) {\n      const event = events[i];\n      if (event.time < trackLastWrapped)\n        break;\n      if (event.time > animationEnd)\n        continue;\n      this.queue.event(entry, event);\n    }\n    let complete = false;\n    if (entry.loop)\n      complete = duration == 0 || trackLastWrapped > entry.trackTime % duration;\n    else\n      complete = animationTime >= animationEnd && entry.animationLast < animationEnd;\n    if (complete)\n      this.queue.complete(entry);\n    for (; i < n; i++) {\n      const event = events[i];\n      if (event.time < animationStart)\n        continue;\n      this.queue.event(entry, events[i]);\n    }\n  }\n  clearTracks() {\n    const oldDrainDisabled = this.queue.drainDisabled;\n    this.queue.drainDisabled = true;\n    for (let i = 0, n = this.tracks.length; i < n; i++)\n      this.clearTrack(i);\n    this.tracks.length = 0;\n    this.queue.drainDisabled = oldDrainDisabled;\n    this.queue.drain();\n  }\n  clearTrack(trackIndex) {\n    if (trackIndex >= this.tracks.length)\n      return;\n    const current = this.tracks[trackIndex];\n    if (current == null)\n      return;\n    this.queue.end(current);\n    this.disposeNext(current);\n    let entry = current;\n    while (true) {\n      const from = entry.mixingFrom;\n      if (from == null)\n        break;\n      this.queue.end(from);\n      entry.mixingFrom = null;\n      entry.mixingTo = null;\n      entry = from;\n    }\n    this.tracks[current.trackIndex] = null;\n    this.queue.drain();\n  }\n  setCurrent(index, current, interrupt) {\n    const from = this.expandToIndex(index);\n    this.tracks[index] = current;\n    if (from != null) {\n      if (interrupt)\n        this.queue.interrupt(from);\n      current.mixingFrom = from;\n      from.mixingTo = current;\n      current.mixTime = 0;\n      if (from.mixingFrom != null && from.mixDuration > 0)\n        current.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);\n      from.timelinesRotation.length = 0;\n    }\n    this.queue.start(current);\n  }\n  setAnimation(trackIndex, animationName, loop) {\n    const animation = this.data.skeletonData.findAnimation(animationName);\n    if (animation == null)\n      throw new Error(`Animation not found: ${animationName}`);\n    return this.setAnimationWith(trackIndex, animation, loop);\n  }\n  setAnimationWith(trackIndex, animation, loop) {\n    if (animation == null)\n      throw new Error(\"animation cannot be null.\");\n    let interrupt = true;\n    let current = this.expandToIndex(trackIndex);\n    if (current != null) {\n      if (current.nextTrackLast == -1) {\n        this.tracks[trackIndex] = current.mixingFrom;\n        this.queue.interrupt(current);\n        this.queue.end(current);\n        this.disposeNext(current);\n        current = current.mixingFrom;\n        interrupt = false;\n      } else\n        this.disposeNext(current);\n    }\n    const entry = this.trackEntry(trackIndex, animation, loop, current);\n    this.setCurrent(trackIndex, entry, interrupt);\n    this.queue.drain();\n    return entry;\n  }\n  addAnimation(trackIndex, animationName, loop, delay) {\n    const animation = this.data.skeletonData.findAnimation(animationName);\n    if (animation == null)\n      throw new Error(`Animation not found: ${animationName}`);\n    return this.addAnimationWith(trackIndex, animation, loop, delay);\n  }\n  addAnimationWith(trackIndex, animation, loop, delay) {\n    if (animation == null)\n      throw new Error(\"animation cannot be null.\");\n    let last = this.expandToIndex(trackIndex);\n    if (last != null) {\n      while (last.next != null)\n        last = last.next;\n    }\n    const entry = this.trackEntry(trackIndex, animation, loop, last);\n    if (last == null) {\n      this.setCurrent(trackIndex, entry, true);\n      this.queue.drain();\n    } else {\n      last.next = entry;\n      if (delay <= 0) {\n        const duration = last.animationEnd - last.animationStart;\n        if (duration != 0) {\n          if (last.loop)\n            delay += duration * (1 + (last.trackTime / duration | 0));\n          else\n            delay += Math.max(duration, last.trackTime);\n          delay -= this.data.getMix(last.animation, animation);\n        } else\n          delay = last.trackTime;\n      }\n    }\n    entry.delay = delay;\n    return entry;\n  }\n  setEmptyAnimation(trackIndex, mixDuration) {\n    const entry = this.setAnimationWith(trackIndex, _AnimationState.emptyAnimation, false);\n    entry.mixDuration = mixDuration;\n    entry.trackEnd = mixDuration;\n    return entry;\n  }\n  addEmptyAnimation(trackIndex, mixDuration, delay) {\n    if (delay <= 0)\n      delay -= mixDuration;\n    const entry = this.addAnimationWith(trackIndex, _AnimationState.emptyAnimation, false, delay);\n    entry.mixDuration = mixDuration;\n    entry.trackEnd = mixDuration;\n    return entry;\n  }\n  setEmptyAnimations(mixDuration) {\n    const oldDrainDisabled = this.queue.drainDisabled;\n    this.queue.drainDisabled = true;\n    for (let i = 0, n = this.tracks.length; i < n; i++) {\n      const current = this.tracks[i];\n      if (current != null)\n        this.setEmptyAnimation(current.trackIndex, mixDuration);\n    }\n    this.queue.drainDisabled = oldDrainDisabled;\n    this.queue.drain();\n  }\n  expandToIndex(index) {\n    if (index < this.tracks.length)\n      return this.tracks[index];\n    Utils.ensureArrayCapacity(this.tracks, index - this.tracks.length + 1, null);\n    this.tracks.length = index + 1;\n    return null;\n  }\n  trackEntry(trackIndex, animation, loop, last) {\n    const entry = this.trackEntryPool.obtain();\n    entry.trackIndex = trackIndex;\n    entry.animation = animation;\n    entry.loop = loop;\n    entry.holdPrevious = false;\n    entry.eventThreshold = 0;\n    entry.attachmentThreshold = 0;\n    entry.drawOrderThreshold = 0;\n    entry.animationStart = 0;\n    entry.animationEnd = animation.duration;\n    entry.animationLast = -1;\n    entry.nextAnimationLast = -1;\n    entry.delay = 0;\n    entry.trackTime = 0;\n    entry.trackLast = -1;\n    entry.nextTrackLast = -1;\n    entry.trackEnd = Number.MAX_VALUE;\n    entry.timeScale = 1;\n    entry.alpha = 1;\n    entry.interruptAlpha = 1;\n    entry.mixTime = 0;\n    entry.mixDuration = last == null ? 0 : this.data.getMix(last.animation, animation);\n    return entry;\n  }\n  disposeNext(entry) {\n    let next = entry.next;\n    while (next != null) {\n      this.queue.dispose(next);\n      next = next.next;\n    }\n    entry.next = null;\n  }\n  _animationsChanged() {\n    this.animationsChanged = false;\n    this.propertyIDs.clear();\n    for (let i = 0, n = this.tracks.length; i < n; i++) {\n      let entry = this.tracks[i];\n      if (entry == null)\n        continue;\n      while (entry.mixingFrom != null)\n        entry = entry.mixingFrom;\n      do {\n        if (entry.mixingFrom == null || entry.mixBlend != MixBlend.add)\n          this.setTimelineModes(entry);\n        entry = entry.mixingTo;\n      } while (entry != null);\n    }\n  }\n  setTimelineModes(entry) {\n    const to = entry.mixingTo;\n    const timelines = entry.animation.timelines;\n    const timelinesCount = entry.animation.timelines.length;\n    const timelineMode = Utils.setArraySize(entry.timelineMode, timelinesCount);\n    entry.timelineHoldMix.length = 0;\n    const timelineDipMix = Utils.setArraySize(entry.timelineHoldMix, timelinesCount);\n    const propertyIDs = this.propertyIDs;\n    if (to != null && to.holdPrevious) {\n      for (let i = 0; i < timelinesCount; i++) {\n        propertyIDs.add(timelines[i].getPropertyId());\n        timelineMode[i] = _AnimationState.HOLD;\n      }\n      return;\n    }\n    outer:\n      for (let i = 0; i < timelinesCount; i++) {\n        const id = timelines[i].getPropertyId();\n        if (!propertyIDs.add(id))\n          timelineMode[i] = _AnimationState.SUBSEQUENT;\n        else if (to == null || !this.hasTimeline(to, id))\n          timelineMode[i] = _AnimationState.FIRST;\n        else {\n          for (let next = to.mixingTo; next != null; next = next.mixingTo) {\n            if (this.hasTimeline(next, id))\n              continue;\n            if (entry.mixDuration > 0) {\n              timelineMode[i] = _AnimationState.HOLD_MIX;\n              timelineDipMix[i] = next;\n              continue outer;\n            }\n            break;\n          }\n          timelineMode[i] = _AnimationState.HOLD;\n        }\n      }\n  }\n  hasTimeline(entry, id) {\n    const timelines = entry.animation.timelines;\n    for (let i = 0, n = timelines.length; i < n; i++)\n      if (timelines[i].getPropertyId() == id)\n        return true;\n    return false;\n  }\n  getCurrent(trackIndex) {\n    if (trackIndex >= this.tracks.length)\n      return null;\n    return this.tracks[trackIndex];\n  }\n  addListener(listener) {\n    if (listener == null)\n      throw new Error(\"listener cannot be null.\");\n    this.listeners.push(listener);\n  }\n  /** Removes the listener added with {@link #addListener(AnimationStateListener)}. */\n  removeListener(listener) {\n    const index = this.listeners.indexOf(listener);\n    if (index >= 0)\n      this.listeners.splice(index, 1);\n  }\n  clearListeners() {\n    this.listeners.length = 0;\n  }\n  clearListenerNotifications() {\n    this.queue.clear();\n  }\n  setAnimationByName(trackIndex, animationName, loop) {\n    if (!_AnimationState.deprecatedWarning1) {\n      _AnimationState.deprecatedWarning1 = true;\n      console.warn(\"Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.\");\n    }\n    this.setAnimation(trackIndex, animationName, loop);\n  }\n  addAnimationByName(trackIndex, animationName, loop, delay) {\n    if (!_AnimationState.deprecatedWarning2) {\n      _AnimationState.deprecatedWarning2 = true;\n      console.warn(\"Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.\");\n    }\n    this.addAnimation(trackIndex, animationName, loop, delay);\n  }\n  hasAnimation(animationName) {\n    const animation = this.data.skeletonData.findAnimation(animationName);\n    return animation !== null;\n  }\n  hasAnimationByName(animationName) {\n    if (!_AnimationState.deprecatedWarning3) {\n      _AnimationState.deprecatedWarning3 = true;\n      console.warn(\"Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.\");\n    }\n    return this.hasAnimation(animationName);\n  }\n};\nlet AnimationState = _AnimationState;\nAnimationState.emptyAnimation = new Animation(\"<empty>\", [], 0);\nAnimationState.SUBSEQUENT = 0;\nAnimationState.FIRST = 1;\nAnimationState.HOLD = 2;\nAnimationState.HOLD_MIX = 3;\nAnimationState.deprecatedWarning1 = false;\nAnimationState.deprecatedWarning2 = false;\nAnimationState.deprecatedWarning3 = false;\nconst _TrackEntry = class {\n  constructor() {\n    this.mixBlend = MixBlend.replace;\n    this.timelineMode = new Array();\n    this.timelineHoldMix = new Array();\n    this.timelinesRotation = new Array();\n  }\n  reset() {\n    this.next = null;\n    this.mixingFrom = null;\n    this.mixingTo = null;\n    this.animation = null;\n    this.listener = null;\n    this.timelineMode.length = 0;\n    this.timelineHoldMix.length = 0;\n    this.timelinesRotation.length = 0;\n  }\n  getAnimationTime() {\n    if (this.loop) {\n      const duration = this.animationEnd - this.animationStart;\n      if (duration == 0)\n        return this.animationStart;\n      return this.trackTime % duration + this.animationStart;\n    }\n    return Math.min(this.trackTime + this.animationStart, this.animationEnd);\n  }\n  setAnimationLast(animationLast) {\n    this.animationLast = animationLast;\n    this.nextAnimationLast = animationLast;\n  }\n  isComplete() {\n    return this.trackTime >= this.animationEnd - this.animationStart;\n  }\n  resetRotationDirections() {\n    this.timelinesRotation.length = 0;\n  }\n  get time() {\n    if (!_TrackEntry.deprecatedWarning1) {\n      _TrackEntry.deprecatedWarning1 = true;\n      console.warn(\"Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.\");\n    }\n    return this.trackTime;\n  }\n  set time(value) {\n    if (!_TrackEntry.deprecatedWarning1) {\n      _TrackEntry.deprecatedWarning1 = true;\n      console.warn(\"Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.\");\n    }\n    this.trackTime = value;\n  }\n  get endTime() {\n    if (!_TrackEntry.deprecatedWarning2) {\n      _TrackEntry.deprecatedWarning2 = true;\n      console.warn(\"Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.\");\n    }\n    return this.trackTime;\n  }\n  set endTime(value) {\n    if (!_TrackEntry.deprecatedWarning2) {\n      _TrackEntry.deprecatedWarning2 = true;\n      console.warn(\"Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.\");\n    }\n    this.trackTime = value;\n  }\n  loopsCount() {\n    return Math.floor(this.trackTime / this.trackEnd);\n  }\n};\nlet TrackEntry = _TrackEntry;\nTrackEntry.deprecatedWarning1 = false;\nTrackEntry.deprecatedWarning2 = false;\nconst _EventQueue = class {\n  constructor(animState) {\n    this.objects = [];\n    this.drainDisabled = false;\n    this.animState = animState;\n  }\n  start(entry) {\n    this.objects.push(EventType.start);\n    this.objects.push(entry);\n    this.animState.animationsChanged = true;\n  }\n  interrupt(entry) {\n    this.objects.push(EventType.interrupt);\n    this.objects.push(entry);\n  }\n  end(entry) {\n    this.objects.push(EventType.end);\n    this.objects.push(entry);\n    this.animState.animationsChanged = true;\n  }\n  dispose(entry) {\n    this.objects.push(EventType.dispose);\n    this.objects.push(entry);\n  }\n  complete(entry) {\n    this.objects.push(EventType.complete);\n    this.objects.push(entry);\n  }\n  event(entry, event) {\n    this.objects.push(EventType.event);\n    this.objects.push(entry);\n    this.objects.push(event);\n  }\n  deprecateStuff() {\n    if (!_EventQueue.deprecatedWarning1) {\n      _EventQueue.deprecatedWarning1 = true;\n      console.warn(\n        \"Spine Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'\"\n      );\n    }\n    return true;\n  }\n  drain() {\n    if (this.drainDisabled)\n      return;\n    this.drainDisabled = true;\n    const objects = this.objects;\n    const listeners = this.animState.listeners;\n    for (let i = 0; i < objects.length; i += 2) {\n      const type = objects[i];\n      const entry = objects[i + 1];\n      switch (type) {\n        case EventType.start:\n          if (entry.listener != null && entry.listener.start)\n            entry.listener.start(entry);\n          for (let ii = 0; ii < listeners.length; ii++)\n            if (listeners[ii].start)\n              listeners[ii].start(entry);\n          entry.onStart && this.deprecateStuff() && entry.onStart(entry.trackIndex);\n          this.animState.onStart && this.deprecateStuff() && this.deprecateStuff && this.animState.onStart(entry.trackIndex);\n          break;\n        case EventType.interrupt:\n          if (entry.listener != null && entry.listener.interrupt)\n            entry.listener.interrupt(entry);\n          for (let ii = 0; ii < listeners.length; ii++)\n            if (listeners[ii].interrupt)\n              listeners[ii].interrupt(entry);\n          break;\n        case EventType.end:\n          if (entry.listener != null && entry.listener.end)\n            entry.listener.end(entry);\n          for (let ii = 0; ii < listeners.length; ii++)\n            if (listeners[ii].end)\n              listeners[ii].end(entry);\n          entry.onEnd && this.deprecateStuff() && entry.onEnd(entry.trackIndex);\n          this.animState.onEnd && this.deprecateStuff() && this.animState.onEnd(entry.trackIndex);\n        case EventType.dispose:\n          if (entry.listener != null && entry.listener.dispose)\n            entry.listener.dispose(entry);\n          for (let ii = 0; ii < listeners.length; ii++)\n            if (listeners[ii].dispose)\n              listeners[ii].dispose(entry);\n          this.animState.trackEntryPool.free(entry);\n          break;\n        case EventType.complete:\n          if (entry.listener != null && entry.listener.complete)\n            entry.listener.complete(entry);\n          for (let ii = 0; ii < listeners.length; ii++)\n            if (listeners[ii].complete)\n              listeners[ii].complete(entry);\n          const count = MathUtils.toInt(entry.loopsCount());\n          entry.onComplete && this.deprecateStuff() && entry.onComplete(entry.trackIndex, count);\n          this.animState.onComplete && this.deprecateStuff() && this.animState.onComplete(entry.trackIndex, count);\n          break;\n        case EventType.event:\n          const event = objects[i++ + 2];\n          if (entry.listener != null && entry.listener.event)\n            entry.listener.event(entry, event);\n          for (let ii = 0; ii < listeners.length; ii++)\n            if (listeners[ii].event)\n              listeners[ii].event(entry, event);\n          entry.onEvent && this.deprecateStuff() && entry.onEvent(entry.trackIndex, event);\n          this.animState.onEvent && this.deprecateStuff() && this.animState.onEvent(entry.trackIndex, event);\n          break;\n      }\n    }\n    this.clear();\n    this.drainDisabled = false;\n  }\n  clear() {\n    this.objects.length = 0;\n  }\n};\nlet EventQueue = _EventQueue;\nEventQueue.deprecatedWarning1 = false;\nvar EventType = /* @__PURE__ */ ((EventType2) => {\n  EventType2[EventType2[\"start\"] = 0] = \"start\";\n  EventType2[EventType2[\"interrupt\"] = 1] = \"interrupt\";\n  EventType2[EventType2[\"end\"] = 2] = \"end\";\n  EventType2[EventType2[\"dispose\"] = 3] = \"dispose\";\n  EventType2[EventType2[\"complete\"] = 4] = \"complete\";\n  EventType2[EventType2[\"event\"] = 5] = \"event\";\n  return EventType2;\n})(EventType || {});\nclass AnimationStateAdapter2 {\n  start(entry) {\n  }\n  interrupt(entry) {\n  }\n  end(entry) {\n  }\n  dispose(entry) {\n  }\n  complete(entry) {\n  }\n  event(entry, event) {\n  }\n}\n\nexport { AnimationState, AnimationStateAdapter2, EventQueue, EventType, TrackEntry };\n//# sourceMappingURL=AnimationState.mjs.map\n","const _AnimationStateData = class {\n  constructor(skeletonData) {\n    this.animationToMixTime = {};\n    this.defaultMix = 0;\n    if (skeletonData == null)\n      throw new Error(\"skeletonData cannot be null.\");\n    this.skeletonData = skeletonData;\n  }\n  setMix(fromName, toName, duration) {\n    const from = this.skeletonData.findAnimation(fromName);\n    if (from == null)\n      throw new Error(`Animation not found: ${fromName}`);\n    const to = this.skeletonData.findAnimation(toName);\n    if (to == null)\n      throw new Error(`Animation not found: ${toName}`);\n    this.setMixWith(from, to, duration);\n  }\n  setMixByName(fromName, toName, duration) {\n    if (!_AnimationStateData.deprecatedWarning1) {\n      _AnimationStateData.deprecatedWarning1 = true;\n      console.warn(\"Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.\");\n    }\n    this.setMix(fromName, toName, duration);\n  }\n  setMixWith(from, to, duration) {\n    if (from == null)\n      throw new Error(\"from cannot be null.\");\n    if (to == null)\n      throw new Error(\"to cannot be null.\");\n    const key = `${from.name}.${to.name}`;\n    this.animationToMixTime[key] = duration;\n  }\n  getMix(from, to) {\n    const key = `${from.name}.${to.name}`;\n    const value = this.animationToMixTime[key];\n    return value === void 0 ? this.defaultMix : value;\n  }\n};\nlet AnimationStateData = _AnimationStateData;\nAnimationStateData.deprecatedWarning1 = false;\n\nexport { AnimationStateData };\n//# sourceMappingURL=AnimationStateData.mjs.map\n","import './attachments/Attachment.mjs';\nimport { BoundingBoxAttachment } from './attachments/BoundingBoxAttachment.mjs';\nimport { ClippingAttachment } from './attachments/ClippingAttachment.mjs';\nimport { MeshAttachment } from './attachments/MeshAttachment.mjs';\nimport { PathAttachment } from './attachments/PathAttachment.mjs';\nimport { PointAttachment } from './attachments/PointAttachment.mjs';\nimport { RegionAttachment } from './attachments/RegionAttachment.mjs';\n\nclass AtlasAttachmentLoader {\n  constructor(atlas) {\n    this.atlas = atlas;\n  }\n  /** @return May be null to not load an attachment. */\n  newRegionAttachment(skin, name, path) {\n    const region = this.atlas.findRegion(path);\n    if (region == null)\n      throw new Error(`Region not found in atlas: ${path} (region attachment: ${name})`);\n    const attachment = new RegionAttachment(name);\n    attachment.region = region;\n    return attachment;\n  }\n  /** @return May be null to not load an attachment. */\n  newMeshAttachment(skin, name, path) {\n    const region = this.atlas.findRegion(path);\n    if (region == null)\n      throw new Error(`Region not found in atlas: ${path} (mesh attachment: ${name})`);\n    const attachment = new MeshAttachment(name);\n    attachment.region = region;\n    return attachment;\n  }\n  /** @return May be null to not load an attachment. */\n  newBoundingBoxAttachment(skin, name) {\n    return new BoundingBoxAttachment(name);\n  }\n  /** @return May be null to not load an attachment */\n  newPathAttachment(skin, name) {\n    return new PathAttachment(name);\n  }\n  newPointAttachment(skin, name) {\n    return new PointAttachment(name);\n  }\n  newClippingAttachment(skin, name) {\n    return new ClippingAttachment(name);\n  }\n}\n\nexport { AtlasAttachmentLoader };\n//# sourceMappingURL=AtlasAttachmentLoader.mjs.map\n","import { Matrix } from '@pixi/core';\nimport { settings, MathUtils, TransformMode } from '@pixi-spine/base';\n\nclass Bone {\n  /** @param parent May be null. */\n  constructor(data, skeleton, parent) {\n    // be careful! Spine b,c is c,b in pixi matrix\n    this.matrix = new Matrix();\n    this.children = new Array();\n    this.x = 0;\n    this.y = 0;\n    this.rotation = 0;\n    this.scaleX = 0;\n    this.scaleY = 0;\n    this.shearX = 0;\n    this.shearY = 0;\n    this.ax = 0;\n    this.ay = 0;\n    this.arotation = 0;\n    this.ascaleX = 0;\n    this.ascaleY = 0;\n    this.ashearX = 0;\n    this.ashearY = 0;\n    this.appliedValid = false;\n    this.sorted = false;\n    /** NOT USED IN 3.7. Needed for the debug graph code */\n    this.active = true;\n    if (data == null)\n      throw new Error(\"data cannot be null.\");\n    if (skeleton == null)\n      throw new Error(\"skeleton cannot be null.\");\n    this.data = data;\n    this.skeleton = skeleton;\n    this.parent = parent;\n    this.setToSetupPose();\n  }\n  get worldX() {\n    return this.matrix.tx;\n  }\n  get worldY() {\n    return this.matrix.ty;\n  }\n  /** Same as {@link #updateWorldTransform()}. This method exists for Bone to implement {@link Updatable}. */\n  update() {\n    this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\n  }\n  /** Computes the world transform using the parent bone and this bone's local transform. */\n  updateWorldTransform() {\n    this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\n  }\n  /** Computes the world transform using the parent bone and the specified local transform. */\n  updateWorldTransformWith(x, y, rotation, scaleX, scaleY, shearX, shearY) {\n    this.ax = x;\n    this.ay = y;\n    this.arotation = rotation;\n    this.ascaleX = scaleX;\n    this.ascaleY = scaleY;\n    this.ashearX = shearX;\n    this.ashearY = shearY;\n    this.appliedValid = true;\n    const parent = this.parent;\n    const m = this.matrix;\n    const sx = this.skeleton.scaleX;\n    const sy = settings.yDown ? -this.skeleton.scaleY : this.skeleton.scaleY;\n    if (parent == null) {\n      const skeleton = this.skeleton;\n      const rotationY = rotation + 90 + shearY;\n      m.a = MathUtils.cosDeg(rotation + shearX) * scaleX * sx;\n      m.c = MathUtils.cosDeg(rotationY) * scaleY * sx;\n      m.b = MathUtils.sinDeg(rotation + shearX) * scaleX * sy;\n      m.d = MathUtils.sinDeg(rotationY) * scaleY * sy;\n      m.tx = x * sx + skeleton.x;\n      m.ty = y * sy + skeleton.y;\n      return;\n    }\n    let pa = parent.matrix.a;\n    let pb = parent.matrix.c;\n    let pc = parent.matrix.b;\n    let pd = parent.matrix.d;\n    m.tx = pa * x + pb * y + parent.matrix.tx;\n    m.ty = pc * x + pd * y + parent.matrix.ty;\n    switch (this.data.transformMode) {\n      case TransformMode.Normal: {\n        const rotationY = rotation + 90 + shearY;\n        const la = MathUtils.cosDeg(rotation + shearX) * scaleX;\n        const lb = MathUtils.cosDeg(rotationY) * scaleY;\n        const lc = MathUtils.sinDeg(rotation + shearX) * scaleX;\n        const ld = MathUtils.sinDeg(rotationY) * scaleY;\n        m.a = pa * la + pb * lc;\n        m.c = pa * lb + pb * ld;\n        m.b = pc * la + pd * lc;\n        m.d = pc * lb + pd * ld;\n        return;\n      }\n      case TransformMode.OnlyTranslation: {\n        const rotationY = rotation + 90 + shearY;\n        m.a = MathUtils.cosDeg(rotation + shearX) * scaleX;\n        m.c = MathUtils.cosDeg(rotationY) * scaleY;\n        m.b = MathUtils.sinDeg(rotation + shearX) * scaleX;\n        m.d = MathUtils.sinDeg(rotationY) * scaleY;\n        break;\n      }\n      case TransformMode.NoRotationOrReflection: {\n        let s = pa * pa + pc * pc;\n        let prx = 0;\n        if (s > 1e-4) {\n          s = Math.abs(pa * pd - pb * pc) / s;\n          pb = pc * s;\n          pd = pa * s;\n          prx = Math.atan2(pc, pa) * MathUtils.radDeg;\n        } else {\n          pa = 0;\n          pc = 0;\n          prx = 90 - Math.atan2(pd, pb) * MathUtils.radDeg;\n        }\n        const rx = rotation + shearX - prx;\n        const ry = rotation + shearY - prx + 90;\n        const la = MathUtils.cosDeg(rx) * scaleX;\n        const lb = MathUtils.cosDeg(ry) * scaleY;\n        const lc = MathUtils.sinDeg(rx) * scaleX;\n        const ld = MathUtils.sinDeg(ry) * scaleY;\n        m.a = pa * la - pb * lc;\n        m.c = pa * lb - pb * ld;\n        m.b = pc * la + pd * lc;\n        m.d = pc * lb + pd * ld;\n        break;\n      }\n      case TransformMode.NoScale:\n      case TransformMode.NoScaleOrReflection: {\n        const cos = MathUtils.cosDeg(rotation);\n        const sin = MathUtils.sinDeg(rotation);\n        let za = (pa * cos + pb * sin) / sx;\n        let zc = (pc * cos + pd * sin) / sy;\n        let s = Math.sqrt(za * za + zc * zc);\n        if (s > 1e-5)\n          s = 1 / s;\n        za *= s;\n        zc *= s;\n        s = Math.sqrt(za * za + zc * zc);\n        if (this.data.transformMode == TransformMode.NoScale && pa * pd - pb * pc < 0 != (settings.yDown ? this.skeleton.scaleX < 0 != this.skeleton.scaleY > 0 : this.skeleton.scaleX < 0 != this.skeleton.scaleY < 0))\n          s = -s;\n        const r = Math.PI / 2 + Math.atan2(zc, za);\n        const zb = Math.cos(r) * s;\n        const zd = Math.sin(r) * s;\n        const la = MathUtils.cosDeg(shearX) * scaleX;\n        const lb = MathUtils.cosDeg(90 + shearY) * scaleY;\n        const lc = MathUtils.sinDeg(shearX) * scaleX;\n        const ld = MathUtils.sinDeg(90 + shearY) * scaleY;\n        m.a = za * la + zb * lc;\n        m.c = za * lb + zb * ld;\n        m.b = zc * la + zd * lc;\n        m.d = zc * lb + zd * ld;\n        break;\n      }\n    }\n    m.a *= sx;\n    m.c *= sx;\n    m.b *= sy;\n    m.d *= sy;\n  }\n  setToSetupPose() {\n    const data = this.data;\n    this.x = data.x;\n    this.y = data.y;\n    this.rotation = data.rotation;\n    this.scaleX = data.scaleX;\n    this.scaleY = data.scaleY;\n    this.shearX = data.shearX;\n    this.shearY = data.shearY;\n  }\n  getWorldRotationX() {\n    return Math.atan2(this.matrix.b, this.matrix.a) * MathUtils.radDeg;\n  }\n  getWorldRotationY() {\n    return Math.atan2(this.matrix.d, this.matrix.c) * MathUtils.radDeg;\n  }\n  getWorldScaleX() {\n    const m = this.matrix;\n    return Math.sqrt(m.a * m.a + m.c * m.c);\n  }\n  getWorldScaleY() {\n    const m = this.matrix;\n    return Math.sqrt(m.b * m.b + m.d * m.d);\n  }\n  /** Computes the individual applied transform values from the world transform. This can be useful to perform processing using\n   * the applied transform after the world transform has been modified directly (eg, by a constraint).\n   * <p>\n   * Some information is ambiguous in the world transform, such as -1,-1 scale versus 180 rotation. */\n  updateAppliedTransform() {\n    this.appliedValid = true;\n    const parent = this.parent;\n    const m = this.matrix;\n    if (parent == null) {\n      this.ax = m.tx;\n      this.ay = m.ty;\n      this.arotation = Math.atan2(m.b, m.a) * MathUtils.radDeg;\n      this.ascaleX = Math.sqrt(m.a * m.a + m.b * m.b);\n      this.ascaleY = Math.sqrt(m.c * m.c + m.d * m.d);\n      this.ashearX = 0;\n      this.ashearY = Math.atan2(m.a * m.c + m.b * m.d, m.a * m.d - m.b * m.c) * MathUtils.radDeg;\n      return;\n    }\n    const pm = parent.matrix;\n    const pid = 1 / (pm.a * pm.d - pm.b * pm.c);\n    const dx = m.tx - pm.tx;\n    const dy = m.ty - pm.ty;\n    this.ax = dx * pm.d * pid - dy * pm.c * pid;\n    this.ay = dy * pm.a * pid - dx * pm.b * pid;\n    const ia = pid * pm.d;\n    const id = pid * pm.a;\n    const ib = pid * pm.c;\n    const ic = pid * pm.b;\n    const ra = ia * m.a - ib * m.b;\n    const rb = ia * m.c - ib * m.d;\n    const rc = id * m.b - ic * m.a;\n    const rd = id * m.d - ic * m.c;\n    this.ashearX = 0;\n    this.ascaleX = Math.sqrt(ra * ra + rc * rc);\n    if (this.ascaleX > 1e-4) {\n      const det = ra * rd - rb * rc;\n      this.ascaleY = det / this.ascaleX;\n      this.ashearY = Math.atan2(ra * rb + rc * rd, det) * MathUtils.radDeg;\n      this.arotation = Math.atan2(rc, ra) * MathUtils.radDeg;\n    } else {\n      this.ascaleX = 0;\n      this.ascaleY = Math.sqrt(rb * rb + rd * rd);\n      this.ashearY = 0;\n      this.arotation = 90 - Math.atan2(rd, rb) * MathUtils.radDeg;\n    }\n  }\n  worldToLocal(world) {\n    const m = this.matrix;\n    const a = m.a;\n    const b = m.c;\n    const c = m.b;\n    const d = m.d;\n    const invDet = 1 / (a * d - b * c);\n    const x = world.x - m.tx;\n    const y = world.y - m.ty;\n    world.x = x * d * invDet - y * b * invDet;\n    world.y = y * a * invDet - x * c * invDet;\n    return world;\n  }\n  localToWorld(local) {\n    const m = this.matrix;\n    const x = local.x;\n    const y = local.y;\n    local.x = x * m.a + y * m.c + m.tx;\n    local.y = x * m.b + y * m.d + m.ty;\n    return local;\n  }\n  worldToLocalRotation(worldRotation) {\n    const sin = MathUtils.sinDeg(worldRotation);\n    const cos = MathUtils.cosDeg(worldRotation);\n    const mat = this.matrix;\n    return Math.atan2(mat.a * sin - mat.b * cos, mat.d * cos - mat.c * sin) * MathUtils.radDeg;\n  }\n  localToWorldRotation(localRotation) {\n    const sin = MathUtils.sinDeg(localRotation);\n    const cos = MathUtils.cosDeg(localRotation);\n    const mat = this.matrix;\n    return Math.atan2(cos * mat.b + sin * mat.d, cos * mat.a + sin * mat.c) * MathUtils.radDeg;\n  }\n  rotateWorld(degrees) {\n    const mat = this.matrix;\n    const a = mat.a;\n    const b = mat.c;\n    const c = mat.b;\n    const d = mat.d;\n    const cos = MathUtils.cosDeg(degrees);\n    const sin = MathUtils.sinDeg(degrees);\n    mat.a = cos * a - sin * c;\n    mat.c = cos * b - sin * d;\n    mat.b = sin * a + cos * c;\n    mat.d = sin * b + cos * d;\n    this.appliedValid = false;\n  }\n}\n\nexport { Bone };\n//# sourceMappingURL=Bone.mjs.map\n","import { TransformMode } from '@pixi-spine/base';\n\nclass BoneData {\n  constructor(index, name, parent) {\n    this.x = 0;\n    this.y = 0;\n    this.rotation = 0;\n    this.scaleX = 1;\n    this.scaleY = 1;\n    this.shearX = 0;\n    this.shearY = 0;\n    this.transformMode = TransformMode.Normal;\n    if (index < 0)\n      throw new Error(\"index must be >= 0.\");\n    if (name == null)\n      throw new Error(\"name cannot be null.\");\n    this.index = index;\n    this.name = name;\n    this.parent = parent;\n  }\n}\n\nexport { BoneData };\n//# sourceMappingURL=BoneData.mjs.map\n","class Event {\n  constructor(time, data) {\n    if (data == null)\n      throw new Error(\"data cannot be null.\");\n    this.time = time;\n    this.data = data;\n  }\n}\n\nexport { Event };\n//# sourceMappingURL=Event.mjs.map\n","class EventData {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\nexport { EventData };\n//# sourceMappingURL=EventData.mjs.map\n","import { MathUtils } from '@pixi-spine/base';\n\nclass IkConstraint {\n  constructor(data, skeleton) {\n    this.bendDirection = 0;\n    this.compress = false;\n    this.stretch = false;\n    this.mix = 1;\n    if (data == null)\n      throw new Error(\"data cannot be null.\");\n    if (skeleton == null)\n      throw new Error(\"skeleton cannot be null.\");\n    this.data = data;\n    this.mix = data.mix;\n    this.bendDirection = data.bendDirection;\n    this.compress = data.compress;\n    this.stretch = data.stretch;\n    this.bones = new Array();\n    for (let i = 0; i < data.bones.length; i++)\n      this.bones.push(skeleton.findBone(data.bones[i].name));\n    this.target = skeleton.findBone(data.target.name);\n  }\n  getOrder() {\n    return this.data.order;\n  }\n  apply() {\n    this.update();\n  }\n  update() {\n    const target = this.target;\n    const bones = this.bones;\n    switch (bones.length) {\n      case 1:\n        this.apply1(bones[0], target.worldX, target.worldY, this.compress, this.stretch, this.data.uniform, this.mix);\n        break;\n      case 2:\n        this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.stretch, this.mix);\n        break;\n    }\n  }\n  /** Adjusts the bone rotation so the tip is as close to the target position as possible. The target is specified in the world\n   * coordinate system. */\n  apply1(bone, targetX, targetY, compress, stretch, uniform, alpha) {\n    if (!bone.appliedValid)\n      bone.updateAppliedTransform();\n    const p = bone.parent.matrix;\n    const id = 1 / (p.a * p.d - p.b * p.c);\n    const x = targetX - p.tx;\n    const y = targetY - p.ty;\n    const tx = (x * p.d - y * p.c) * id - bone.ax;\n    const ty = (y * p.a - x * p.b) * id - bone.ay;\n    let rotationIK = Math.atan2(ty, tx) * MathUtils.radDeg - bone.ashearX - bone.arotation;\n    if (bone.ascaleX < 0)\n      rotationIK += 180;\n    if (rotationIK > 180)\n      rotationIK -= 360;\n    else if (rotationIK < -180)\n      rotationIK += 360;\n    let sx = bone.ascaleX;\n    let sy = bone.ascaleY;\n    if (compress || stretch) {\n      const b = bone.data.length * sx;\n      const dd = Math.sqrt(tx * tx + ty * ty);\n      if (compress && dd < b || stretch && dd > b && b > 1e-4) {\n        const s = (dd / b - 1) * alpha + 1;\n        sx *= s;\n        if (uniform)\n          sy *= s;\n      }\n    }\n    bone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, sx, sy, bone.ashearX, bone.ashearY);\n  }\n  /** Adjusts the parent and child bone rotations so the tip of the child is as close to the target position as possible. The\n   * target is specified in the world coordinate system.\n   * @param child A direct descendant of the parent bone. */\n  apply2(parent, child, targetX, targetY, bendDir, stretch, alpha) {\n    if (alpha == 0) {\n      child.updateWorldTransform();\n      return;\n    }\n    if (!parent.appliedValid)\n      parent.updateAppliedTransform();\n    if (!child.appliedValid)\n      child.updateAppliedTransform();\n    const px = parent.ax;\n    const py = parent.ay;\n    let psx = parent.ascaleX;\n    let sx = psx;\n    let psy = parent.ascaleY;\n    let csx = child.ascaleX;\n    const pmat = parent.matrix;\n    let os1 = 0;\n    let os2 = 0;\n    let s2 = 0;\n    if (psx < 0) {\n      psx = -psx;\n      os1 = 180;\n      s2 = -1;\n    } else {\n      os1 = 0;\n      s2 = 1;\n    }\n    if (psy < 0) {\n      psy = -psy;\n      s2 = -s2;\n    }\n    if (csx < 0) {\n      csx = -csx;\n      os2 = 180;\n    } else\n      os2 = 0;\n    const cx = child.ax;\n    let cy = 0;\n    let cwx = 0;\n    let cwy = 0;\n    let a = pmat.a;\n    let b = pmat.c;\n    let c = pmat.b;\n    let d = pmat.d;\n    const u = Math.abs(psx - psy) <= 1e-4;\n    if (!u) {\n      cy = 0;\n      cwx = a * cx + pmat.tx;\n      cwy = c * cx + pmat.ty;\n    } else {\n      cy = child.ay;\n      cwx = a * cx + b * cy + pmat.tx;\n      cwy = c * cx + d * cy + pmat.ty;\n    }\n    const pp = parent.parent.matrix;\n    a = pp.a;\n    b = pp.c;\n    c = pp.b;\n    d = pp.d;\n    const id = 1 / (a * d - b * c);\n    let x = targetX - pp.tx;\n    let y = targetY - pp.ty;\n    const tx = (x * d - y * b) * id - px;\n    const ty = (y * a - x * c) * id - py;\n    const dd = tx * tx + ty * ty;\n    x = cwx - pp.tx;\n    y = cwy - pp.ty;\n    const dx = (x * d - y * b) * id - px;\n    const dy = (y * a - x * c) * id - py;\n    const l1 = Math.sqrt(dx * dx + dy * dy);\n    let l2 = child.data.length * csx;\n    let a1 = 0;\n    let a2 = 0;\n    outer:\n      if (u) {\n        l2 *= psx;\n        let cos = (dd - l1 * l1 - l2 * l2) / (2 * l1 * l2);\n        if (cos < -1)\n          cos = -1;\n        else if (cos > 1) {\n          cos = 1;\n          if (stretch && l1 + l2 > 1e-4)\n            sx *= (Math.sqrt(dd) / (l1 + l2) - 1) * alpha + 1;\n        }\n        a2 = Math.acos(cos) * bendDir;\n        a = l1 + l2 * cos;\n        b = l2 * Math.sin(a2);\n        a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);\n      } else {\n        a = psx * l2;\n        b = psy * l2;\n        const aa = a * a;\n        const bb = b * b;\n        const ta = Math.atan2(ty, tx);\n        c = bb * l1 * l1 + aa * dd - aa * bb;\n        const c1 = -2 * bb * l1;\n        const c2 = bb - aa;\n        d = c1 * c1 - 4 * c2 * c;\n        if (d >= 0) {\n          let q = Math.sqrt(d);\n          if (c1 < 0)\n            q = -q;\n          q = -(c1 + q) / 2;\n          const r0 = q / c2;\n          const r1 = c / q;\n          const r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;\n          if (r * r <= dd) {\n            y = Math.sqrt(dd - r * r) * bendDir;\n            a1 = ta - Math.atan2(y, r);\n            a2 = Math.atan2(y / psy, (r - l1) / psx);\n            break outer;\n          }\n        }\n        let minAngle = MathUtils.PI;\n        let minX = l1 - a;\n        let minDist = minX * minX;\n        let minY = 0;\n        let maxAngle = 0;\n        let maxX = l1 + a;\n        let maxDist = maxX * maxX;\n        let maxY = 0;\n        c = -a * l1 / (aa - bb);\n        if (c >= -1 && c <= 1) {\n          c = Math.acos(c);\n          x = a * Math.cos(c) + l1;\n          y = b * Math.sin(c);\n          d = x * x + y * y;\n          if (d < minDist) {\n            minAngle = c;\n            minDist = d;\n            minX = x;\n            minY = y;\n          }\n          if (d > maxDist) {\n            maxAngle = c;\n            maxDist = d;\n            maxX = x;\n            maxY = y;\n          }\n        }\n        if (dd <= (minDist + maxDist) / 2) {\n          a1 = ta - Math.atan2(minY * bendDir, minX);\n          a2 = minAngle * bendDir;\n        } else {\n          a1 = ta - Math.atan2(maxY * bendDir, maxX);\n          a2 = maxAngle * bendDir;\n        }\n      }\n    const os = Math.atan2(cy, cx) * s2;\n    let rotation = parent.arotation;\n    a1 = (a1 - os) * MathUtils.radDeg + os1 - rotation;\n    if (a1 > 180)\n      a1 -= 360;\n    else if (a1 < -180)\n      a1 += 360;\n    parent.updateWorldTransformWith(px, py, rotation + a1 * alpha, sx, parent.ascaleY, 0, 0);\n    rotation = child.arotation;\n    a2 = ((a2 + os) * MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;\n    if (a2 > 180)\n      a2 -= 360;\n    else if (a2 < -180)\n      a2 += 360;\n    child.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\n  }\n}\n\nexport { IkConstraint };\n//# sourceMappingURL=IkConstraint.mjs.map\n","class IkConstraintData {\n  constructor(name) {\n    this.order = 0;\n    this.bones = new Array();\n    this.bendDirection = 1;\n    this.compress = false;\n    this.stretch = false;\n    this.uniform = false;\n    this.mix = 1;\n    this.name = name;\n  }\n}\n\nexport { IkConstraintData };\n//# sourceMappingURL=IkConstraintData.mjs.map\n","class PathConstraintData {\n  constructor(name) {\n    this.order = 0;\n    this.bones = new Array();\n    this.name = name;\n  }\n}\nvar SpacingMode = /* @__PURE__ */ ((SpacingMode2) => {\n  SpacingMode2[SpacingMode2[\"Length\"] = 0] = \"Length\";\n  SpacingMode2[SpacingMode2[\"Fixed\"] = 1] = \"Fixed\";\n  SpacingMode2[SpacingMode2[\"Percent\"] = 2] = \"Percent\";\n  return SpacingMode2;\n})(SpacingMode || {});\n\nexport { PathConstraintData, SpacingMode };\n//# sourceMappingURL=PathConstraintData.mjs.map\n","import './attachments/Attachment.mjs';\nimport { RotateMode, Utils, PositionMode, MathUtils } from '@pixi-spine/base';\nimport { PathAttachment } from './attachments/PathAttachment.mjs';\nimport './attachments/RegionAttachment.mjs';\nimport { SpacingMode } from './PathConstraintData.mjs';\n\nconst _PathConstraint = class {\n  constructor(data, skeleton) {\n    this.position = 0;\n    this.spacing = 0;\n    this.rotateMix = 0;\n    this.translateMix = 0;\n    this.spaces = new Array();\n    this.positions = new Array();\n    this.world = new Array();\n    this.curves = new Array();\n    this.lengths = new Array();\n    this.segments = new Array();\n    if (data == null)\n      throw new Error(\"data cannot be null.\");\n    if (skeleton == null)\n      throw new Error(\"skeleton cannot be null.\");\n    this.data = data;\n    this.bones = new Array();\n    for (let i = 0, n = data.bones.length; i < n; i++)\n      this.bones.push(skeleton.findBone(data.bones[i].name));\n    this.target = skeleton.findSlot(data.target.name);\n    this.position = data.position;\n    this.spacing = data.spacing;\n    this.rotateMix = data.rotateMix;\n    this.translateMix = data.translateMix;\n  }\n  apply() {\n    this.update();\n  }\n  update() {\n    const attachment = this.target.getAttachment();\n    if (!(attachment instanceof PathAttachment))\n      return;\n    const rotateMix = this.rotateMix;\n    const translateMix = this.translateMix;\n    const translate = translateMix > 0;\n    const rotate = rotateMix > 0;\n    if (!translate && !rotate)\n      return;\n    const data = this.data;\n    const spacingMode = data.spacingMode;\n    const lengthSpacing = spacingMode == SpacingMode.Length;\n    const rotateMode = data.rotateMode;\n    const tangents = rotateMode == RotateMode.Tangent;\n    const scale = rotateMode == RotateMode.ChainScale;\n    const boneCount = this.bones.length;\n    const spacesCount = tangents ? boneCount : boneCount + 1;\n    const bones = this.bones;\n    const spaces = Utils.setArraySize(this.spaces, spacesCount);\n    let lengths = null;\n    const spacing = this.spacing;\n    if (scale || lengthSpacing) {\n      if (scale)\n        lengths = Utils.setArraySize(this.lengths, boneCount);\n      for (let i = 0, n = spacesCount - 1; i < n; ) {\n        const bone = bones[i];\n        const setupLength = bone.data.length;\n        if (setupLength < _PathConstraint.epsilon) {\n          if (scale)\n            lengths[i] = 0;\n          spaces[++i] = 0;\n        } else {\n          const x = setupLength * bone.matrix.a;\n          const y = setupLength * bone.matrix.b;\n          const length = Math.sqrt(x * x + y * y);\n          if (scale)\n            lengths[i] = length;\n          spaces[++i] = (lengthSpacing ? setupLength + spacing : spacing) * length / setupLength;\n        }\n      }\n    } else {\n      for (let i = 1; i < spacesCount; i++)\n        spaces[i] = spacing;\n    }\n    const positions = this.computeWorldPositions(\n      attachment,\n      spacesCount,\n      tangents,\n      data.positionMode == PositionMode.Percent,\n      spacingMode == SpacingMode.Percent\n    );\n    let boneX = positions[0];\n    let boneY = positions[1];\n    let offsetRotation = data.offsetRotation;\n    let tip = false;\n    if (offsetRotation == 0)\n      tip = rotateMode == RotateMode.Chain;\n    else {\n      tip = false;\n      const p = this.target.bone.matrix;\n      offsetRotation *= p.a * p.d - p.b * p.c > 0 ? MathUtils.degRad : -MathUtils.degRad;\n    }\n    for (let i = 0, p = 3; i < boneCount; i++, p += 3) {\n      const bone = bones[i];\n      const mat = bone.matrix;\n      mat.tx += (boneX - mat.tx) * translateMix;\n      mat.ty += (boneY - mat.ty) * translateMix;\n      const x = positions[p];\n      const y = positions[p + 1];\n      const dx = x - boneX;\n      const dy = y - boneY;\n      if (scale) {\n        const length = lengths[i];\n        if (length != 0) {\n          const s = (Math.sqrt(dx * dx + dy * dy) / length - 1) * rotateMix + 1;\n          mat.a *= s;\n          mat.b *= s;\n        }\n      }\n      boneX = x;\n      boneY = y;\n      if (rotate) {\n        const a = mat.a;\n        const b = mat.c;\n        const c = mat.b;\n        const d = mat.d;\n        let r = 0;\n        let cos = 0;\n        let sin = 0;\n        if (tangents)\n          if (tangents)\n            r = positions[p - 1];\n          else if (spaces[i + 1] == 0)\n            r = positions[p + 2];\n          else\n            r = Math.atan2(dy, dx);\n        r -= Math.atan2(c, a);\n        if (tip) {\n          cos = Math.cos(r);\n          sin = Math.sin(r);\n          const length = bone.data.length;\n          boneX += (length * (cos * a - sin * c) - dx) * rotateMix;\n          boneY += (length * (sin * a + cos * c) - dy) * rotateMix;\n        } else {\n          r += offsetRotation;\n        }\n        if (r > MathUtils.PI)\n          r -= MathUtils.PI2;\n        else if (r < -MathUtils.PI)\n          r += MathUtils.PI2;\n        r *= rotateMix;\n        cos = Math.cos(r);\n        sin = Math.sin(r);\n        mat.a = cos * a - sin * c;\n        mat.c = cos * b - sin * d;\n        mat.b = sin * a + cos * c;\n        mat.d = sin * b + cos * d;\n      }\n      bone.appliedValid = false;\n    }\n  }\n  computeWorldPositions(path, spacesCount, tangents, percentPosition, percentSpacing) {\n    const target = this.target;\n    let position = this.position;\n    const spaces = this.spaces;\n    const out = Utils.setArraySize(this.positions, spacesCount * 3 + 2);\n    let world = null;\n    const closed = path.closed;\n    let verticesLength = path.worldVerticesLength;\n    let curveCount = verticesLength / 6;\n    let prevCurve = _PathConstraint.NONE;\n    if (!path.constantSpeed) {\n      const lengths = path.lengths;\n      curveCount -= closed ? 1 : 2;\n      const pathLength2 = lengths[curveCount];\n      if (percentPosition)\n        position *= pathLength2;\n      if (percentSpacing) {\n        for (let i = 0; i < spacesCount; i++)\n          spaces[i] *= pathLength2;\n      }\n      world = Utils.setArraySize(this.world, 8);\n      for (let i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {\n        const space = spaces[i];\n        position += space;\n        let p = position;\n        if (closed) {\n          p %= pathLength2;\n          if (p < 0)\n            p += pathLength2;\n          curve = 0;\n        } else if (p < 0) {\n          if (prevCurve != _PathConstraint.BEFORE) {\n            prevCurve = _PathConstraint.BEFORE;\n            path.computeWorldVertices(target, 2, 4, world, 0, 2);\n          }\n          this.addBeforePosition(p, world, 0, out, o);\n          continue;\n        } else if (p > pathLength2) {\n          if (prevCurve != _PathConstraint.AFTER) {\n            prevCurve = _PathConstraint.AFTER;\n            path.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2);\n          }\n          this.addAfterPosition(p - pathLength2, world, 0, out, o);\n          continue;\n        }\n        for (; ; curve++) {\n          const length = lengths[curve];\n          if (p > length)\n            continue;\n          if (curve == 0)\n            p /= length;\n          else {\n            const prev = lengths[curve - 1];\n            p = (p - prev) / (length - prev);\n          }\n          break;\n        }\n        if (curve != prevCurve) {\n          prevCurve = curve;\n          if (closed && curve == curveCount) {\n            path.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);\n            path.computeWorldVertices(target, 0, 4, world, 4, 2);\n          } else\n            path.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2);\n        }\n        this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o, tangents || i > 0 && space == 0);\n      }\n      return out;\n    }\n    if (closed) {\n      verticesLength += 2;\n      world = Utils.setArraySize(this.world, verticesLength);\n      path.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);\n      path.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);\n      world[verticesLength - 2] = world[0];\n      world[verticesLength - 1] = world[1];\n    } else {\n      curveCount--;\n      verticesLength -= 4;\n      world = Utils.setArraySize(this.world, verticesLength);\n      path.computeWorldVertices(target, 2, verticesLength, world, 0, 2);\n    }\n    const curves = Utils.setArraySize(this.curves, curveCount);\n    let pathLength = 0;\n    let x1 = world[0];\n    let y1 = world[1];\n    let cx1 = 0;\n    let cy1 = 0;\n    let cx2 = 0;\n    let cy2 = 0;\n    let x2 = 0;\n    let y2 = 0;\n    let tmpx = 0;\n    let tmpy = 0;\n    let dddfx = 0;\n    let dddfy = 0;\n    let ddfx = 0;\n    let ddfy = 0;\n    let dfx = 0;\n    let dfy = 0;\n    for (let i = 0, w = 2; i < curveCount; i++, w += 6) {\n      cx1 = world[w];\n      cy1 = world[w + 1];\n      cx2 = world[w + 2];\n      cy2 = world[w + 3];\n      x2 = world[w + 4];\n      y2 = world[w + 5];\n      tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;\n      tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;\n      dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;\n      dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;\n      ddfx = tmpx * 2 + dddfx;\n      ddfy = tmpy * 2 + dddfy;\n      dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;\n      dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;\n      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n      dfx += ddfx;\n      dfy += ddfy;\n      ddfx += dddfx;\n      ddfy += dddfy;\n      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n      dfx += ddfx;\n      dfy += ddfy;\n      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n      dfx += ddfx + dddfx;\n      dfy += ddfy + dddfy;\n      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n      curves[i] = pathLength;\n      x1 = x2;\n      y1 = y2;\n    }\n    if (percentPosition)\n      position *= pathLength;\n    if (percentSpacing) {\n      for (let i = 0; i < spacesCount; i++)\n        spaces[i] *= pathLength;\n    }\n    const segments = this.segments;\n    let curveLength = 0;\n    for (let i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {\n      const space = spaces[i];\n      position += space;\n      let p = position;\n      if (closed) {\n        p %= pathLength;\n        if (p < 0)\n          p += pathLength;\n        curve = 0;\n      } else if (p < 0) {\n        this.addBeforePosition(p, world, 0, out, o);\n        continue;\n      } else if (p > pathLength) {\n        this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);\n        continue;\n      }\n      for (; ; curve++) {\n        const length = curves[curve];\n        if (p > length)\n          continue;\n        if (curve == 0)\n          p /= length;\n        else {\n          const prev = curves[curve - 1];\n          p = (p - prev) / (length - prev);\n        }\n        break;\n      }\n      if (curve != prevCurve) {\n        prevCurve = curve;\n        let ii = curve * 6;\n        x1 = world[ii];\n        y1 = world[ii + 1];\n        cx1 = world[ii + 2];\n        cy1 = world[ii + 3];\n        cx2 = world[ii + 4];\n        cy2 = world[ii + 5];\n        x2 = world[ii + 6];\n        y2 = world[ii + 7];\n        tmpx = (x1 - cx1 * 2 + cx2) * 0.03;\n        tmpy = (y1 - cy1 * 2 + cy2) * 0.03;\n        dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 6e-3;\n        dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 6e-3;\n        ddfx = tmpx * 2 + dddfx;\n        ddfy = tmpy * 2 + dddfy;\n        dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;\n        dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;\n        curveLength = Math.sqrt(dfx * dfx + dfy * dfy);\n        segments[0] = curveLength;\n        for (ii = 1; ii < 8; ii++) {\n          dfx += ddfx;\n          dfy += ddfy;\n          ddfx += dddfx;\n          ddfy += dddfy;\n          curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n          segments[ii] = curveLength;\n        }\n        dfx += ddfx;\n        dfy += ddfy;\n        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n        segments[8] = curveLength;\n        dfx += ddfx + dddfx;\n        dfy += ddfy + dddfy;\n        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n        segments[9] = curveLength;\n        segment = 0;\n      }\n      p *= curveLength;\n      for (; ; segment++) {\n        const length = segments[segment];\n        if (p > length)\n          continue;\n        if (segment == 0)\n          p /= length;\n        else {\n          const prev = segments[segment - 1];\n          p = segment + (p - prev) / (length - prev);\n        }\n        break;\n      }\n      this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || i > 0 && space == 0);\n    }\n    return out;\n  }\n  addBeforePosition(p, temp, i, out, o) {\n    const x1 = temp[i];\n    const y1 = temp[i + 1];\n    const dx = temp[i + 2] - x1;\n    const dy = temp[i + 3] - y1;\n    const r = Math.atan2(dy, dx);\n    out[o] = x1 + p * Math.cos(r);\n    out[o + 1] = y1 + p * Math.sin(r);\n    out[o + 2] = r;\n  }\n  addAfterPosition(p, temp, i, out, o) {\n    const x1 = temp[i + 2];\n    const y1 = temp[i + 3];\n    const dx = x1 - temp[i];\n    const dy = y1 - temp[i + 1];\n    const r = Math.atan2(dy, dx);\n    out[o] = x1 + p * Math.cos(r);\n    out[o + 1] = y1 + p * Math.sin(r);\n    out[o + 2] = r;\n  }\n  addCurvePosition(p, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents) {\n    if (p == 0 || isNaN(p))\n      p = 1e-4;\n    const tt = p * p;\n    const ttt = tt * p;\n    const u = 1 - p;\n    const uu = u * u;\n    const uuu = uu * u;\n    const ut = u * p;\n    const ut3 = ut * 3;\n    const uut3 = u * ut3;\n    const utt3 = ut3 * p;\n    const x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt;\n    const y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;\n    out[o] = x;\n    out[o + 1] = y;\n    if (tangents)\n      out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));\n  }\n  getOrder() {\n    return this.data.order;\n  }\n};\nlet PathConstraint = _PathConstraint;\nPathConstraint.NONE = -1;\nPathConstraint.BEFORE = -2;\nPathConstraint.AFTER = -3;\nPathConstraint.epsilon = 1e-5;\n\nexport { PathConstraint };\n//# sourceMappingURL=PathConstraint.mjs.map\n","import { Vector2, MathUtils } from '@pixi-spine/base';\n\nclass TransformConstraint {\n  constructor(data, skeleton) {\n    this.rotateMix = 0;\n    this.translateMix = 0;\n    this.scaleMix = 0;\n    this.shearMix = 0;\n    this.temp = new Vector2();\n    if (data == null)\n      throw new Error(\"data cannot be null.\");\n    if (skeleton == null)\n      throw new Error(\"skeleton cannot be null.\");\n    this.data = data;\n    this.rotateMix = data.rotateMix;\n    this.translateMix = data.translateMix;\n    this.scaleMix = data.scaleMix;\n    this.shearMix = data.shearMix;\n    this.bones = new Array();\n    for (let i = 0; i < data.bones.length; i++)\n      this.bones.push(skeleton.findBone(data.bones[i].name));\n    this.target = skeleton.findBone(data.target.name);\n  }\n  apply() {\n    this.update();\n  }\n  update() {\n    if (this.data.local) {\n      if (this.data.relative)\n        this.applyRelativeLocal();\n      else\n        this.applyAbsoluteLocal();\n    } else if (this.data.relative)\n      this.applyRelativeWorld();\n    else\n      this.applyAbsoluteWorld();\n  }\n  applyAbsoluteWorld() {\n    const rotateMix = this.rotateMix;\n    const translateMix = this.translateMix;\n    const scaleMix = this.scaleMix;\n    const shearMix = this.shearMix;\n    const target = this.target;\n    const targetMat = target.matrix;\n    const ta = targetMat.a;\n    const tb = targetMat.c;\n    const tc = targetMat.b;\n    const td = targetMat.d;\n    const degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;\n    const offsetRotation = this.data.offsetRotation * degRadReflect;\n    const offsetShearY = this.data.offsetShearY * degRadReflect;\n    const bones = this.bones;\n    for (let i = 0, n = bones.length; i < n; i++) {\n      const bone = bones[i];\n      let modified = false;\n      const mat = bone.matrix;\n      if (rotateMix != 0) {\n        const a = mat.a;\n        const b = mat.c;\n        const c = mat.b;\n        const d = mat.d;\n        let r = Math.atan2(tc, ta) - Math.atan2(c, a) + offsetRotation;\n        if (r > MathUtils.PI)\n          r -= MathUtils.PI2;\n        else if (r < -MathUtils.PI)\n          r += MathUtils.PI2;\n        r *= rotateMix;\n        const cos = Math.cos(r);\n        const sin = Math.sin(r);\n        mat.a = cos * a - sin * c;\n        mat.c = cos * b - sin * d;\n        mat.b = sin * a + cos * c;\n        mat.d = sin * b + cos * d;\n        modified = true;\n      }\n      if (translateMix != 0) {\n        const temp = this.temp;\n        target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\n        mat.tx += (temp.x - mat.tx) * translateMix;\n        mat.ty += (temp.y - mat.ty) * translateMix;\n        modified = true;\n      }\n      if (scaleMix > 0) {\n        let s = Math.sqrt(mat.a * mat.a + mat.b * mat.b);\n        let ts = Math.sqrt(ta * ta + tc * tc);\n        if (s > 1e-5)\n          s = (s + (ts - s + this.data.offsetScaleX) * scaleMix) / s;\n        mat.a *= s;\n        mat.b *= s;\n        s = Math.sqrt(mat.c * mat.c + mat.d * mat.d);\n        ts = Math.sqrt(tb * tb + td * td);\n        if (s > 1e-5)\n          s = (s + (ts - s + this.data.offsetScaleY) * scaleMix) / s;\n        mat.c *= s;\n        mat.d *= s;\n        modified = true;\n      }\n      if (shearMix > 0) {\n        const b = mat.c;\n        const d = mat.d;\n        const by = Math.atan2(d, b);\n        let r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(mat.b, mat.a));\n        if (r > MathUtils.PI)\n          r -= MathUtils.PI2;\n        else if (r < -MathUtils.PI)\n          r += MathUtils.PI2;\n        r = by + (r + offsetShearY) * shearMix;\n        const s = Math.sqrt(b * b + d * d);\n        mat.c = Math.cos(r) * s;\n        mat.d = Math.sin(r) * s;\n        modified = true;\n      }\n      if (modified)\n        bone.appliedValid = false;\n    }\n  }\n  applyRelativeWorld() {\n    const rotateMix = this.rotateMix;\n    const translateMix = this.translateMix;\n    const scaleMix = this.scaleMix;\n    const shearMix = this.shearMix;\n    const target = this.target;\n    const targetMat = target.matrix;\n    const ta = targetMat.a;\n    const tb = targetMat.c;\n    const tc = targetMat.b;\n    const td = targetMat.d;\n    const degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;\n    const offsetRotation = this.data.offsetRotation * degRadReflect;\n    const offsetShearY = this.data.offsetShearY * degRadReflect;\n    const bones = this.bones;\n    for (let i = 0, n = bones.length; i < n; i++) {\n      const bone = bones[i];\n      let modified = false;\n      const mat = bone.matrix;\n      if (rotateMix != 0) {\n        const a = mat.a;\n        const b = mat.c;\n        const c = mat.b;\n        const d = mat.d;\n        let r = Math.atan2(tc, ta) + offsetRotation;\n        if (r > MathUtils.PI)\n          r -= MathUtils.PI2;\n        else if (r < -MathUtils.PI)\n          r += MathUtils.PI2;\n        r *= rotateMix;\n        const cos = Math.cos(r);\n        const sin = Math.sin(r);\n        mat.a = cos * a - sin * c;\n        mat.c = cos * b - sin * d;\n        mat.b = sin * a + cos * c;\n        mat.d = sin * b + cos * d;\n        modified = true;\n      }\n      if (translateMix != 0) {\n        const temp = this.temp;\n        target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\n        mat.tx += temp.x * translateMix;\n        mat.ty += temp.y * translateMix;\n        modified = true;\n      }\n      if (scaleMix > 0) {\n        let s = (Math.sqrt(ta * ta + tc * tc) - 1 + this.data.offsetScaleX) * scaleMix + 1;\n        mat.a *= s;\n        mat.b *= s;\n        s = (Math.sqrt(tb * tb + td * td) - 1 + this.data.offsetScaleY) * scaleMix + 1;\n        mat.c *= s;\n        mat.d *= s;\n        modified = true;\n      }\n      if (shearMix > 0) {\n        let r = Math.atan2(td, tb) - Math.atan2(tc, ta);\n        if (r > MathUtils.PI)\n          r -= MathUtils.PI2;\n        else if (r < -MathUtils.PI)\n          r += MathUtils.PI2;\n        const b = mat.c;\n        const d = mat.d;\n        r = Math.atan2(d, b) + (r - MathUtils.PI / 2 + offsetShearY) * shearMix;\n        const s = Math.sqrt(b * b + d * d);\n        mat.c = Math.cos(r) * s;\n        mat.d = Math.sin(r) * s;\n        modified = true;\n      }\n      if (modified)\n        bone.appliedValid = false;\n    }\n  }\n  applyAbsoluteLocal() {\n    const rotateMix = this.rotateMix;\n    const translateMix = this.translateMix;\n    const scaleMix = this.scaleMix;\n    const shearMix = this.shearMix;\n    const target = this.target;\n    if (!target.appliedValid)\n      target.updateAppliedTransform();\n    const bones = this.bones;\n    for (let i = 0, n = bones.length; i < n; i++) {\n      const bone = bones[i];\n      if (!bone.appliedValid)\n        bone.updateAppliedTransform();\n      let rotation = bone.arotation;\n      if (rotateMix != 0) {\n        let r = target.arotation - rotation + this.data.offsetRotation;\n        r -= (16384 - (16384.499999999996 - r / 360 | 0)) * 360;\n        rotation += r * rotateMix;\n      }\n      let x = bone.ax;\n      let y = bone.ay;\n      if (translateMix != 0) {\n        x += (target.ax - x + this.data.offsetX) * translateMix;\n        y += (target.ay - y + this.data.offsetY) * translateMix;\n      }\n      let scaleX = bone.ascaleX;\n      let scaleY = bone.ascaleY;\n      if (scaleMix > 0) {\n        if (scaleX > 1e-5)\n          scaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * scaleMix) / scaleX;\n        if (scaleY > 1e-5)\n          scaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * scaleMix) / scaleY;\n      }\n      const shearY = bone.ashearY;\n      if (shearMix > 0) {\n        let r = target.ashearY - shearY + this.data.offsetShearY;\n        r -= (16384 - (16384.499999999996 - r / 360 | 0)) * 360;\n        bone.shearY += r * shearMix;\n      }\n      bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\n    }\n  }\n  applyRelativeLocal() {\n    const rotateMix = this.rotateMix;\n    const translateMix = this.translateMix;\n    const scaleMix = this.scaleMix;\n    const shearMix = this.shearMix;\n    const target = this.target;\n    if (!target.appliedValid)\n      target.updateAppliedTransform();\n    const bones = this.bones;\n    for (let i = 0, n = bones.length; i < n; i++) {\n      const bone = bones[i];\n      if (!bone.appliedValid)\n        bone.updateAppliedTransform();\n      let rotation = bone.arotation;\n      if (rotateMix != 0)\n        rotation += (target.arotation + this.data.offsetRotation) * rotateMix;\n      let x = bone.ax;\n      let y = bone.ay;\n      if (translateMix != 0) {\n        x += (target.ax + this.data.offsetX) * translateMix;\n        y += (target.ay + this.data.offsetY) * translateMix;\n      }\n      let scaleX = bone.ascaleX;\n      let scaleY = bone.ascaleY;\n      if (scaleMix > 0) {\n        if (scaleX > 1e-5)\n          scaleX *= (target.ascaleX - 1 + this.data.offsetScaleX) * scaleMix + 1;\n        if (scaleY > 1e-5)\n          scaleY *= (target.ascaleY - 1 + this.data.offsetScaleY) * scaleMix + 1;\n      }\n      let shearY = bone.ashearY;\n      if (shearMix > 0)\n        shearY += (target.ashearY + this.data.offsetShearY) * shearMix;\n      bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\n    }\n  }\n  getOrder() {\n    return this.data.order;\n  }\n}\n\nexport { TransformConstraint };\n//# sourceMappingURL=TransformConstraint.mjs.map\n","import './attachments/Attachment.mjs';\nimport { Color, Utils } from '@pixi-spine/base';\nimport { MeshAttachment } from './attachments/MeshAttachment.mjs';\nimport { PathAttachment } from './attachments/PathAttachment.mjs';\nimport { RegionAttachment } from './attachments/RegionAttachment.mjs';\nimport { Bone } from './Bone.mjs';\nimport { Slot } from './Slot.mjs';\nimport { IkConstraint } from './IkConstraint.mjs';\nimport { TransformConstraint } from './TransformConstraint.mjs';\nimport { PathConstraint } from './PathConstraint.mjs';\n\nconst _Skeleton = class {\n  constructor(data) {\n    this._updateCache = new Array();\n    this.updateCacheReset = new Array();\n    this.time = 0;\n    this.scaleX = 1;\n    this.scaleY = 1;\n    this.x = 0;\n    this.y = 0;\n    if (data == null)\n      throw new Error(\"data cannot be null.\");\n    this.data = data;\n    this.bones = new Array();\n    for (let i = 0; i < data.bones.length; i++) {\n      const boneData = data.bones[i];\n      let bone;\n      if (boneData.parent == null)\n        bone = new Bone(boneData, this, null);\n      else {\n        const parent = this.bones[boneData.parent.index];\n        bone = new Bone(boneData, this, parent);\n        parent.children.push(bone);\n      }\n      this.bones.push(bone);\n    }\n    this.slots = new Array();\n    this.drawOrder = new Array();\n    for (let i = 0; i < data.slots.length; i++) {\n      const slotData = data.slots[i];\n      const bone = this.bones[slotData.boneData.index];\n      const slot = new Slot(slotData, bone);\n      this.slots.push(slot);\n      this.drawOrder.push(slot);\n    }\n    this.ikConstraints = new Array();\n    for (let i = 0; i < data.ikConstraints.length; i++) {\n      const ikConstraintData = data.ikConstraints[i];\n      this.ikConstraints.push(new IkConstraint(ikConstraintData, this));\n    }\n    this.transformConstraints = new Array();\n    for (let i = 0; i < data.transformConstraints.length; i++) {\n      const transformConstraintData = data.transformConstraints[i];\n      this.transformConstraints.push(new TransformConstraint(transformConstraintData, this));\n    }\n    this.pathConstraints = new Array();\n    for (let i = 0; i < data.pathConstraints.length; i++) {\n      const pathConstraintData = data.pathConstraints[i];\n      this.pathConstraints.push(new PathConstraint(pathConstraintData, this));\n    }\n    this.color = new Color(1, 1, 1, 1);\n    this.updateCache();\n  }\n  updateCache() {\n    const updateCache = this._updateCache;\n    updateCache.length = 0;\n    this.updateCacheReset.length = 0;\n    const bones = this.bones;\n    for (let i = 0, n = bones.length; i < n; i++)\n      bones[i].sorted = false;\n    const ikConstraints = this.ikConstraints;\n    const transformConstraints = this.transformConstraints;\n    const pathConstraints = this.pathConstraints;\n    const ikCount = ikConstraints.length;\n    const transformCount = transformConstraints.length;\n    const pathCount = pathConstraints.length;\n    const constraintCount = ikCount + transformCount + pathCount;\n    outer:\n      for (let i = 0; i < constraintCount; i++) {\n        for (let ii = 0; ii < ikCount; ii++) {\n          const constraint = ikConstraints[ii];\n          if (constraint.data.order == i) {\n            this.sortIkConstraint(constraint);\n            continue outer;\n          }\n        }\n        for (let ii = 0; ii < transformCount; ii++) {\n          const constraint = transformConstraints[ii];\n          if (constraint.data.order == i) {\n            this.sortTransformConstraint(constraint);\n            continue outer;\n          }\n        }\n        for (let ii = 0; ii < pathCount; ii++) {\n          const constraint = pathConstraints[ii];\n          if (constraint.data.order == i) {\n            this.sortPathConstraint(constraint);\n            continue outer;\n          }\n        }\n      }\n    for (let i = 0, n = bones.length; i < n; i++)\n      this.sortBone(bones[i]);\n  }\n  sortIkConstraint(constraint) {\n    const target = constraint.target;\n    this.sortBone(target);\n    const constrained = constraint.bones;\n    const parent = constrained[0];\n    this.sortBone(parent);\n    if (constrained.length > 1) {\n      const child = constrained[constrained.length - 1];\n      if (!(this._updateCache.indexOf(child) > -1))\n        this.updateCacheReset.push(child);\n    }\n    this._updateCache.push(constraint);\n    this.sortReset(parent.children);\n    constrained[constrained.length - 1].sorted = true;\n  }\n  sortPathConstraint(constraint) {\n    const slot = constraint.target;\n    const slotIndex = slot.data.index;\n    const slotBone = slot.bone;\n    if (this.skin != null)\n      this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);\n    if (this.data.defaultSkin != null && this.data.defaultSkin != this.skin)\n      this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);\n    for (let i = 0, n = this.data.skins.length; i < n; i++)\n      this.sortPathConstraintAttachment(this.data.skins[i], slotIndex, slotBone);\n    const attachment = slot.getAttachment();\n    if (attachment instanceof PathAttachment)\n      this.sortPathConstraintAttachmentWith(attachment, slotBone);\n    const constrained = constraint.bones;\n    const boneCount = constrained.length;\n    for (let i = 0; i < boneCount; i++)\n      this.sortBone(constrained[i]);\n    this._updateCache.push(constraint);\n    for (let i = 0; i < boneCount; i++)\n      this.sortReset(constrained[i].children);\n    for (let i = 0; i < boneCount; i++)\n      constrained[i].sorted = true;\n  }\n  sortTransformConstraint(constraint) {\n    this.sortBone(constraint.target);\n    const constrained = constraint.bones;\n    const boneCount = constrained.length;\n    if (constraint.data.local) {\n      for (let i = 0; i < boneCount; i++) {\n        const child = constrained[i];\n        this.sortBone(child.parent);\n        if (!(this._updateCache.indexOf(child) > -1))\n          this.updateCacheReset.push(child);\n      }\n    } else {\n      for (let i = 0; i < boneCount; i++) {\n        this.sortBone(constrained[i]);\n      }\n    }\n    this._updateCache.push(constraint);\n    for (let ii = 0; ii < boneCount; ii++)\n      this.sortReset(constrained[ii].children);\n    for (let ii = 0; ii < boneCount; ii++)\n      constrained[ii].sorted = true;\n  }\n  sortPathConstraintAttachment(skin, slotIndex, slotBone) {\n    const attachments = skin.attachments[slotIndex];\n    if (!attachments)\n      return;\n    for (const key in attachments) {\n      this.sortPathConstraintAttachmentWith(attachments[key], slotBone);\n    }\n  }\n  sortPathConstraintAttachmentWith(attachment, slotBone) {\n    if (!(attachment instanceof PathAttachment))\n      return;\n    const pathBones = attachment.bones;\n    if (pathBones == null)\n      this.sortBone(slotBone);\n    else {\n      const bones = this.bones;\n      let i = 0;\n      while (i < pathBones.length) {\n        const boneCount = pathBones[i++];\n        for (let n = i + boneCount; i < n; i++) {\n          const boneIndex = pathBones[i];\n          this.sortBone(bones[boneIndex]);\n        }\n      }\n    }\n  }\n  sortBone(bone) {\n    if (bone.sorted)\n      return;\n    const parent = bone.parent;\n    if (parent != null)\n      this.sortBone(parent);\n    bone.sorted = true;\n    this._updateCache.push(bone);\n  }\n  sortReset(bones) {\n    for (let i = 0, n = bones.length; i < n; i++) {\n      const bone = bones[i];\n      if (bone.sorted)\n        this.sortReset(bone.children);\n      bone.sorted = false;\n    }\n  }\n  /** Updates the world transform for each bone and applies constraints. */\n  updateWorldTransform() {\n    const updateCacheReset = this.updateCacheReset;\n    for (let i = 0, n = updateCacheReset.length; i < n; i++) {\n      const bone = updateCacheReset[i];\n      bone.ax = bone.x;\n      bone.ay = bone.y;\n      bone.arotation = bone.rotation;\n      bone.ascaleX = bone.scaleX;\n      bone.ascaleY = bone.scaleY;\n      bone.ashearX = bone.shearX;\n      bone.ashearY = bone.shearY;\n      bone.appliedValid = true;\n    }\n    const updateCache = this._updateCache;\n    for (let i = 0, n = updateCache.length; i < n; i++)\n      updateCache[i].update();\n  }\n  /** Sets the bones, constraints, and slots to their setup pose values. */\n  setToSetupPose() {\n    this.setBonesToSetupPose();\n    this.setSlotsToSetupPose();\n  }\n  /** Sets the bones and constraints to their setup pose values. */\n  setBonesToSetupPose() {\n    const bones = this.bones;\n    for (let i = 0, n = bones.length; i < n; i++)\n      bones[i].setToSetupPose();\n    const ikConstraints = this.ikConstraints;\n    for (let i = 0, n = ikConstraints.length; i < n; i++) {\n      const constraint = ikConstraints[i];\n      constraint.bendDirection = constraint.data.bendDirection;\n      constraint.mix = constraint.data.mix;\n    }\n    const transformConstraints = this.transformConstraints;\n    for (let i = 0, n = transformConstraints.length; i < n; i++) {\n      const constraint = transformConstraints[i];\n      const data = constraint.data;\n      constraint.rotateMix = data.rotateMix;\n      constraint.translateMix = data.translateMix;\n      constraint.scaleMix = data.scaleMix;\n      constraint.shearMix = data.shearMix;\n    }\n    const pathConstraints = this.pathConstraints;\n    for (let i = 0, n = pathConstraints.length; i < n; i++) {\n      const constraint = pathConstraints[i];\n      const data = constraint.data;\n      constraint.position = data.position;\n      constraint.spacing = data.spacing;\n      constraint.rotateMix = data.rotateMix;\n      constraint.translateMix = data.translateMix;\n    }\n  }\n  setSlotsToSetupPose() {\n    const slots = this.slots;\n    Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);\n    for (let i = 0, n = slots.length; i < n; i++)\n      slots[i].setToSetupPose();\n  }\n  /** @return May return null. */\n  getRootBone() {\n    if (this.bones.length == 0)\n      return null;\n    return this.bones[0];\n  }\n  /** @return May be null. */\n  findBone(boneName) {\n    if (boneName == null)\n      throw new Error(\"boneName cannot be null.\");\n    const bones = this.bones;\n    for (let i = 0, n = bones.length; i < n; i++) {\n      const bone = bones[i];\n      if (bone.data.name == boneName)\n        return bone;\n    }\n    return null;\n  }\n  /** @return -1 if the bone was not found. */\n  findBoneIndex(boneName) {\n    if (boneName == null)\n      throw new Error(\"boneName cannot be null.\");\n    const bones = this.bones;\n    for (let i = 0, n = bones.length; i < n; i++)\n      if (bones[i].data.name == boneName)\n        return i;\n    return -1;\n  }\n  /** @return May be null. */\n  findSlot(slotName) {\n    if (slotName == null)\n      throw new Error(\"slotName cannot be null.\");\n    const slots = this.slots;\n    for (let i = 0, n = slots.length; i < n; i++) {\n      const slot = slots[i];\n      if (slot.data.name == slotName)\n        return slot;\n    }\n    return null;\n  }\n  /** @return -1 if the bone was not found. */\n  findSlotIndex(slotName) {\n    if (slotName == null)\n      throw new Error(\"slotName cannot be null.\");\n    const slots = this.slots;\n    for (let i = 0, n = slots.length; i < n; i++)\n      if (slots[i].data.name == slotName)\n        return i;\n    return -1;\n  }\n  /** Sets a skin by name.\n   * @see #setSkin(Skin) */\n  setSkinByName(skinName) {\n    const skin = this.data.findSkin(skinName);\n    if (skin == null)\n      throw new Error(`Skin not found: ${skinName}`);\n    this.setSkin(skin);\n  }\n  /** Sets the skin used to look up attachments before looking in the {@link SkeletonData#getDefaultSkin() default skin}.\n   * Attachments from the new skin are attached if the corresponding attachment from the old skin was attached. If there was no\n   * old skin, each slot's setup mode attachment is attached from the new skin.\n   * @param newSkin May be null. */\n  setSkin(newSkin) {\n    if (newSkin != null) {\n      if (this.skin != null)\n        newSkin.attachAll(this, this.skin);\n      else {\n        const slots = this.slots;\n        for (let i = 0, n = slots.length; i < n; i++) {\n          const slot = slots[i];\n          const name = slot.data.attachmentName;\n          if (name != null) {\n            const attachment = newSkin.getAttachment(i, name);\n            if (attachment != null)\n              slot.setAttachment(attachment);\n          }\n        }\n      }\n    }\n    this.skin = newSkin;\n  }\n  /** @return May be null. */\n  getAttachmentByName(slotName, attachmentName) {\n    return this.getAttachment(this.data.findSlotIndex(slotName), attachmentName);\n  }\n  /** @return May be null. */\n  getAttachment(slotIndex, attachmentName) {\n    if (attachmentName == null)\n      throw new Error(\"attachmentName cannot be null.\");\n    if (this.skin != null) {\n      const attachment = this.skin.getAttachment(slotIndex, attachmentName);\n      if (attachment != null)\n        return attachment;\n    }\n    if (this.data.defaultSkin != null)\n      return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);\n    return null;\n  }\n  /** @param attachmentName May be null. */\n  setAttachment(slotName, attachmentName) {\n    if (slotName == null)\n      throw new Error(\"slotName cannot be null.\");\n    const slots = this.slots;\n    for (let i = 0, n = slots.length; i < n; i++) {\n      const slot = slots[i];\n      if (slot.data.name == slotName) {\n        let attachment = null;\n        if (attachmentName != null) {\n          attachment = this.getAttachment(i, attachmentName);\n          if (attachment == null)\n            throw new Error(`Attachment not found: ${attachmentName}, for slot: ${slotName}`);\n        }\n        slot.setAttachment(attachment);\n        return;\n      }\n    }\n    throw new Error(`Slot not found: ${slotName}`);\n  }\n  /** @return May be null. */\n  findIkConstraint(constraintName) {\n    if (constraintName == null)\n      throw new Error(\"constraintName cannot be null.\");\n    const ikConstraints = this.ikConstraints;\n    for (let i = 0, n = ikConstraints.length; i < n; i++) {\n      const ikConstraint = ikConstraints[i];\n      if (ikConstraint.data.name == constraintName)\n        return ikConstraint;\n    }\n    return null;\n  }\n  /** @return May be null. */\n  findTransformConstraint(constraintName) {\n    if (constraintName == null)\n      throw new Error(\"constraintName cannot be null.\");\n    const transformConstraints = this.transformConstraints;\n    for (let i = 0, n = transformConstraints.length; i < n; i++) {\n      const constraint = transformConstraints[i];\n      if (constraint.data.name == constraintName)\n        return constraint;\n    }\n    return null;\n  }\n  /** @return May be null. */\n  findPathConstraint(constraintName) {\n    if (constraintName == null)\n      throw new Error(\"constraintName cannot be null.\");\n    const pathConstraints = this.pathConstraints;\n    for (let i = 0, n = pathConstraints.length; i < n; i++) {\n      const constraint = pathConstraints[i];\n      if (constraint.data.name == constraintName)\n        return constraint;\n    }\n    return null;\n  }\n  /** Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose.\n   * @param offset The distance from the skeleton origin to the bottom left corner of the AABB.\n   * @param size The width and height of the AABB.\n   * @param temp Working memory */\n  getBounds(offset, size, temp) {\n    if (offset == null)\n      throw new Error(\"offset cannot be null.\");\n    if (size == null)\n      throw new Error(\"size cannot be null.\");\n    const drawOrder = this.drawOrder;\n    let minX = Number.POSITIVE_INFINITY;\n    let minY = Number.POSITIVE_INFINITY;\n    let maxX = Number.NEGATIVE_INFINITY;\n    let maxY = Number.NEGATIVE_INFINITY;\n    for (let i = 0, n = drawOrder.length; i < n; i++) {\n      const slot = drawOrder[i];\n      let verticesLength = 0;\n      let vertices = null;\n      const attachment = slot.getAttachment();\n      if (attachment instanceof RegionAttachment) {\n        verticesLength = 8;\n        vertices = Utils.setArraySize(temp, verticesLength, 0);\n        attachment.computeWorldVertices(slot.bone, vertices, 0, 2);\n      } else if (attachment instanceof MeshAttachment) {\n        const mesh = attachment;\n        verticesLength = mesh.worldVerticesLength;\n        vertices = Utils.setArraySize(temp, verticesLength, 0);\n        mesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);\n      }\n      if (vertices != null) {\n        for (let ii = 0, nn = vertices.length; ii < nn; ii += 2) {\n          const x = vertices[ii];\n          const y = vertices[ii + 1];\n          minX = Math.min(minX, x);\n          minY = Math.min(minY, y);\n          maxX = Math.max(maxX, x);\n          maxY = Math.max(maxY, y);\n        }\n      }\n    }\n    offset.set(minX, minY);\n    size.set(maxX - minX, maxY - minY);\n  }\n  update(delta) {\n    this.time += delta;\n  }\n  get flipX() {\n    return this.scaleX == -1;\n  }\n  set flipX(value) {\n    if (!_Skeleton.deprecatedWarning1) {\n      _Skeleton.deprecatedWarning1 = true;\n      console.warn(\"Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY\");\n    }\n    this.scaleX = value ? 1 : -1;\n  }\n  get flipY() {\n    return this.scaleY == -1;\n  }\n  set flipY(value) {\n    if (!_Skeleton.deprecatedWarning1) {\n      _Skeleton.deprecatedWarning1 = true;\n      console.warn(\"Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY\");\n    }\n    this.scaleY = value ? 1 : -1;\n  }\n};\nlet Skeleton = _Skeleton;\nSkeleton.deprecatedWarning1 = false;\n\nexport { Skeleton };\n//# sourceMappingURL=Skeleton.mjs.map\n","import { SkeletonBoundsBase } from '@pixi-spine/base';\n\nclass SkeletonBounds extends SkeletonBoundsBase {\n}\n\nexport { SkeletonBounds };\n//# sourceMappingURL=SkeletonBounds.mjs.map\n","class SkeletonData {\n  constructor() {\n    this.bones = new Array();\n    // Ordered parents first.\n    this.slots = new Array();\n    // Setup pose draw order.\n    this.skins = new Array();\n    this.events = new Array();\n    this.animations = new Array();\n    this.ikConstraints = new Array();\n    this.transformConstraints = new Array();\n    this.pathConstraints = new Array();\n    // Nonessential\n    this.fps = 0;\n  }\n  findBone(boneName) {\n    if (boneName == null)\n      throw new Error(\"boneName cannot be null.\");\n    const bones = this.bones;\n    for (let i = 0, n = bones.length; i < n; i++) {\n      const bone = bones[i];\n      if (bone.name == boneName)\n        return bone;\n    }\n    return null;\n  }\n  findBoneIndex(boneName) {\n    if (boneName == null)\n      throw new Error(\"boneName cannot be null.\");\n    const bones = this.bones;\n    for (let i = 0, n = bones.length; i < n; i++)\n      if (bones[i].name == boneName)\n        return i;\n    return -1;\n  }\n  findSlot(slotName) {\n    if (slotName == null)\n      throw new Error(\"slotName cannot be null.\");\n    const slots = this.slots;\n    for (let i = 0, n = slots.length; i < n; i++) {\n      const slot = slots[i];\n      if (slot.name == slotName)\n        return slot;\n    }\n    return null;\n  }\n  findSlotIndex(slotName) {\n    if (slotName == null)\n      throw new Error(\"slotName cannot be null.\");\n    const slots = this.slots;\n    for (let i = 0, n = slots.length; i < n; i++)\n      if (slots[i].name == slotName)\n        return i;\n    return -1;\n  }\n  findSkin(skinName) {\n    if (skinName == null)\n      throw new Error(\"skinName cannot be null.\");\n    const skins = this.skins;\n    for (let i = 0, n = skins.length; i < n; i++) {\n      const skin = skins[i];\n      if (skin.name == skinName)\n        return skin;\n    }\n    return null;\n  }\n  findEvent(eventDataName) {\n    if (eventDataName == null)\n      throw new Error(\"eventDataName cannot be null.\");\n    const events = this.events;\n    for (let i = 0, n = events.length; i < n; i++) {\n      const event = events[i];\n      if (event.name == eventDataName)\n        return event;\n    }\n    return null;\n  }\n  findAnimation(animationName) {\n    if (animationName == null)\n      throw new Error(\"animationName cannot be null.\");\n    const animations = this.animations;\n    for (let i = 0, n = animations.length; i < n; i++) {\n      const animation = animations[i];\n      if (animation.name == animationName)\n        return animation;\n    }\n    return null;\n  }\n  findIkConstraint(constraintName) {\n    if (constraintName == null)\n      throw new Error(\"constraintName cannot be null.\");\n    const ikConstraints = this.ikConstraints;\n    for (let i = 0, n = ikConstraints.length; i < n; i++) {\n      const constraint = ikConstraints[i];\n      if (constraint.name == constraintName)\n        return constraint;\n    }\n    return null;\n  }\n  findTransformConstraint(constraintName) {\n    if (constraintName == null)\n      throw new Error(\"constraintName cannot be null.\");\n    const transformConstraints = this.transformConstraints;\n    for (let i = 0, n = transformConstraints.length; i < n; i++) {\n      const constraint = transformConstraints[i];\n      if (constraint.name == constraintName)\n        return constraint;\n    }\n    return null;\n  }\n  findPathConstraint(constraintName) {\n    if (constraintName == null)\n      throw new Error(\"constraintName cannot be null.\");\n    const pathConstraints = this.pathConstraints;\n    for (let i = 0, n = pathConstraints.length; i < n; i++) {\n      const constraint = pathConstraints[i];\n      if (constraint.name == constraintName)\n        return constraint;\n    }\n    return null;\n  }\n  findPathConstraintIndex(pathConstraintName) {\n    if (pathConstraintName == null)\n      throw new Error(\"pathConstraintName cannot be null.\");\n    const pathConstraints = this.pathConstraints;\n    for (let i = 0, n = pathConstraints.length; i < n; i++)\n      if (pathConstraints[i].name == pathConstraintName)\n        return i;\n    return -1;\n  }\n}\n\nexport { SkeletonData };\n//# sourceMappingURL=SkeletonData.mjs.map\n","import { Color } from '@pixi-spine/base';\n\nclass SlotData {\n  constructor(index, name, boneData) {\n    this.color = new Color(1, 1, 1, 1);\n    if (index < 0)\n      throw new Error(\"index must be >= 0.\");\n    if (name == null)\n      throw new Error(\"name cannot be null.\");\n    if (boneData == null)\n      throw new Error(\"boneData cannot be null.\");\n    this.index = index;\n    this.name = name;\n    this.boneData = boneData;\n  }\n}\n\nexport { SlotData };\n//# sourceMappingURL=SlotData.mjs.map\n","class TransformConstraintData {\n  constructor(name) {\n    this.order = 0;\n    this.bones = new Array();\n    this.rotateMix = 0;\n    this.translateMix = 0;\n    this.scaleMix = 0;\n    this.shearMix = 0;\n    this.offsetRotation = 0;\n    this.offsetX = 0;\n    this.offsetY = 0;\n    this.offsetScaleX = 0;\n    this.offsetScaleY = 0;\n    this.offsetShearY = 0;\n    this.relative = false;\n    this.local = false;\n    if (name == null)\n      throw new Error(\"name cannot be null.\");\n    this.name = name;\n  }\n}\n\nexport { TransformConstraintData };\n//# sourceMappingURL=TransformConstraintData.mjs.map\n","class Skin {\n  constructor(name) {\n    this.attachments = new Array();\n    if (name == null)\n      throw new Error(\"name cannot be null.\");\n    this.name = name;\n  }\n  addAttachment(slotIndex, name, attachment) {\n    if (attachment == null)\n      throw new Error(\"attachment cannot be null.\");\n    const attachments = this.attachments;\n    if (slotIndex >= attachments.length)\n      attachments.length = slotIndex + 1;\n    if (!attachments[slotIndex])\n      attachments[slotIndex] = {};\n    attachments[slotIndex][name] = attachment;\n  }\n  /** @return May be null. */\n  getAttachment(slotIndex, name) {\n    const dictionary = this.attachments[slotIndex];\n    return dictionary ? dictionary[name] : null;\n  }\n  /** Attach each attachment in this skin if the corresponding attachment in the old skin is currently attached. */\n  attachAll(skeleton, oldSkin) {\n    let slotIndex = 0;\n    for (let i = 0; i < skeleton.slots.length; i++) {\n      const slot = skeleton.slots[i];\n      const slotAttachment = slot.getAttachment();\n      if (slotAttachment && slotIndex < oldSkin.attachments.length) {\n        const dictionary = oldSkin.attachments[slotIndex];\n        for (const key in dictionary) {\n          const skinAttachment = dictionary[key];\n          if (slotAttachment == skinAttachment) {\n            const attachment = this.getAttachment(slotIndex, key);\n            if (attachment != null)\n              slot.setAttachment(attachment);\n            break;\n          }\n        }\n      }\n      slotIndex++;\n    }\n  }\n}\n\nexport { Skin };\n//# sourceMappingURL=Skin.mjs.map\n","import { Event } from './Event.mjs';\nimport { SkeletonData } from './SkeletonData.mjs';\nimport { SlotData } from './SlotData.mjs';\nimport { BoneData } from './BoneData.mjs';\nimport { IkConstraintData } from './IkConstraintData.mjs';\nimport { TransformConstraintData } from './TransformConstraintData.mjs';\nimport { PathConstraintData, SpacingMode } from './PathConstraintData.mjs';\nimport { Skin } from './Skin.mjs';\nimport { EventData } from './EventData.mjs';\nimport { AttachmentTimeline, ColorTimeline, TwoColorTimeline, RotateTimeline, ScaleTimeline, ShearTimeline, TranslateTimeline, IkConstraintTimeline, TransformConstraintTimeline, PathConstraintSpacingTimeline, PathConstraintPositionTimeline, PathConstraintMixTimeline, DeformTimeline, DrawOrderTimeline, EventTimeline, Animation } from './Animation.mjs';\nimport { Color, PositionMode, Utils, settings, RotateMode, TransformMode } from '@pixi-spine/base';\nimport { BLEND_MODES } from '@pixi/core';\n\nclass SkeletonJson {\n  constructor(attachmentLoader) {\n    this.scale = 1;\n    this.linkedMeshes = new Array();\n    this.attachmentLoader = attachmentLoader;\n  }\n  readSkeletonData(json) {\n    const scale = this.scale;\n    const skeletonData = new SkeletonData();\n    const root = typeof json === \"string\" ? JSON.parse(json) : json;\n    const skeletonMap = root.skeleton;\n    if (skeletonMap != null) {\n      skeletonData.hash = skeletonMap.hash;\n      skeletonData.version = skeletonMap.spine;\n      skeletonData.width = skeletonMap.width;\n      skeletonData.height = skeletonMap.height;\n      skeletonData.fps = skeletonMap.fps;\n      skeletonData.imagesPath = skeletonMap.images;\n    }\n    if (root.bones) {\n      for (let i = 0; i < root.bones.length; i++) {\n        const boneMap = root.bones[i];\n        let parent = null;\n        const parentName = this.getValue(boneMap, \"parent\", null);\n        if (parentName != null) {\n          parent = skeletonData.findBone(parentName);\n          if (parent == null)\n            throw new Error(`Parent bone not found: ${parentName}`);\n        }\n        const data = new BoneData(skeletonData.bones.length, boneMap.name, parent);\n        data.length = this.getValue(boneMap, \"length\", 0) * scale;\n        data.x = this.getValue(boneMap, \"x\", 0) * scale;\n        data.y = this.getValue(boneMap, \"y\", 0) * scale;\n        data.rotation = this.getValue(boneMap, \"rotation\", 0);\n        data.scaleX = this.getValue(boneMap, \"scaleX\", 1);\n        data.scaleY = this.getValue(boneMap, \"scaleY\", 1);\n        data.shearX = this.getValue(boneMap, \"shearX\", 0);\n        data.shearY = this.getValue(boneMap, \"shearY\", 0);\n        data.transformMode = SkeletonJson.transformModeFromString(this.getValue(boneMap, \"transform\", \"normal\"));\n        skeletonData.bones.push(data);\n      }\n    }\n    if (root.slots) {\n      for (let i = 0; i < root.slots.length; i++) {\n        const slotMap = root.slots[i];\n        const slotName = slotMap.name;\n        const boneName = slotMap.bone;\n        const boneData = skeletonData.findBone(boneName);\n        if (boneData == null)\n          throw new Error(`Slot bone not found: ${boneName}`);\n        const data = new SlotData(skeletonData.slots.length, slotName, boneData);\n        const color = this.getValue(slotMap, \"color\", null);\n        if (color != null)\n          data.color.setFromString(color);\n        const dark = this.getValue(slotMap, \"dark\", null);\n        if (dark != null) {\n          data.darkColor = new Color(1, 1, 1, 1);\n          data.darkColor.setFromString(dark);\n        }\n        data.attachmentName = this.getValue(slotMap, \"attachment\", null);\n        data.blendMode = SkeletonJson.blendModeFromString(this.getValue(slotMap, \"blend\", \"normal\"));\n        skeletonData.slots.push(data);\n      }\n    }\n    if (root.ik) {\n      for (let i = 0; i < root.ik.length; i++) {\n        const constraintMap = root.ik[i];\n        const data = new IkConstraintData(constraintMap.name);\n        data.order = this.getValue(constraintMap, \"order\", 0);\n        for (let j = 0; j < constraintMap.bones.length; j++) {\n          const boneName = constraintMap.bones[j];\n          const bone = skeletonData.findBone(boneName);\n          if (bone == null)\n            throw new Error(`IK bone not found: ${boneName}`);\n          data.bones.push(bone);\n        }\n        const targetName = constraintMap.target;\n        data.target = skeletonData.findBone(targetName);\n        if (data.target == null)\n          throw new Error(`IK target bone not found: ${targetName}`);\n        data.bendDirection = this.getValue(constraintMap, \"bendPositive\", true) ? 1 : -1;\n        data.mix = this.getValue(constraintMap, \"mix\", 1);\n        skeletonData.ikConstraints.push(data);\n      }\n    }\n    if (root.transform) {\n      for (let i = 0; i < root.transform.length; i++) {\n        const constraintMap = root.transform[i];\n        const data = new TransformConstraintData(constraintMap.name);\n        data.order = this.getValue(constraintMap, \"order\", 0);\n        for (let j = 0; j < constraintMap.bones.length; j++) {\n          const boneName = constraintMap.bones[j];\n          const bone = skeletonData.findBone(boneName);\n          if (bone == null)\n            throw new Error(`Transform constraint bone not found: ${boneName}`);\n          data.bones.push(bone);\n        }\n        const targetName = constraintMap.target;\n        data.target = skeletonData.findBone(targetName);\n        if (data.target == null)\n          throw new Error(`Transform constraint target bone not found: ${targetName}`);\n        data.local = this.getValue(constraintMap, \"local\", false);\n        data.relative = this.getValue(constraintMap, \"relative\", false);\n        data.offsetRotation = this.getValue(constraintMap, \"rotation\", 0);\n        data.offsetX = this.getValue(constraintMap, \"x\", 0) * scale;\n        data.offsetY = this.getValue(constraintMap, \"y\", 0) * scale;\n        data.offsetScaleX = this.getValue(constraintMap, \"scaleX\", 0);\n        data.offsetScaleY = this.getValue(constraintMap, \"scaleY\", 0);\n        data.offsetShearY = this.getValue(constraintMap, \"shearY\", 0);\n        data.rotateMix = this.getValue(constraintMap, \"rotateMix\", 1);\n        data.translateMix = this.getValue(constraintMap, \"translateMix\", 1);\n        data.scaleMix = this.getValue(constraintMap, \"scaleMix\", 1);\n        data.shearMix = this.getValue(constraintMap, \"shearMix\", 1);\n        skeletonData.transformConstraints.push(data);\n      }\n    }\n    if (root.path) {\n      for (let i = 0; i < root.path.length; i++) {\n        const constraintMap = root.path[i];\n        const data = new PathConstraintData(constraintMap.name);\n        data.order = this.getValue(constraintMap, \"order\", 0);\n        for (let j = 0; j < constraintMap.bones.length; j++) {\n          const boneName = constraintMap.bones[j];\n          const bone = skeletonData.findBone(boneName);\n          if (bone == null)\n            throw new Error(`Transform constraint bone not found: ${boneName}`);\n          data.bones.push(bone);\n        }\n        const targetName = constraintMap.target;\n        data.target = skeletonData.findSlot(targetName);\n        if (data.target == null)\n          throw new Error(`Path target slot not found: ${targetName}`);\n        data.positionMode = SkeletonJson.positionModeFromString(this.getValue(constraintMap, \"positionMode\", \"percent\"));\n        data.spacingMode = SkeletonJson.spacingModeFromString(this.getValue(constraintMap, \"spacingMode\", \"length\"));\n        data.rotateMode = SkeletonJson.rotateModeFromString(this.getValue(constraintMap, \"rotateMode\", \"tangent\"));\n        data.offsetRotation = this.getValue(constraintMap, \"rotation\", 0);\n        data.position = this.getValue(constraintMap, \"position\", 0);\n        if (data.positionMode == PositionMode.Fixed)\n          data.position *= scale;\n        data.spacing = this.getValue(constraintMap, \"spacing\", 0);\n        if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed)\n          data.spacing *= scale;\n        data.rotateMix = this.getValue(constraintMap, \"rotateMix\", 1);\n        data.translateMix = this.getValue(constraintMap, \"translateMix\", 1);\n        skeletonData.pathConstraints.push(data);\n      }\n    }\n    if (root.skins) {\n      for (const skinName in root.skins) {\n        const skinMap = root.skins[skinName];\n        const skin = new Skin(skinName);\n        for (const slotName in skinMap) {\n          const slotIndex = skeletonData.findSlotIndex(slotName);\n          if (slotIndex == -1)\n            throw new Error(`Slot not found: ${slotName}`);\n          const slotMap = skinMap[slotName];\n          for (const entryName in slotMap) {\n            const attachment = this.readAttachment(slotMap[entryName], skin, slotIndex, entryName, skeletonData);\n            if (attachment != null)\n              skin.addAttachment(slotIndex, entryName, attachment);\n          }\n        }\n        skeletonData.skins.push(skin);\n        if (skin.name == \"default\")\n          skeletonData.defaultSkin = skin;\n      }\n    }\n    for (let i = 0, n = this.linkedMeshes.length; i < n; i++) {\n      const linkedMesh = this.linkedMeshes[i];\n      const skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\n      if (skin == null)\n        throw new Error(`Skin not found: ${linkedMesh.skin}`);\n      const parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\n      if (parent == null)\n        throw new Error(`Parent mesh not found: ${linkedMesh.parent}`);\n      linkedMesh.mesh.setParentMesh(parent);\n    }\n    this.linkedMeshes.length = 0;\n    if (root.events) {\n      for (const eventName in root.events) {\n        const eventMap = root.events[eventName];\n        const data = new EventData(eventName);\n        data.intValue = this.getValue(eventMap, \"int\", 0);\n        data.floatValue = this.getValue(eventMap, \"float\", 0);\n        data.stringValue = this.getValue(eventMap, \"string\", \"\");\n        data.audioPath = this.getValue(eventMap, \"audio\", null);\n        if (data.audioPath != null) {\n          data.volume = this.getValue(eventMap, \"volume\", 1);\n          data.balance = this.getValue(eventMap, \"balance\", 0);\n        }\n        skeletonData.events.push(data);\n      }\n    }\n    if (root.animations) {\n      for (const animationName in root.animations) {\n        const animationMap = root.animations[animationName];\n        this.readAnimation(animationMap, animationName, skeletonData);\n      }\n    }\n    return skeletonData;\n  }\n  readAttachment(map, skin, slotIndex, name, skeletonData) {\n    const scale = this.scale;\n    name = this.getValue(map, \"name\", name);\n    const type = this.getValue(map, \"type\", \"region\");\n    switch (type) {\n      case \"region\": {\n        const path = this.getValue(map, \"path\", name);\n        const region = this.attachmentLoader.newRegionAttachment(skin, name, path);\n        if (region == null)\n          return null;\n        region.path = path;\n        region.x = this.getValue(map, \"x\", 0) * scale;\n        region.y = this.getValue(map, \"y\", 0) * scale;\n        region.scaleX = this.getValue(map, \"scaleX\", 1);\n        region.scaleY = this.getValue(map, \"scaleY\", 1);\n        region.rotation = this.getValue(map, \"rotation\", 0);\n        region.width = map.width * scale;\n        region.height = map.height * scale;\n        const color = this.getValue(map, \"color\", null);\n        if (color != null)\n          region.color.setFromString(color);\n        return region;\n      }\n      case \"boundingbox\": {\n        const box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\n        if (box == null)\n          return null;\n        this.readVertices(map, box, map.vertexCount << 1);\n        const color = this.getValue(map, \"color\", null);\n        if (color != null)\n          box.color.setFromString(color);\n        return box;\n      }\n      case \"mesh\":\n      case \"linkedmesh\": {\n        const path = this.getValue(map, \"path\", name);\n        const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\n        if (mesh == null)\n          return null;\n        mesh.path = path;\n        const color = this.getValue(map, \"color\", null);\n        if (color != null)\n          mesh.color.setFromString(color);\n        const parent = this.getValue(map, \"parent\", null);\n        if (parent != null) {\n          mesh.inheritDeform = this.getValue(map, \"deform\", true);\n          this.linkedMeshes.push(new LinkedMesh(mesh, this.getValue(map, \"skin\", null), slotIndex, parent));\n          return mesh;\n        }\n        const uvs = map.uvs;\n        this.readVertices(map, mesh, uvs.length);\n        mesh.triangles = map.triangles;\n        mesh.regionUVs = new Float32Array(uvs);\n        mesh.hullLength = this.getValue(map, \"hull\", 0) * 2;\n        return mesh;\n      }\n      case \"path\": {\n        const path = this.attachmentLoader.newPathAttachment(skin, name);\n        if (path == null)\n          return null;\n        path.closed = this.getValue(map, \"closed\", false);\n        path.constantSpeed = this.getValue(map, \"constantSpeed\", true);\n        const vertexCount = map.vertexCount;\n        this.readVertices(map, path, vertexCount << 1);\n        const lengths = Utils.newArray(vertexCount / 3, 0);\n        for (let i = 0; i < map.lengths.length; i++)\n          lengths[i] = map.lengths[i] * scale;\n        path.lengths = lengths;\n        const color = this.getValue(map, \"color\", null);\n        if (color != null)\n          path.color.setFromString(color);\n        return path;\n      }\n      case \"point\": {\n        const point = this.attachmentLoader.newPointAttachment(skin, name);\n        if (point == null)\n          return null;\n        point.x = this.getValue(map, \"x\", 0) * scale;\n        point.y = this.getValue(map, \"y\", 0) * scale;\n        point.rotation = this.getValue(map, \"rotation\", 0);\n        const color = this.getValue(map, \"color\", null);\n        if (color != null)\n          point.color.setFromString(color);\n        return point;\n      }\n      case \"clipping\": {\n        const clip = this.attachmentLoader.newClippingAttachment(skin, name);\n        if (clip == null)\n          return null;\n        const end = this.getValue(map, \"end\", null);\n        if (end != null) {\n          const slot = skeletonData.findSlot(end);\n          if (slot == null)\n            throw new Error(`Clipping end slot not found: ${end}`);\n          clip.endSlot = slot;\n        }\n        const vertexCount = map.vertexCount;\n        this.readVertices(map, clip, vertexCount << 1);\n        const color = this.getValue(map, \"color\", null);\n        if (color != null)\n          clip.color.setFromString(color);\n        return clip;\n      }\n    }\n    return null;\n  }\n  readVertices(map, attachment, verticesLength) {\n    const scale = this.scale;\n    attachment.worldVerticesLength = verticesLength;\n    const vertices = map.vertices;\n    if (verticesLength == vertices.length) {\n      const scaledVertices = Utils.toFloatArray(vertices);\n      if (scale != 1) {\n        for (let i = 0, n = vertices.length; i < n; i++)\n          scaledVertices[i] *= scale;\n      }\n      attachment.vertices = scaledVertices;\n      return;\n    }\n    const weights = new Array();\n    const bones = new Array();\n    for (let i = 0, n = vertices.length; i < n; ) {\n      const boneCount = vertices[i++];\n      bones.push(boneCount);\n      for (let nn = i + boneCount * 4; i < nn; i += 4) {\n        bones.push(vertices[i]);\n        weights.push(vertices[i + 1] * scale);\n        weights.push(vertices[i + 2] * scale);\n        weights.push(vertices[i + 3]);\n      }\n    }\n    attachment.bones = bones;\n    attachment.vertices = Utils.toFloatArray(weights);\n  }\n  readAnimation(map, name, skeletonData) {\n    const scale = this.scale;\n    const timelines = new Array();\n    let duration = 0;\n    if (map.slots) {\n      for (const slotName in map.slots) {\n        const slotMap = map.slots[slotName];\n        const slotIndex = skeletonData.findSlotIndex(slotName);\n        if (slotIndex == -1)\n          throw new Error(`Slot not found: ${slotName}`);\n        for (const timelineName in slotMap) {\n          const timelineMap = slotMap[timelineName];\n          if (timelineName == \"attachment\") {\n            const timeline = new AttachmentTimeline(timelineMap.length);\n            timeline.slotIndex = slotIndex;\n            let frameIndex = 0;\n            for (let i = 0; i < timelineMap.length; i++) {\n              const valueMap = timelineMap[i];\n              timeline.setFrame(frameIndex++, valueMap.time, valueMap.name);\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n          } else if (timelineName == \"color\") {\n            const timeline = new ColorTimeline(timelineMap.length);\n            timeline.slotIndex = slotIndex;\n            let frameIndex = 0;\n            for (let i = 0; i < timelineMap.length; i++) {\n              const valueMap = timelineMap[i];\n              const color = new Color();\n              color.setFromString(valueMap.color || \"ffffffff\");\n              timeline.setFrame(frameIndex, valueMap.time, color.r, color.g, color.b, color.a);\n              this.readCurve(valueMap, timeline, frameIndex);\n              frameIndex++;\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * ColorTimeline.ENTRIES]);\n          } else if (timelineName == \"twoColor\") {\n            const timeline = new TwoColorTimeline(timelineMap.length);\n            timeline.slotIndex = slotIndex;\n            let frameIndex = 0;\n            for (let i = 0; i < timelineMap.length; i++) {\n              const valueMap = timelineMap[i];\n              const light = new Color();\n              const dark = new Color();\n              light.setFromString(valueMap.light);\n              dark.setFromString(valueMap.dark);\n              timeline.setFrame(frameIndex, valueMap.time, light.r, light.g, light.b, light.a, dark.r, dark.g, dark.b);\n              this.readCurve(valueMap, timeline, frameIndex);\n              frameIndex++;\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TwoColorTimeline.ENTRIES]);\n          } else\n            throw new Error(`Invalid timeline type for a slot: ${timelineName} (${slotName})`);\n        }\n      }\n    }\n    if (map.bones) {\n      for (const boneName in map.bones) {\n        const boneMap = map.bones[boneName];\n        const boneIndex = skeletonData.findBoneIndex(boneName);\n        if (boneIndex == -1)\n          throw new Error(`Bone not found: ${boneName}`);\n        for (const timelineName in boneMap) {\n          const timelineMap = boneMap[timelineName];\n          if (timelineName === \"rotate\") {\n            const timeline = new RotateTimeline(timelineMap.length);\n            timeline.boneIndex = boneIndex;\n            let frameIndex = 0;\n            for (let i = 0; i < timelineMap.length; i++) {\n              const valueMap = timelineMap[i];\n              timeline.setFrame(frameIndex, valueMap.time, valueMap.angle);\n              this.readCurve(valueMap, timeline, frameIndex);\n              frameIndex++;\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * RotateTimeline.ENTRIES]);\n          } else if (timelineName === \"translate\" || timelineName === \"scale\" || timelineName === \"shear\") {\n            let timeline = null;\n            let timelineScale = 1;\n            if (timelineName === \"scale\")\n              timeline = new ScaleTimeline(timelineMap.length);\n            else if (timelineName === \"shear\")\n              timeline = new ShearTimeline(timelineMap.length);\n            else {\n              timeline = new TranslateTimeline(timelineMap.length);\n              timelineScale = scale;\n            }\n            timeline.boneIndex = boneIndex;\n            let frameIndex = 0;\n            for (let i = 0; i < timelineMap.length; i++) {\n              const valueMap = timelineMap[i];\n              const x = this.getValue(valueMap, \"x\", 0);\n              const y = this.getValue(valueMap, \"y\", 0);\n              timeline.setFrame(frameIndex, valueMap.time, x * timelineScale, y * timelineScale);\n              this.readCurve(valueMap, timeline, frameIndex);\n              frameIndex++;\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TranslateTimeline.ENTRIES]);\n          } else\n            throw new Error(`Invalid timeline type for a bone: ${timelineName} (${boneName})`);\n        }\n      }\n    }\n    if (map.ik) {\n      for (const constraintName in map.ik) {\n        const constraintMap = map.ik[constraintName];\n        const constraint = skeletonData.findIkConstraint(constraintName);\n        const timeline = new IkConstraintTimeline(constraintMap.length);\n        timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(constraint);\n        let frameIndex = 0;\n        for (let i = 0; i < constraintMap.length; i++) {\n          const valueMap = constraintMap[i];\n          timeline.setFrame(\n            frameIndex,\n            valueMap.time,\n            this.getValue(valueMap, \"mix\", 1),\n            this.getValue(valueMap, \"bendPositive\", true) ? 1 : -1,\n            this.getValue(valueMap, \"compress\", false),\n            this.getValue(valueMap, \"stretch\", false)\n          );\n          this.readCurve(valueMap, timeline, frameIndex);\n          frameIndex++;\n        }\n        timelines.push(timeline);\n        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * IkConstraintTimeline.ENTRIES]);\n      }\n    }\n    if (map.transform) {\n      for (const constraintName in map.transform) {\n        const constraintMap = map.transform[constraintName];\n        const constraint = skeletonData.findTransformConstraint(constraintName);\n        const timeline = new TransformConstraintTimeline(constraintMap.length);\n        timeline.transformConstraintIndex = skeletonData.transformConstraints.indexOf(constraint);\n        let frameIndex = 0;\n        for (let i = 0; i < constraintMap.length; i++) {\n          const valueMap = constraintMap[i];\n          timeline.setFrame(\n            frameIndex,\n            valueMap.time,\n            this.getValue(valueMap, \"rotateMix\", 1),\n            this.getValue(valueMap, \"translateMix\", 1),\n            this.getValue(valueMap, \"scaleMix\", 1),\n            this.getValue(valueMap, \"shearMix\", 1)\n          );\n          this.readCurve(valueMap, timeline, frameIndex);\n          frameIndex++;\n        }\n        timelines.push(timeline);\n        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TransformConstraintTimeline.ENTRIES]);\n      }\n    }\n    if (map.paths) {\n      for (const constraintName in map.paths) {\n        const constraintMap = map.paths[constraintName];\n        const index = skeletonData.findPathConstraintIndex(constraintName);\n        if (index == -1)\n          throw new Error(`Path constraint not found: ${constraintName}`);\n        const data = skeletonData.pathConstraints[index];\n        for (const timelineName in constraintMap) {\n          const timelineMap = constraintMap[timelineName];\n          if (timelineName === \"position\" || timelineName === \"spacing\") {\n            let timeline = null;\n            let timelineScale = 1;\n            if (timelineName === \"spacing\") {\n              timeline = new PathConstraintSpacingTimeline(timelineMap.length);\n              if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed)\n                timelineScale = scale;\n            } else {\n              timeline = new PathConstraintPositionTimeline(timelineMap.length);\n              if (data.positionMode == PositionMode.Fixed)\n                timelineScale = scale;\n            }\n            timeline.pathConstraintIndex = index;\n            let frameIndex = 0;\n            for (let i = 0; i < timelineMap.length; i++) {\n              const valueMap = timelineMap[i];\n              timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, timelineName, 0) * timelineScale);\n              this.readCurve(valueMap, timeline, frameIndex);\n              frameIndex++;\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * PathConstraintPositionTimeline.ENTRIES]);\n          } else if (timelineName === \"mix\") {\n            const timeline = new PathConstraintMixTimeline(timelineMap.length);\n            timeline.pathConstraintIndex = index;\n            let frameIndex = 0;\n            for (let i = 0; i < timelineMap.length; i++) {\n              const valueMap = timelineMap[i];\n              timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, \"rotateMix\", 1), this.getValue(valueMap, \"translateMix\", 1));\n              this.readCurve(valueMap, timeline, frameIndex);\n              frameIndex++;\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * PathConstraintMixTimeline.ENTRIES]);\n          }\n        }\n      }\n    }\n    if (map.deform) {\n      for (const deformName in map.deform) {\n        const deformMap = map.deform[deformName];\n        const skin = skeletonData.findSkin(deformName);\n        if (skin == null) {\n          if (settings.FAIL_ON_NON_EXISTING_SKIN) {\n            throw new Error(`Skin not found: ${deformName}`);\n          } else {\n            continue;\n          }\n        }\n        for (const slotName in deformMap) {\n          const slotMap = deformMap[slotName];\n          const slotIndex = skeletonData.findSlotIndex(slotName);\n          if (slotIndex == -1)\n            throw new Error(`Slot not found: ${slotMap.name}`);\n          for (const timelineName in slotMap) {\n            const timelineMap = slotMap[timelineName];\n            const attachment = skin.getAttachment(slotIndex, timelineName);\n            if (attachment == null)\n              throw new Error(`Deform attachment not found: ${timelineMap.name}`);\n            const weighted = attachment.bones != null;\n            const vertices = attachment.vertices;\n            const deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;\n            const timeline = new DeformTimeline(timelineMap.length);\n            timeline.slotIndex = slotIndex;\n            timeline.attachment = attachment;\n            let frameIndex = 0;\n            for (let j = 0; j < timelineMap.length; j++) {\n              const valueMap = timelineMap[j];\n              let deform;\n              const verticesValue = this.getValue(valueMap, \"vertices\", null);\n              if (verticesValue == null)\n                deform = weighted ? Utils.newFloatArray(deformLength) : vertices;\n              else {\n                deform = Utils.newFloatArray(deformLength);\n                const start = this.getValue(valueMap, \"offset\", 0);\n                Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);\n                if (scale != 1) {\n                  for (let i = start, n = i + verticesValue.length; i < n; i++)\n                    deform[i] *= scale;\n                }\n                if (!weighted) {\n                  for (let i = 0; i < deformLength; i++)\n                    deform[i] += vertices[i];\n                }\n              }\n              timeline.setFrame(frameIndex, valueMap.time, deform);\n              this.readCurve(valueMap, timeline, frameIndex);\n              frameIndex++;\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n          }\n        }\n      }\n    }\n    let drawOrderNode = map.drawOrder;\n    if (drawOrderNode == null)\n      drawOrderNode = map.draworder;\n    if (drawOrderNode != null) {\n      const timeline = new DrawOrderTimeline(drawOrderNode.length);\n      const slotCount = skeletonData.slots.length;\n      let frameIndex = 0;\n      for (let j = 0; j < drawOrderNode.length; j++) {\n        const drawOrderMap = drawOrderNode[j];\n        let drawOrder = null;\n        const offsets = this.getValue(drawOrderMap, \"offsets\", null);\n        if (offsets != null) {\n          drawOrder = Utils.newArray(slotCount, -1);\n          const unchanged = Utils.newArray(slotCount - offsets.length, 0);\n          let originalIndex = 0;\n          let unchangedIndex = 0;\n          for (let i = 0; i < offsets.length; i++) {\n            const offsetMap = offsets[i];\n            const slotIndex = skeletonData.findSlotIndex(offsetMap.slot);\n            if (slotIndex == -1)\n              throw new Error(`Slot not found: ${offsetMap.slot}`);\n            while (originalIndex != slotIndex)\n              unchanged[unchangedIndex++] = originalIndex++;\n            drawOrder[originalIndex + offsetMap.offset] = originalIndex++;\n          }\n          while (originalIndex < slotCount)\n            unchanged[unchangedIndex++] = originalIndex++;\n          for (let i = slotCount - 1; i >= 0; i--)\n            if (drawOrder[i] == -1)\n              drawOrder[i] = unchanged[--unchangedIndex];\n        }\n        timeline.setFrame(frameIndex++, drawOrderMap.time, drawOrder);\n      }\n      timelines.push(timeline);\n      duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n    }\n    if (map.events) {\n      const timeline = new EventTimeline(map.events.length);\n      let frameIndex = 0;\n      for (let i = 0; i < map.events.length; i++) {\n        const eventMap = map.events[i];\n        const eventData = skeletonData.findEvent(eventMap.name);\n        if (eventData == null)\n          throw new Error(`Event not found: ${eventMap.name}`);\n        const event = new Event(Utils.toSinglePrecision(eventMap.time), eventData);\n        event.intValue = this.getValue(eventMap, \"int\", eventData.intValue);\n        event.floatValue = this.getValue(eventMap, \"float\", eventData.floatValue);\n        event.stringValue = this.getValue(eventMap, \"string\", eventData.stringValue);\n        if (event.data.audioPath != null) {\n          event.volume = this.getValue(eventMap, \"volume\", 1);\n          event.balance = this.getValue(eventMap, \"balance\", 0);\n        }\n        timeline.setFrame(frameIndex++, event);\n      }\n      timelines.push(timeline);\n      duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n    }\n    if (isNaN(duration)) {\n      throw new Error(\"Error while parsing animation, duration is NaN\");\n    }\n    skeletonData.animations.push(new Animation(name, timelines, duration));\n  }\n  readCurve(map, timeline, frameIndex) {\n    if (!map.curve)\n      return;\n    if (map.curve === \"stepped\")\n      timeline.setStepped(frameIndex);\n    else if (Object.prototype.toString.call(map.curve) === \"[object Array]\") {\n      const curve = map.curve;\n      timeline.setCurve(frameIndex, curve[0], curve[1], curve[2], curve[3]);\n    }\n  }\n  getValue(map, prop, defaultValue) {\n    return map[prop] !== void 0 ? map[prop] : defaultValue;\n  }\n  static blendModeFromString(str) {\n    str = str.toLowerCase();\n    if (str == \"normal\")\n      return BLEND_MODES.NORMAL;\n    if (str == \"additive\")\n      return BLEND_MODES.ADD;\n    if (str == \"multiply\")\n      return BLEND_MODES.MULTIPLY;\n    if (str == \"screen\")\n      return BLEND_MODES.SCREEN;\n    throw new Error(`Unknown blend mode: ${str}`);\n  }\n  static positionModeFromString(str) {\n    str = str.toLowerCase();\n    if (str == \"fixed\")\n      return PositionMode.Fixed;\n    if (str == \"percent\")\n      return PositionMode.Percent;\n    throw new Error(`Unknown position mode: ${str}`);\n  }\n  static spacingModeFromString(str) {\n    str = str.toLowerCase();\n    if (str == \"length\")\n      return SpacingMode.Length;\n    if (str == \"fixed\")\n      return SpacingMode.Fixed;\n    if (str == \"percent\")\n      return SpacingMode.Percent;\n    throw new Error(`Unknown position mode: ${str}`);\n  }\n  static rotateModeFromString(str) {\n    str = str.toLowerCase();\n    if (str == \"tangent\")\n      return RotateMode.Tangent;\n    if (str == \"chain\")\n      return RotateMode.Chain;\n    if (str == \"chainscale\")\n      return RotateMode.ChainScale;\n    throw new Error(`Unknown rotate mode: ${str}`);\n  }\n  static transformModeFromString(str) {\n    str = str.toLowerCase();\n    if (str == \"normal\")\n      return TransformMode.Normal;\n    if (str == \"onlytranslation\")\n      return TransformMode.OnlyTranslation;\n    if (str == \"norotationorreflection\")\n      return TransformMode.NoRotationOrReflection;\n    if (str == \"noscale\")\n      return TransformMode.NoScale;\n    if (str == \"noscaleorreflection\")\n      return TransformMode.NoScaleOrReflection;\n    throw new Error(`Unknown transform mode: ${str}`);\n  }\n}\nclass LinkedMesh {\n  constructor(mesh, skin, slotIndex, parent) {\n    this.mesh = mesh;\n    this.skin = skin;\n    this.slotIndex = slotIndex;\n    this.parent = parent;\n  }\n}\n\nexport { SkeletonJson };\n//# sourceMappingURL=SkeletonJson.mjs.map\n","import { SpineBase } from '@pixi-spine/base';\nimport { Skeleton } from './core/Skeleton.mjs';\nimport { AnimationState } from './core/AnimationState.mjs';\nimport { AnimationStateData } from './core/AnimationStateData.mjs';\n\nclass Spine extends SpineBase {\n  createSkeleton(spineData) {\n    this.skeleton = new Skeleton(spineData);\n    this.skeleton.updateWorldTransform();\n    this.stateData = new AnimationStateData(spineData);\n    this.state = new AnimationState(this.stateData);\n  }\n}\n\nexport { Spine };\n//# sourceMappingURL=Spine.mjs.map\n","import { Utils } from '@pixi-spine/base';\n\nclass Attachment {\n  constructor(name) {\n    if (!name)\n      throw new Error(\"name cannot be null.\");\n    this.name = name;\n  }\n}\nconst _VertexAttachment = class extends Attachment {\n  constructor(name) {\n    super(name);\n    /** The unique ID for this attachment. */\n    this.id = _VertexAttachment.nextID++;\n    /** The bones which affect the {@link #getVertices()}. The array entries are, for each vertex, the number of bones affecting\n     * the vertex followed by that many bone indices, which is the index of the bone in {@link Skeleton#bones}. Will be null\n     * if this attachment has no weights. */\n    this.bones = null;\n    /** The vertex positions in the bone's coordinate system. For a non-weighted attachment, the values are `x,y`\n     * entries for each vertex. For a weighted attachment, the values are `x,y,weight` entries for each bone affecting\n     * each vertex. */\n    this.vertices = [];\n    /** The maximum number of world vertex values that can be output by\n     * {@link #computeWorldVertices()} using the `count` parameter. */\n    this.worldVerticesLength = 0;\n    /** Timelines for the timeline attachment are also applied to this attachment.\n     * May be null if no attachment-specific timelines should be applied. */\n    this.timelineAttachment = this;\n  }\n  computeWorldVerticesOld(slot, worldVertices) {\n    this.computeWorldVertices(slot, 0, this.worldVerticesLength, worldVertices, 0, 2);\n  }\n  /** Transforms the attachment's local {@link #vertices} to world coordinates. If the slot's {@link Slot#deform} is\n   * not empty, it is used to deform the vertices.\n   *\n   * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine\n   * Runtimes Guide.\n   * @param start The index of the first {@link #vertices} value to transform. Each vertex has 2 values, x and y.\n   * @param count The number of world vertex values to output. Must be <= {@link #worldVerticesLength} - `start`.\n   * @param worldVertices The output world vertices. Must have a length >= `offset` + `count` *\n   *           `stride` / 2.\n   * @param offset The `worldVertices` index to begin writing values.\n   * @param stride The number of `worldVertices` entries between the value pairs written. */\n  computeWorldVertices(slot, start, count, worldVertices, offset, stride) {\n    count = offset + (count >> 1) * stride;\n    const skeleton = slot.bone.skeleton;\n    const deformArray = slot.deform;\n    let vertices = this.vertices;\n    const bones = this.bones;\n    if (!bones) {\n      if (deformArray.length > 0)\n        vertices = deformArray;\n      const mat = slot.bone.matrix;\n      const x = mat.tx;\n      const y = mat.ty;\n      const a = mat.a;\n      const b = mat.c;\n      const c = mat.b;\n      const d = mat.d;\n      for (let v2 = start, w = offset; w < count; v2 += 2, w += stride) {\n        const vx = vertices[v2];\n        const vy = vertices[v2 + 1];\n        worldVertices[w] = vx * a + vy * b + x;\n        worldVertices[w + 1] = vx * c + vy * d + y;\n      }\n      return;\n    }\n    let v = 0;\n    let skip = 0;\n    for (let i = 0; i < start; i += 2) {\n      const n = bones[v];\n      v += n + 1;\n      skip += n;\n    }\n    const skeletonBones = skeleton.bones;\n    if (deformArray.length == 0) {\n      for (let w = offset, b = skip * 3; w < count; w += stride) {\n        let wx = 0;\n        let wy = 0;\n        let n = bones[v++];\n        n += v;\n        for (; v < n; v++, b += 3) {\n          const mat = skeletonBones[bones[v]].matrix;\n          const vx = vertices[b];\n          const vy = vertices[b + 1];\n          const weight = vertices[b + 2];\n          wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\n          wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\n        }\n        worldVertices[w] = wx;\n        worldVertices[w + 1] = wy;\n      }\n    } else {\n      const deform = deformArray;\n      for (let w = offset, b = skip * 3, f = skip << 1; w < count; w += stride) {\n        let wx = 0;\n        let wy = 0;\n        let n = bones[v++];\n        n += v;\n        for (; v < n; v++, b += 3, f += 2) {\n          const mat = skeletonBones[bones[v]].matrix;\n          const vx = vertices[b] + deform[f];\n          const vy = vertices[b + 1] + deform[f + 1];\n          const weight = vertices[b + 2];\n          wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\n          wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\n        }\n        worldVertices[w] = wx;\n        worldVertices[w + 1] = wy;\n      }\n    }\n  }\n  /** Does not copy id (generated) or name (set on construction). **/\n  copyTo(attachment) {\n    if (this.bones) {\n      attachment.bones = new Array(this.bones.length);\n      Utils.arrayCopy(this.bones, 0, attachment.bones, 0, this.bones.length);\n    } else\n      attachment.bones = null;\n    if (this.vertices) {\n      attachment.vertices = Utils.newFloatArray(this.vertices.length);\n      Utils.arrayCopy(this.vertices, 0, attachment.vertices, 0, this.vertices.length);\n    }\n    attachment.worldVerticesLength = this.worldVerticesLength;\n    attachment.timelineAttachment = this.timelineAttachment;\n  }\n};\nlet VertexAttachment = _VertexAttachment;\nVertexAttachment.nextID = 0;\n\nexport { Attachment, VertexAttachment };\n//# sourceMappingURL=Attachment.mjs.map\n","import { VertexAttachment } from './Attachment.mjs';\nimport { AttachmentType, Color } from '@pixi-spine/base';\n\nclass BoundingBoxAttachment extends VertexAttachment {\n  constructor(name) {\n    super(name);\n    this.type = AttachmentType.BoundingBox;\n    this.color = new Color(1, 1, 1, 1);\n  }\n  copy() {\n    const copy = new BoundingBoxAttachment(this.name);\n    this.copyTo(copy);\n    copy.color.setFromColor(this.color);\n    return copy;\n  }\n}\n\nexport { BoundingBoxAttachment };\n//# sourceMappingURL=BoundingBoxAttachment.mjs.map\n","import { VertexAttachment } from './Attachment.mjs';\nimport { AttachmentType, Color } from '@pixi-spine/base';\n\nclass ClippingAttachment extends VertexAttachment {\n  // ce3a3aff\n  constructor(name) {\n    super(name);\n    this.type = AttachmentType.Clipping;\n    /** Clipping is performed between the clipping polygon's slot and the end slot. Returns null if clipping is done until the end of\n     * the skeleton's rendering. */\n    this.endSlot = null;\n    // Nonessential.\n    /** The color of the clipping polygon as it was in Spine. Available only when nonessential data was exported. Clipping polygons\n     * are not usually rendered at runtime. */\n    this.color = new Color(0.2275, 0.2275, 0.8078, 1);\n  }\n  copy() {\n    const copy = new ClippingAttachment(this.name);\n    this.copyTo(copy);\n    copy.endSlot = this.endSlot;\n    copy.color.setFromColor(this.color);\n    return copy;\n  }\n}\n\nexport { ClippingAttachment };\n//# sourceMappingURL=ClippingAttachment.mjs.map\n","import { VertexAttachment } from './Attachment.mjs';\nimport { AttachmentType, Color, Utils } from '@pixi-spine/base';\n\nclass MeshAttachment extends VertexAttachment {\n  constructor(name, path) {\n    super(name);\n    this.type = AttachmentType.Mesh;\n    this.region = null;\n    /** Triplets of vertex indices which describe the mesh's triangulation. */\n    this.triangles = [];\n    /** The color to tint the mesh. */\n    this.color = new Color(1, 1, 1, 1);\n    /** The width of the mesh's image. Available only when nonessential data was exported. */\n    this.width = 0;\n    /** The height of the mesh's image. Available only when nonessential data was exported. */\n    this.height = 0;\n    /** The number of entries at the beginning of {@link #vertices} that make up the mesh hull. */\n    this.hullLength = 0;\n    /** Vertex index pairs describing edges for controling triangulation. Mesh triangles will never cross edges. Only available if\n     * nonessential data was exported. Triangulation is not performed at runtime. */\n    this.edges = [];\n    this.parentMesh = null;\n    this.sequence = null;\n    this.tempColor = new Color(0, 0, 0, 0);\n    this.path = path;\n  }\n  /** The parent mesh if this is a linked mesh, else null. A linked mesh shares the {@link #bones}, {@link #vertices},\n   * {@link #regionUVs}, {@link #triangles}, {@link #hullLength}, {@link #edges}, {@link #width}, and {@link #height} with the\n   * parent mesh, but may have a different {@link #name} or {@link #path} (and therefore a different texture). */\n  getParentMesh() {\n    return this.parentMesh;\n  }\n  /** @param parentMesh May be null. */\n  setParentMesh(parentMesh) {\n    this.parentMesh = parentMesh;\n    if (parentMesh) {\n      this.bones = parentMesh.bones;\n      this.vertices = parentMesh.vertices;\n      this.worldVerticesLength = parentMesh.worldVerticesLength;\n      this.regionUVs = parentMesh.regionUVs;\n      this.triangles = parentMesh.triangles;\n      this.hullLength = parentMesh.hullLength;\n      this.worldVerticesLength = parentMesh.worldVerticesLength;\n    }\n  }\n  copy() {\n    if (this.parentMesh)\n      return this.newLinkedMesh();\n    const copy = new MeshAttachment(this.name, this.path);\n    copy.region = this.region;\n    copy.color.setFromColor(this.color);\n    this.copyTo(copy);\n    copy.regionUVs = new Float32Array(this.regionUVs.length);\n    Utils.arrayCopy(this.regionUVs, 0, copy.regionUVs, 0, this.regionUVs.length);\n    copy.triangles = new Array(this.triangles.length);\n    Utils.arrayCopy(this.triangles, 0, copy.triangles, 0, this.triangles.length);\n    copy.hullLength = this.hullLength;\n    copy.sequence = this.sequence != null ? this.sequence.copy() : null;\n    if (this.edges) {\n      copy.edges = new Array(this.edges.length);\n      Utils.arrayCopy(this.edges, 0, copy.edges, 0, this.edges.length);\n    }\n    copy.width = this.width;\n    copy.height = this.height;\n    return copy;\n  }\n  computeWorldVertices(slot, start, count, worldVertices, offset, stride) {\n    if (this.sequence != null)\n      this.sequence.apply(slot, this);\n    super.computeWorldVertices(slot, start, count, worldVertices, offset, stride);\n  }\n  /** Returns a new mesh with the {@link #parentMesh} set to this mesh's parent mesh, if any, else to this mesh. **/\n  newLinkedMesh() {\n    const copy = new MeshAttachment(this.name, this.path);\n    copy.region = this.region;\n    copy.color.setFromColor(this.color);\n    copy.timelineAttachment = this.timelineAttachment;\n    copy.setParentMesh(this.parentMesh ? this.parentMesh : this);\n    return copy;\n  }\n}\n\nexport { MeshAttachment };\n//# sourceMappingURL=MeshAttachment.mjs.map\n","import { VertexAttachment } from './Attachment.mjs';\nimport { AttachmentType, Color, Utils } from '@pixi-spine/base';\n\nclass PathAttachment extends VertexAttachment {\n  constructor(name) {\n    super(name);\n    this.type = AttachmentType.Path;\n    /** The lengths along the path in the setup pose from the start of the path to the end of each Bezier curve. */\n    this.lengths = [];\n    /** If true, the start and end knots are connected. */\n    this.closed = false;\n    /** If true, additional calculations are performed to make calculating positions along the path more accurate. If false, fewer\n     * calculations are performed but calculating positions along the path is less accurate. */\n    this.constantSpeed = false;\n    /** The color of the path as it was in Spine. Available only when nonessential data was exported. Paths are not usually\n     * rendered at runtime. */\n    this.color = new Color(1, 1, 1, 1);\n  }\n  copy() {\n    const copy = new PathAttachment(this.name);\n    this.copyTo(copy);\n    copy.lengths = new Array(this.lengths.length);\n    Utils.arrayCopy(this.lengths, 0, copy.lengths, 0, this.lengths.length);\n    copy.closed = closed;\n    copy.constantSpeed = this.constantSpeed;\n    copy.color.setFromColor(this.color);\n    return copy;\n  }\n}\n\nexport { PathAttachment };\n//# sourceMappingURL=PathAttachment.mjs.map\n","import { VertexAttachment } from './Attachment.mjs';\nimport { AttachmentType, Color, MathUtils } from '@pixi-spine/base';\n\nclass PointAttachment extends VertexAttachment {\n  constructor(name) {\n    super(name);\n    this.type = AttachmentType.Point;\n    this.x = 0;\n    this.y = 0;\n    this.rotation = 0;\n    /** The color of the point attachment as it was in Spine. Available only when nonessential data was exported. Point attachments\n     * are not usually rendered at runtime. */\n    this.color = new Color(0.38, 0.94, 0, 1);\n  }\n  computeWorldPosition(bone, point) {\n    const mat = bone.matrix;\n    point.x = this.x * mat.a + this.y * mat.c + bone.worldX;\n    point.y = this.x * mat.b + this.y * mat.d + bone.worldY;\n    return point;\n  }\n  computeWorldRotation(bone) {\n    const mat = bone.matrix;\n    const cos = MathUtils.cosDeg(this.rotation);\n    const sin = MathUtils.sinDeg(this.rotation);\n    const x = cos * mat.a + sin * mat.c;\n    const y = cos * mat.b + sin * mat.d;\n    return Math.atan2(y, x) * MathUtils.radDeg;\n  }\n  copy() {\n    const copy = new PointAttachment(this.name);\n    copy.x = this.x;\n    copy.y = this.y;\n    copy.rotation = this.rotation;\n    copy.color.setFromColor(this.color);\n    return copy;\n  }\n}\n\nexport { PointAttachment };\n//# sourceMappingURL=PointAttachment.mjs.map\n","import { Attachment } from './Attachment.mjs';\nimport { AttachmentType, Color, Utils } from '@pixi-spine/base';\n\nconst _RegionAttachment = class extends Attachment {\n  constructor(name, path) {\n    super(name);\n    this.type = AttachmentType.Region;\n    /** The local x translation. */\n    this.x = 0;\n    /** The local y translation. */\n    this.y = 0;\n    /** The local scaleX. */\n    this.scaleX = 1;\n    /** The local scaleY. */\n    this.scaleY = 1;\n    /** The local rotation. */\n    this.rotation = 0;\n    /** The width of the region attachment in Spine. */\n    this.width = 0;\n    /** The height of the region attachment in Spine. */\n    this.height = 0;\n    /** The color to tint the region attachment. */\n    this.color = new Color(1, 1, 1, 1);\n    this.rendererObject = null;\n    this.region = null;\n    this.sequence = null;\n    /** For each of the 4 vertices, a pair of <code>x,y</code> values that is the local position of the vertex.\n     *\n     * See {@link #updateOffset()}. */\n    this.offset = Utils.newFloatArray(8);\n    this.uvs = Utils.newFloatArray(8);\n    this.tempColor = new Color(1, 1, 1, 1);\n    this.path = path;\n  }\n  /** Calculates the {@link #offset} using the region settings. Must be called after changing region settings. */\n  updateRegion() {\n    if (!this.region)\n      throw new Error(\"Region not set.\");\n    const region = this.region;\n    const regionScaleX = this.width / this.region.originalWidth * this.scaleX;\n    const regionScaleY = this.height / this.region.originalHeight * this.scaleY;\n    const localX = -this.width / 2 * this.scaleX + this.region.offsetX * regionScaleX;\n    const localY = -this.height / 2 * this.scaleY + this.region.offsetY * regionScaleY;\n    const localX2 = localX + this.region.width * regionScaleX;\n    const localY2 = localY + this.region.height * regionScaleY;\n    const radians = this.rotation * Math.PI / 180;\n    const cos = Math.cos(radians);\n    const sin = Math.sin(radians);\n    const x = this.x;\n    const y = this.y;\n    const localXCos = localX * cos + x;\n    const localXSin = localX * sin;\n    const localYCos = localY * cos + y;\n    const localYSin = localY * sin;\n    const localX2Cos = localX2 * cos + x;\n    const localX2Sin = localX2 * sin;\n    const localY2Cos = localY2 * cos + y;\n    const localY2Sin = localY2 * sin;\n    const offset = this.offset;\n    offset[0] = localXCos - localYSin;\n    offset[1] = localYCos + localXSin;\n    offset[2] = localXCos - localY2Sin;\n    offset[3] = localY2Cos + localXSin;\n    offset[4] = localX2Cos - localY2Sin;\n    offset[5] = localY2Cos + localX2Sin;\n    offset[6] = localX2Cos - localYSin;\n    offset[7] = localYCos + localX2Sin;\n    const uvs = this.uvs;\n    if (region.degrees == 90) {\n      uvs[2] = region.u;\n      uvs[3] = region.v2;\n      uvs[4] = region.u;\n      uvs[5] = region.v;\n      uvs[6] = region.u2;\n      uvs[7] = region.v;\n      uvs[0] = region.u2;\n      uvs[1] = region.v2;\n    } else {\n      uvs[0] = region.u;\n      uvs[1] = region.v2;\n      uvs[2] = region.u;\n      uvs[3] = region.v;\n      uvs[4] = region.u2;\n      uvs[5] = region.v;\n      uvs[6] = region.u2;\n      uvs[7] = region.v2;\n    }\n  }\n  /** Transforms the attachment's four vertices to world coordinates. If the attachment has a {@link #sequence}, the region may\n   * be changed.\n   * <p>\n   * See <a href=\"http://esotericsoftware.com/spine-runtime-skeletons#World-transforms\">World transforms</a> in the Spine\n   * Runtimes Guide.\n   * @param worldVertices The output world vertices. Must have a length >= <code>offset</code> + 8.\n   * @param offset The <code>worldVertices</code> index to begin writing values.\n   * @param stride The number of <code>worldVertices</code> entries between the value pairs written. */\n  computeWorldVertices(slot, worldVertices, offset, stride) {\n    if (this.sequence != null)\n      this.sequence.apply(slot, this);\n    const bone = slot.bone;\n    const vertexOffset = this.offset;\n    const mat = bone.matrix;\n    const x = mat.tx;\n    const y = mat.ty;\n    const a = mat.a;\n    const b = mat.c;\n    const c = mat.b;\n    const d = mat.d;\n    let offsetX = 0;\n    let offsetY = 0;\n    offsetX = vertexOffset[0];\n    offsetY = vertexOffset[1];\n    worldVertices[offset] = offsetX * a + offsetY * b + x;\n    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n    offset += stride;\n    offsetX = vertexOffset[2];\n    offsetY = vertexOffset[3];\n    worldVertices[offset] = offsetX * a + offsetY * b + x;\n    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n    offset += stride;\n    offsetX = vertexOffset[4];\n    offsetY = vertexOffset[5];\n    worldVertices[offset] = offsetX * a + offsetY * b + x;\n    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n    offset += stride;\n    offsetX = vertexOffset[6];\n    offsetY = vertexOffset[7];\n    worldVertices[offset] = offsetX * a + offsetY * b + x;\n    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n  }\n  copy() {\n    const copy = new _RegionAttachment(this.name, this.path);\n    copy.region = this.region;\n    copy.rendererObject = this.rendererObject;\n    copy.x = this.x;\n    copy.y = this.y;\n    copy.scaleX = this.scaleX;\n    copy.scaleY = this.scaleY;\n    copy.rotation = this.rotation;\n    copy.width = this.width;\n    copy.height = this.height;\n    Utils.arrayCopy(this.uvs, 0, copy.uvs, 0, 8);\n    Utils.arrayCopy(this.offset, 0, copy.offset, 0, 8);\n    copy.color.setFromColor(this.color);\n    copy.sequence = this.sequence != null ? this.sequence.copy() : null;\n    return copy;\n  }\n};\nlet RegionAttachment = _RegionAttachment;\nRegionAttachment.X1 = 0;\nRegionAttachment.Y1 = 1;\nRegionAttachment.C1R = 2;\nRegionAttachment.C1G = 3;\nRegionAttachment.C1B = 4;\nRegionAttachment.C1A = 5;\nRegionAttachment.U1 = 6;\nRegionAttachment.V1 = 7;\nRegionAttachment.X2 = 8;\nRegionAttachment.Y2 = 9;\nRegionAttachment.C2R = 10;\nRegionAttachment.C2G = 11;\nRegionAttachment.C2B = 12;\nRegionAttachment.C2A = 13;\nRegionAttachment.U2 = 14;\nRegionAttachment.V2 = 15;\nRegionAttachment.X3 = 16;\nRegionAttachment.Y3 = 17;\nRegionAttachment.C3R = 18;\nRegionAttachment.C3G = 19;\nRegionAttachment.C3B = 20;\nRegionAttachment.C3A = 21;\nRegionAttachment.U3 = 22;\nRegionAttachment.V3 = 23;\nRegionAttachment.X4 = 24;\nRegionAttachment.Y4 = 25;\nRegionAttachment.C4R = 26;\nRegionAttachment.C4G = 27;\nRegionAttachment.C4B = 28;\nRegionAttachment.C4A = 29;\nRegionAttachment.U4 = 30;\nRegionAttachment.V4 = 31;\n\nexport { RegionAttachment };\n//# sourceMappingURL=RegionAttachment.mjs.map\n","import { Utils } from '@pixi-spine/base';\n\nconst _Sequence = class {\n  constructor(count) {\n    this.id = _Sequence.nextID();\n    this.start = 0;\n    this.digits = 0;\n    /** The index of the region to show for the setup pose. */\n    this.setupIndex = 0;\n    this.regions = new Array(count);\n  }\n  copy() {\n    const copy = new _Sequence(this.regions.length);\n    Utils.arrayCopy(this.regions, 0, copy.regions, 0, this.regions.length);\n    copy.start = this.start;\n    copy.digits = this.digits;\n    copy.setupIndex = this.setupIndex;\n    return copy;\n  }\n  apply(slot, attachment) {\n    let index = slot.sequenceIndex;\n    if (index == -1)\n      index = this.setupIndex;\n    if (index >= this.regions.length)\n      index = this.regions.length - 1;\n    const region = this.regions[index];\n    if (attachment.region != region) {\n      attachment.region = region;\n    }\n  }\n  getPath(basePath, index) {\n    let result = basePath;\n    const frame = (this.start + index).toString();\n    for (let i = this.digits - frame.length; i > 0; i--)\n      result += \"0\";\n    result += frame;\n    return result;\n  }\n  static nextID() {\n    return _Sequence._nextID++;\n  }\n};\nlet Sequence = _Sequence;\nSequence._nextID = 0;\nvar SequenceMode = /* @__PURE__ */ ((SequenceMode2) => {\n  SequenceMode2[SequenceMode2[\"hold\"] = 0] = \"hold\";\n  SequenceMode2[SequenceMode2[\"once\"] = 1] = \"once\";\n  SequenceMode2[SequenceMode2[\"loop\"] = 2] = \"loop\";\n  SequenceMode2[SequenceMode2[\"pingpong\"] = 3] = \"pingpong\";\n  SequenceMode2[SequenceMode2[\"onceReverse\"] = 4] = \"onceReverse\";\n  SequenceMode2[SequenceMode2[\"loopReverse\"] = 5] = \"loopReverse\";\n  SequenceMode2[SequenceMode2[\"pingpongReverse\"] = 6] = \"pingpongReverse\";\n  return SequenceMode2;\n})(SequenceMode || {});\nconst SequenceModeValues = [\n  0 /* hold */,\n  1 /* once */,\n  2 /* loop */,\n  3 /* pingpong */,\n  4 /* onceReverse */,\n  5 /* loopReverse */,\n  6 /* pingpongReverse */\n];\n\nexport { Sequence, SequenceMode, SequenceModeValues };\n//# sourceMappingURL=Sequence.mjs.map\n","import { VertexAttachment } from './attachments/Attachment.mjs';\nimport { StringSet, Utils, MixBlend, MixDirection, MathUtils } from '@pixi-spine/base';\nimport './attachments/RegionAttachment.mjs';\nimport { SequenceModeValues, SequenceMode } from './attachments/Sequence.mjs';\n\nclass Animation {\n  constructor(name, timelines, duration) {\n    this.timelines = [];\n    this.timelineIds = new StringSet();\n    if (!name)\n      throw new Error(\"name cannot be null.\");\n    this.name = name;\n    this.setTimelines(timelines);\n    this.duration = duration;\n  }\n  setTimelines(timelines) {\n    if (!timelines)\n      throw new Error(\"timelines cannot be null.\");\n    this.timelines = timelines;\n    this.timelineIds.clear();\n    for (let i = 0; i < timelines.length; i++)\n      this.timelineIds.addAll(timelines[i].getPropertyIds());\n  }\n  hasTimeline(ids) {\n    for (let i = 0; i < ids.length; i++)\n      if (this.timelineIds.contains(ids[i]))\n        return true;\n    return false;\n  }\n  /** Applies all the animation's timelines to the specified skeleton.\n   *\n   * See Timeline {@link Timeline#apply(Skeleton, float, float, Array, float, MixBlend, MixDirection)}.\n   * @param loop If true, the animation repeats after {@link #getDuration()}.\n   * @param events May be null to ignore fired events. */\n  apply(skeleton, lastTime, time, loop, events, alpha, blend, direction) {\n    if (!skeleton)\n      throw new Error(\"skeleton cannot be null.\");\n    if (loop && this.duration != 0) {\n      time %= this.duration;\n      if (lastTime > 0)\n        lastTime %= this.duration;\n    }\n    const timelines = this.timelines;\n    for (let i = 0, n = timelines.length; i < n; i++)\n      timelines[i].apply(skeleton, lastTime, time, events, alpha, blend, direction);\n  }\n}\nconst Property = {\n  rotate: 0,\n  x: 1,\n  y: 2,\n  scaleX: 3,\n  scaleY: 4,\n  shearX: 5,\n  shearY: 6,\n  rgb: 7,\n  alpha: 8,\n  rgb2: 9,\n  attachment: 10,\n  deform: 11,\n  event: 12,\n  drawOrder: 13,\n  ikConstraint: 14,\n  transformConstraint: 15,\n  pathConstraintPosition: 16,\n  pathConstraintSpacing: 17,\n  pathConstraintMix: 18,\n  sequence: 19\n};\nclass Timeline {\n  constructor(frameCount, propertyIds) {\n    this.propertyIds = propertyIds;\n    this.frames = Utils.newFloatArray(frameCount * this.getFrameEntries());\n  }\n  getPropertyIds() {\n    return this.propertyIds;\n  }\n  getFrameEntries() {\n    return 1;\n  }\n  getFrameCount() {\n    return this.frames.length / this.getFrameEntries();\n  }\n  getDuration() {\n    return this.frames[this.frames.length - this.getFrameEntries()];\n  }\n  static search1(frames, time) {\n    const n = frames.length;\n    for (let i = 1; i < n; i++)\n      if (frames[i] > time)\n        return i - 1;\n    return n - 1;\n  }\n  static search(frames, time, step) {\n    const n = frames.length;\n    for (let i = step; i < n; i += step)\n      if (frames[i] > time)\n        return i - step;\n    return n - step;\n  }\n}\nclass CurveTimeline extends Timeline {\n  // type, x, y, ...\n  constructor(frameCount, bezierCount, propertyIds) {\n    super(frameCount, propertyIds);\n    this.curves = Utils.newFloatArray(\n      frameCount + bezierCount * 18\n      /* BEZIER_SIZE*/\n    );\n    this.curves[frameCount - 1] = 1;\n  }\n  /** Sets the specified key frame to linear interpolation. */\n  setLinear(frame) {\n    this.curves[frame] = 0;\n  }\n  /** Sets the specified key frame to stepped interpolation. */\n  setStepped(frame) {\n    this.curves[frame] = 1;\n  }\n  /** Shrinks the storage for Bezier curves, for use when <code>bezierCount</code> (specified in the constructor) was larger\n   * than the actual number of Bezier curves. */\n  shrink(bezierCount) {\n    const size = this.getFrameCount() + bezierCount * 18;\n    if (this.curves.length > size) {\n      const newCurves = Utils.newFloatArray(size);\n      Utils.arrayCopy(this.curves, 0, newCurves, 0, size);\n      this.curves = newCurves;\n    }\n  }\n  /** Stores the segments for the specified Bezier curve. For timelines that modify multiple values, there may be more than\n   * one curve per frame.\n   * @param bezier The ordinal of this Bezier curve for this timeline, between 0 and <code>bezierCount - 1</code> (specified\n   *           in the constructor), inclusive.\n   * @param frame Between 0 and <code>frameCount - 1</code>, inclusive.\n   * @param value The index of the value for this frame that this curve is used for.\n   * @param time1 The time for the first key.\n   * @param value1 The value for the first key.\n   * @param cx1 The time for the first Bezier handle.\n   * @param cy1 The value for the first Bezier handle.\n   * @param cx2 The time of the second Bezier handle.\n   * @param cy2 The value for the second Bezier handle.\n   * @param time2 The time for the second key.\n   * @param value2 The value for the second key. */\n  setBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2) {\n    const curves = this.curves;\n    let i = this.getFrameCount() + bezier * 18;\n    if (value == 0)\n      curves[frame] = 2 + i;\n    const tmpx = (time1 - cx1 * 2 + cx2) * 0.03;\n    const tmpy = (value1 - cy1 * 2 + cy2) * 0.03;\n    const dddx = ((cx1 - cx2) * 3 - time1 + time2) * 6e-3;\n    const dddy = ((cy1 - cy2) * 3 - value1 + value2) * 6e-3;\n    let ddx = tmpx * 2 + dddx;\n    let ddy = tmpy * 2 + dddy;\n    let dx = (cx1 - time1) * 0.3 + tmpx + dddx * 0.16666667;\n    let dy = (cy1 - value1) * 0.3 + tmpy + dddy * 0.16666667;\n    let x = time1 + dx;\n    let y = value1 + dy;\n    for (let n = i + 18; i < n; i += 2) {\n      curves[i] = x;\n      curves[i + 1] = y;\n      dx += ddx;\n      dy += ddy;\n      ddx += dddx;\n      ddy += dddy;\n      x += dx;\n      y += dy;\n    }\n  }\n  /** Returns the Bezier interpolated value for the specified time.\n   * @param frameIndex The index into {@link #getFrames()} for the values of the frame before <code>time</code>.\n   * @param valueOffset The offset from <code>frameIndex</code> to the value this curve is used for.\n   * @param i The index of the Bezier segments. See {@link #getCurveType(int)}. */\n  getBezierValue(time, frameIndex, valueOffset, i) {\n    const curves = this.curves;\n    if (curves[i] > time) {\n      const x2 = this.frames[frameIndex];\n      const y2 = this.frames[frameIndex + valueOffset];\n      return y2 + (time - x2) / (curves[i] - x2) * (curves[i + 1] - y2);\n    }\n    const n = i + 18;\n    for (i += 2; i < n; i += 2) {\n      if (curves[i] >= time) {\n        const x2 = curves[i - 2];\n        const y2 = curves[i - 1];\n        return y2 + (time - x2) / (curves[i] - x2) * (curves[i + 1] - y2);\n      }\n    }\n    frameIndex += this.getFrameEntries();\n    const x = curves[n - 2];\n    const y = curves[n - 1];\n    return y + (time - x) / (this.frames[frameIndex] - x) * (this.frames[frameIndex + valueOffset] - y);\n  }\n}\nclass CurveTimeline1 extends CurveTimeline {\n  constructor(frameCount, bezierCount, propertyId) {\n    super(frameCount, bezierCount, [propertyId]);\n  }\n  getFrameEntries() {\n    return 2;\n  }\n  /** Sets the time and value for the specified frame.\n   * @param frame Between 0 and <code>frameCount</code>, inclusive.\n   * @param time The frame time in seconds. */\n  setFrame(frame, time, value) {\n    frame <<= 1;\n    this.frames[frame] = time;\n    this.frames[\n      frame + 1\n      /* VALUE*/\n    ] = value;\n  }\n  /** Returns the interpolated value for the specified time. */\n  getCurveValue(time) {\n    const frames = this.frames;\n    let i = frames.length - 2;\n    for (let ii = 2; ii <= i; ii += 2) {\n      if (frames[ii] > time) {\n        i = ii - 2;\n        break;\n      }\n    }\n    const curveType = this.curves[i >> 1];\n    switch (curveType) {\n      case 0:\n        const before = frames[i];\n        const value = frames[\n          i + 1\n          /* VALUE*/\n        ];\n        return value + (time - before) / (frames[\n          i + 2\n          /* ENTRIES*/\n        ] - before) * (frames[\n          i + 2 + 1\n          /* VALUE*/\n        ] - value);\n      case 1:\n        return frames[\n          i + 1\n          /* VALUE*/\n        ];\n    }\n    return this.getBezierValue(\n      time,\n      i,\n      1,\n      curveType - 2\n      /* BEZIER*/\n    );\n  }\n}\nclass CurveTimeline2 extends CurveTimeline {\n  /** @param bezierCount The maximum number of Bezier curves. See {@link #shrink(int)}.\n   * @param propertyIds Unique identifiers for the properties the timeline modifies. */\n  constructor(frameCount, bezierCount, propertyId1, propertyId2) {\n    super(frameCount, bezierCount, [propertyId1, propertyId2]);\n  }\n  getFrameEntries() {\n    return 3;\n  }\n  /** Sets the time and values for the specified frame.\n   * @param frame Between 0 and <code>frameCount</code>, inclusive.\n   * @param time The frame time in seconds. */\n  setFrame(frame, time, value1, value2) {\n    frame *= 3;\n    this.frames[frame] = time;\n    this.frames[\n      frame + 1\n      /* VALUE1*/\n    ] = value1;\n    this.frames[\n      frame + 2\n      /* VALUE2*/\n    ] = value2;\n  }\n}\nclass RotateTimeline extends CurveTimeline1 {\n  constructor(frameCount, bezierCount, boneIndex) {\n    super(frameCount, bezierCount, `${Property.rotate}|${boneIndex}`);\n    this.boneIndex = 0;\n    this.boneIndex = boneIndex;\n  }\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    const bone = skeleton.bones[this.boneIndex];\n    if (!bone.active)\n      return;\n    const frames = this.frames;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.rotation = bone.data.rotation;\n          return;\n        case MixBlend.first:\n          bone.rotation += (bone.data.rotation - bone.rotation) * alpha;\n      }\n      return;\n    }\n    let r = this.getCurveValue(time);\n    switch (blend) {\n      case MixBlend.setup:\n        bone.rotation = bone.data.rotation + r * alpha;\n        break;\n      case MixBlend.first:\n      case MixBlend.replace:\n        r += bone.data.rotation - bone.rotation;\n      case MixBlend.add:\n        bone.rotation += r * alpha;\n    }\n  }\n}\nclass TranslateTimeline extends CurveTimeline2 {\n  constructor(frameCount, bezierCount, boneIndex) {\n    super(frameCount, bezierCount, `${Property.x}|${boneIndex}`, `${Property.y}|${boneIndex}`);\n    this.boneIndex = 0;\n    this.boneIndex = boneIndex;\n  }\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    const bone = skeleton.bones[this.boneIndex];\n    if (!bone.active)\n      return;\n    const frames = this.frames;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.x = bone.data.x;\n          bone.y = bone.data.y;\n          return;\n        case MixBlend.first:\n          bone.x += (bone.data.x - bone.x) * alpha;\n          bone.y += (bone.data.y - bone.y) * alpha;\n      }\n      return;\n    }\n    let x = 0;\n    let y = 0;\n    const i = Timeline.search(\n      frames,\n      time,\n      3\n      /* ENTRIES*/\n    );\n    const curveType = this.curves[\n      i / 3\n      /* ENTRIES*/\n    ];\n    switch (curveType) {\n      case 0:\n        const before = frames[i];\n        x = frames[\n          i + 1\n          /* VALUE1*/\n        ];\n        y = frames[\n          i + 2\n          /* VALUE2*/\n        ];\n        const t = (time - before) / (frames[\n          i + 3\n          /* ENTRIES*/\n        ] - before);\n        x += (frames[\n          i + 3 + 1\n          /* VALUE1*/\n        ] - x) * t;\n        y += (frames[\n          i + 3 + 2\n          /* VALUE2*/\n        ] - y) * t;\n        break;\n      case 1:\n        x = frames[\n          i + 1\n          /* VALUE1*/\n        ];\n        y = frames[\n          i + 2\n          /* VALUE2*/\n        ];\n        break;\n      default:\n        x = this.getBezierValue(\n          time,\n          i,\n          1,\n          curveType - 2\n          /* BEZIER*/\n        );\n        y = this.getBezierValue(\n          time,\n          i,\n          2,\n          curveType + 18 - 2\n          /* BEZIER*/\n        );\n    }\n    switch (blend) {\n      case MixBlend.setup:\n        bone.x = bone.data.x + x * alpha;\n        bone.y = bone.data.y + y * alpha;\n        break;\n      case MixBlend.first:\n      case MixBlend.replace:\n        bone.x += (bone.data.x + x - bone.x) * alpha;\n        bone.y += (bone.data.y + y - bone.y) * alpha;\n        break;\n      case MixBlend.add:\n        bone.x += x * alpha;\n        bone.y += y * alpha;\n    }\n  }\n}\nclass TranslateXTimeline extends CurveTimeline1 {\n  constructor(frameCount, bezierCount, boneIndex) {\n    super(frameCount, bezierCount, `${Property.x}|${boneIndex}`);\n    this.boneIndex = 0;\n    this.boneIndex = boneIndex;\n  }\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    const bone = skeleton.bones[this.boneIndex];\n    if (!bone.active)\n      return;\n    const frames = this.frames;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.x = bone.data.x;\n          return;\n        case MixBlend.first:\n          bone.x += (bone.data.x - bone.x) * alpha;\n      }\n      return;\n    }\n    const x = this.getCurveValue(time);\n    switch (blend) {\n      case MixBlend.setup:\n        bone.x = bone.data.x + x * alpha;\n        break;\n      case MixBlend.first:\n      case MixBlend.replace:\n        bone.x += (bone.data.x + x - bone.x) * alpha;\n        break;\n      case MixBlend.add:\n        bone.x += x * alpha;\n    }\n  }\n}\nclass TranslateYTimeline extends CurveTimeline1 {\n  constructor(frameCount, bezierCount, boneIndex) {\n    super(frameCount, bezierCount, `${Property.y}|${boneIndex}`);\n    this.boneIndex = 0;\n    this.boneIndex = boneIndex;\n  }\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    const bone = skeleton.bones[this.boneIndex];\n    if (!bone.active)\n      return;\n    const frames = this.frames;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.y = bone.data.y;\n          return;\n        case MixBlend.first:\n          bone.y += (bone.data.y - bone.y) * alpha;\n      }\n      return;\n    }\n    const y = this.getCurveValue(time);\n    switch (blend) {\n      case MixBlend.setup:\n        bone.y = bone.data.y + y * alpha;\n        break;\n      case MixBlend.first:\n      case MixBlend.replace:\n        bone.y += (bone.data.y + y - bone.y) * alpha;\n        break;\n      case MixBlend.add:\n        bone.y += y * alpha;\n    }\n  }\n}\nclass ScaleTimeline extends CurveTimeline2 {\n  constructor(frameCount, bezierCount, boneIndex) {\n    super(frameCount, bezierCount, `${Property.scaleX}|${boneIndex}`, `${Property.scaleY}|${boneIndex}`);\n    this.boneIndex = 0;\n    this.boneIndex = boneIndex;\n  }\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    const bone = skeleton.bones[this.boneIndex];\n    if (!bone.active)\n      return;\n    const frames = this.frames;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.scaleX = bone.data.scaleX;\n          bone.scaleY = bone.data.scaleY;\n          return;\n        case MixBlend.first:\n          bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;\n          bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;\n      }\n      return;\n    }\n    let x;\n    let y;\n    const i = Timeline.search(\n      frames,\n      time,\n      3\n      /* ENTRIES*/\n    );\n    const curveType = this.curves[\n      i / 3\n      /* ENTRIES*/\n    ];\n    switch (curveType) {\n      case 0:\n        const before = frames[i];\n        x = frames[\n          i + 1\n          /* VALUE1*/\n        ];\n        y = frames[\n          i + 2\n          /* VALUE2*/\n        ];\n        const t = (time - before) / (frames[\n          i + 3\n          /* ENTRIES*/\n        ] - before);\n        x += (frames[\n          i + 3 + 1\n          /* VALUE1*/\n        ] - x) * t;\n        y += (frames[\n          i + 3 + 2\n          /* VALUE2*/\n        ] - y) * t;\n        break;\n      case 1:\n        x = frames[\n          i + 1\n          /* VALUE1*/\n        ];\n        y = frames[\n          i + 2\n          /* VALUE2*/\n        ];\n        break;\n      default:\n        x = this.getBezierValue(\n          time,\n          i,\n          1,\n          curveType - 2\n          /* BEZIER*/\n        );\n        y = this.getBezierValue(\n          time,\n          i,\n          2,\n          curveType + 18 - 2\n          /* BEZIER*/\n        );\n    }\n    x *= bone.data.scaleX;\n    y *= bone.data.scaleY;\n    if (alpha == 1) {\n      if (blend == MixBlend.add) {\n        bone.scaleX += x - bone.data.scaleX;\n        bone.scaleY += y - bone.data.scaleY;\n      } else {\n        bone.scaleX = x;\n        bone.scaleY = y;\n      }\n    } else {\n      let bx = 0;\n      let by = 0;\n      if (direction == MixDirection.mixOut) {\n        switch (blend) {\n          case MixBlend.setup:\n            bx = bone.data.scaleX;\n            by = bone.data.scaleY;\n            bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\n            bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\n            break;\n          case MixBlend.first:\n          case MixBlend.replace:\n            bx = bone.scaleX;\n            by = bone.scaleY;\n            bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\n            bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\n            break;\n          case MixBlend.add:\n            bone.scaleX += (x - bone.data.scaleX) * alpha;\n            bone.scaleY += (y - bone.data.scaleY) * alpha;\n        }\n      } else {\n        switch (blend) {\n          case MixBlend.setup:\n            bx = Math.abs(bone.data.scaleX) * MathUtils.signum(x);\n            by = Math.abs(bone.data.scaleY) * MathUtils.signum(y);\n            bone.scaleX = bx + (x - bx) * alpha;\n            bone.scaleY = by + (y - by) * alpha;\n            break;\n          case MixBlend.first:\n          case MixBlend.replace:\n            bx = Math.abs(bone.scaleX) * MathUtils.signum(x);\n            by = Math.abs(bone.scaleY) * MathUtils.signum(y);\n            bone.scaleX = bx + (x - bx) * alpha;\n            bone.scaleY = by + (y - by) * alpha;\n            break;\n          case MixBlend.add:\n            bone.scaleX += (x - bone.data.scaleX) * alpha;\n            bone.scaleY += (y - bone.data.scaleY) * alpha;\n        }\n      }\n    }\n  }\n}\nclass ScaleXTimeline extends CurveTimeline1 {\n  constructor(frameCount, bezierCount, boneIndex) {\n    super(frameCount, bezierCount, `${Property.scaleX}|${boneIndex}`);\n    this.boneIndex = 0;\n    this.boneIndex = boneIndex;\n  }\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    const bone = skeleton.bones[this.boneIndex];\n    if (!bone.active)\n      return;\n    const frames = this.frames;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.scaleX = bone.data.scaleX;\n          return;\n        case MixBlend.first:\n          bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;\n      }\n      return;\n    }\n    const x = this.getCurveValue(time) * bone.data.scaleX;\n    if (alpha == 1) {\n      if (blend == MixBlend.add)\n        bone.scaleX += x - bone.data.scaleX;\n      else\n        bone.scaleX = x;\n    } else {\n      let bx = 0;\n      if (direction == MixDirection.mixOut) {\n        switch (blend) {\n          case MixBlend.setup:\n            bx = bone.data.scaleX;\n            bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\n            break;\n          case MixBlend.first:\n          case MixBlend.replace:\n            bx = bone.scaleX;\n            bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\n            break;\n          case MixBlend.add:\n            bone.scaleX += (x - bone.data.scaleX) * alpha;\n        }\n      } else {\n        switch (blend) {\n          case MixBlend.setup:\n            bx = Math.abs(bone.data.scaleX) * MathUtils.signum(x);\n            bone.scaleX = bx + (x - bx) * alpha;\n            break;\n          case MixBlend.first:\n          case MixBlend.replace:\n            bx = Math.abs(bone.scaleX) * MathUtils.signum(x);\n            bone.scaleX = bx + (x - bx) * alpha;\n            break;\n          case MixBlend.add:\n            bone.scaleX += (x - bone.data.scaleX) * alpha;\n        }\n      }\n    }\n  }\n}\nclass ScaleYTimeline extends CurveTimeline1 {\n  constructor(frameCount, bezierCount, boneIndex) {\n    super(frameCount, bezierCount, `${Property.scaleY}|${boneIndex}`);\n    this.boneIndex = 0;\n    this.boneIndex = boneIndex;\n  }\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    const bone = skeleton.bones[this.boneIndex];\n    if (!bone.active)\n      return;\n    const frames = this.frames;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.scaleY = bone.data.scaleY;\n          return;\n        case MixBlend.first:\n          bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;\n      }\n      return;\n    }\n    const y = this.getCurveValue(time) * bone.data.scaleY;\n    if (alpha == 1) {\n      if (blend == MixBlend.add)\n        bone.scaleY += y - bone.data.scaleY;\n      else\n        bone.scaleY = y;\n    } else {\n      let by = 0;\n      if (direction == MixDirection.mixOut) {\n        switch (blend) {\n          case MixBlend.setup:\n            by = bone.data.scaleY;\n            bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\n            break;\n          case MixBlend.first:\n          case MixBlend.replace:\n            by = bone.scaleY;\n            bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\n            break;\n          case MixBlend.add:\n            bone.scaleY += (y - bone.data.scaleY) * alpha;\n        }\n      } else {\n        switch (blend) {\n          case MixBlend.setup:\n            by = Math.abs(bone.data.scaleY) * MathUtils.signum(y);\n            bone.scaleY = by + (y - by) * alpha;\n            break;\n          case MixBlend.first:\n          case MixBlend.replace:\n            by = Math.abs(bone.scaleY) * MathUtils.signum(y);\n            bone.scaleY = by + (y - by) * alpha;\n            break;\n          case MixBlend.add:\n            bone.scaleY += (y - bone.data.scaleY) * alpha;\n        }\n      }\n    }\n  }\n}\nclass ShearTimeline extends CurveTimeline2 {\n  constructor(frameCount, bezierCount, boneIndex) {\n    super(frameCount, bezierCount, `${Property.shearX}|${boneIndex}`, `${Property.shearY}|${boneIndex}`);\n    this.boneIndex = 0;\n    this.boneIndex = boneIndex;\n  }\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    const bone = skeleton.bones[this.boneIndex];\n    if (!bone.active)\n      return;\n    const frames = this.frames;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.shearX = bone.data.shearX;\n          bone.shearY = bone.data.shearY;\n          return;\n        case MixBlend.first:\n          bone.shearX += (bone.data.shearX - bone.shearX) * alpha;\n          bone.shearY += (bone.data.shearY - bone.shearY) * alpha;\n      }\n      return;\n    }\n    let x = 0;\n    let y = 0;\n    const i = Timeline.search(\n      frames,\n      time,\n      3\n      /* ENTRIES*/\n    );\n    const curveType = this.curves[\n      i / 3\n      /* ENTRIES*/\n    ];\n    switch (curveType) {\n      case 0:\n        const before = frames[i];\n        x = frames[\n          i + 1\n          /* VALUE1*/\n        ];\n        y = frames[\n          i + 2\n          /* VALUE2*/\n        ];\n        const t = (time - before) / (frames[\n          i + 3\n          /* ENTRIES*/\n        ] - before);\n        x += (frames[\n          i + 3 + 1\n          /* VALUE1*/\n        ] - x) * t;\n        y += (frames[\n          i + 3 + 2\n          /* VALUE2*/\n        ] - y) * t;\n        break;\n      case 1:\n        x = frames[\n          i + 1\n          /* VALUE1*/\n        ];\n        y = frames[\n          i + 2\n          /* VALUE2*/\n        ];\n        break;\n      default:\n        x = this.getBezierValue(\n          time,\n          i,\n          1,\n          curveType - 2\n          /* BEZIER*/\n        );\n        y = this.getBezierValue(\n          time,\n          i,\n          2,\n          curveType + 18 - 2\n          /* BEZIER*/\n        );\n    }\n    switch (blend) {\n      case MixBlend.setup:\n        bone.shearX = bone.data.shearX + x * alpha;\n        bone.shearY = bone.data.shearY + y * alpha;\n        break;\n      case MixBlend.first:\n      case MixBlend.replace:\n        bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;\n        bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;\n        break;\n      case MixBlend.add:\n        bone.shearX += x * alpha;\n        bone.shearY += y * alpha;\n    }\n  }\n}\nclass ShearXTimeline extends CurveTimeline1 {\n  constructor(frameCount, bezierCount, boneIndex) {\n    super(frameCount, bezierCount, `${Property.shearX}|${boneIndex}`);\n    this.boneIndex = 0;\n    this.boneIndex = boneIndex;\n  }\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    const bone = skeleton.bones[this.boneIndex];\n    if (!bone.active)\n      return;\n    const frames = this.frames;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.shearX = bone.data.shearX;\n          return;\n        case MixBlend.first:\n          bone.shearX += (bone.data.shearX - bone.shearX) * alpha;\n      }\n      return;\n    }\n    const x = this.getCurveValue(time);\n    switch (blend) {\n      case MixBlend.setup:\n        bone.shearX = bone.data.shearX + x * alpha;\n        break;\n      case MixBlend.first:\n      case MixBlend.replace:\n        bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;\n        break;\n      case MixBlend.add:\n        bone.shearX += x * alpha;\n    }\n  }\n}\nclass ShearYTimeline extends CurveTimeline1 {\n  constructor(frameCount, bezierCount, boneIndex) {\n    super(frameCount, bezierCount, `${Property.shearY}|${boneIndex}`);\n    this.boneIndex = 0;\n    this.boneIndex = boneIndex;\n  }\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    const bone = skeleton.bones[this.boneIndex];\n    if (!bone.active)\n      return;\n    const frames = this.frames;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.shearY = bone.data.shearY;\n          return;\n        case MixBlend.first:\n          bone.shearY += (bone.data.shearY - bone.shearY) * alpha;\n      }\n      return;\n    }\n    const y = this.getCurveValue(time);\n    switch (blend) {\n      case MixBlend.setup:\n        bone.shearY = bone.data.shearY + y * alpha;\n        break;\n      case MixBlend.first:\n      case MixBlend.replace:\n        bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;\n        break;\n      case MixBlend.add:\n        bone.shearY += y * alpha;\n    }\n  }\n}\nclass RGBATimeline extends CurveTimeline {\n  constructor(frameCount, bezierCount, slotIndex) {\n    super(frameCount, bezierCount, [`${Property.rgb}|${slotIndex}`, `${Property.alpha}|${slotIndex}`]);\n    this.slotIndex = 0;\n    this.slotIndex = slotIndex;\n  }\n  getFrameEntries() {\n    return 5;\n  }\n  /** Sets the time in seconds, red, green, blue, and alpha for the specified key frame. */\n  setFrame(frame, time, r, g, b, a) {\n    frame *= 5;\n    this.frames[frame] = time;\n    this.frames[\n      frame + 1\n      /* R*/\n    ] = r;\n    this.frames[\n      frame + 2\n      /* G*/\n    ] = g;\n    this.frames[\n      frame + 3\n      /* B*/\n    ] = b;\n    this.frames[\n      frame + 4\n      /* A*/\n    ] = a;\n  }\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    const slot = skeleton.slots[this.slotIndex];\n    if (!slot.bone.active)\n      return;\n    const frames = this.frames;\n    const color = slot.color;\n    if (time < frames[0]) {\n      const setup = slot.data.color;\n      switch (blend) {\n        case MixBlend.setup:\n          color.setFromColor(setup);\n          return;\n        case MixBlend.first:\n          color.add((setup.r - color.r) * alpha, (setup.g - color.g) * alpha, (setup.b - color.b) * alpha, (setup.a - color.a) * alpha);\n      }\n      return;\n    }\n    let r = 0;\n    let g = 0;\n    let b = 0;\n    let a = 0;\n    const i = Timeline.search(\n      frames,\n      time,\n      5\n      /* ENTRIES*/\n    );\n    const curveType = this.curves[\n      i / 5\n      /* ENTRIES*/\n    ];\n    switch (curveType) {\n      case 0:\n        const before = frames[i];\n        r = frames[\n          i + 1\n          /* R*/\n        ];\n        g = frames[\n          i + 2\n          /* G*/\n        ];\n        b = frames[\n          i + 3\n          /* B*/\n        ];\n        a = frames[\n          i + 4\n          /* A*/\n        ];\n        const t = (time - before) / (frames[\n          i + 5\n          /* ENTRIES*/\n        ] - before);\n        r += (frames[\n          i + 5 + 1\n          /* R*/\n        ] - r) * t;\n        g += (frames[\n          i + 5 + 2\n          /* G*/\n        ] - g) * t;\n        b += (frames[\n          i + 5 + 3\n          /* B*/\n        ] - b) * t;\n        a += (frames[\n          i + 5 + 4\n          /* A*/\n        ] - a) * t;\n        break;\n      case 1:\n        r = frames[\n          i + 1\n          /* R*/\n        ];\n        g = frames[\n          i + 2\n          /* G*/\n        ];\n        b = frames[\n          i + 3\n          /* B*/\n        ];\n        a = frames[\n          i + 4\n          /* A*/\n        ];\n        break;\n      default:\n        r = this.getBezierValue(\n          time,\n          i,\n          1,\n          curveType - 2\n          /* BEZIER*/\n        );\n        g = this.getBezierValue(\n          time,\n          i,\n          2,\n          curveType + 18 - 2\n          /* BEZIER*/\n        );\n        b = this.getBezierValue(\n          time,\n          i,\n          3,\n          curveType + 18 * 2 - 2\n          /* BEZIER*/\n        );\n        a = this.getBezierValue(\n          time,\n          i,\n          4,\n          curveType + 18 * 3 - 2\n          /* BEZIER*/\n        );\n    }\n    if (alpha == 1)\n      color.set(r, g, b, a);\n    else {\n      if (blend == MixBlend.setup)\n        color.setFromColor(slot.data.color);\n      color.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);\n    }\n  }\n}\nclass RGBTimeline extends CurveTimeline {\n  constructor(frameCount, bezierCount, slotIndex) {\n    super(frameCount, bezierCount, [`${Property.rgb}|${slotIndex}`]);\n    this.slotIndex = 0;\n    this.slotIndex = slotIndex;\n  }\n  getFrameEntries() {\n    return 4;\n  }\n  /** Sets the time in seconds, red, green, blue, and alpha for the specified key frame. */\n  setFrame(frame, time, r, g, b) {\n    frame <<= 2;\n    this.frames[frame] = time;\n    this.frames[\n      frame + 1\n      /* R*/\n    ] = r;\n    this.frames[\n      frame + 2\n      /* G*/\n    ] = g;\n    this.frames[\n      frame + 3\n      /* B*/\n    ] = b;\n  }\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    const slot = skeleton.slots[this.slotIndex];\n    if (!slot.bone.active)\n      return;\n    const frames = this.frames;\n    const color = slot.color;\n    if (time < frames[0]) {\n      const setup = slot.data.color;\n      switch (blend) {\n        case MixBlend.setup:\n          color.r = setup.r;\n          color.g = setup.g;\n          color.b = setup.b;\n          return;\n        case MixBlend.first:\n          color.r += (setup.r - color.r) * alpha;\n          color.g += (setup.g - color.g) * alpha;\n          color.b += (setup.b - color.b) * alpha;\n      }\n      return;\n    }\n    let r = 0;\n    let g = 0;\n    let b = 0;\n    const i = Timeline.search(\n      frames,\n      time,\n      4\n      /* ENTRIES*/\n    );\n    const curveType = this.curves[i >> 2];\n    switch (curveType) {\n      case 0:\n        const before = frames[i];\n        r = frames[\n          i + 1\n          /* R*/\n        ];\n        g = frames[\n          i + 2\n          /* G*/\n        ];\n        b = frames[\n          i + 3\n          /* B*/\n        ];\n        const t = (time - before) / (frames[\n          i + 4\n          /* ENTRIES*/\n        ] - before);\n        r += (frames[\n          i + 4 + 1\n          /* R*/\n        ] - r) * t;\n        g += (frames[\n          i + 4 + 2\n          /* G*/\n        ] - g) * t;\n        b += (frames[\n          i + 4 + 3\n          /* B*/\n        ] - b) * t;\n        break;\n      case 1:\n        r = frames[\n          i + 1\n          /* R*/\n        ];\n        g = frames[\n          i + 2\n          /* G*/\n        ];\n        b = frames[\n          i + 3\n          /* B*/\n        ];\n        break;\n      default:\n        r = this.getBezierValue(\n          time,\n          i,\n          1,\n          curveType - 2\n          /* BEZIER*/\n        );\n        g = this.getBezierValue(\n          time,\n          i,\n          2,\n          curveType + 18 - 2\n          /* BEZIER*/\n        );\n        b = this.getBezierValue(\n          time,\n          i,\n          3,\n          curveType + 18 * 2 - 2\n          /* BEZIER*/\n        );\n    }\n    if (alpha == 1) {\n      color.r = r;\n      color.g = g;\n      color.b = b;\n    } else {\n      if (blend == MixBlend.setup) {\n        const setup = slot.data.color;\n        color.r = setup.r;\n        color.g = setup.g;\n        color.b = setup.b;\n      }\n      color.r += (r - color.r) * alpha;\n      color.g += (g - color.g) * alpha;\n      color.b += (b - color.b) * alpha;\n    }\n  }\n}\nclass AlphaTimeline extends CurveTimeline1 {\n  constructor(frameCount, bezierCount, slotIndex) {\n    super(frameCount, bezierCount, `${Property.alpha}|${slotIndex}`);\n    this.slotIndex = 0;\n    this.slotIndex = slotIndex;\n  }\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    const slot = skeleton.slots[this.slotIndex];\n    if (!slot.bone.active)\n      return;\n    const color = slot.color;\n    if (time < this.frames[0]) {\n      const setup = slot.data.color;\n      switch (blend) {\n        case MixBlend.setup:\n          color.a = setup.a;\n          return;\n        case MixBlend.first:\n          color.a += (setup.a - color.a) * alpha;\n      }\n      return;\n    }\n    const a = this.getCurveValue(time);\n    if (alpha == 1)\n      color.a = a;\n    else {\n      if (blend == MixBlend.setup)\n        color.a = slot.data.color.a;\n      color.a += (a - color.a) * alpha;\n    }\n  }\n}\nclass RGBA2Timeline extends CurveTimeline {\n  constructor(frameCount, bezierCount, slotIndex) {\n    super(frameCount, bezierCount, [`${Property.rgb}|${slotIndex}`, `${Property.alpha}|${slotIndex}`, `${Property.rgb2}|${slotIndex}`]);\n    this.slotIndex = 0;\n    this.slotIndex = slotIndex;\n  }\n  getFrameEntries() {\n    return 8;\n  }\n  /** Sets the time in seconds, light, and dark colors for the specified key frame. */\n  setFrame(frame, time, r, g, b, a, r2, g2, b2) {\n    frame <<= 3;\n    this.frames[frame] = time;\n    this.frames[\n      frame + 1\n      /* R*/\n    ] = r;\n    this.frames[\n      frame + 2\n      /* G*/\n    ] = g;\n    this.frames[\n      frame + 3\n      /* B*/\n    ] = b;\n    this.frames[\n      frame + 4\n      /* A*/\n    ] = a;\n    this.frames[\n      frame + 5\n      /* R2*/\n    ] = r2;\n    this.frames[\n      frame + 6\n      /* G2*/\n    ] = g2;\n    this.frames[\n      frame + 7\n      /* B2*/\n    ] = b2;\n  }\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    const slot = skeleton.slots[this.slotIndex];\n    if (!slot.bone.active)\n      return;\n    const frames = this.frames;\n    const light = slot.color;\n    const dark = slot.darkColor;\n    if (time < frames[0]) {\n      const setupLight = slot.data.color;\n      const setupDark = slot.data.darkColor;\n      switch (blend) {\n        case MixBlend.setup:\n          light.setFromColor(setupLight);\n          dark.r = setupDark.r;\n          dark.g = setupDark.g;\n          dark.b = setupDark.b;\n          return;\n        case MixBlend.first:\n          light.add((setupLight.r - light.r) * alpha, (setupLight.g - light.g) * alpha, (setupLight.b - light.b) * alpha, (setupLight.a - light.a) * alpha);\n          dark.r += (setupDark.r - dark.r) * alpha;\n          dark.g += (setupDark.g - dark.g) * alpha;\n          dark.b += (setupDark.b - dark.b) * alpha;\n      }\n      return;\n    }\n    let r = 0;\n    let g = 0;\n    let b = 0;\n    let a = 0;\n    let r2 = 0;\n    let g2 = 0;\n    let b2 = 0;\n    const i = Timeline.search(\n      frames,\n      time,\n      8\n      /* ENTRIES*/\n    );\n    const curveType = this.curves[i >> 3];\n    switch (curveType) {\n      case 0:\n        const before = frames[i];\n        r = frames[\n          i + 1\n          /* R*/\n        ];\n        g = frames[\n          i + 2\n          /* G*/\n        ];\n        b = frames[\n          i + 3\n          /* B*/\n        ];\n        a = frames[\n          i + 4\n          /* A*/\n        ];\n        r2 = frames[\n          i + 5\n          /* R2*/\n        ];\n        g2 = frames[\n          i + 6\n          /* G2*/\n        ];\n        b2 = frames[\n          i + 7\n          /* B2*/\n        ];\n        const t = (time - before) / (frames[\n          i + 8\n          /* ENTRIES*/\n        ] - before);\n        r += (frames[\n          i + 8 + 1\n          /* R*/\n        ] - r) * t;\n        g += (frames[\n          i + 8 + 2\n          /* G*/\n        ] - g) * t;\n        b += (frames[\n          i + 8 + 3\n          /* B*/\n        ] - b) * t;\n        a += (frames[\n          i + 8 + 4\n          /* A*/\n        ] - a) * t;\n        r2 += (frames[\n          i + 8 + 5\n          /* R2*/\n        ] - r2) * t;\n        g2 += (frames[\n          i + 8 + 6\n          /* G2*/\n        ] - g2) * t;\n        b2 += (frames[\n          i + 8 + 7\n          /* B2*/\n        ] - b2) * t;\n        break;\n      case 1:\n        r = frames[\n          i + 1\n          /* R*/\n        ];\n        g = frames[\n          i + 2\n          /* G*/\n        ];\n        b = frames[\n          i + 3\n          /* B*/\n        ];\n        a = frames[\n          i + 4\n          /* A*/\n        ];\n        r2 = frames[\n          i + 5\n          /* R2*/\n        ];\n        g2 = frames[\n          i + 6\n          /* G2*/\n        ];\n        b2 = frames[\n          i + 7\n          /* B2*/\n        ];\n        break;\n      default:\n        r = this.getBezierValue(\n          time,\n          i,\n          1,\n          curveType - 2\n          /* BEZIER*/\n        );\n        g = this.getBezierValue(\n          time,\n          i,\n          2,\n          curveType + 18 - 2\n          /* BEZIER*/\n        );\n        b = this.getBezierValue(\n          time,\n          i,\n          3,\n          curveType + 18 * 2 - 2\n          /* BEZIER*/\n        );\n        a = this.getBezierValue(\n          time,\n          i,\n          4,\n          curveType + 18 * 3 - 2\n          /* BEZIER*/\n        );\n        r2 = this.getBezierValue(\n          time,\n          i,\n          5,\n          curveType + 18 * 4 - 2\n          /* BEZIER*/\n        );\n        g2 = this.getBezierValue(\n          time,\n          i,\n          6,\n          curveType + 18 * 5 - 2\n          /* BEZIER*/\n        );\n        b2 = this.getBezierValue(\n          time,\n          i,\n          7,\n          curveType + 18 * 6 - 2\n          /* BEZIER*/\n        );\n    }\n    if (alpha == 1) {\n      light.set(r, g, b, a);\n      dark.r = r2;\n      dark.g = g2;\n      dark.b = b2;\n    } else {\n      if (blend == MixBlend.setup) {\n        light.setFromColor(slot.data.color);\n        const setupDark = slot.data.darkColor;\n        dark.r = setupDark.r;\n        dark.g = setupDark.g;\n        dark.b = setupDark.b;\n      }\n      light.add((r - light.r) * alpha, (g - light.g) * alpha, (b - light.b) * alpha, (a - light.a) * alpha);\n      dark.r += (r2 - dark.r) * alpha;\n      dark.g += (g2 - dark.g) * alpha;\n      dark.b += (b2 - dark.b) * alpha;\n    }\n  }\n}\nclass RGB2Timeline extends CurveTimeline {\n  constructor(frameCount, bezierCount, slotIndex) {\n    super(frameCount, bezierCount, [`${Property.rgb}|${slotIndex}`, `${Property.rgb2}|${slotIndex}`]);\n    this.slotIndex = 0;\n    this.slotIndex = slotIndex;\n  }\n  getFrameEntries() {\n    return 7;\n  }\n  /** Sets the time in seconds, light, and dark colors for the specified key frame. */\n  setFrame(frame, time, r, g, b, r2, g2, b2) {\n    frame *= 7;\n    this.frames[frame] = time;\n    this.frames[\n      frame + 1\n      /* R*/\n    ] = r;\n    this.frames[\n      frame + 2\n      /* G*/\n    ] = g;\n    this.frames[\n      frame + 3\n      /* B*/\n    ] = b;\n    this.frames[\n      frame + 4\n      /* R2*/\n    ] = r2;\n    this.frames[\n      frame + 5\n      /* G2*/\n    ] = g2;\n    this.frames[\n      frame + 6\n      /* B2*/\n    ] = b2;\n  }\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    const slot = skeleton.slots[this.slotIndex];\n    if (!slot.bone.active)\n      return;\n    const frames = this.frames;\n    const light = slot.color;\n    const dark = slot.darkColor;\n    if (time < frames[0]) {\n      const setupLight = slot.data.color;\n      const setupDark = slot.data.darkColor;\n      switch (blend) {\n        case MixBlend.setup:\n          light.r = setupLight.r;\n          light.g = setupLight.g;\n          light.b = setupLight.b;\n          dark.r = setupDark.r;\n          dark.g = setupDark.g;\n          dark.b = setupDark.b;\n          return;\n        case MixBlend.first:\n          light.r += (setupLight.r - light.r) * alpha;\n          light.g += (setupLight.g - light.g) * alpha;\n          light.b += (setupLight.b - light.b) * alpha;\n          dark.r += (setupDark.r - dark.r) * alpha;\n          dark.g += (setupDark.g - dark.g) * alpha;\n          dark.b += (setupDark.b - dark.b) * alpha;\n      }\n      return;\n    }\n    let r = 0;\n    let g = 0;\n    let b = 0;\n    let r2 = 0;\n    let g2 = 0;\n    let b2 = 0;\n    const i = Timeline.search(\n      frames,\n      time,\n      7\n      /* ENTRIES*/\n    );\n    const curveType = this.curves[\n      i / 7\n      /* ENTRIES*/\n    ];\n    switch (curveType) {\n      case 0:\n        const before = frames[i];\n        r = frames[\n          i + 1\n          /* R*/\n        ];\n        g = frames[\n          i + 2\n          /* G*/\n        ];\n        b = frames[\n          i + 3\n          /* B*/\n        ];\n        r2 = frames[\n          i + 4\n          /* R2*/\n        ];\n        g2 = frames[\n          i + 5\n          /* G2*/\n        ];\n        b2 = frames[\n          i + 6\n          /* B2*/\n        ];\n        const t = (time - before) / (frames[\n          i + 7\n          /* ENTRIES*/\n        ] - before);\n        r += (frames[\n          i + 7 + 1\n          /* R*/\n        ] - r) * t;\n        g += (frames[\n          i + 7 + 2\n          /* G*/\n        ] - g) * t;\n        b += (frames[\n          i + 7 + 3\n          /* B*/\n        ] - b) * t;\n        r2 += (frames[\n          i + 7 + 4\n          /* R2*/\n        ] - r2) * t;\n        g2 += (frames[\n          i + 7 + 5\n          /* G2*/\n        ] - g2) * t;\n        b2 += (frames[\n          i + 7 + 6\n          /* B2*/\n        ] - b2) * t;\n        break;\n      case 1:\n        r = frames[\n          i + 1\n          /* R*/\n        ];\n        g = frames[\n          i + 2\n          /* G*/\n        ];\n        b = frames[\n          i + 3\n          /* B*/\n        ];\n        r2 = frames[\n          i + 4\n          /* R2*/\n        ];\n        g2 = frames[\n          i + 5\n          /* G2*/\n        ];\n        b2 = frames[\n          i + 6\n          /* B2*/\n        ];\n        break;\n      default:\n        r = this.getBezierValue(\n          time,\n          i,\n          1,\n          curveType - 2\n          /* BEZIER*/\n        );\n        g = this.getBezierValue(\n          time,\n          i,\n          2,\n          curveType + 18 - 2\n          /* BEZIER*/\n        );\n        b = this.getBezierValue(\n          time,\n          i,\n          3,\n          curveType + 18 * 2 - 2\n          /* BEZIER*/\n        );\n        r2 = this.getBezierValue(\n          time,\n          i,\n          4,\n          curveType + 18 * 3 - 2\n          /* BEZIER*/\n        );\n        g2 = this.getBezierValue(\n          time,\n          i,\n          5,\n          curveType + 18 * 4 - 2\n          /* BEZIER*/\n        );\n        b2 = this.getBezierValue(\n          time,\n          i,\n          6,\n          curveType + 18 * 5 - 2\n          /* BEZIER*/\n        );\n    }\n    if (alpha == 1) {\n      light.r = r;\n      light.g = g;\n      light.b = b;\n      dark.r = r2;\n      dark.g = g2;\n      dark.b = b2;\n    } else {\n      if (blend == MixBlend.setup) {\n        const setupLight = slot.data.color;\n        const setupDark = slot.data.darkColor;\n        light.r = setupLight.r;\n        light.g = setupLight.g;\n        light.b = setupLight.b;\n        dark.r = setupDark.r;\n        dark.g = setupDark.g;\n        dark.b = setupDark.b;\n      }\n      light.r += (r - light.r) * alpha;\n      light.g += (g - light.g) * alpha;\n      light.b += (b - light.b) * alpha;\n      dark.r += (r2 - dark.r) * alpha;\n      dark.g += (g2 - dark.g) * alpha;\n      dark.b += (b2 - dark.b) * alpha;\n    }\n  }\n}\nclass AttachmentTimeline extends Timeline {\n  constructor(frameCount, slotIndex) {\n    super(frameCount, [`${Property.attachment}|${slotIndex}`]);\n    this.slotIndex = 0;\n    this.slotIndex = slotIndex;\n    this.attachmentNames = new Array(frameCount);\n  }\n  getFrameCount() {\n    return this.frames.length;\n  }\n  /** Sets the time in seconds and the attachment name for the specified key frame. */\n  setFrame(frame, time, attachmentName) {\n    this.frames[frame] = time;\n    this.attachmentNames[frame] = attachmentName;\n  }\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    const slot = skeleton.slots[this.slotIndex];\n    if (!slot.bone.active)\n      return;\n    if (direction == MixDirection.mixOut) {\n      if (blend == MixBlend.setup)\n        this.setAttachment(skeleton, slot, slot.data.attachmentName);\n      return;\n    }\n    if (time < this.frames[0]) {\n      if (blend == MixBlend.setup || blend == MixBlend.first)\n        this.setAttachment(skeleton, slot, slot.data.attachmentName);\n      return;\n    }\n    this.setAttachment(skeleton, slot, this.attachmentNames[Timeline.search1(this.frames, time)]);\n  }\n  setAttachment(skeleton, slot, attachmentName) {\n    slot.setAttachment(!attachmentName ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\n  }\n}\nclass DeformTimeline extends CurveTimeline {\n  constructor(frameCount, bezierCount, slotIndex, attachment) {\n    super(frameCount, bezierCount, [`${Property.deform}|${slotIndex}|${attachment.id}`]);\n    this.slotIndex = 0;\n    this.slotIndex = slotIndex;\n    this.attachment = attachment;\n    this.vertices = new Array(frameCount);\n  }\n  getFrameCount() {\n    return this.frames.length;\n  }\n  /** Sets the time in seconds and the vertices for the specified key frame.\n   * @param vertices Vertex positions for an unweighted VertexAttachment, or deform offsets if it has weights. */\n  setFrame(frame, time, vertices) {\n    this.frames[frame] = time;\n    this.vertices[frame] = vertices;\n  }\n  /** @param value1 Ignored (0 is used for a deform timeline).\n   * @param value2 Ignored (1 is used for a deform timeline). */\n  setBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2) {\n    const curves = this.curves;\n    let i = this.getFrameCount() + bezier * 18;\n    if (value == 0)\n      curves[frame] = 2 + i;\n    const tmpx = (time1 - cx1 * 2 + cx2) * 0.03;\n    const tmpy = cy2 * 0.03 - cy1 * 0.06;\n    const dddx = ((cx1 - cx2) * 3 - time1 + time2) * 6e-3;\n    const dddy = (cy1 - cy2 + 0.33333333) * 0.018;\n    let ddx = tmpx * 2 + dddx;\n    let ddy = tmpy * 2 + dddy;\n    let dx = (cx1 - time1) * 0.3 + tmpx + dddx * 0.16666667;\n    let dy = cy1 * 0.3 + tmpy + dddy * 0.16666667;\n    let x = time1 + dx;\n    let y = dy;\n    for (let n = i + 18; i < n; i += 2) {\n      curves[i] = x;\n      curves[i + 1] = y;\n      dx += ddx;\n      dy += ddy;\n      ddx += dddx;\n      ddy += dddy;\n      x += dx;\n      y += dy;\n    }\n  }\n  getCurvePercent(time, frame) {\n    const curves = this.curves;\n    let i = curves[frame];\n    switch (i) {\n      case 0:\n        const x2 = this.frames[frame];\n        return (time - x2) / (this.frames[frame + this.getFrameEntries()] - x2);\n      case 1:\n        return 0;\n    }\n    i -= 2;\n    if (curves[i] > time) {\n      const x2 = this.frames[frame];\n      return curves[i + 1] * (time - x2) / (curves[i] - x2);\n    }\n    const n = i + 18;\n    for (i += 2; i < n; i += 2) {\n      if (curves[i] >= time) {\n        const x2 = curves[i - 2];\n        const y2 = curves[i - 1];\n        return y2 + (time - x2) / (curves[i] - x2) * (curves[i + 1] - y2);\n      }\n    }\n    const x = curves[n - 2];\n    const y = curves[n - 1];\n    return y + (1 - y) * (time - x) / (this.frames[frame + this.getFrameEntries()] - x);\n  }\n  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n    const slot = skeleton.slots[this.slotIndex];\n    if (!slot.bone.active)\n      return;\n    const slotAttachment = slot.getAttachment();\n    if (!slotAttachment)\n      return;\n    if (!(slotAttachment instanceof VertexAttachment) || slotAttachment.timelineAttachment != this.attachment)\n      return;\n    const deform = slot.deform;\n    if (deform.length == 0)\n      blend = MixBlend.setup;\n    const vertices = this.vertices;\n    const vertexCount = vertices[0].length;\n    const frames = this.frames;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          deform.length = 0;\n          return;\n        case MixBlend.first:\n          if (alpha == 1) {\n            deform.length = 0;\n            return;\n          }\n          deform.length = vertexCount;\n          const vertexAttachment = slotAttachment;\n          if (!vertexAttachment.bones) {\n            const setupVertices = vertexAttachment.vertices;\n            for (let i = 0; i < vertexCount; i++)\n              deform[i] += (setupVertices[i] - deform[i]) * alpha;\n          } else {\n            alpha = 1 - alpha;\n            for (let i = 0; i < vertexCount; i++)\n              deform[i] *= alpha;\n          }\n      }\n      return;\n    }\n    deform.length = vertexCount;\n    if (time >= frames[frames.length - 1]) {\n      const lastVertices = vertices[frames.length - 1];\n      if (alpha == 1) {\n        if (blend == MixBlend.add) {\n          const vertexAttachment = slotAttachment;\n          if (!vertexAttachment.bones) {\n            const setupVertices = vertexAttachment.vertices;\n            for (let i = 0; i < vertexCount; i++)\n              deform[i] += lastVertices[i] - setupVertices[i];\n          } else {\n            for (let i = 0; i < vertexCount; i++)\n              deform[i] += lastVertices[i];\n          }\n        } else\n          Utils.arrayCopy(lastVertices, 0, deform, 0, vertexCount);\n      } else {\n        switch (blend) {\n          case MixBlend.setup: {\n            const vertexAttachment2 = slotAttachment;\n            if (!vertexAttachment2.bones) {\n              const setupVertices = vertexAttachment2.vertices;\n              for (let i = 0; i < vertexCount; i++) {\n                const setup = setupVertices[i];\n                deform[i] = setup + (lastVertices[i] - setup) * alpha;\n              }\n            } else {\n              for (let i = 0; i < vertexCount; i++)\n                deform[i] = lastVertices[i] * alpha;\n            }\n            break;\n          }\n          case MixBlend.first:\n          case MixBlend.replace:\n            for (let i = 0; i < vertexCount; i++)\n              deform[i] += (lastVertices[i] - deform[i]) * alpha;\n            break;\n          case MixBlend.add:\n            const vertexAttachment = slotAttachment;\n            if (!vertexAttachment.bones) {\n              const setupVertices = vertexAttachment.vertices;\n              for (let i = 0; i < vertexCount; i++)\n                deform[i] += (lastVertices[i] - setupVertices[i]) * alpha;\n            } else {\n              for (let i = 0; i < vertexCount; i++)\n                deform[i] += lastVertices[i] * alpha;\n            }\n        }\n      }\n      return;\n    }\n    const frame = Timeline.search1(frames, time);\n    const percent = this.getCurvePercent(time, frame);\n    const prevVertices = vertices[frame];\n    const nextVertices = vertices[frame + 1];\n    if (alpha == 1) {\n      if (blend == MixBlend.add) {\n        const vertexAttachment = slotAttachment;\n        if (!vertexAttachment.bones) {\n          const setupVertices = vertexAttachment.vertices;\n          for (let i = 0; i < vertexCount; i++) {\n            const prev = prevVertices[i];\n            deform[i] += prev + (nextVertices[i] - prev) * percent - setupVertices[i];\n          }\n        } else {\n          for (let i = 0; i < vertexCount; i++) {\n            const prev = prevVertices[i];\n            deform[i] += prev + (nextVertices[i] - prev) * percent;\n          }\n        }\n      } else {\n        for (let i = 0; i < vertexCount; i++) {\n          const prev = prevVertices[i];\n          deform[i] = prev + (nextVertices[i] - prev) * percent;\n        }\n      }\n    } else {\n      switch (blend) {\n        case MixBlend.setup: {\n          const vertexAttachment2 = slotAttachment;\n          if (!vertexAttachment2.bones) {\n            const setupVertices = vertexAttachment2.vertices;\n            for (let i = 0; i < vertexCount; i++) {\n              const prev = prevVertices[i];\n              const setup = setupVertices[i];\n              deform[i] = setup + (prev + (nextVertices[i] - prev) * percent - setup) * alpha;\n            }\n          } else {\n            for (let i = 0; i < vertexCount; i++) {\n              const prev = prevVertices[i];\n              deform[i] = (prev + (nextVertices[i] - prev) * percent) * alpha;\n            }\n          }\n          break;\n        }\n        case MixBlend.first:\n        case MixBlend.replace:\n          for (let i = 0; i < vertexCount; i++) {\n            const prev = prevVertices[i];\n            deform[i] += (prev + (nextVertices[i] - prev) * percent - deform[i]) * alpha;\n          }\n          break;\n        case MixBlend.add:\n          const vertexAttachment = slotAttachment;\n          if (!vertexAttachment.bones) {\n            const setupVertices = vertexAttachment.vertices;\n            for (let i = 0; i < vertexCount; i++) {\n              const prev = prevVertices[i];\n              deform[i] += (prev + (nextVertices[i] - prev) * percent - setupVertices[i]) * alpha;\n            }\n          } else {\n            for (let i = 0; i < vertexCount; i++) {\n              const prev = prevVertices[i];\n              deform[i] += (prev + (nextVertices[i] - prev) * percent) * alpha;\n            }\n          }\n      }\n    }\n  }\n}\nconst _EventTimeline = class extends Timeline {\n  constructor(frameCount) {\n    super(frameCount, _EventTimeline.propertyIds);\n    this.events = new Array(frameCount);\n  }\n  getFrameCount() {\n    return this.frames.length;\n  }\n  /** Sets the time in seconds and the event for the specified key frame. */\n  setFrame(frame, event) {\n    this.frames[frame] = event.time;\n    this.events[frame] = event;\n  }\n  /** Fires events for frames > `lastTime` and <= `time`. */\n  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n    if (!firedEvents)\n      return;\n    const frames = this.frames;\n    const frameCount = this.frames.length;\n    if (lastTime > time) {\n      this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, blend, direction);\n      lastTime = -1;\n    } else if (lastTime >= frames[frameCount - 1])\n      return;\n    if (time < frames[0])\n      return;\n    let i = 0;\n    if (lastTime < frames[0])\n      i = 0;\n    else {\n      i = Timeline.search1(frames, lastTime) + 1;\n      const frameTime = frames[i];\n      while (i > 0) {\n        if (frames[i - 1] != frameTime)\n          break;\n        i--;\n      }\n    }\n    for (; i < frameCount && time >= frames[i]; i++)\n      firedEvents.push(this.events[i]);\n  }\n};\nlet EventTimeline = _EventTimeline;\nEventTimeline.propertyIds = [`${Property.event}`];\nconst _DrawOrderTimeline = class extends Timeline {\n  constructor(frameCount) {\n    super(frameCount, _DrawOrderTimeline.propertyIds);\n    this.drawOrders = new Array(frameCount);\n  }\n  getFrameCount() {\n    return this.frames.length;\n  }\n  /** Sets the time in seconds and the draw order for the specified key frame.\n   * @param drawOrder For each slot in {@link Skeleton#slots}, the index of the new draw order. May be null to use setup pose\n   *           draw order. */\n  setFrame(frame, time, drawOrder) {\n    this.frames[frame] = time;\n    this.drawOrders[frame] = drawOrder;\n  }\n  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n    if (direction == MixDirection.mixOut) {\n      if (blend == MixBlend.setup)\n        Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\n      return;\n    }\n    if (time < this.frames[0]) {\n      if (blend == MixBlend.setup || blend == MixBlend.first)\n        Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\n      return;\n    }\n    const idx = Timeline.search1(this.frames, time);\n    const drawOrderToSetupIndex = this.drawOrders[idx];\n    if (!drawOrderToSetupIndex)\n      Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\n    else {\n      const drawOrder = skeleton.drawOrder;\n      const slots = skeleton.slots;\n      for (let i = 0, n = drawOrderToSetupIndex.length; i < n; i++)\n        drawOrder[i] = slots[drawOrderToSetupIndex[i]];\n    }\n  }\n};\nlet DrawOrderTimeline = _DrawOrderTimeline;\nDrawOrderTimeline.propertyIds = [`${Property.drawOrder}`];\nclass IkConstraintTimeline extends CurveTimeline {\n  constructor(frameCount, bezierCount, ikConstraintIndex) {\n    super(frameCount, bezierCount, [`${Property.ikConstraint}|${ikConstraintIndex}`]);\n    /** The index of the IK constraint slot in {@link Skeleton#ikConstraints} that will be changed. */\n    this.ikConstraintIndex = 0;\n    this.ikConstraintIndex = ikConstraintIndex;\n  }\n  getFrameEntries() {\n    return 6;\n  }\n  /** Sets the time in seconds, mix, softness, bend direction, compress, and stretch for the specified key frame. */\n  setFrame(frame, time, mix, softness, bendDirection, compress, stretch) {\n    frame *= 6;\n    this.frames[frame] = time;\n    this.frames[\n      frame + 1\n      /* MIX*/\n    ] = mix;\n    this.frames[\n      frame + 2\n      /* SOFTNESS*/\n    ] = softness;\n    this.frames[\n      frame + 3\n      /* BEND_DIRECTION*/\n    ] = bendDirection;\n    this.frames[\n      frame + 4\n      /* COMPRESS*/\n    ] = compress ? 1 : 0;\n    this.frames[\n      frame + 5\n      /* STRETCH*/\n    ] = stretch ? 1 : 0;\n  }\n  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n    const constraint = skeleton.ikConstraints[this.ikConstraintIndex];\n    if (!constraint.active)\n      return;\n    const frames = this.frames;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          constraint.mix = constraint.data.mix;\n          constraint.softness = constraint.data.softness;\n          constraint.bendDirection = constraint.data.bendDirection;\n          constraint.compress = constraint.data.compress;\n          constraint.stretch = constraint.data.stretch;\n          return;\n        case MixBlend.first:\n          constraint.mix += (constraint.data.mix - constraint.mix) * alpha;\n          constraint.softness += (constraint.data.softness - constraint.softness) * alpha;\n          constraint.bendDirection = constraint.data.bendDirection;\n          constraint.compress = constraint.data.compress;\n          constraint.stretch = constraint.data.stretch;\n      }\n      return;\n    }\n    let mix = 0;\n    let softness = 0;\n    const i = Timeline.search(\n      frames,\n      time,\n      6\n      /* ENTRIES*/\n    );\n    const curveType = this.curves[\n      i / 6\n      /* ENTRIES*/\n    ];\n    switch (curveType) {\n      case 0:\n        const before = frames[i];\n        mix = frames[\n          i + 1\n          /* MIX*/\n        ];\n        softness = frames[\n          i + 2\n          /* SOFTNESS*/\n        ];\n        const t = (time - before) / (frames[\n          i + 6\n          /* ENTRIES*/\n        ] - before);\n        mix += (frames[\n          i + 6 + 1\n          /* MIX*/\n        ] - mix) * t;\n        softness += (frames[\n          i + 6 + 2\n          /* SOFTNESS*/\n        ] - softness) * t;\n        break;\n      case 1:\n        mix = frames[\n          i + 1\n          /* MIX*/\n        ];\n        softness = frames[\n          i + 2\n          /* SOFTNESS*/\n        ];\n        break;\n      default:\n        mix = this.getBezierValue(\n          time,\n          i,\n          1,\n          curveType - 2\n          /* BEZIER*/\n        );\n        softness = this.getBezierValue(\n          time,\n          i,\n          2,\n          curveType + 18 - 2\n          /* BEZIER*/\n        );\n    }\n    if (blend == MixBlend.setup) {\n      constraint.mix = constraint.data.mix + (mix - constraint.data.mix) * alpha;\n      constraint.softness = constraint.data.softness + (softness - constraint.data.softness) * alpha;\n      if (direction == MixDirection.mixOut) {\n        constraint.bendDirection = constraint.data.bendDirection;\n        constraint.compress = constraint.data.compress;\n        constraint.stretch = constraint.data.stretch;\n      } else {\n        constraint.bendDirection = frames[\n          i + 3\n          /* BEND_DIRECTION*/\n        ];\n        constraint.compress = frames[\n          i + 4\n          /* COMPRESS*/\n        ] != 0;\n        constraint.stretch = frames[\n          i + 5\n          /* STRETCH*/\n        ] != 0;\n      }\n    } else {\n      constraint.mix += (mix - constraint.mix) * alpha;\n      constraint.softness += (softness - constraint.softness) * alpha;\n      if (direction == MixDirection.mixIn) {\n        constraint.bendDirection = frames[\n          i + 3\n          /* BEND_DIRECTION*/\n        ];\n        constraint.compress = frames[\n          i + 4\n          /* COMPRESS*/\n        ] != 0;\n        constraint.stretch = frames[\n          i + 5\n          /* STRETCH*/\n        ] != 0;\n      }\n    }\n  }\n}\nclass TransformConstraintTimeline extends CurveTimeline {\n  constructor(frameCount, bezierCount, transformConstraintIndex) {\n    super(frameCount, bezierCount, [`${Property.transformConstraint}|${transformConstraintIndex}`]);\n    /** The index of the transform constraint slot in {@link Skeleton#transformConstraints} that will be changed. */\n    this.transformConstraintIndex = 0;\n    this.transformConstraintIndex = transformConstraintIndex;\n  }\n  getFrameEntries() {\n    return 7;\n  }\n  /** The time in seconds, rotate mix, translate mix, scale mix, and shear mix for the specified key frame. */\n  setFrame(frame, time, mixRotate, mixX, mixY, mixScaleX, mixScaleY, mixShearY) {\n    const frames = this.frames;\n    frame *= 7;\n    frames[frame] = time;\n    frames[\n      frame + 1\n      /* ROTATE*/\n    ] = mixRotate;\n    frames[\n      frame + 2\n      /* X*/\n    ] = mixX;\n    frames[\n      frame + 3\n      /* Y*/\n    ] = mixY;\n    frames[\n      frame + 4\n      /* SCALEX*/\n    ] = mixScaleX;\n    frames[\n      frame + 5\n      /* SCALEY*/\n    ] = mixScaleY;\n    frames[\n      frame + 6\n      /* SHEARY*/\n    ] = mixShearY;\n  }\n  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n    const constraint = skeleton.transformConstraints[this.transformConstraintIndex];\n    if (!constraint.active)\n      return;\n    const frames = this.frames;\n    if (time < frames[0]) {\n      const data = constraint.data;\n      switch (blend) {\n        case MixBlend.setup:\n          constraint.mixRotate = data.mixRotate;\n          constraint.mixX = data.mixX;\n          constraint.mixY = data.mixY;\n          constraint.mixScaleX = data.mixScaleX;\n          constraint.mixScaleY = data.mixScaleY;\n          constraint.mixShearY = data.mixShearY;\n          return;\n        case MixBlend.first:\n          constraint.mixRotate += (data.mixRotate - constraint.mixRotate) * alpha;\n          constraint.mixX += (data.mixX - constraint.mixX) * alpha;\n          constraint.mixY += (data.mixY - constraint.mixY) * alpha;\n          constraint.mixScaleX += (data.mixScaleX - constraint.mixScaleX) * alpha;\n          constraint.mixScaleY += (data.mixScaleY - constraint.mixScaleY) * alpha;\n          constraint.mixShearY += (data.mixShearY - constraint.mixShearY) * alpha;\n      }\n      return;\n    }\n    let rotate;\n    let x;\n    let y;\n    let scaleX;\n    let scaleY;\n    let shearY;\n    const i = Timeline.search(\n      frames,\n      time,\n      7\n      /* ENTRIES*/\n    );\n    const curveType = this.curves[\n      i / 7\n      /* ENTRIES*/\n    ];\n    switch (curveType) {\n      case 0:\n        const before = frames[i];\n        rotate = frames[\n          i + 1\n          /* ROTATE*/\n        ];\n        x = frames[\n          i + 2\n          /* X*/\n        ];\n        y = frames[\n          i + 3\n          /* Y*/\n        ];\n        scaleX = frames[\n          i + 4\n          /* SCALEX*/\n        ];\n        scaleY = frames[\n          i + 5\n          /* SCALEY*/\n        ];\n        shearY = frames[\n          i + 6\n          /* SHEARY*/\n        ];\n        const t = (time - before) / (frames[\n          i + 7\n          /* ENTRIES*/\n        ] - before);\n        rotate += (frames[\n          i + 7 + 1\n          /* ROTATE*/\n        ] - rotate) * t;\n        x += (frames[\n          i + 7 + 2\n          /* X*/\n        ] - x) * t;\n        y += (frames[\n          i + 7 + 3\n          /* Y*/\n        ] - y) * t;\n        scaleX += (frames[\n          i + 7 + 4\n          /* SCALEX*/\n        ] - scaleX) * t;\n        scaleY += (frames[\n          i + 7 + 5\n          /* SCALEY*/\n        ] - scaleY) * t;\n        shearY += (frames[\n          i + 7 + 6\n          /* SHEARY*/\n        ] - shearY) * t;\n        break;\n      case 1:\n        rotate = frames[\n          i + 1\n          /* ROTATE*/\n        ];\n        x = frames[\n          i + 2\n          /* X*/\n        ];\n        y = frames[\n          i + 3\n          /* Y*/\n        ];\n        scaleX = frames[\n          i + 4\n          /* SCALEX*/\n        ];\n        scaleY = frames[\n          i + 5\n          /* SCALEY*/\n        ];\n        shearY = frames[\n          i + 6\n          /* SHEARY*/\n        ];\n        break;\n      default:\n        rotate = this.getBezierValue(\n          time,\n          i,\n          1,\n          curveType - 2\n          /* BEZIER*/\n        );\n        x = this.getBezierValue(\n          time,\n          i,\n          2,\n          curveType + 18 - 2\n          /* BEZIER*/\n        );\n        y = this.getBezierValue(\n          time,\n          i,\n          3,\n          curveType + 18 * 2 - 2\n          /* BEZIER*/\n        );\n        scaleX = this.getBezierValue(\n          time,\n          i,\n          4,\n          curveType + 18 * 3 - 2\n          /* BEZIER*/\n        );\n        scaleY = this.getBezierValue(\n          time,\n          i,\n          5,\n          curveType + 18 * 4 - 2\n          /* BEZIER*/\n        );\n        shearY = this.getBezierValue(\n          time,\n          i,\n          6,\n          curveType + 18 * 5 - 2\n          /* BEZIER*/\n        );\n    }\n    if (blend == MixBlend.setup) {\n      const data = constraint.data;\n      constraint.mixRotate = data.mixRotate + (rotate - data.mixRotate) * alpha;\n      constraint.mixX = data.mixX + (x - data.mixX) * alpha;\n      constraint.mixY = data.mixY + (y - data.mixY) * alpha;\n      constraint.mixScaleX = data.mixScaleX + (scaleX - data.mixScaleX) * alpha;\n      constraint.mixScaleY = data.mixScaleY + (scaleY - data.mixScaleY) * alpha;\n      constraint.mixShearY = data.mixShearY + (shearY - data.mixShearY) * alpha;\n    } else {\n      constraint.mixRotate += (rotate - constraint.mixRotate) * alpha;\n      constraint.mixX += (x - constraint.mixX) * alpha;\n      constraint.mixY += (y - constraint.mixY) * alpha;\n      constraint.mixScaleX += (scaleX - constraint.mixScaleX) * alpha;\n      constraint.mixScaleY += (scaleY - constraint.mixScaleY) * alpha;\n      constraint.mixShearY += (shearY - constraint.mixShearY) * alpha;\n    }\n  }\n}\nclass PathConstraintPositionTimeline extends CurveTimeline1 {\n  constructor(frameCount, bezierCount, pathConstraintIndex) {\n    super(frameCount, bezierCount, `${Property.pathConstraintPosition}|${pathConstraintIndex}`);\n    /** The index of the path constraint slot in {@link Skeleton#pathConstraints} that will be changed. */\n    this.pathConstraintIndex = 0;\n    this.pathConstraintIndex = pathConstraintIndex;\n  }\n  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n    const constraint = skeleton.pathConstraints[this.pathConstraintIndex];\n    if (!constraint.active)\n      return;\n    const frames = this.frames;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          constraint.position = constraint.data.position;\n          return;\n        case MixBlend.first:\n          constraint.position += (constraint.data.position - constraint.position) * alpha;\n      }\n      return;\n    }\n    const position = this.getCurveValue(time);\n    if (blend == MixBlend.setup)\n      constraint.position = constraint.data.position + (position - constraint.data.position) * alpha;\n    else\n      constraint.position += (position - constraint.position) * alpha;\n  }\n}\nclass PathConstraintSpacingTimeline extends CurveTimeline1 {\n  constructor(frameCount, bezierCount, pathConstraintIndex) {\n    super(frameCount, bezierCount, `${Property.pathConstraintSpacing}|${pathConstraintIndex}`);\n    /** The index of the path constraint slot in {@link Skeleton#getPathConstraints()} that will be changed. */\n    this.pathConstraintIndex = 0;\n    this.pathConstraintIndex = pathConstraintIndex;\n  }\n  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n    const constraint = skeleton.pathConstraints[this.pathConstraintIndex];\n    if (!constraint.active)\n      return;\n    const frames = this.frames;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          constraint.spacing = constraint.data.spacing;\n          return;\n        case MixBlend.first:\n          constraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha;\n      }\n      return;\n    }\n    const spacing = this.getCurveValue(time);\n    if (blend == MixBlend.setup)\n      constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha;\n    else\n      constraint.spacing += (spacing - constraint.spacing) * alpha;\n  }\n}\nclass PathConstraintMixTimeline extends CurveTimeline {\n  constructor(frameCount, bezierCount, pathConstraintIndex) {\n    super(frameCount, bezierCount, [`${Property.pathConstraintMix}|${pathConstraintIndex}`]);\n    /** The index of the path constraint slot in {@link Skeleton#getPathConstraints()} that will be changed. */\n    this.pathConstraintIndex = 0;\n    this.pathConstraintIndex = pathConstraintIndex;\n  }\n  getFrameEntries() {\n    return 4;\n  }\n  setFrame(frame, time, mixRotate, mixX, mixY) {\n    const frames = this.frames;\n    frame <<= 2;\n    frames[frame] = time;\n    frames[\n      frame + 1\n      /* ROTATE*/\n    ] = mixRotate;\n    frames[\n      frame + 2\n      /* X*/\n    ] = mixX;\n    frames[\n      frame + 3\n      /* Y*/\n    ] = mixY;\n  }\n  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n    const constraint = skeleton.pathConstraints[this.pathConstraintIndex];\n    if (!constraint.active)\n      return;\n    const frames = this.frames;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          constraint.mixRotate = constraint.data.mixRotate;\n          constraint.mixX = constraint.data.mixX;\n          constraint.mixY = constraint.data.mixY;\n          return;\n        case MixBlend.first:\n          constraint.mixRotate += (constraint.data.mixRotate - constraint.mixRotate) * alpha;\n          constraint.mixX += (constraint.data.mixX - constraint.mixX) * alpha;\n          constraint.mixY += (constraint.data.mixY - constraint.mixY) * alpha;\n      }\n      return;\n    }\n    let rotate;\n    let x;\n    let y;\n    const i = Timeline.search(\n      frames,\n      time,\n      4\n      /* ENTRIES*/\n    );\n    const curveType = this.curves[i >> 2];\n    switch (curveType) {\n      case 0:\n        const before = frames[i];\n        rotate = frames[\n          i + 1\n          /* ROTATE*/\n        ];\n        x = frames[\n          i + 2\n          /* X*/\n        ];\n        y = frames[\n          i + 3\n          /* Y*/\n        ];\n        const t = (time - before) / (frames[\n          i + 4\n          /* ENTRIES*/\n        ] - before);\n        rotate += (frames[\n          i + 4 + 1\n          /* ROTATE*/\n        ] - rotate) * t;\n        x += (frames[\n          i + 4 + 2\n          /* X*/\n        ] - x) * t;\n        y += (frames[\n          i + 4 + 3\n          /* Y*/\n        ] - y) * t;\n        break;\n      case 1:\n        rotate = frames[\n          i + 1\n          /* ROTATE*/\n        ];\n        x = frames[\n          i + 2\n          /* X*/\n        ];\n        y = frames[\n          i + 3\n          /* Y*/\n        ];\n        break;\n      default:\n        rotate = this.getBezierValue(\n          time,\n          i,\n          1,\n          curveType - 2\n          /* BEZIER*/\n        );\n        x = this.getBezierValue(\n          time,\n          i,\n          2,\n          curveType + 18 - 2\n          /* BEZIER*/\n        );\n        y = this.getBezierValue(\n          time,\n          i,\n          3,\n          curveType + 18 * 2 - 2\n          /* BEZIER*/\n        );\n    }\n    if (blend == MixBlend.setup) {\n      const data = constraint.data;\n      constraint.mixRotate = data.mixRotate + (rotate - data.mixRotate) * alpha;\n      constraint.mixX = data.mixX + (x - data.mixX) * alpha;\n      constraint.mixY = data.mixY + (y - data.mixY) * alpha;\n    } else {\n      constraint.mixRotate += (rotate - constraint.mixRotate) * alpha;\n      constraint.mixX += (x - constraint.mixX) * alpha;\n      constraint.mixY += (y - constraint.mixY) * alpha;\n    }\n  }\n}\nconst _SequenceTimeline = class extends Timeline {\n  constructor(frameCount, slotIndex, attachment) {\n    super(frameCount, [`${Property.sequence}|${slotIndex}|${attachment.sequence.id}`]);\n    this.slotIndex = slotIndex;\n    this.attachment = attachment;\n  }\n  getFrameEntries() {\n    return _SequenceTimeline.ENTRIES;\n  }\n  getSlotIndex() {\n    return this.slotIndex;\n  }\n  getAttachment() {\n    return this.attachment;\n  }\n  /** Sets the time, mode, index, and frame time for the specified frame.\n   * @param frame Between 0 and <code>frameCount</code>, inclusive.\n   * @param time Seconds between frames. */\n  setFrame(frame, time, mode, index, delay) {\n    const frames = this.frames;\n    frame *= _SequenceTimeline.ENTRIES;\n    frames[frame] = time;\n    frames[frame + _SequenceTimeline.MODE] = mode | index << 4;\n    frames[frame + _SequenceTimeline.DELAY] = delay;\n  }\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    const slot = skeleton.slots[this.slotIndex];\n    if (!slot.bone.active)\n      return;\n    const slotAttachment = slot.attachment;\n    const attachment = this.attachment;\n    if (slotAttachment != attachment) {\n      if (!(slotAttachment instanceof VertexAttachment) || slotAttachment.timelineAttachment != attachment)\n        return;\n    }\n    const frames = this.frames;\n    if (time < frames[0]) {\n      if (blend == MixBlend.setup || blend == MixBlend.first)\n        slot.sequenceIndex = -1;\n      return;\n    }\n    const i = Timeline.search(frames, time, _SequenceTimeline.ENTRIES);\n    const before = frames[i];\n    const modeAndIndex = frames[i + _SequenceTimeline.MODE];\n    const delay = frames[i + _SequenceTimeline.DELAY];\n    if (!this.attachment.sequence)\n      return;\n    let index = modeAndIndex >> 4;\n    const count = this.attachment.sequence.regions.length;\n    const mode = SequenceModeValues[modeAndIndex & 15];\n    if (mode != SequenceMode.hold) {\n      index += (time - before) / delay + 1e-5 | 0;\n      switch (mode) {\n        case SequenceMode.once:\n          index = Math.min(count - 1, index);\n          break;\n        case SequenceMode.loop:\n          index %= count;\n          break;\n        case SequenceMode.pingpong: {\n          const n = (count << 1) - 2;\n          index = n == 0 ? 0 : index % n;\n          if (index >= count)\n            index = n - index;\n          break;\n        }\n        case SequenceMode.onceReverse:\n          index = Math.max(count - 1 - index, 0);\n          break;\n        case SequenceMode.loopReverse:\n          index = count - 1 - index % count;\n          break;\n        case SequenceMode.pingpongReverse: {\n          const n = (count << 1) - 2;\n          index = n == 0 ? 0 : (index + count - 1) % n;\n          if (index >= count)\n            index = n - index;\n        }\n      }\n    }\n    slot.sequenceIndex = index;\n  }\n};\nlet SequenceTimeline = _SequenceTimeline;\nSequenceTimeline.ENTRIES = 3;\nSequenceTimeline.MODE = 1;\nSequenceTimeline.DELAY = 2;\n\nexport { AlphaTimeline, Animation, AttachmentTimeline, CurveTimeline, CurveTimeline1, CurveTimeline2, DeformTimeline, DrawOrderTimeline, EventTimeline, IkConstraintTimeline, PathConstraintMixTimeline, PathConstraintPositionTimeline, PathConstraintSpacingTimeline, RGB2Timeline, RGBA2Timeline, RGBATimeline, RGBTimeline, RotateTimeline, ScaleTimeline, ScaleXTimeline, ScaleYTimeline, SequenceTimeline, ShearTimeline, ShearXTimeline, ShearYTimeline, Timeline, TransformConstraintTimeline, TranslateTimeline, TranslateXTimeline, TranslateYTimeline };\n//# sourceMappingURL=Animation.mjs.map\n","import { StringSet, Pool, MixBlend, Utils, MixDirection, MathUtils } from '@pixi-spine/base';\nimport { Animation, AttachmentTimeline, RotateTimeline, DrawOrderTimeline, Timeline, EventTimeline } from './Animation.mjs';\n\nconst _AnimationState = class {\n  constructor(data) {\n    /** The list of tracks that currently have animations, which may contain null entries. */\n    this.tracks = new Array();\n    /** Multiplier for the delta time when the animation state is updated, causing time for all animations and mixes to play slower\n     * or faster. Defaults to 1.\n     *\n     * See TrackEntry {@link TrackEntry#timeScale} for affecting a single animation. */\n    this.timeScale = 1;\n    this.unkeyedState = 0;\n    this.events = new Array();\n    this.listeners = new Array();\n    this.queue = new EventQueue(this);\n    this.propertyIDs = new StringSet();\n    this.animationsChanged = false;\n    this.trackEntryPool = new Pool(() => new TrackEntry());\n    this.data = data;\n  }\n  static emptyAnimation() {\n    return _AnimationState._emptyAnimation;\n  }\n  /** Increments each track entry {@link TrackEntry#trackTime()}, setting queued animations as current if needed. */\n  update(delta) {\n    delta *= this.timeScale;\n    const tracks = this.tracks;\n    for (let i = 0, n = tracks.length; i < n; i++) {\n      const current = tracks[i];\n      if (!current)\n        continue;\n      current.animationLast = current.nextAnimationLast;\n      current.trackLast = current.nextTrackLast;\n      let currentDelta = delta * current.timeScale;\n      if (current.delay > 0) {\n        current.delay -= currentDelta;\n        if (current.delay > 0)\n          continue;\n        currentDelta = -current.delay;\n        current.delay = 0;\n      }\n      let next = current.next;\n      if (next) {\n        const nextTime = current.trackLast - next.delay;\n        if (nextTime >= 0) {\n          next.delay = 0;\n          next.trackTime += current.timeScale == 0 ? 0 : (nextTime / current.timeScale + delta) * next.timeScale;\n          current.trackTime += currentDelta;\n          this.setCurrent(i, next, true);\n          while (next.mixingFrom) {\n            next.mixTime += delta;\n            next = next.mixingFrom;\n          }\n          continue;\n        }\n      } else if (current.trackLast >= current.trackEnd && !current.mixingFrom) {\n        tracks[i] = null;\n        this.queue.end(current);\n        this.clearNext(current);\n        continue;\n      }\n      if (current.mixingFrom && this.updateMixingFrom(current, delta)) {\n        let from = current.mixingFrom;\n        current.mixingFrom = null;\n        if (from)\n          from.mixingTo = null;\n        while (from) {\n          this.queue.end(from);\n          from = from.mixingFrom;\n        }\n      }\n      current.trackTime += currentDelta;\n    }\n    this.queue.drain();\n  }\n  /** Returns true when all mixing from entries are complete. */\n  updateMixingFrom(to, delta) {\n    const from = to.mixingFrom;\n    if (!from)\n      return true;\n    const finished = this.updateMixingFrom(from, delta);\n    from.animationLast = from.nextAnimationLast;\n    from.trackLast = from.nextTrackLast;\n    if (to.mixTime > 0 && to.mixTime >= to.mixDuration) {\n      if (from.totalAlpha == 0 || to.mixDuration == 0) {\n        to.mixingFrom = from.mixingFrom;\n        if (from.mixingFrom)\n          from.mixingFrom.mixingTo = to;\n        to.interruptAlpha = from.interruptAlpha;\n        this.queue.end(from);\n      }\n      return finished;\n    }\n    from.trackTime += delta * from.timeScale;\n    to.mixTime += delta;\n    return false;\n  }\n  /** Poses the skeleton using the track entry animations. There are no side effects other than invoking listeners, so the\n   * animation state can be applied to multiple skeletons to pose them identically.\n   * @returns True if any animations were applied. */\n  apply(skeleton) {\n    if (!skeleton)\n      throw new Error(\"skeleton cannot be null.\");\n    if (this.animationsChanged)\n      this._animationsChanged();\n    const events = this.events;\n    const tracks = this.tracks;\n    let applied = false;\n    for (let i = 0, n = tracks.length; i < n; i++) {\n      const current = tracks[i];\n      if (!current || current.delay > 0)\n        continue;\n      applied = true;\n      const blend = i == 0 ? MixBlend.first : current.mixBlend;\n      let mix = current.alpha;\n      if (current.mixingFrom)\n        mix *= this.applyMixingFrom(current, skeleton, blend);\n      else if (current.trackTime >= current.trackEnd && !current.next)\n        mix = 0;\n      const animationLast = current.animationLast;\n      const animationTime = current.getAnimationTime();\n      let applyTime = animationTime;\n      let applyEvents = events;\n      if (current.reverse) {\n        applyTime = current.animation.duration - applyTime;\n        applyEvents = null;\n      }\n      const timelines = current.animation.timelines;\n      const timelineCount = timelines.length;\n      if (i == 0 && mix == 1 || blend == MixBlend.add) {\n        for (let ii = 0; ii < timelineCount; ii++) {\n          Utils.webkit602BugfixHelper(mix, blend);\n          const timeline = timelines[ii];\n          if (timeline instanceof AttachmentTimeline)\n            this.applyAttachmentTimeline(timeline, skeleton, applyTime, blend, true);\n          else\n            timeline.apply(skeleton, animationLast, applyTime, applyEvents, mix, blend, MixDirection.mixIn);\n        }\n      } else {\n        const timelineMode = current.timelineMode;\n        const shortestRotation = current.shortestRotation;\n        const firstFrame = !shortestRotation && current.timelinesRotation.length != timelineCount << 1;\n        if (firstFrame)\n          current.timelinesRotation.length = timelineCount << 1;\n        for (let ii = 0; ii < timelineCount; ii++) {\n          const timeline = timelines[ii];\n          const timelineBlend = timelineMode[ii] == SUBSEQUENT ? blend : MixBlend.setup;\n          if (!shortestRotation && timeline instanceof RotateTimeline) {\n            this.applyRotateTimeline(timeline, skeleton, applyTime, mix, timelineBlend, current.timelinesRotation, ii << 1, firstFrame);\n          } else if (timeline instanceof AttachmentTimeline) {\n            this.applyAttachmentTimeline(timeline, skeleton, applyTime, blend, true);\n          } else {\n            Utils.webkit602BugfixHelper(mix, blend);\n            timeline.apply(skeleton, animationLast, applyTime, applyEvents, mix, timelineBlend, MixDirection.mixIn);\n          }\n        }\n      }\n      this.queueEvents(current, animationTime);\n      events.length = 0;\n      current.nextAnimationLast = animationTime;\n      current.nextTrackLast = current.trackTime;\n    }\n    const setupState = this.unkeyedState + SETUP;\n    const slots = skeleton.slots;\n    for (let i = 0, n = skeleton.slots.length; i < n; i++) {\n      const slot = slots[i];\n      if (slot.attachmentState == setupState) {\n        const attachmentName = slot.data.attachmentName;\n        slot.setAttachment(!attachmentName ? null : skeleton.getAttachment(slot.data.index, attachmentName));\n      }\n    }\n    this.unkeyedState += 2;\n    this.queue.drain();\n    return applied;\n  }\n  applyMixingFrom(to, skeleton, blend) {\n    const from = to.mixingFrom;\n    if (from.mixingFrom)\n      this.applyMixingFrom(from, skeleton, blend);\n    let mix = 0;\n    if (to.mixDuration == 0) {\n      mix = 1;\n      if (blend == MixBlend.first)\n        blend = MixBlend.setup;\n    } else {\n      mix = to.mixTime / to.mixDuration;\n      if (mix > 1)\n        mix = 1;\n      if (blend != MixBlend.first)\n        blend = from.mixBlend;\n    }\n    const attachments = mix < from.attachmentThreshold;\n    const drawOrder = mix < from.drawOrderThreshold;\n    const timelines = from.animation.timelines;\n    const timelineCount = timelines.length;\n    const alphaHold = from.alpha * to.interruptAlpha;\n    const alphaMix = alphaHold * (1 - mix);\n    const animationLast = from.animationLast;\n    const animationTime = from.getAnimationTime();\n    let applyTime = animationTime;\n    let events = null;\n    if (from.reverse)\n      applyTime = from.animation.duration - applyTime;\n    else if (mix < from.eventThreshold)\n      events = this.events;\n    if (blend == MixBlend.add) {\n      for (let i = 0; i < timelineCount; i++)\n        timelines[i].apply(skeleton, animationLast, applyTime, events, alphaMix, blend, MixDirection.mixOut);\n    } else {\n      const timelineMode = from.timelineMode;\n      const timelineHoldMix = from.timelineHoldMix;\n      const shortestRotation = from.shortestRotation;\n      const firstFrame = !shortestRotation && from.timelinesRotation.length != timelineCount << 1;\n      if (firstFrame)\n        from.timelinesRotation.length = timelineCount << 1;\n      from.totalAlpha = 0;\n      for (let i = 0; i < timelineCount; i++) {\n        const timeline = timelines[i];\n        let direction = MixDirection.mixOut;\n        let timelineBlend;\n        let alpha = 0;\n        switch (timelineMode[i]) {\n          case SUBSEQUENT:\n            if (!drawOrder && timeline instanceof DrawOrderTimeline)\n              continue;\n            timelineBlend = blend;\n            alpha = alphaMix;\n            break;\n          case FIRST:\n            timelineBlend = MixBlend.setup;\n            alpha = alphaMix;\n            break;\n          case HOLD_SUBSEQUENT:\n            timelineBlend = blend;\n            alpha = alphaHold;\n            break;\n          case HOLD_FIRST:\n            timelineBlend = MixBlend.setup;\n            alpha = alphaHold;\n            break;\n          default:\n            timelineBlend = MixBlend.setup;\n            const holdMix = timelineHoldMix[i];\n            alpha = alphaHold * Math.max(0, 1 - holdMix.mixTime / holdMix.mixDuration);\n            break;\n        }\n        from.totalAlpha += alpha;\n        if (!shortestRotation && timeline instanceof RotateTimeline)\n          this.applyRotateTimeline(timeline, skeleton, applyTime, alpha, timelineBlend, from.timelinesRotation, i << 1, firstFrame);\n        else if (timeline instanceof AttachmentTimeline)\n          this.applyAttachmentTimeline(timeline, skeleton, applyTime, timelineBlend, attachments);\n        else {\n          Utils.webkit602BugfixHelper(alpha, blend);\n          if (drawOrder && timeline instanceof DrawOrderTimeline && timelineBlend == MixBlend.setup)\n            direction = MixDirection.mixIn;\n          timeline.apply(skeleton, animationLast, applyTime, events, alpha, timelineBlend, direction);\n        }\n      }\n    }\n    if (to.mixDuration > 0)\n      this.queueEvents(from, animationTime);\n    this.events.length = 0;\n    from.nextAnimationLast = animationTime;\n    from.nextTrackLast = from.trackTime;\n    return mix;\n  }\n  applyAttachmentTimeline(timeline, skeleton, time, blend, attachments) {\n    const slot = skeleton.slots[timeline.slotIndex];\n    if (!slot.bone.active)\n      return;\n    if (time < timeline.frames[0]) {\n      if (blend == MixBlend.setup || blend == MixBlend.first)\n        this.setAttachment(skeleton, slot, slot.data.attachmentName, attachments);\n    } else\n      this.setAttachment(skeleton, slot, timeline.attachmentNames[Timeline.search1(timeline.frames, time)], attachments);\n    if (slot.attachmentState <= this.unkeyedState)\n      slot.attachmentState = this.unkeyedState + SETUP;\n  }\n  setAttachment(skeleton, slot, attachmentName, attachments) {\n    slot.setAttachment(!attachmentName ? null : skeleton.getAttachment(slot.data.index, attachmentName));\n    if (attachments)\n      slot.attachmentState = this.unkeyedState + CURRENT;\n  }\n  applyRotateTimeline(timeline, skeleton, time, alpha, blend, timelinesRotation, i, firstFrame) {\n    if (firstFrame)\n      timelinesRotation[i] = 0;\n    if (alpha == 1) {\n      timeline.apply(skeleton, 0, time, null, 1, blend, MixDirection.mixIn);\n      return;\n    }\n    const bone = skeleton.bones[timeline.boneIndex];\n    if (!bone.active)\n      return;\n    const frames = timeline.frames;\n    let r1 = 0;\n    let r2 = 0;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.rotation = bone.data.rotation;\n        default:\n          return;\n        case MixBlend.first:\n          r1 = bone.rotation;\n          r2 = bone.data.rotation;\n      }\n    } else {\n      r1 = blend == MixBlend.setup ? bone.data.rotation : bone.rotation;\n      r2 = bone.data.rotation + timeline.getCurveValue(time);\n    }\n    let total = 0;\n    let diff = r2 - r1;\n    diff -= (16384 - (16384.499999999996 - diff / 360 | 0)) * 360;\n    if (diff == 0) {\n      total = timelinesRotation[i];\n    } else {\n      let lastTotal = 0;\n      let lastDiff = 0;\n      if (firstFrame) {\n        lastTotal = 0;\n        lastDiff = diff;\n      } else {\n        lastTotal = timelinesRotation[i];\n        lastDiff = timelinesRotation[i + 1];\n      }\n      const current = diff > 0;\n      let dir = lastTotal >= 0;\n      if (MathUtils.signum(lastDiff) != MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {\n        if (Math.abs(lastTotal) > 180)\n          lastTotal += 360 * MathUtils.signum(lastTotal);\n        dir = current;\n      }\n      total = diff + lastTotal - lastTotal % 360;\n      if (dir != current)\n        total += 360 * MathUtils.signum(lastTotal);\n      timelinesRotation[i] = total;\n    }\n    timelinesRotation[i + 1] = diff;\n    bone.rotation = r1 + total * alpha;\n  }\n  queueEvents(entry, animationTime) {\n    const animationStart = entry.animationStart;\n    const animationEnd = entry.animationEnd;\n    const duration = animationEnd - animationStart;\n    const trackLastWrapped = entry.trackLast % duration;\n    const events = this.events;\n    let i = 0;\n    const n = events.length;\n    for (; i < n; i++) {\n      const event = events[i];\n      if (event.time < trackLastWrapped)\n        break;\n      if (event.time > animationEnd)\n        continue;\n      this.queue.event(entry, event);\n    }\n    let complete = false;\n    if (entry.loop)\n      complete = duration == 0 || trackLastWrapped > entry.trackTime % duration;\n    else\n      complete = animationTime >= animationEnd && entry.animationLast < animationEnd;\n    if (complete)\n      this.queue.complete(entry);\n    for (; i < n; i++) {\n      const event = events[i];\n      if (event.time < animationStart)\n        continue;\n      this.queue.event(entry, event);\n    }\n  }\n  /** Removes all animations from all tracks, leaving skeletons in their current pose.\n   *\n   * It may be desired to use {@link AnimationState#setEmptyAnimation()} to mix the skeletons back to the setup pose,\n   * rather than leaving them in their current pose. */\n  clearTracks() {\n    const oldDrainDisabled = this.queue.drainDisabled;\n    this.queue.drainDisabled = true;\n    for (let i = 0, n = this.tracks.length; i < n; i++)\n      this.clearTrack(i);\n    this.tracks.length = 0;\n    this.queue.drainDisabled = oldDrainDisabled;\n    this.queue.drain();\n  }\n  /** Removes all animations from the track, leaving skeletons in their current pose.\n   *\n   * It may be desired to use {@link AnimationState#setEmptyAnimation()} to mix the skeletons back to the setup pose,\n   * rather than leaving them in their current pose. */\n  clearTrack(trackIndex) {\n    if (trackIndex >= this.tracks.length)\n      return;\n    const current = this.tracks[trackIndex];\n    if (!current)\n      return;\n    this.queue.end(current);\n    this.clearNext(current);\n    let entry = current;\n    while (true) {\n      const from = entry.mixingFrom;\n      if (!from)\n        break;\n      this.queue.end(from);\n      entry.mixingFrom = null;\n      entry.mixingTo = null;\n      entry = from;\n    }\n    this.tracks[current.trackIndex] = null;\n    this.queue.drain();\n  }\n  setCurrent(index, current, interrupt) {\n    const from = this.expandToIndex(index);\n    this.tracks[index] = current;\n    current.previous = null;\n    if (from) {\n      if (interrupt)\n        this.queue.interrupt(from);\n      current.mixingFrom = from;\n      from.mixingTo = current;\n      current.mixTime = 0;\n      if (from.mixingFrom && from.mixDuration > 0)\n        current.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);\n      from.timelinesRotation.length = 0;\n    }\n    this.queue.start(current);\n  }\n  /** Sets an animation by name.\n   *\n   * See {@link #setAnimationWith()}. */\n  setAnimation(trackIndex, animationName, loop = false) {\n    const animation = this.data.skeletonData.findAnimation(animationName);\n    if (!animation)\n      throw new Error(`Animation not found: ${animationName}`);\n    return this.setAnimationWith(trackIndex, animation, loop);\n  }\n  /** Sets the current animation for a track, discarding any queued animations. If the formerly current track entry was never\n   * applied to a skeleton, it is replaced (not mixed from).\n   * @param loop If true, the animation will repeat. If false it will not, instead its last frame is applied if played beyond its\n   *           duration. In either case {@link TrackEntry#trackEnd} determines when the track is cleared.\n   * @returns A track entry to allow further customization of animation playback. References to the track entry must not be kept\n   *         after the {@link AnimationStateListener#dispose()} event occurs. */\n  setAnimationWith(trackIndex, animation, loop = false) {\n    if (!animation)\n      throw new Error(\"animation cannot be null.\");\n    let interrupt = true;\n    let current = this.expandToIndex(trackIndex);\n    if (current) {\n      if (current.nextTrackLast == -1) {\n        this.tracks[trackIndex] = current.mixingFrom;\n        this.queue.interrupt(current);\n        this.queue.end(current);\n        this.clearNext(current);\n        current = current.mixingFrom;\n        interrupt = false;\n      } else\n        this.clearNext(current);\n    }\n    const entry = this.trackEntry(trackIndex, animation, loop, current);\n    this.setCurrent(trackIndex, entry, interrupt);\n    this.queue.drain();\n    return entry;\n  }\n  /** Queues an animation by name.\n   *\n   * See {@link #addAnimationWith()}. */\n  addAnimation(trackIndex, animationName, loop = false, delay = 0) {\n    const animation = this.data.skeletonData.findAnimation(animationName);\n    if (!animation)\n      throw new Error(`Animation not found: ${animationName}`);\n    return this.addAnimationWith(trackIndex, animation, loop, delay);\n  }\n  /** Adds an animation to be played after the current or last queued animation for a track. If the track is empty, it is\n   * equivalent to calling {@link #setAnimationWith()}.\n   * @param delay If > 0, sets {@link TrackEntry#delay}. If <= 0, the delay set is the duration of the previous track entry\n   *           minus any mix duration (from the {@link AnimationStateData}) plus the specified `delay` (ie the mix\n   *           ends at (`delay` = 0) or before (`delay` < 0) the previous track entry duration). If the\n   *           previous entry is looping, its next loop completion is used instead of its duration.\n   * @returns A track entry to allow further customization of animation playback. References to the track entry must not be kept\n   *         after the {@link AnimationStateListener#dispose()} event occurs. */\n  addAnimationWith(trackIndex, animation, loop = false, delay = 0) {\n    if (!animation)\n      throw new Error(\"animation cannot be null.\");\n    let last = this.expandToIndex(trackIndex);\n    if (last) {\n      while (last.next)\n        last = last.next;\n    }\n    const entry = this.trackEntry(trackIndex, animation, loop, last);\n    if (!last) {\n      this.setCurrent(trackIndex, entry, true);\n      this.queue.drain();\n    } else {\n      last.next = entry;\n      entry.previous = last;\n      if (delay <= 0)\n        delay += last.getTrackComplete() - entry.mixDuration;\n    }\n    entry.delay = delay;\n    return entry;\n  }\n  /** Sets an empty animation for a track, discarding any queued animations, and sets the track entry's\n   * {@link TrackEntry#mixduration}. An empty animation has no timelines and serves as a placeholder for mixing in or out.\n   *\n   * Mixing out is done by setting an empty animation with a mix duration using either {@link #setEmptyAnimation()},\n   * {@link #setEmptyAnimations()}, or {@link #addEmptyAnimation()}. Mixing to an empty animation causes\n   * the previous animation to be applied less and less over the mix duration. Properties keyed in the previous animation\n   * transition to the value from lower tracks or to the setup pose value if no lower tracks key the property. A mix duration of\n   * 0 still mixes out over one frame.\n   *\n   * Mixing in is done by first setting an empty animation, then adding an animation using\n   * {@link #addAnimation()} and on the returned track entry, set the\n   * {@link TrackEntry#setMixDuration()}. Mixing from an empty animation causes the new animation to be applied more and\n   * more over the mix duration. Properties keyed in the new animation transition from the value from lower tracks or from the\n   * setup pose value if no lower tracks key the property to the value keyed in the new animation. */\n  setEmptyAnimation(trackIndex, mixDuration = 0) {\n    const entry = this.setAnimationWith(trackIndex, _AnimationState.emptyAnimation(), false);\n    entry.mixDuration = mixDuration;\n    entry.trackEnd = mixDuration;\n    return entry;\n  }\n  /** Adds an empty animation to be played after the current or last queued animation for a track, and sets the track entry's\n   * {@link TrackEntry#mixDuration}. If the track is empty, it is equivalent to calling\n   * {@link #setEmptyAnimation()}.\n   *\n   * See {@link #setEmptyAnimation()}.\n   * @param delay If > 0, sets {@link TrackEntry#delay}. If <= 0, the delay set is the duration of the previous track entry\n   *           minus any mix duration plus the specified `delay` (ie the mix ends at (`delay` = 0) or\n   *           before (`delay` < 0) the previous track entry duration). If the previous entry is looping, its next\n   *           loop completion is used instead of its duration.\n   * @return A track entry to allow further customization of animation playback. References to the track entry must not be kept\n   *         after the {@link AnimationStateListener#dispose()} event occurs. */\n  addEmptyAnimation(trackIndex, mixDuration = 0, delay = 0) {\n    const entry = this.addAnimationWith(trackIndex, _AnimationState.emptyAnimation(), false, delay);\n    if (delay <= 0)\n      entry.delay += entry.mixDuration - mixDuration;\n    entry.mixDuration = mixDuration;\n    entry.trackEnd = mixDuration;\n    return entry;\n  }\n  /** Sets an empty animation for every track, discarding any queued animations, and mixes to it over the specified mix\n   * duration. */\n  setEmptyAnimations(mixDuration = 0) {\n    const oldDrainDisabled = this.queue.drainDisabled;\n    this.queue.drainDisabled = true;\n    for (let i = 0, n = this.tracks.length; i < n; i++) {\n      const current = this.tracks[i];\n      if (current)\n        this.setEmptyAnimation(current.trackIndex, mixDuration);\n    }\n    this.queue.drainDisabled = oldDrainDisabled;\n    this.queue.drain();\n  }\n  expandToIndex(index) {\n    if (index < this.tracks.length)\n      return this.tracks[index];\n    Utils.ensureArrayCapacity(this.tracks, index + 1, null);\n    this.tracks.length = index + 1;\n    return null;\n  }\n  /** @param last May be null. */\n  trackEntry(trackIndex, animation, loop, last) {\n    const entry = this.trackEntryPool.obtain();\n    entry.reset();\n    entry.trackIndex = trackIndex;\n    entry.animation = animation;\n    entry.loop = loop;\n    entry.holdPrevious = false;\n    entry.reverse = false;\n    entry.shortestRotation = false;\n    entry.eventThreshold = 0;\n    entry.attachmentThreshold = 0;\n    entry.drawOrderThreshold = 0;\n    entry.animationStart = 0;\n    entry.animationEnd = animation.duration;\n    entry.animationLast = -1;\n    entry.nextAnimationLast = -1;\n    entry.delay = 0;\n    entry.trackTime = 0;\n    entry.trackLast = -1;\n    entry.nextTrackLast = -1;\n    entry.trackEnd = Number.MAX_VALUE;\n    entry.timeScale = 1;\n    entry.alpha = 1;\n    entry.mixTime = 0;\n    entry.mixDuration = !last ? 0 : this.data.getMix(last.animation, animation);\n    entry.interruptAlpha = 1;\n    entry.totalAlpha = 0;\n    entry.mixBlend = MixBlend.replace;\n    return entry;\n  }\n  /** Removes the {@link TrackEntry#getNext() next entry} and all entries after it for the specified entry. */\n  clearNext(entry) {\n    let next = entry.next;\n    while (next) {\n      this.queue.dispose(next);\n      next = next.next;\n    }\n    entry.next = null;\n  }\n  _animationsChanged() {\n    this.animationsChanged = false;\n    this.propertyIDs.clear();\n    const tracks = this.tracks;\n    for (let i = 0, n = tracks.length; i < n; i++) {\n      let entry = tracks[i];\n      if (!entry)\n        continue;\n      while (entry.mixingFrom)\n        entry = entry.mixingFrom;\n      do {\n        if (!entry.mixingTo || entry.mixBlend != MixBlend.add)\n          this.computeHold(entry);\n        entry = entry.mixingTo;\n      } while (entry);\n    }\n  }\n  computeHold(entry) {\n    const to = entry.mixingTo;\n    const timelines = entry.animation.timelines;\n    const timelinesCount = entry.animation.timelines.length;\n    const timelineMode = entry.timelineMode;\n    timelineMode.length = timelinesCount;\n    const timelineHoldMix = entry.timelineHoldMix;\n    timelineHoldMix.length = 0;\n    const propertyIDs = this.propertyIDs;\n    if (to && to.holdPrevious) {\n      for (let i = 0; i < timelinesCount; i++)\n        timelineMode[i] = propertyIDs.addAll(timelines[i].getPropertyIds()) ? HOLD_FIRST : HOLD_SUBSEQUENT;\n      return;\n    }\n    outer:\n      for (let i = 0; i < timelinesCount; i++) {\n        const timeline = timelines[i];\n        const ids = timeline.getPropertyIds();\n        if (!propertyIDs.addAll(ids))\n          timelineMode[i] = SUBSEQUENT;\n        else if (!to || timeline instanceof AttachmentTimeline || timeline instanceof DrawOrderTimeline || timeline instanceof EventTimeline || !to.animation.hasTimeline(ids)) {\n          timelineMode[i] = FIRST;\n        } else {\n          for (let next = to.mixingTo; next; next = next.mixingTo) {\n            if (next.animation.hasTimeline(ids))\n              continue;\n            if (entry.mixDuration > 0) {\n              timelineMode[i] = HOLD_MIX;\n              timelineHoldMix[i] = next;\n              continue outer;\n            }\n            break;\n          }\n          timelineMode[i] = HOLD_FIRST;\n        }\n      }\n  }\n  /** Returns the track entry for the animation currently playing on the track, or null if no animation is currently playing. */\n  getCurrent(trackIndex) {\n    if (trackIndex >= this.tracks.length)\n      return null;\n    return this.tracks[trackIndex];\n  }\n  /** Adds a listener to receive events for all track entries. */\n  addListener(listener) {\n    if (!listener)\n      throw new Error(\"listener cannot be null.\");\n    this.listeners.push(listener);\n  }\n  /** Removes the listener added with {@link #addListener()}. */\n  removeListener(listener) {\n    const index = this.listeners.indexOf(listener);\n    if (index >= 0)\n      this.listeners.splice(index, 1);\n  }\n  /** Removes all listeners added with {@link #addListener()}. */\n  clearListeners() {\n    this.listeners.length = 0;\n  }\n  /** Discards all listener notifications that have not yet been delivered. This can be useful to call from an\n   * {@link AnimationStateListener} when it is known that further notifications that may have been already queued for delivery\n   * are not wanted because new animations are being set. */\n  clearListenerNotifications() {\n    this.queue.clear();\n  }\n  setAnimationByName(trackIndex, animationName, loop) {\n    if (!_AnimationState.deprecatedWarning1) {\n      _AnimationState.deprecatedWarning1 = true;\n      console.warn(\"Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.\");\n    }\n    this.setAnimation(trackIndex, animationName, loop);\n  }\n  addAnimationByName(trackIndex, animationName, loop, delay) {\n    if (!_AnimationState.deprecatedWarning2) {\n      _AnimationState.deprecatedWarning2 = true;\n      console.warn(\"Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.\");\n    }\n    this.addAnimation(trackIndex, animationName, loop, delay);\n  }\n  hasAnimation(animationName) {\n    const animation = this.data.skeletonData.findAnimation(animationName);\n    return animation !== null;\n  }\n  hasAnimationByName(animationName) {\n    if (!_AnimationState.deprecatedWarning3) {\n      _AnimationState.deprecatedWarning3 = true;\n      console.warn(\"Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.\");\n    }\n    return this.hasAnimation(animationName);\n  }\n};\nlet AnimationState = _AnimationState;\nAnimationState._emptyAnimation = new Animation(\"<empty>\", [], 0);\nAnimationState.deprecatedWarning1 = false;\nAnimationState.deprecatedWarning2 = false;\nAnimationState.deprecatedWarning3 = false;\nconst _TrackEntry = class {\n  constructor() {\n    /** The animation to apply for this track entry. */\n    this.animation = null;\n    this.previous = null;\n    /** The animation queued to start after this animation, or null. `next` makes up a linked list. */\n    this.next = null;\n    /** The track entry for the previous animation when mixing from the previous animation to this animation, or null if no\n     * mixing is currently occuring. When mixing from multiple animations, `mixingFrom` makes up a linked list. */\n    this.mixingFrom = null;\n    /** The track entry for the next animation when mixing from this animation to the next animation, or null if no mixing is\n     * currently occuring. When mixing to multiple animations, `mixingTo` makes up a linked list. */\n    this.mixingTo = null;\n    /** The listener for events generated by this track entry, or null.\n     *\n     * A track entry returned from {@link AnimationState#setAnimation()} is already the current animation\n     * for the track, so the track entry listener {@link AnimationStateListener#start()} will not be called. */\n    this.listener = null;\n    /** The index of the track where this track entry is either current or queued.\n     *\n     * See {@link AnimationState#getCurrent()}. */\n    this.trackIndex = 0;\n    /** If true, the animation will repeat. If false it will not, instead its last frame is applied if played beyond its\n     * duration. */\n    this.loop = false;\n    /** If true, when mixing from the previous animation to this animation, the previous animation is applied as normal instead\n     * of being mixed out.\n     *\n     * When mixing between animations that key the same property, if a lower track also keys that property then the value will\n     * briefly dip toward the lower track value during the mix. This happens because the first animation mixes from 100% to 0%\n     * while the second animation mixes from 0% to 100%. Setting `holdPrevious` to true applies the first animation\n     * at 100% during the mix so the lower track value is overwritten. Such dipping does not occur on the lowest track which\n     * keys the property, only when a higher track also keys the property.\n     *\n     * Snapping will occur if `holdPrevious` is true and this animation does not key all the same properties as the\n     * previous animation. */\n    this.holdPrevious = false;\n    this.reverse = false;\n    this.shortestRotation = false;\n    /** When the mix percentage ({@link #mixTime} / {@link #mixDuration}) is less than the\n     * `eventThreshold`, event timelines are applied while this animation is being mixed out. Defaults to 0, so event\n     * timelines are not applied while this animation is being mixed out. */\n    this.eventThreshold = 0;\n    /** When the mix percentage ({@link #mixtime} / {@link #mixDuration}) is less than the\n     * `attachmentThreshold`, attachment timelines are applied while this animation is being mixed out. Defaults to\n     * 0, so attachment timelines are not applied while this animation is being mixed out. */\n    this.attachmentThreshold = 0;\n    /** When the mix percentage ({@link #mixTime} / {@link #mixDuration}) is less than the\n     * `drawOrderThreshold`, draw order timelines are applied while this animation is being mixed out. Defaults to 0,\n     * so draw order timelines are not applied while this animation is being mixed out. */\n    this.drawOrderThreshold = 0;\n    /** Seconds when this animation starts, both initially and after looping. Defaults to 0.\n     *\n     * When changing the `animationStart` time, it often makes sense to set {@link #animationLast} to the same\n     * value to prevent timeline keys before the start time from triggering. */\n    this.animationStart = 0;\n    /** Seconds for the last frame of this animation. Non-looping animations won't play past this time. Looping animations will\n     * loop back to {@link #animationStart} at this time. Defaults to the animation {@link Animation#duration}. */\n    this.animationEnd = 0;\n    /** The time in seconds this animation was last applied. Some timelines use this for one-time triggers. Eg, when this\n     * animation is applied, event timelines will fire all events between the `animationLast` time (exclusive) and\n     * `animationTime` (inclusive). Defaults to -1 to ensure triggers on frame 0 happen the first time this animation\n     * is applied. */\n    this.animationLast = 0;\n    this.nextAnimationLast = 0;\n    /** Seconds to postpone playing the animation. When this track entry is the current track entry, `delay`\n     * postpones incrementing the {@link #trackTime}. When this track entry is queued, `delay` is the time from\n     * the start of the previous animation to when this track entry will become the current track entry (ie when the previous\n     * track entry {@link TrackEntry#trackTime} >= this track entry's `delay`).\n     *\n     * {@link #timeScale} affects the delay. */\n    this.delay = 0;\n    /** Current time in seconds this track entry has been the current track entry. The track time determines\n     * {@link #animationTime}. The track time can be set to start the animation at a time other than 0, without affecting\n     * looping. */\n    this.trackTime = 0;\n    this.trackLast = 0;\n    this.nextTrackLast = 0;\n    /** The track time in seconds when this animation will be removed from the track. Defaults to the highest possible float\n     * value, meaning the animation will be applied until a new animation is set or the track is cleared. If the track end time\n     * is reached, no other animations are queued for playback, and mixing from any previous animations is complete, then the\n     * properties keyed by the animation are set to the setup pose and the track is cleared.\n     *\n     * It may be desired to use {@link AnimationState#addEmptyAnimation()} rather than have the animation\n     * abruptly cease being applied. */\n    this.trackEnd = 0;\n    /** Multiplier for the delta time when this track entry is updated, causing time for this animation to pass slower or\n     * faster. Defaults to 1.\n     *\n     * {@link #mixTime} is not affected by track entry time scale, so {@link #mixDuration} may need to be adjusted to\n     * match the animation speed.\n     *\n     * When using {@link AnimationState#addAnimation()} with a `delay` <= 0, note the\n     * {@link #delay} is set using the mix duration from the {@link AnimationStateData}, assuming time scale to be 1. If\n     * the time scale is not 1, the delay may need to be adjusted.\n     *\n     * See AnimationState {@link AnimationState#timeScale} for affecting all animations. */\n    this.timeScale = 0;\n    /** Values < 1 mix this animation with the skeleton's current pose (usually the pose resulting from lower tracks). Defaults\n     * to 1, which overwrites the skeleton's current pose with this animation.\n     *\n     * Typically track 0 is used to completely pose the skeleton, then alpha is used on higher tracks. It doesn't make sense to\n     * use alpha on track 0 if the skeleton pose is from the last frame render. */\n    this.alpha = 0;\n    /** Seconds from 0 to the {@link #getMixDuration()} when mixing from the previous animation to this animation. May be\n     * slightly more than `mixDuration` when the mix is complete. */\n    this.mixTime = 0;\n    /** Seconds for mixing from the previous animation to this animation. Defaults to the value provided by AnimationStateData\n     * {@link AnimationStateData#getMix()} based on the animation before this animation (if any).\n     *\n     * A mix duration of 0 still mixes out over one frame to provide the track entry being mixed out a chance to revert the\n     * properties it was animating.\n     *\n     * The `mixDuration` can be set manually rather than use the value from\n     * {@link AnimationStateData#getMix()}. In that case, the `mixDuration` can be set for a new\n     * track entry only before {@link AnimationState#update(float)} is first called.\n     *\n     * When using {@link AnimationState#addAnimation()} with a `delay` <= 0, note the\n     * {@link #delay} is set using the mix duration from the {@link AnimationStateData}, not a mix duration set\n     * afterward. */\n    this.mixDuration = 0;\n    this.interruptAlpha = 0;\n    this.totalAlpha = 0;\n    /** Controls how properties keyed in the animation are mixed with lower tracks. Defaults to {@link MixBlend#replace}, which\n     * replaces the values from the lower tracks with the animation values. {@link MixBlend#add} adds the animation values to\n     * the values from the lower tracks.\n     *\n     * The `mixBlend` can be set for a new track entry only before {@link AnimationState#apply()} is first\n     * called. */\n    this.mixBlend = MixBlend.replace;\n    this.timelineMode = new Array();\n    this.timelineHoldMix = new Array();\n    this.timelinesRotation = new Array();\n  }\n  reset() {\n    this.next = null;\n    this.previous = null;\n    this.mixingFrom = null;\n    this.mixingTo = null;\n    this.animation = null;\n    this.listener = null;\n    this.timelineMode.length = 0;\n    this.timelineHoldMix.length = 0;\n    this.timelinesRotation.length = 0;\n  }\n  /** Uses {@link #trackTime} to compute the `animationTime`, which is between {@link #animationStart}\n   * and {@link #animationEnd}. When the `trackTime` is 0, the `animationTime` is equal to the\n   * `animationStart` time. */\n  getAnimationTime() {\n    if (this.loop) {\n      const duration = this.animationEnd - this.animationStart;\n      if (duration == 0)\n        return this.animationStart;\n      return this.trackTime % duration + this.animationStart;\n    }\n    return Math.min(this.trackTime + this.animationStart, this.animationEnd);\n  }\n  setAnimationLast(animationLast) {\n    this.animationLast = animationLast;\n    this.nextAnimationLast = animationLast;\n  }\n  /** Returns true if at least one loop has been completed.\n   *\n   * See {@link AnimationStateListener#complete()}. */\n  isComplete() {\n    return this.trackTime >= this.animationEnd - this.animationStart;\n  }\n  /** Resets the rotation directions for mixing this entry's rotate timelines. This can be useful to avoid bones rotating the\n   * long way around when using {@link #alpha} and starting animations on other tracks.\n   *\n   * Mixing with {@link MixBlend#replace} involves finding a rotation between two others, which has two possible solutions:\n   * the short way or the long way around. The two rotations likely change over time, so which direction is the short or long\n   * way also changes. If the short way was always chosen, bones would flip to the other side when that direction became the\n   * long way. TrackEntry chooses the short way the first time it is applied and remembers that direction. */\n  resetRotationDirections() {\n    this.timelinesRotation.length = 0;\n  }\n  getTrackComplete() {\n    const duration = this.animationEnd - this.animationStart;\n    if (duration != 0) {\n      if (this.loop)\n        return duration * (1 + (this.trackTime / duration | 0));\n      if (this.trackTime < duration)\n        return duration;\n    }\n    return this.trackTime;\n  }\n  get time() {\n    if (!_TrackEntry.deprecatedWarning1) {\n      _TrackEntry.deprecatedWarning1 = true;\n      console.warn(\"Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.\");\n    }\n    return this.trackTime;\n  }\n  set time(value) {\n    if (!_TrackEntry.deprecatedWarning1) {\n      _TrackEntry.deprecatedWarning1 = true;\n      console.warn(\"Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.\");\n    }\n    this.trackTime = value;\n  }\n  get endTime() {\n    if (!_TrackEntry.deprecatedWarning2) {\n      _TrackEntry.deprecatedWarning2 = true;\n      console.warn(\"Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.\");\n    }\n    return this.trackTime;\n  }\n  set endTime(value) {\n    if (!_TrackEntry.deprecatedWarning2) {\n      _TrackEntry.deprecatedWarning2 = true;\n      console.warn(\"Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.\");\n    }\n    this.trackTime = value;\n  }\n  loopsCount() {\n    return Math.floor(this.trackTime / this.trackEnd);\n  }\n};\nlet TrackEntry = _TrackEntry;\nTrackEntry.deprecatedWarning1 = false;\nTrackEntry.deprecatedWarning2 = false;\nclass EventQueue {\n  constructor(animState) {\n    this.objects = [];\n    this.drainDisabled = false;\n    this.animState = animState;\n  }\n  start(entry) {\n    this.objects.push(EventType.start);\n    this.objects.push(entry);\n    this.animState.animationsChanged = true;\n  }\n  interrupt(entry) {\n    this.objects.push(EventType.interrupt);\n    this.objects.push(entry);\n  }\n  end(entry) {\n    this.objects.push(EventType.end);\n    this.objects.push(entry);\n    this.animState.animationsChanged = true;\n  }\n  dispose(entry) {\n    this.objects.push(EventType.dispose);\n    this.objects.push(entry);\n  }\n  complete(entry) {\n    this.objects.push(EventType.complete);\n    this.objects.push(entry);\n  }\n  event(entry, event) {\n    this.objects.push(EventType.event);\n    this.objects.push(entry);\n    this.objects.push(event);\n  }\n  drain() {\n    if (this.drainDisabled)\n      return;\n    this.drainDisabled = true;\n    const objects = this.objects;\n    const listeners = this.animState.listeners;\n    for (let i = 0; i < objects.length; i += 2) {\n      const type = objects[i];\n      const entry = objects[i + 1];\n      switch (type) {\n        case EventType.start:\n          if (entry.listener && entry.listener.start)\n            entry.listener.start(entry);\n          for (let ii = 0; ii < listeners.length; ii++) {\n            const listener = listeners[ii];\n            if (listener.start)\n              listener.start(entry);\n          }\n          break;\n        case EventType.interrupt:\n          if (entry.listener && entry.listener.interrupt)\n            entry.listener.interrupt(entry);\n          for (let ii = 0; ii < listeners.length; ii++) {\n            const listener = listeners[ii];\n            if (listener.interrupt)\n              listener.interrupt(entry);\n          }\n          break;\n        case EventType.end:\n          if (entry.listener && entry.listener.end)\n            entry.listener.end(entry);\n          for (let ii = 0; ii < listeners.length; ii++) {\n            const listener = listeners[ii];\n            if (listener.end)\n              listener.end(entry);\n          }\n        case EventType.dispose:\n          if (entry.listener && entry.listener.dispose)\n            entry.listener.dispose(entry);\n          for (let ii = 0; ii < listeners.length; ii++) {\n            const listener = listeners[ii];\n            if (listener.dispose)\n              listener.dispose(entry);\n          }\n          this.animState.trackEntryPool.free(entry);\n          break;\n        case EventType.complete:\n          if (entry.listener && entry.listener.complete)\n            entry.listener.complete(entry);\n          for (let ii = 0; ii < listeners.length; ii++) {\n            const listener = listeners[ii];\n            if (listener.complete)\n              listener.complete(entry);\n          }\n          break;\n        case EventType.event:\n          const event = objects[i++ + 2];\n          if (entry.listener && entry.listener.event)\n            entry.listener.event(entry, event);\n          for (let ii = 0; ii < listeners.length; ii++) {\n            const listener = listeners[ii];\n            if (listener.event)\n              listener.event(entry, event);\n          }\n          break;\n      }\n    }\n    this.clear();\n    this.drainDisabled = false;\n  }\n  clear() {\n    this.objects.length = 0;\n  }\n}\nvar EventType = /* @__PURE__ */ ((EventType2) => {\n  EventType2[EventType2[\"start\"] = 0] = \"start\";\n  EventType2[EventType2[\"interrupt\"] = 1] = \"interrupt\";\n  EventType2[EventType2[\"end\"] = 2] = \"end\";\n  EventType2[EventType2[\"dispose\"] = 3] = \"dispose\";\n  EventType2[EventType2[\"complete\"] = 4] = \"complete\";\n  EventType2[EventType2[\"event\"] = 5] = \"event\";\n  return EventType2;\n})(EventType || {});\nclass AnimationStateAdapter {\n  start(entry) {\n  }\n  interrupt(entry) {\n  }\n  end(entry) {\n  }\n  dispose(entry) {\n  }\n  complete(entry) {\n  }\n  event(entry, event) {\n  }\n}\nconst SUBSEQUENT = 0;\nconst FIRST = 1;\nconst HOLD_SUBSEQUENT = 2;\nconst HOLD_FIRST = 3;\nconst HOLD_MIX = 4;\nconst SETUP = 1;\nconst CURRENT = 2;\n\nexport { AnimationState, AnimationStateAdapter, EventQueue, EventType, TrackEntry };\n//# sourceMappingURL=AnimationState.mjs.map\n","class AnimationStateData {\n  constructor(skeletonData) {\n    this.animationToMixTime = {};\n    /** The mix duration to use when no mix duration has been defined between two animations. */\n    this.defaultMix = 0;\n    if (!skeletonData)\n      throw new Error(\"skeletonData cannot be null.\");\n    this.skeletonData = skeletonData;\n  }\n  /** Sets a mix duration by animation name.\n   *\n   * See {@link #setMixWith()}. */\n  setMix(fromName, toName, duration) {\n    const from = this.skeletonData.findAnimation(fromName);\n    if (!from)\n      throw new Error(`Animation not found: ${fromName}`);\n    const to = this.skeletonData.findAnimation(toName);\n    if (!to)\n      throw new Error(`Animation not found: ${toName}`);\n    this.setMixWith(from, to, duration);\n  }\n  /** Sets the mix duration when changing from the specified animation to the other.\n   *\n   * See {@link TrackEntry#mixDuration}. */\n  setMixWith(from, to, duration) {\n    if (!from)\n      throw new Error(\"from cannot be null.\");\n    if (!to)\n      throw new Error(\"to cannot be null.\");\n    const key = `${from.name}.${to.name}`;\n    this.animationToMixTime[key] = duration;\n  }\n  /** Returns the mix duration to use when changing from the specified animation to the other, or the {@link #defaultMix} if\n   * no mix duration has been set. */\n  getMix(from, to) {\n    const key = `${from.name}.${to.name}`;\n    const value = this.animationToMixTime[key];\n    return value === void 0 ? this.defaultMix : value;\n  }\n}\n\nexport { AnimationStateData };\n//# sourceMappingURL=AnimationStateData.mjs.map\n","import './attachments/Attachment.mjs';\nimport { BoundingBoxAttachment } from './attachments/BoundingBoxAttachment.mjs';\nimport { ClippingAttachment } from './attachments/ClippingAttachment.mjs';\nimport { MeshAttachment } from './attachments/MeshAttachment.mjs';\nimport { PathAttachment } from './attachments/PathAttachment.mjs';\nimport { PointAttachment } from './attachments/PointAttachment.mjs';\nimport { RegionAttachment } from './attachments/RegionAttachment.mjs';\nimport './attachments/Sequence.mjs';\n\nclass AtlasAttachmentLoader {\n  constructor(atlas) {\n    this.atlas = atlas;\n  }\n  loadSequence(name, basePath, sequence) {\n    const regions = sequence.regions;\n    for (let i = 0, n = regions.length; i < n; i++) {\n      const path = sequence.getPath(basePath, i);\n      const region = this.atlas.findRegion(path);\n      if (region == null)\n        throw new Error(`Region not found in atlas: ${path} (sequence: ${name})`);\n      regions[i] = region;\n      regions[i].renderObject = regions[i];\n    }\n  }\n  newRegionAttachment(skin, name, path, sequence) {\n    const attachment = new RegionAttachment(name, path);\n    if (sequence != null) {\n      this.loadSequence(name, path, sequence);\n    } else {\n      const region = this.atlas.findRegion(path);\n      if (!region)\n        throw new Error(`Region not found in atlas: ${path} (region attachment: ${name})`);\n      region.renderObject = region;\n      attachment.region = region;\n    }\n    return attachment;\n  }\n  newMeshAttachment(skin, name, path, sequence) {\n    const attachment = new MeshAttachment(name, path);\n    if (sequence != null) {\n      this.loadSequence(name, path, sequence);\n    } else {\n      const region = this.atlas.findRegion(path);\n      if (!region)\n        throw new Error(`Region not found in atlas: ${path} (mesh attachment: ${name})`);\n      region.renderObject = region;\n      attachment.region = region;\n    }\n    return attachment;\n  }\n  newBoundingBoxAttachment(skin, name) {\n    return new BoundingBoxAttachment(name);\n  }\n  newPathAttachment(skin, name) {\n    return new PathAttachment(name);\n  }\n  newPointAttachment(skin, name) {\n    return new PointAttachment(name);\n  }\n  newClippingAttachment(skin, name) {\n    return new ClippingAttachment(name);\n  }\n}\n\nexport { AtlasAttachmentLoader };\n//# sourceMappingURL=AtlasAttachmentLoader.mjs.map\n","import { Matrix } from '@pixi/core';\nimport { settings, MathUtils, TransformMode } from '@pixi-spine/base';\n\nclass Bone {\n  /** @param parent May be null. */\n  constructor(data, skeleton, parent) {\n    // be careful! Spine b,c is c,b in pixi matrix\n    this.matrix = new Matrix();\n    /** The parent bone, or null if this is the root bone. */\n    this.parent = null;\n    /** The immediate children of this bone. */\n    this.children = new Array();\n    /** The local x translation. */\n    this.x = 0;\n    /** The local y translation. */\n    this.y = 0;\n    /** The local rotation in degrees, counter clockwise. */\n    this.rotation = 0;\n    /** The local scaleX. */\n    this.scaleX = 0;\n    /** The local scaleY. */\n    this.scaleY = 0;\n    /** The local shearX. */\n    this.shearX = 0;\n    /** The local shearY. */\n    this.shearY = 0;\n    /** The applied local x translation. */\n    this.ax = 0;\n    /** The applied local y translation. */\n    this.ay = 0;\n    /** The applied local rotation in degrees, counter clockwise. */\n    this.arotation = 0;\n    /** The applied local scaleX. */\n    this.ascaleX = 0;\n    /** The applied local scaleY. */\n    this.ascaleY = 0;\n    /** The applied local shearX. */\n    this.ashearX = 0;\n    /** The applied local shearY. */\n    this.ashearY = 0;\n    this.sorted = false;\n    this.active = false;\n    if (!data)\n      throw new Error(\"data cannot be null.\");\n    if (!skeleton)\n      throw new Error(\"skeleton cannot be null.\");\n    this.data = data;\n    this.skeleton = skeleton;\n    this.parent = parent;\n    this.setToSetupPose();\n  }\n  get worldX() {\n    return this.matrix.tx;\n  }\n  get worldY() {\n    return this.matrix.ty;\n  }\n  /** Returns false when the bone has not been computed because {@link BoneData#skinRequired} is true and the\n   * {@link Skeleton#skin active skin} does not {@link Skin#bones contain} this bone. */\n  isActive() {\n    return this.active;\n  }\n  /** Computes the world transform using the parent bone and this bone's local applied transform. */\n  update() {\n    this.updateWorldTransformWith(this.ax, this.ay, this.arotation, this.ascaleX, this.ascaleY, this.ashearX, this.ashearY);\n  }\n  /** Computes the world transform using the parent bone and this bone's local transform.\n   *\n   * See {@link #updateWorldTransformWith()}. */\n  updateWorldTransform() {\n    this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\n  }\n  /** Computes the world transform using the parent bone and the specified local transform. The applied transform is set to the\n   * specified local transform. Child bones are not updated.\n   *\n   * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine\n   * Runtimes Guide. */\n  updateWorldTransformWith(x, y, rotation, scaleX, scaleY, shearX, shearY) {\n    this.ax = x;\n    this.ay = y;\n    this.arotation = rotation;\n    this.ascaleX = scaleX;\n    this.ascaleY = scaleY;\n    this.ashearX = shearX;\n    this.ashearY = shearY;\n    const parent = this.parent;\n    const m = this.matrix;\n    const sx = this.skeleton.scaleX;\n    const sy = settings.yDown ? -this.skeleton.scaleY : this.skeleton.scaleY;\n    if (!parent) {\n      const skeleton = this.skeleton;\n      const rotationY = rotation + 90 + shearY;\n      m.a = MathUtils.cosDeg(rotation + shearX) * scaleX * sx;\n      m.c = MathUtils.cosDeg(rotationY) * scaleY * sx;\n      m.b = MathUtils.sinDeg(rotation + shearX) * scaleX * sy;\n      m.d = MathUtils.sinDeg(rotationY) * scaleY * sy;\n      m.tx = x * sx + skeleton.x;\n      m.ty = y * sy + skeleton.y;\n      return;\n    }\n    let pa = parent.matrix.a;\n    let pb = parent.matrix.c;\n    let pc = parent.matrix.b;\n    let pd = parent.matrix.d;\n    m.tx = pa * x + pb * y + parent.matrix.tx;\n    m.ty = pc * x + pd * y + parent.matrix.ty;\n    switch (this.data.transformMode) {\n      case TransformMode.Normal: {\n        const rotationY = rotation + 90 + shearY;\n        const la = MathUtils.cosDeg(rotation + shearX) * scaleX;\n        const lb = MathUtils.cosDeg(rotationY) * scaleY;\n        const lc = MathUtils.sinDeg(rotation + shearX) * scaleX;\n        const ld = MathUtils.sinDeg(rotationY) * scaleY;\n        m.a = pa * la + pb * lc;\n        m.c = pa * lb + pb * ld;\n        m.b = pc * la + pd * lc;\n        m.d = pc * lb + pd * ld;\n        return;\n      }\n      case TransformMode.OnlyTranslation: {\n        const rotationY = rotation + 90 + shearY;\n        m.a = MathUtils.cosDeg(rotation + shearX) * scaleX;\n        m.c = MathUtils.cosDeg(rotationY) * scaleY;\n        m.b = MathUtils.sinDeg(rotation + shearX) * scaleX;\n        m.d = MathUtils.sinDeg(rotationY) * scaleY;\n        break;\n      }\n      case TransformMode.NoRotationOrReflection: {\n        let s = pa * pa + pc * pc;\n        let prx = 0;\n        if (s > 1e-4) {\n          s = Math.abs(pa * pd - pb * pc) / s;\n          pa /= sx;\n          pc /= sy;\n          pb = pc * s;\n          pd = pa * s;\n          prx = Math.atan2(pc, pa) * MathUtils.radDeg;\n        } else {\n          pa = 0;\n          pc = 0;\n          prx = 90 - Math.atan2(pd, pb) * MathUtils.radDeg;\n        }\n        const rx = rotation + shearX - prx;\n        const ry = rotation + shearY - prx + 90;\n        const la = MathUtils.cosDeg(rx) * scaleX;\n        const lb = MathUtils.cosDeg(ry) * scaleY;\n        const lc = MathUtils.sinDeg(rx) * scaleX;\n        const ld = MathUtils.sinDeg(ry) * scaleY;\n        m.a = pa * la - pb * lc;\n        m.c = pa * lb - pb * ld;\n        m.b = pc * la + pd * lc;\n        m.d = pc * lb + pd * ld;\n        break;\n      }\n      case TransformMode.NoScale:\n      case TransformMode.NoScaleOrReflection: {\n        const cos = MathUtils.cosDeg(rotation);\n        const sin = MathUtils.sinDeg(rotation);\n        let za = (pa * cos + pb * sin) / sx;\n        let zc = (pc * cos + pd * sin) / sy;\n        let s = Math.sqrt(za * za + zc * zc);\n        if (s > 1e-5)\n          s = 1 / s;\n        za *= s;\n        zc *= s;\n        s = Math.sqrt(za * za + zc * zc);\n        if (this.data.transformMode == TransformMode.NoScale && pa * pd - pb * pc < 0 != (sx < 0 != sy < 0))\n          s = -s;\n        const r = Math.PI / 2 + Math.atan2(zc, za);\n        const zb = Math.cos(r) * s;\n        const zd = Math.sin(r) * s;\n        const la = MathUtils.cosDeg(shearX) * scaleX;\n        const lb = MathUtils.cosDeg(90 + shearY) * scaleY;\n        const lc = MathUtils.sinDeg(shearX) * scaleX;\n        const ld = MathUtils.sinDeg(90 + shearY) * scaleY;\n        m.a = za * la + zb * lc;\n        m.c = za * lb + zb * ld;\n        m.b = zc * la + zd * lc;\n        m.d = zc * lb + zd * ld;\n        break;\n      }\n    }\n    m.a *= sx;\n    m.c *= sx;\n    m.b *= sy;\n    m.d *= sy;\n  }\n  /** Sets this bone's local transform to the setup pose. */\n  setToSetupPose() {\n    const data = this.data;\n    this.x = data.x;\n    this.y = data.y;\n    this.rotation = data.rotation;\n    this.scaleX = data.scaleX;\n    this.scaleY = data.scaleY;\n    this.shearX = data.shearX;\n    this.shearY = data.shearY;\n  }\n  /** The world rotation for the X axis, calculated using {@link #a} and {@link #c}. */\n  getWorldRotationX() {\n    return Math.atan2(this.matrix.b, this.matrix.a) * MathUtils.radDeg;\n  }\n  /** The world rotation for the Y axis, calculated using {@link #b} and {@link #d}. */\n  getWorldRotationY() {\n    return Math.atan2(this.matrix.d, this.matrix.c) * MathUtils.radDeg;\n  }\n  /** The magnitude (always positive) of the world scale X, calculated using {@link #a} and {@link #c}. */\n  getWorldScaleX() {\n    const m = this.matrix;\n    return Math.sqrt(m.a * m.a + m.b * m.b);\n  }\n  /** The magnitude (always positive) of the world scale Y, calculated using {@link #b} and {@link #d}. */\n  getWorldScaleY() {\n    const m = this.matrix;\n    return Math.sqrt(m.c * m.c + m.d * m.d);\n  }\n  /** Computes the applied transform values from the world transform.\n   *\n   * If the world transform is modified (by a constraint, {@link #rotateWorld(float)}, etc) then this method should be called so\n   * the applied transform matches the world transform. The applied transform may be needed by other code (eg to apply other\n   * constraints).\n   *\n   * Some information is ambiguous in the world transform, such as -1,-1 scale versus 180 rotation. The applied transform after\n   * calling this method is equivalent to the local transform used to compute the world transform, but may not be identical. */\n  updateAppliedTransform() {\n    const parent = this.parent;\n    const m = this.matrix;\n    if (!parent) {\n      this.ax = m.tx - this.skeleton.x;\n      this.ay = m.ty - this.skeleton.y;\n      this.arotation = Math.atan2(m.b, m.a) * MathUtils.radDeg;\n      this.ascaleX = Math.sqrt(m.a * m.a + m.b * m.b);\n      this.ascaleY = Math.sqrt(m.c * m.c + m.d * m.d);\n      this.ashearX = 0;\n      this.ashearY = Math.atan2(m.a * m.c + m.b * m.d, m.a * m.d - m.b * m.c) * MathUtils.radDeg;\n      return;\n    }\n    const pm = parent.matrix;\n    const pid = 1 / (pm.a * pm.d - pm.b * pm.c);\n    const dx = m.tx - pm.tx;\n    const dy = m.ty - pm.ty;\n    this.ax = dx * pm.d * pid - dy * pm.c * pid;\n    this.ay = dy * pm.a * pid - dx * pm.b * pid;\n    const ia = pid * pm.d;\n    const id = pid * pm.a;\n    const ib = pid * pm.c;\n    const ic = pid * pm.b;\n    const ra = ia * m.a - ib * m.b;\n    const rb = ia * m.c - ib * m.d;\n    const rc = id * m.b - ic * m.a;\n    const rd = id * m.d - ic * m.c;\n    this.ashearX = 0;\n    this.ascaleX = Math.sqrt(ra * ra + rc * rc);\n    if (this.ascaleX > 1e-4) {\n      const det = ra * rd - rb * rc;\n      this.ascaleY = det / this.ascaleX;\n      this.ashearY = Math.atan2(ra * rb + rc * rd, det) * MathUtils.radDeg;\n      this.arotation = Math.atan2(rc, ra) * MathUtils.radDeg;\n    } else {\n      this.ascaleX = 0;\n      this.ascaleY = Math.sqrt(rb * rb + rd * rd);\n      this.ashearY = 0;\n      this.arotation = 90 - Math.atan2(rd, rb) * MathUtils.radDeg;\n    }\n  }\n  /** Transforms a point from world coordinates to the bone's local coordinates. */\n  worldToLocal(world) {\n    const m = this.matrix;\n    const a = m.a;\n    const b = m.c;\n    const c = m.b;\n    const d = m.d;\n    const invDet = 1 / (a * d - b * c);\n    const x = world.x - m.tx;\n    const y = world.y - m.ty;\n    world.x = x * d * invDet - y * b * invDet;\n    world.y = y * a * invDet - x * c * invDet;\n    return world;\n  }\n  /** Transforms a point from the bone's local coordinates to world coordinates. */\n  localToWorld(local) {\n    const m = this.matrix;\n    const x = local.x;\n    const y = local.y;\n    local.x = x * m.a + y * m.c + m.tx;\n    local.y = x * m.b + y * m.d + m.ty;\n    return local;\n  }\n  /** Transforms a world rotation to a local rotation. */\n  worldToLocalRotation(worldRotation) {\n    const sin = MathUtils.sinDeg(worldRotation);\n    const cos = MathUtils.cosDeg(worldRotation);\n    const mat = this.matrix;\n    return Math.atan2(mat.a * sin - mat.b * cos, mat.d * cos - mat.c * sin) * MathUtils.radDeg;\n  }\n  /** Transforms a local rotation to a world rotation. */\n  localToWorldRotation(localRotation) {\n    localRotation -= this.rotation - this.shearX;\n    const sin = MathUtils.sinDeg(localRotation);\n    const cos = MathUtils.cosDeg(localRotation);\n    const mat = this.matrix;\n    return Math.atan2(cos * mat.b + sin * mat.d, cos * mat.a + sin * mat.c) * MathUtils.radDeg;\n  }\n  /** Rotates the world transform the specified amount.\n   * <p>\n   * After changes are made to the world transform, {@link #updateAppliedTransform()} should be called and {@link #update()} will\n   * need to be called on any child bones, recursively. */\n  rotateWorld(degrees) {\n    const mat = this.matrix;\n    const a = mat.a;\n    const b = mat.c;\n    const c = mat.b;\n    const d = mat.d;\n    const cos = MathUtils.cosDeg(degrees);\n    const sin = MathUtils.sinDeg(degrees);\n    mat.a = cos * a - sin * c;\n    mat.c = cos * b - sin * d;\n    mat.b = sin * a + cos * c;\n    mat.d = sin * b + cos * d;\n  }\n}\n\nexport { Bone };\n//# sourceMappingURL=Bone.mjs.map\n","import { TransformMode, Color } from '@pixi-spine/base';\n\nclass BoneData {\n  constructor(index, name, parent) {\n    /** The index of the bone in {@link Skeleton#getBones()}. */\n    this.index = 0;\n    /** @returns May be null. */\n    this.parent = null;\n    /** The bone's length. */\n    this.length = 0;\n    /** The local x translation. */\n    this.x = 0;\n    /** The local y translation. */\n    this.y = 0;\n    /** The local rotation. */\n    this.rotation = 0;\n    /** The local scaleX. */\n    this.scaleX = 1;\n    /** The local scaleY. */\n    this.scaleY = 1;\n    /** The local shearX. */\n    this.shearX = 0;\n    /** The local shearX. */\n    this.shearY = 0;\n    /** The transform mode for how parent world transforms affect this bone. */\n    this.transformMode = TransformMode.Normal;\n    /** When true, {@link Skeleton#updateWorldTransform()} only updates this bone if the {@link Skeleton#skin} contains this\n     * bone.\n     * @see Skin#bones */\n    this.skinRequired = false;\n    /** The color of the bone as it was in Spine. Available only when nonessential data was exported. Bones are not usually\n     * rendered at runtime. */\n    this.color = new Color();\n    if (index < 0)\n      throw new Error(\"index must be >= 0.\");\n    if (!name)\n      throw new Error(\"name cannot be null.\");\n    this.index = index;\n    this.name = name;\n    this.parent = parent;\n  }\n}\n\nexport { BoneData };\n//# sourceMappingURL=BoneData.mjs.map\n","class ConstraintData {\n  constructor(name, order, skinRequired) {\n    this.name = name;\n    this.order = order;\n    this.skinRequired = skinRequired;\n  }\n}\n\nexport { ConstraintData };\n//# sourceMappingURL=ConstraintData.mjs.map\n","class Event {\n  constructor(time, data) {\n    this.intValue = 0;\n    this.floatValue = 0;\n    this.stringValue = null;\n    this.time = 0;\n    this.volume = 0;\n    this.balance = 0;\n    if (!data)\n      throw new Error(\"data cannot be null.\");\n    this.time = time;\n    this.data = data;\n  }\n}\n\nexport { Event };\n//# sourceMappingURL=Event.mjs.map\n","class EventData {\n  constructor(name) {\n    this.intValue = 0;\n    this.floatValue = 0;\n    this.stringValue = null;\n    this.audioPath = null;\n    this.volume = 0;\n    this.balance = 0;\n    this.name = name;\n  }\n}\n\nexport { EventData };\n//# sourceMappingURL=EventData.mjs.map\n","import { settings, TransformMode, MathUtils } from '@pixi-spine/base';\n\nclass IkConstraint {\n  constructor(data, skeleton) {\n    /** Controls the bend direction of the IK bones, either 1 or -1. */\n    this.bendDirection = 0;\n    /** When true and only a single bone is being constrained, if the target is too close, the bone is scaled to reach it. */\n    this.compress = false;\n    /** When true, if the target is out of range, the parent bone is scaled to reach it. If more than one bone is being constrained\n     * and the parent bone has local nonuniform scale, stretch is not applied. */\n    this.stretch = false;\n    /** A percentage (0-1) that controls the mix between the constrained and unconstrained rotations. */\n    this.mix = 1;\n    /** For two bone IK, the distance from the maximum reach of the bones that rotation will slow. */\n    this.softness = 0;\n    this.active = false;\n    if (!data)\n      throw new Error(\"data cannot be null.\");\n    if (!skeleton)\n      throw new Error(\"skeleton cannot be null.\");\n    this.data = data;\n    this.mix = data.mix;\n    this.softness = data.softness;\n    this.bendDirection = data.bendDirection;\n    this.compress = data.compress;\n    this.stretch = data.stretch;\n    this.bones = new Array();\n    for (let i = 0; i < data.bones.length; i++) {\n      const bone = skeleton.findBone(data.bones[i].name);\n      if (!bone)\n        throw new Error(`Couldn't find bone ${data.bones[i].name}`);\n      this.bones.push(bone);\n    }\n    const target = skeleton.findBone(data.target.name);\n    if (!target)\n      throw new Error(`Couldn't find bone ${data.target.name}`);\n    this.target = target;\n  }\n  isActive() {\n    return this.active;\n  }\n  update() {\n    if (this.mix == 0)\n      return;\n    const target = this.target;\n    const bones = this.bones;\n    switch (bones.length) {\n      case 1:\n        this.apply1(bones[0], target.worldX, target.worldY, this.compress, this.stretch, this.data.uniform, this.mix);\n        break;\n      case 2:\n        this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.stretch, this.data.uniform, this.softness, this.mix);\n        break;\n    }\n  }\n  /** Applies 1 bone IK. The target is specified in the world coordinate system. */\n  apply1(bone, targetX, targetY, compress, stretch, uniform, alpha) {\n    const p = bone.parent.matrix;\n    if (!p)\n      throw new Error(\"IK bone must have parent.\");\n    const pa = p.a;\n    let pb = p.c;\n    const pc = p.b;\n    let pd = p.d;\n    let rotationIK = -bone.ashearX - bone.arotation;\n    let tx = 0;\n    let ty = 0;\n    const skelX = bone.skeleton.scaleX;\n    const skelY = settings.yDown ? -bone.skeleton.scaleY : bone.skeleton.scaleY;\n    switch (bone.data.transformMode) {\n      case TransformMode.OnlyTranslation:\n        tx = targetX - bone.worldX;\n        ty = targetY - bone.worldY;\n        if (settings.yDown) {\n          ty = -ty;\n        }\n        break;\n      case TransformMode.NoRotationOrReflection:\n        const s = Math.abs(pa * pd - pb * pc) / (pa * pa + pc * pc);\n        const sa = pa / skelX;\n        const sc = pc / skelY;\n        pb = -sc * s * skelX;\n        pd = sa * s * skelY;\n        rotationIK += Math.atan2(sc, sa) * MathUtils.radDeg;\n      default:\n        const x = targetX - p.tx;\n        const y = targetY - p.ty;\n        const d = pa * pd - pb * pc;\n        tx = (x * pd - y * pb) / d - bone.ax;\n        ty = (y * pa - x * pc) / d - bone.ay;\n    }\n    rotationIK += Math.atan2(ty, tx) * MathUtils.radDeg;\n    if (bone.ascaleX < 0)\n      rotationIK += 180;\n    if (rotationIK > 180)\n      rotationIK -= 360;\n    else if (rotationIK < -180)\n      rotationIK += 360;\n    let sx = bone.ascaleX;\n    let sy = bone.ascaleY;\n    if (compress || stretch) {\n      switch (bone.data.transformMode) {\n        case TransformMode.NoScale:\n        case TransformMode.NoScaleOrReflection:\n          tx = targetX - bone.worldX;\n          ty = targetY - bone.worldY;\n      }\n      const b = bone.data.length * sx;\n      const dd = Math.sqrt(tx * tx + ty * ty);\n      if (compress && dd < b || stretch && dd > b && b > 1e-4) {\n        const s = (dd / b - 1) * alpha + 1;\n        sx *= s;\n        if (uniform)\n          sy *= s;\n      }\n    }\n    bone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, sx, sy, bone.ashearX, bone.ashearY);\n  }\n  /** Applies 2 bone IK. The target is specified in the world coordinate system.\n   * @param child A direct descendant of the parent bone. */\n  apply2(parent, child, targetX, targetY, bendDir, stretch, uniform, softness, alpha) {\n    const px = parent.ax;\n    const py = parent.ay;\n    let psx = parent.ascaleX;\n    let psy = parent.ascaleY;\n    let sx = psx;\n    let sy = psy;\n    let csx = child.ascaleX;\n    const pmat = parent.matrix;\n    let os1 = 0;\n    let os2 = 0;\n    let s2 = 0;\n    if (psx < 0) {\n      psx = -psx;\n      os1 = 180;\n      s2 = -1;\n    } else {\n      os1 = 0;\n      s2 = 1;\n    }\n    if (psy < 0) {\n      psy = -psy;\n      s2 = -s2;\n    }\n    if (csx < 0) {\n      csx = -csx;\n      os2 = 180;\n    } else\n      os2 = 0;\n    const cx = child.ax;\n    let cy = 0;\n    let cwx = 0;\n    let cwy = 0;\n    let a = pmat.a;\n    let b = pmat.c;\n    let c = pmat.b;\n    let d = pmat.d;\n    const u = Math.abs(psx - psy) <= 1e-4;\n    if (!u || stretch) {\n      cy = 0;\n      cwx = a * cx + pmat.tx;\n      cwy = c * cx + pmat.ty;\n    } else {\n      cy = child.ay;\n      cwx = a * cx + b * cy + pmat.tx;\n      cwy = c * cx + d * cy + pmat.ty;\n    }\n    const pp = parent.parent.matrix;\n    if (!pp)\n      throw new Error(\"IK parent must itself have a parent.\");\n    a = pp.a;\n    b = pp.c;\n    c = pp.b;\n    d = pp.d;\n    const id = 1 / (a * d - b * c);\n    let x = cwx - pp.tx;\n    let y = cwy - pp.ty;\n    const dx = (x * d - y * b) * id - px;\n    const dy = (y * a - x * c) * id - py;\n    const l1 = Math.sqrt(dx * dx + dy * dy);\n    let l2 = child.data.length * csx;\n    let a1;\n    let a2;\n    if (l1 < 1e-4) {\n      this.apply1(parent, targetX, targetY, false, stretch, false, alpha);\n      child.updateWorldTransformWith(cx, cy, 0, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\n      return;\n    }\n    x = targetX - pp.tx;\n    y = targetY - pp.ty;\n    let tx = (x * d - y * b) * id - px;\n    let ty = (y * a - x * c) * id - py;\n    let dd = tx * tx + ty * ty;\n    if (softness != 0) {\n      softness *= psx * (csx + 1) * 0.5;\n      const td = Math.sqrt(dd);\n      const sd = td - l1 - l2 * psx + softness;\n      if (sd > 0) {\n        let p = Math.min(1, sd / (softness * 2)) - 1;\n        p = (sd - softness * (1 - p * p)) / td;\n        tx -= p * tx;\n        ty -= p * ty;\n        dd = tx * tx + ty * ty;\n      }\n    }\n    outer:\n      if (u) {\n        l2 *= psx;\n        let cos = (dd - l1 * l1 - l2 * l2) / (2 * l1 * l2);\n        if (cos < -1) {\n          cos = -1;\n          a2 = Math.PI * bendDir;\n        } else if (cos > 1) {\n          cos = 1;\n          a2 = 0;\n          if (stretch) {\n            a = (Math.sqrt(dd) / (l1 + l2) - 1) * alpha + 1;\n            sx *= a;\n            if (uniform)\n              sy *= a;\n          }\n        } else\n          a2 = Math.acos(cos) * bendDir;\n        a = l1 + l2 * cos;\n        b = l2 * Math.sin(a2);\n        a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);\n      } else {\n        a = psx * l2;\n        b = psy * l2;\n        const aa = a * a;\n        const bb = b * b;\n        const ta = Math.atan2(ty, tx);\n        c = bb * l1 * l1 + aa * dd - aa * bb;\n        const c1 = -2 * bb * l1;\n        const c2 = bb - aa;\n        d = c1 * c1 - 4 * c2 * c;\n        if (d >= 0) {\n          let q = Math.sqrt(d);\n          if (c1 < 0)\n            q = -q;\n          q = -(c1 + q) * 0.5;\n          const r0 = q / c2;\n          const r1 = c / q;\n          const r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;\n          if (r * r <= dd) {\n            y = Math.sqrt(dd - r * r) * bendDir;\n            a1 = ta - Math.atan2(y, r);\n            a2 = Math.atan2(y / psy, (r - l1) / psx);\n            break outer;\n          }\n        }\n        let minAngle = MathUtils.PI;\n        let minX = l1 - a;\n        let minDist = minX * minX;\n        let minY = 0;\n        let maxAngle = 0;\n        let maxX = l1 + a;\n        let maxDist = maxX * maxX;\n        let maxY = 0;\n        c = -a * l1 / (aa - bb);\n        if (c >= -1 && c <= 1) {\n          c = Math.acos(c);\n          x = a * Math.cos(c) + l1;\n          y = b * Math.sin(c);\n          d = x * x + y * y;\n          if (d < minDist) {\n            minAngle = c;\n            minDist = d;\n            minX = x;\n            minY = y;\n          }\n          if (d > maxDist) {\n            maxAngle = c;\n            maxDist = d;\n            maxX = x;\n            maxY = y;\n          }\n        }\n        if (dd <= (minDist + maxDist) * 0.5) {\n          a1 = ta - Math.atan2(minY * bendDir, minX);\n          a2 = minAngle * bendDir;\n        } else {\n          a1 = ta - Math.atan2(maxY * bendDir, maxX);\n          a2 = maxAngle * bendDir;\n        }\n      }\n    const os = Math.atan2(cy, cx) * s2;\n    let rotation = parent.arotation;\n    a1 = (a1 - os) * MathUtils.radDeg + os1 - rotation;\n    if (a1 > 180)\n      a1 -= 360;\n    else if (a1 < -180)\n      a1 += 360;\n    parent.updateWorldTransformWith(px, py, rotation + a1 * alpha, sx, sy, 0, 0);\n    rotation = child.arotation;\n    a2 = ((a2 + os) * MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;\n    if (a2 > 180)\n      a2 -= 360;\n    else if (a2 < -180)\n      a2 += 360;\n    child.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\n  }\n}\n\nexport { IkConstraint };\n//# sourceMappingURL=IkConstraint.mjs.map\n","import { ConstraintData } from './ConstraintData.mjs';\n\nclass IkConstraintData extends ConstraintData {\n  constructor(name) {\n    super(name, 0, false);\n    /** The bones that are constrained by this IK constraint. */\n    this.bones = new Array();\n    /** The bone that is the IK target. */\n    this._target = null;\n    /** Controls the bend direction of the IK bones, either 1 or -1. */\n    this.bendDirection = 1;\n    /** When true and only a single bone is being constrained, if the target is too close, the bone is scaled to reach it. */\n    this.compress = false;\n    /** When true, if the target is out of range, the parent bone is scaled to reach it. If more than one bone is being constrained\n     * and the parent bone has local nonuniform scale, stretch is not applied. */\n    this.stretch = false;\n    /** When true, only a single bone is being constrained, and {@link #getCompress()} or {@link #getStretch()} is used, the bone\n     * is scaled on both the X and Y axes. */\n    this.uniform = false;\n    /** A percentage (0-1) that controls the mix between the constrained and unconstrained rotations. */\n    this.mix = 1;\n    /** For two bone IK, the distance from the maximum reach of the bones that rotation will slow. */\n    this.softness = 0;\n  }\n  set target(boneData) {\n    this._target = boneData;\n  }\n  get target() {\n    if (!this._target)\n      throw new Error(\"BoneData not set.\");\n    else\n      return this._target;\n  }\n}\n\nexport { IkConstraintData };\n//# sourceMappingURL=IkConstraintData.mjs.map\n","import { ConstraintData } from './ConstraintData.mjs';\nimport { PositionMode, RotateMode } from '@pixi-spine/base';\n\nclass PathConstraintData extends ConstraintData {\n  constructor(name) {\n    super(name, 0, false);\n    /** The bones that will be modified by this path constraint. */\n    this.bones = new Array();\n    /** The slot whose path attachment will be used to constrained the bones. */\n    this._target = null;\n    /** The mode for positioning the first bone on the path. */\n    this.positionMode = PositionMode.Fixed;\n    /** The mode for positioning the bones after the first bone on the path. */\n    this.spacingMode = SpacingMode.Fixed;\n    /** The mode for adjusting the rotation of the bones. */\n    this.rotateMode = RotateMode.Chain;\n    /** An offset added to the constrained bone rotation. */\n    this.offsetRotation = 0;\n    /** The position along the path. */\n    this.position = 0;\n    /** The spacing between bones. */\n    this.spacing = 0;\n    this.mixRotate = 0;\n    this.mixX = 0;\n    this.mixY = 0;\n  }\n  set target(slotData) {\n    this._target = slotData;\n  }\n  get target() {\n    if (!this._target)\n      throw new Error(\"SlotData not set.\");\n    else\n      return this._target;\n  }\n}\nvar SpacingMode = /* @__PURE__ */ ((SpacingMode2) => {\n  SpacingMode2[SpacingMode2[\"Length\"] = 0] = \"Length\";\n  SpacingMode2[SpacingMode2[\"Fixed\"] = 1] = \"Fixed\";\n  SpacingMode2[SpacingMode2[\"Percent\"] = 2] = \"Percent\";\n  SpacingMode2[SpacingMode2[\"Proportional\"] = 3] = \"Proportional\";\n  return SpacingMode2;\n})(SpacingMode || {});\n\nexport { PathConstraintData, SpacingMode };\n//# sourceMappingURL=PathConstraintData.mjs.map\n","import './attachments/Attachment.mjs';\nimport { RotateMode, Utils, MathUtils, PositionMode } from '@pixi-spine/base';\nimport { PathAttachment } from './attachments/PathAttachment.mjs';\nimport './attachments/RegionAttachment.mjs';\nimport './attachments/Sequence.mjs';\nimport { SpacingMode } from './PathConstraintData.mjs';\n\nconst _PathConstraint = class {\n  constructor(data, skeleton) {\n    /** The position along the path. */\n    this.position = 0;\n    /** The spacing between bones. */\n    this.spacing = 0;\n    this.mixRotate = 0;\n    this.mixX = 0;\n    this.mixY = 0;\n    this.spaces = new Array();\n    this.positions = new Array();\n    this.world = new Array();\n    this.curves = new Array();\n    this.lengths = new Array();\n    this.segments = new Array();\n    this.active = false;\n    if (!data)\n      throw new Error(\"data cannot be null.\");\n    if (!skeleton)\n      throw new Error(\"skeleton cannot be null.\");\n    this.data = data;\n    this.bones = new Array();\n    for (let i = 0, n = data.bones.length; i < n; i++) {\n      const bone = skeleton.findBone(data.bones[i].name);\n      if (!bone)\n        throw new Error(`Couldn't find bone ${data.bones[i].name}.`);\n      this.bones.push(bone);\n    }\n    const target = skeleton.findSlot(data.target.name);\n    if (!target)\n      throw new Error(`Couldn't find target bone ${data.target.name}`);\n    this.target = target;\n    this.position = data.position;\n    this.spacing = data.spacing;\n    this.mixRotate = data.mixRotate;\n    this.mixX = data.mixX;\n    this.mixY = data.mixY;\n  }\n  isActive() {\n    return this.active;\n  }\n  update() {\n    const attachment = this.target.getAttachment();\n    if (!(attachment instanceof PathAttachment))\n      return;\n    const mixRotate = this.mixRotate;\n    const mixX = this.mixX;\n    const mixY = this.mixY;\n    if (mixRotate == 0 && mixX == 0 && mixY == 0)\n      return;\n    const data = this.data;\n    const tangents = data.rotateMode == RotateMode.Tangent;\n    const scale = data.rotateMode == RotateMode.ChainScale;\n    const bones = this.bones;\n    const boneCount = bones.length;\n    const spacesCount = tangents ? boneCount : boneCount + 1;\n    const spaces = Utils.setArraySize(this.spaces, spacesCount);\n    const lengths = scale ? this.lengths = Utils.setArraySize(this.lengths, boneCount) : [];\n    const spacing = this.spacing;\n    switch (data.spacingMode) {\n      case SpacingMode.Percent:\n        if (scale) {\n          for (let i = 0, n = spacesCount - 1; i < n; i++) {\n            const bone = bones[i];\n            const setupLength = bone.data.length;\n            if (setupLength < _PathConstraint.epsilon)\n              lengths[i] = 0;\n            else {\n              const x = setupLength * bone.matrix.a;\n              const y = setupLength * bone.matrix.b;\n              lengths[i] = Math.sqrt(x * x + y * y);\n            }\n          }\n        }\n        Utils.arrayFill(spaces, 1, spacesCount, spacing);\n        break;\n      case SpacingMode.Proportional:\n        let sum = 0;\n        for (let i = 0, n = spacesCount - 1; i < n; ) {\n          const bone = bones[i];\n          const setupLength = bone.data.length;\n          if (setupLength < _PathConstraint.epsilon) {\n            if (scale)\n              lengths[i] = 0;\n            spaces[++i] = spacing;\n          } else {\n            const x = setupLength * bone.matrix.a;\n            const y = setupLength * bone.matrix.b;\n            const length = Math.sqrt(x * x + y * y);\n            if (scale)\n              lengths[i] = length;\n            spaces[++i] = length;\n            sum += length;\n          }\n        }\n        if (sum > 0) {\n          sum = spacesCount / sum * spacing;\n          for (let i = 1; i < spacesCount; i++)\n            spaces[i] *= sum;\n        }\n        break;\n      default:\n        const lengthSpacing = data.spacingMode == SpacingMode.Length;\n        for (let i = 0, n = spacesCount - 1; i < n; ) {\n          const bone = bones[i];\n          const setupLength = bone.data.length;\n          if (setupLength < _PathConstraint.epsilon) {\n            if (scale)\n              lengths[i] = 0;\n            spaces[++i] = spacing;\n          } else {\n            const x = setupLength * bone.matrix.a;\n            const y = setupLength * bone.matrix.b;\n            const length = Math.sqrt(x * x + y * y);\n            if (scale)\n              lengths[i] = length;\n            spaces[++i] = (lengthSpacing ? setupLength + spacing : spacing) * length / setupLength;\n          }\n        }\n    }\n    const positions = this.computeWorldPositions(attachment, spacesCount, tangents);\n    let boneX = positions[0];\n    let boneY = positions[1];\n    let offsetRotation = data.offsetRotation;\n    let tip = false;\n    if (offsetRotation == 0)\n      tip = data.rotateMode == RotateMode.Chain;\n    else {\n      tip = false;\n      const p = this.target.bone.matrix;\n      offsetRotation *= p.a * p.d - p.b * p.c > 0 ? MathUtils.degRad : -MathUtils.degRad;\n    }\n    for (let i = 0, p = 3; i < boneCount; i++, p += 3) {\n      const bone = bones[i];\n      const mat = bone.matrix;\n      mat.tx += (boneX - mat.tx) * mixX;\n      mat.ty += (boneY - mat.ty) * mixY;\n      const x = positions[p];\n      const y = positions[p + 1];\n      const dx = x - boneX;\n      const dy = y - boneY;\n      if (scale) {\n        const length = lengths[i];\n        if (length != 0) {\n          const s = (Math.sqrt(dx * dx + dy * dy) / length - 1) * mixRotate + 1;\n          mat.a *= s;\n          mat.b *= s;\n        }\n      }\n      boneX = x;\n      boneY = y;\n      if (mixRotate > 0) {\n        const a = mat.a;\n        const b = mat.c;\n        const c = mat.b;\n        const d = mat.d;\n        let r = 0;\n        let cos = 0;\n        let sin = 0;\n        if (tangents)\n          r = positions[p - 1];\n        else if (spaces[i + 1] == 0)\n          r = positions[p + 2];\n        else\n          r = Math.atan2(dy, dx);\n        r -= Math.atan2(c, a);\n        if (tip) {\n          cos = Math.cos(r);\n          sin = Math.sin(r);\n          const length = bone.data.length;\n          boneX += (length * (cos * a - sin * c) - dx) * mixRotate;\n          boneY += (length * (sin * a + cos * c) - dy) * mixRotate;\n        } else {\n          r += offsetRotation;\n        }\n        if (r > MathUtils.PI)\n          r -= MathUtils.PI2;\n        else if (r < -MathUtils.PI)\n          r += MathUtils.PI2;\n        r *= mixRotate;\n        cos = Math.cos(r);\n        sin = Math.sin(r);\n        mat.a = cos * a - sin * c;\n        mat.c = cos * b - sin * d;\n        mat.b = sin * a + cos * c;\n        mat.d = sin * b + cos * d;\n      }\n      bone.updateAppliedTransform();\n    }\n  }\n  computeWorldPositions(path, spacesCount, tangents) {\n    const target = this.target;\n    let position = this.position;\n    const spaces = this.spaces;\n    const out = Utils.setArraySize(this.positions, spacesCount * 3 + 2);\n    let world = this.world;\n    const closed = path.closed;\n    let verticesLength = path.worldVerticesLength;\n    let curveCount = verticesLength / 6;\n    let prevCurve = _PathConstraint.NONE;\n    if (!path.constantSpeed) {\n      const lengths = path.lengths;\n      curveCount -= closed ? 1 : 2;\n      const pathLength2 = lengths[curveCount];\n      if (this.data.positionMode == PositionMode.Percent)\n        position *= pathLength2;\n      let multiplier2;\n      switch (this.data.spacingMode) {\n        case SpacingMode.Percent:\n          multiplier2 = pathLength2;\n          break;\n        case SpacingMode.Proportional:\n          multiplier2 = pathLength2 / spacesCount;\n          break;\n        default:\n          multiplier2 = 1;\n      }\n      world = Utils.setArraySize(this.world, 8);\n      for (let i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {\n        const space = spaces[i] * multiplier2;\n        position += space;\n        let p = position;\n        if (closed) {\n          p %= pathLength2;\n          if (p < 0)\n            p += pathLength2;\n          curve = 0;\n        } else if (p < 0) {\n          if (prevCurve != _PathConstraint.BEFORE) {\n            prevCurve = _PathConstraint.BEFORE;\n            path.computeWorldVertices(target, 2, 4, world, 0, 2);\n          }\n          this.addBeforePosition(p, world, 0, out, o);\n          continue;\n        } else if (p > pathLength2) {\n          if (prevCurve != _PathConstraint.AFTER) {\n            prevCurve = _PathConstraint.AFTER;\n            path.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2);\n          }\n          this.addAfterPosition(p - pathLength2, world, 0, out, o);\n          continue;\n        }\n        for (; ; curve++) {\n          const length = lengths[curve];\n          if (p > length)\n            continue;\n          if (curve == 0)\n            p /= length;\n          else {\n            const prev = lengths[curve - 1];\n            p = (p - prev) / (length - prev);\n          }\n          break;\n        }\n        if (curve != prevCurve) {\n          prevCurve = curve;\n          if (closed && curve == curveCount) {\n            path.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);\n            path.computeWorldVertices(target, 0, 4, world, 4, 2);\n          } else\n            path.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2);\n        }\n        this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o, tangents || i > 0 && space == 0);\n      }\n      return out;\n    }\n    if (closed) {\n      verticesLength += 2;\n      world = Utils.setArraySize(this.world, verticesLength);\n      path.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);\n      path.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);\n      world[verticesLength - 2] = world[0];\n      world[verticesLength - 1] = world[1];\n    } else {\n      curveCount--;\n      verticesLength -= 4;\n      world = Utils.setArraySize(this.world, verticesLength);\n      path.computeWorldVertices(target, 2, verticesLength, world, 0, 2);\n    }\n    const curves = Utils.setArraySize(this.curves, curveCount);\n    let pathLength = 0;\n    let x1 = world[0];\n    let y1 = world[1];\n    let cx1 = 0;\n    let cy1 = 0;\n    let cx2 = 0;\n    let cy2 = 0;\n    let x2 = 0;\n    let y2 = 0;\n    let tmpx = 0;\n    let tmpy = 0;\n    let dddfx = 0;\n    let dddfy = 0;\n    let ddfx = 0;\n    let ddfy = 0;\n    let dfx = 0;\n    let dfy = 0;\n    for (let i = 0, w = 2; i < curveCount; i++, w += 6) {\n      cx1 = world[w];\n      cy1 = world[w + 1];\n      cx2 = world[w + 2];\n      cy2 = world[w + 3];\n      x2 = world[w + 4];\n      y2 = world[w + 5];\n      tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;\n      tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;\n      dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;\n      dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;\n      ddfx = tmpx * 2 + dddfx;\n      ddfy = tmpy * 2 + dddfy;\n      dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;\n      dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;\n      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n      dfx += ddfx;\n      dfy += ddfy;\n      ddfx += dddfx;\n      ddfy += dddfy;\n      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n      dfx += ddfx;\n      dfy += ddfy;\n      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n      dfx += ddfx + dddfx;\n      dfy += ddfy + dddfy;\n      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n      curves[i] = pathLength;\n      x1 = x2;\n      y1 = y2;\n    }\n    if (this.data.positionMode == PositionMode.Percent)\n      position *= pathLength;\n    let multiplier;\n    switch (this.data.spacingMode) {\n      case SpacingMode.Percent:\n        multiplier = pathLength;\n        break;\n      case SpacingMode.Proportional:\n        multiplier = pathLength / spacesCount;\n        break;\n      default:\n        multiplier = 1;\n    }\n    const segments = this.segments;\n    let curveLength = 0;\n    for (let i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {\n      const space = spaces[i] * multiplier;\n      position += space;\n      let p = position;\n      if (closed) {\n        p %= pathLength;\n        if (p < 0)\n          p += pathLength;\n        curve = 0;\n      } else if (p < 0) {\n        this.addBeforePosition(p, world, 0, out, o);\n        continue;\n      } else if (p > pathLength) {\n        this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);\n        continue;\n      }\n      for (; ; curve++) {\n        const length = curves[curve];\n        if (p > length)\n          continue;\n        if (curve == 0)\n          p /= length;\n        else {\n          const prev = curves[curve - 1];\n          p = (p - prev) / (length - prev);\n        }\n        break;\n      }\n      if (curve != prevCurve) {\n        prevCurve = curve;\n        let ii = curve * 6;\n        x1 = world[ii];\n        y1 = world[ii + 1];\n        cx1 = world[ii + 2];\n        cy1 = world[ii + 3];\n        cx2 = world[ii + 4];\n        cy2 = world[ii + 5];\n        x2 = world[ii + 6];\n        y2 = world[ii + 7];\n        tmpx = (x1 - cx1 * 2 + cx2) * 0.03;\n        tmpy = (y1 - cy1 * 2 + cy2) * 0.03;\n        dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 6e-3;\n        dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 6e-3;\n        ddfx = tmpx * 2 + dddfx;\n        ddfy = tmpy * 2 + dddfy;\n        dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;\n        dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;\n        curveLength = Math.sqrt(dfx * dfx + dfy * dfy);\n        segments[0] = curveLength;\n        for (ii = 1; ii < 8; ii++) {\n          dfx += ddfx;\n          dfy += ddfy;\n          ddfx += dddfx;\n          ddfy += dddfy;\n          curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n          segments[ii] = curveLength;\n        }\n        dfx += ddfx;\n        dfy += ddfy;\n        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n        segments[8] = curveLength;\n        dfx += ddfx + dddfx;\n        dfy += ddfy + dddfy;\n        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n        segments[9] = curveLength;\n        segment = 0;\n      }\n      p *= curveLength;\n      for (; ; segment++) {\n        const length = segments[segment];\n        if (p > length)\n          continue;\n        if (segment == 0)\n          p /= length;\n        else {\n          const prev = segments[segment - 1];\n          p = segment + (p - prev) / (length - prev);\n        }\n        break;\n      }\n      this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || i > 0 && space == 0);\n    }\n    return out;\n  }\n  addBeforePosition(p, temp, i, out, o) {\n    const x1 = temp[i];\n    const y1 = temp[i + 1];\n    const dx = temp[i + 2] - x1;\n    const dy = temp[i + 3] - y1;\n    const r = Math.atan2(dy, dx);\n    out[o] = x1 + p * Math.cos(r);\n    out[o + 1] = y1 + p * Math.sin(r);\n    out[o + 2] = r;\n  }\n  addAfterPosition(p, temp, i, out, o) {\n    const x1 = temp[i + 2];\n    const y1 = temp[i + 3];\n    const dx = x1 - temp[i];\n    const dy = y1 - temp[i + 1];\n    const r = Math.atan2(dy, dx);\n    out[o] = x1 + p * Math.cos(r);\n    out[o + 1] = y1 + p * Math.sin(r);\n    out[o + 2] = r;\n  }\n  addCurvePosition(p, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents) {\n    if (p == 0 || isNaN(p)) {\n      out[o] = x1;\n      out[o + 1] = y1;\n      out[o + 2] = Math.atan2(cy1 - y1, cx1 - x1);\n      return;\n    }\n    const tt = p * p;\n    const ttt = tt * p;\n    const u = 1 - p;\n    const uu = u * u;\n    const uuu = uu * u;\n    const ut = u * p;\n    const ut3 = ut * 3;\n    const uut3 = u * ut3;\n    const utt3 = ut3 * p;\n    const x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt;\n    const y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;\n    out[o] = x;\n    out[o + 1] = y;\n    if (tangents) {\n      if (p < 1e-3)\n        out[o + 2] = Math.atan2(cy1 - y1, cx1 - x1);\n      else\n        out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));\n    }\n  }\n};\nlet PathConstraint = _PathConstraint;\nPathConstraint.NONE = -1;\nPathConstraint.BEFORE = -2;\nPathConstraint.AFTER = -3;\nPathConstraint.epsilon = 1e-5;\n\nexport { PathConstraint };\n//# sourceMappingURL=PathConstraint.mjs.map\n","import { Color } from '@pixi-spine/base';\nimport { VertexAttachment } from './attachments/Attachment.mjs';\n\nclass Slot {\n  constructor(data, bone) {\n    /** The dark color used to tint the slot's attachment for two color tinting, or null if two color tinting is not used. The dark\n     * color's alpha is not used. */\n    this.darkColor = null;\n    this.attachment = null;\n    this.attachmentState = 0;\n    /** The index of the texture region to display when the slot's attachment has a {@link Sequence}. -1 represents the\n     * {@link Sequence#getSetupIndex()}. */\n    this.sequenceIndex = -1;\n    /** Values to deform the slot's attachment. For an unweighted mesh, the entries are local positions for each vertex. For a\n     * weighted mesh, the entries are an offset for each vertex which will be added to the mesh's local vertex positions.\n     *\n     * See {@link VertexAttachment#computeWorldVertices()} and {@link DeformTimeline}. */\n    this.deform = new Array();\n    if (!data)\n      throw new Error(\"data cannot be null.\");\n    if (!bone)\n      throw new Error(\"bone cannot be null.\");\n    this.data = data;\n    this.bone = bone;\n    this.color = new Color();\n    this.darkColor = !data.darkColor ? null : new Color();\n    this.setToSetupPose();\n    this.blendMode = this.data.blendMode;\n  }\n  /** The skeleton this slot belongs to. */\n  getSkeleton() {\n    return this.bone.skeleton;\n  }\n  /** The current attachment for the slot, or null if the slot has no attachment. */\n  getAttachment() {\n    return this.attachment;\n  }\n  /** Sets the slot's attachment and, if the attachment changed, resets {@link #sequenceIndex} and clears the {@link #deform}.\n   * The deform is not cleared if the old attachment has the same {@link VertexAttachment#getTimelineAttachment()} as the\n   * specified attachment. */\n  setAttachment(attachment) {\n    if (this.attachment == attachment)\n      return;\n    if (!(attachment instanceof VertexAttachment) || !(this.attachment instanceof VertexAttachment) || attachment.timelineAttachment != this.attachment.timelineAttachment) {\n      this.deform.length = 0;\n    }\n    this.attachment = attachment;\n    this.sequenceIndex = -1;\n  }\n  /** Sets this slot to the setup pose. */\n  setToSetupPose() {\n    this.color.setFromColor(this.data.color);\n    if (this.darkColor)\n      this.darkColor.setFromColor(this.data.darkColor);\n    if (!this.data.attachmentName)\n      this.attachment = null;\n    else {\n      this.attachment = null;\n      this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));\n    }\n  }\n}\n\nexport { Slot };\n//# sourceMappingURL=Slot.mjs.map\n","import { Vector2, MathUtils } from '@pixi-spine/base';\n\nclass TransformConstraint {\n  constructor(data, skeleton) {\n    this.mixRotate = 0;\n    this.mixX = 0;\n    this.mixY = 0;\n    this.mixScaleX = 0;\n    this.mixScaleY = 0;\n    this.mixShearY = 0;\n    this.temp = new Vector2();\n    this.active = false;\n    if (!data)\n      throw new Error(\"data cannot be null.\");\n    if (!skeleton)\n      throw new Error(\"skeleton cannot be null.\");\n    this.data = data;\n    this.mixRotate = data.mixRotate;\n    this.mixX = data.mixX;\n    this.mixY = data.mixY;\n    this.mixScaleX = data.mixScaleX;\n    this.mixScaleY = data.mixScaleY;\n    this.mixShearY = data.mixShearY;\n    this.bones = new Array();\n    for (let i = 0; i < data.bones.length; i++) {\n      const bone = skeleton.findBone(data.bones[i].name);\n      if (!bone)\n        throw new Error(`Couldn't find bone ${data.bones[i].name}.`);\n      this.bones.push(bone);\n    }\n    const target = skeleton.findBone(data.target.name);\n    if (!target)\n      throw new Error(`Couldn't find target bone ${data.target.name}.`);\n    this.target = target;\n  }\n  isActive() {\n    return this.active;\n  }\n  update() {\n    if (this.mixRotate == 0 && this.mixX == 0 && this.mixY == 0 && this.mixScaleX == 0 && this.mixScaleX == 0 && this.mixShearY == 0)\n      return;\n    if (this.data.local) {\n      if (this.data.relative)\n        this.applyRelativeLocal();\n      else\n        this.applyAbsoluteLocal();\n    } else if (this.data.relative)\n      this.applyRelativeWorld();\n    else\n      this.applyAbsoluteWorld();\n  }\n  applyAbsoluteWorld() {\n    const mixRotate = this.mixRotate;\n    const mixX = this.mixX;\n    const mixY = this.mixY;\n    const mixScaleX = this.mixScaleX;\n    const mixScaleY = this.mixScaleY;\n    const mixShearY = this.mixShearY;\n    const translate = mixX != 0 || mixY != 0;\n    const target = this.target;\n    const targetMat = target.matrix;\n    const ta = targetMat.a;\n    const tb = targetMat.c;\n    const tc = targetMat.b;\n    const td = targetMat.d;\n    const degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;\n    const offsetRotation = this.data.offsetRotation * degRadReflect;\n    const offsetShearY = this.data.offsetShearY * degRadReflect;\n    const bones = this.bones;\n    for (let i = 0, n = bones.length; i < n; i++) {\n      const bone = bones[i];\n      const mat = bone.matrix;\n      if (mixRotate != 0) {\n        const a = mat.a;\n        const b = mat.c;\n        const c = mat.b;\n        const d = mat.d;\n        let r = Math.atan2(tc, ta) - Math.atan2(c, a) + offsetRotation;\n        if (r > MathUtils.PI)\n          r -= MathUtils.PI2;\n        else if (r < -MathUtils.PI)\n          r += MathUtils.PI2;\n        r *= mixRotate;\n        const cos = Math.cos(r);\n        const sin = Math.sin(r);\n        mat.a = cos * a - sin * c;\n        mat.c = cos * b - sin * d;\n        mat.b = sin * a + cos * c;\n        mat.d = sin * b + cos * d;\n      }\n      if (translate) {\n        const temp = this.temp;\n        target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\n        mat.tx += (temp.x - mat.tx) * mixX;\n        mat.ty += (temp.y - mat.ty) * mixY;\n      }\n      if (mixScaleX != 0) {\n        let s = Math.sqrt(mat.a * mat.a + mat.b * mat.b);\n        if (s != 0)\n          s = (s + (Math.sqrt(ta * ta + tc * tc) - s + this.data.offsetScaleX) * mixScaleX) / s;\n        mat.a *= s;\n        mat.b *= s;\n      }\n      if (mixScaleY != 0) {\n        let s = Math.sqrt(mat.c * mat.c + mat.d * mat.d);\n        if (s != 0)\n          s = (s + (Math.sqrt(tb * tb + td * td) - s + this.data.offsetScaleY) * mixScaleY) / s;\n        mat.c *= s;\n        mat.d *= s;\n      }\n      if (mixShearY > 0) {\n        const b = mat.c;\n        const d = mat.d;\n        const by = Math.atan2(d, b);\n        let r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(mat.b, mat.a));\n        if (r > MathUtils.PI)\n          r -= MathUtils.PI2;\n        else if (r < -MathUtils.PI)\n          r += MathUtils.PI2;\n        r = by + (r + offsetShearY) * mixShearY;\n        const s = Math.sqrt(b * b + d * d);\n        mat.c = Math.cos(r) * s;\n        mat.d = Math.sin(r) * s;\n      }\n      bone.updateAppliedTransform();\n    }\n  }\n  applyRelativeWorld() {\n    const mixRotate = this.mixRotate;\n    const mixX = this.mixX;\n    const mixY = this.mixY;\n    const mixScaleX = this.mixScaleX;\n    const mixScaleY = this.mixScaleY;\n    const mixShearY = this.mixShearY;\n    const translate = mixX != 0 || mixY != 0;\n    const target = this.target;\n    const targetMat = target.matrix;\n    const ta = targetMat.a;\n    const tb = targetMat.c;\n    const tc = targetMat.b;\n    const td = targetMat.d;\n    const degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;\n    const offsetRotation = this.data.offsetRotation * degRadReflect;\n    const offsetShearY = this.data.offsetShearY * degRadReflect;\n    const bones = this.bones;\n    for (let i = 0, n = bones.length; i < n; i++) {\n      const bone = bones[i];\n      const mat = bone.matrix;\n      if (mixRotate != 0) {\n        const a = mat.a;\n        const b = mat.c;\n        const c = mat.b;\n        const d = mat.d;\n        let r = Math.atan2(tc, ta) + offsetRotation;\n        if (r > MathUtils.PI)\n          r -= MathUtils.PI2;\n        else if (r < -MathUtils.PI)\n          r += MathUtils.PI2;\n        r *= mixRotate;\n        const cos = Math.cos(r);\n        const sin = Math.sin(r);\n        mat.a = cos * a - sin * c;\n        mat.c = cos * b - sin * d;\n        mat.b = sin * a + cos * c;\n        mat.d = sin * b + cos * d;\n      }\n      if (translate) {\n        const temp = this.temp;\n        target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\n        mat.tx += temp.x * mixX;\n        mat.ty += temp.y * mixY;\n      }\n      if (mixScaleX != 0) {\n        const s = (Math.sqrt(ta * ta + tc * tc) - 1 + this.data.offsetScaleX) * mixScaleX + 1;\n        mat.a *= s;\n        mat.b *= s;\n      }\n      if (mixScaleY != 0) {\n        const s = (Math.sqrt(tb * tb + td * td) - 1 + this.data.offsetScaleY) * mixScaleY + 1;\n        mat.c *= s;\n        mat.d *= s;\n      }\n      if (mixShearY > 0) {\n        let r = Math.atan2(td, tb) - Math.atan2(tc, ta);\n        if (r > MathUtils.PI)\n          r -= MathUtils.PI2;\n        else if (r < -MathUtils.PI)\n          r += MathUtils.PI2;\n        const b = mat.c;\n        const d = mat.d;\n        r = Math.atan2(d, b) + (r - MathUtils.PI / 2 + offsetShearY) * mixShearY;\n        const s = Math.sqrt(b * b + d * d);\n        mat.c = Math.cos(r) * s;\n        mat.d = Math.sin(r) * s;\n      }\n      bone.updateAppliedTransform();\n    }\n  }\n  applyAbsoluteLocal() {\n    const mixRotate = this.mixRotate;\n    const mixX = this.mixX;\n    const mixY = this.mixY;\n    const mixScaleX = this.mixScaleX;\n    const mixScaleY = this.mixScaleY;\n    const mixShearY = this.mixShearY;\n    const target = this.target;\n    const bones = this.bones;\n    for (let i = 0, n = bones.length; i < n; i++) {\n      const bone = bones[i];\n      let rotation = bone.arotation;\n      if (mixRotate != 0) {\n        let r = target.arotation - rotation + this.data.offsetRotation;\n        r -= (16384 - (16384.499999999996 - r / 360 | 0)) * 360;\n        rotation += r * mixRotate;\n      }\n      let x = bone.ax;\n      let y = bone.ay;\n      x += (target.ax - x + this.data.offsetX) * mixX;\n      y += (target.ay - y + this.data.offsetY) * mixY;\n      let scaleX = bone.ascaleX;\n      let scaleY = bone.ascaleY;\n      if (mixScaleX != 0 && scaleX != 0)\n        scaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * mixScaleX) / scaleX;\n      if (mixScaleY != 0 && scaleY != 0)\n        scaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * mixScaleY) / scaleY;\n      let shearY = bone.ashearY;\n      if (mixShearY != 0) {\n        let r = target.ashearY - shearY + this.data.offsetShearY;\n        r -= (16384 - (16384.499999999996 - r / 360 | 0)) * 360;\n        shearY += r * mixShearY;\n      }\n      bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\n    }\n  }\n  applyRelativeLocal() {\n    const mixRotate = this.mixRotate;\n    const mixX = this.mixX;\n    const mixY = this.mixY;\n    const mixScaleX = this.mixScaleX;\n    const mixScaleY = this.mixScaleY;\n    const mixShearY = this.mixShearY;\n    const target = this.target;\n    const bones = this.bones;\n    for (let i = 0, n = bones.length; i < n; i++) {\n      const bone = bones[i];\n      const rotation = bone.arotation + (target.arotation + this.data.offsetRotation) * mixRotate;\n      const x = bone.ax + (target.ax + this.data.offsetX) * mixX;\n      const y = bone.ay + (target.ay + this.data.offsetY) * mixY;\n      const scaleX = bone.ascaleX * ((target.ascaleX - 1 + this.data.offsetScaleX) * mixScaleX + 1);\n      const scaleY = bone.ascaleY * ((target.ascaleY - 1 + this.data.offsetScaleY) * mixScaleY + 1);\n      const shearY = bone.ashearY + (target.ashearY + this.data.offsetShearY) * mixShearY;\n      bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\n    }\n  }\n}\n\nexport { TransformConstraint };\n//# sourceMappingURL=TransformConstraint.mjs.map\n","import './attachments/Attachment.mjs';\nimport { Color, Utils, MathUtils, settings, Vector2 } from '@pixi-spine/base';\nimport { MeshAttachment } from './attachments/MeshAttachment.mjs';\nimport { PathAttachment } from './attachments/PathAttachment.mjs';\nimport { RegionAttachment } from './attachments/RegionAttachment.mjs';\nimport './attachments/Sequence.mjs';\nimport { Bone } from './Bone.mjs';\nimport { Slot } from './Slot.mjs';\nimport { IkConstraint } from './IkConstraint.mjs';\nimport { TransformConstraint } from './TransformConstraint.mjs';\nimport { PathConstraint } from './PathConstraint.mjs';\n\nconst _Skeleton = class {\n  constructor(data) {\n    /** The list of bones and constraints, sorted in the order they should be updated, as computed by {@link #updateCache()}. */\n    this._updateCache = new Array();\n    /** The skeleton's current skin. May be null. */\n    this.skin = null;\n    /** Scales the entire skeleton on the X axis. This affects all bones, even if the bone's transform mode disallows scale\n     * inheritance. */\n    this.scaleX = 1;\n    /** Scales the entire skeleton on the Y axis. This affects all bones, even if the bone's transform mode disallows scale\n     * inheritance. */\n    this.scaleY = 1;\n    /** Sets the skeleton X position, which is added to the root bone worldX position. */\n    this.x = 0;\n    /** Sets the skeleton Y position, which is added to the root bone worldY position. */\n    this.y = 0;\n    if (!data)\n      throw new Error(\"data cannot be null.\");\n    this.data = data;\n    this.bones = new Array();\n    for (let i = 0; i < data.bones.length; i++) {\n      const boneData = data.bones[i];\n      let bone;\n      if (!boneData.parent)\n        bone = new Bone(boneData, this, null);\n      else {\n        const parent = this.bones[boneData.parent.index];\n        bone = new Bone(boneData, this, parent);\n        parent.children.push(bone);\n      }\n      this.bones.push(bone);\n    }\n    this.slots = new Array();\n    this.drawOrder = new Array();\n    for (let i = 0; i < data.slots.length; i++) {\n      const slotData = data.slots[i];\n      const bone = this.bones[slotData.boneData.index];\n      const slot = new Slot(slotData, bone);\n      this.slots.push(slot);\n      this.drawOrder.push(slot);\n    }\n    this.ikConstraints = new Array();\n    for (let i = 0; i < data.ikConstraints.length; i++) {\n      const ikConstraintData = data.ikConstraints[i];\n      this.ikConstraints.push(new IkConstraint(ikConstraintData, this));\n    }\n    this.transformConstraints = new Array();\n    for (let i = 0; i < data.transformConstraints.length; i++) {\n      const transformConstraintData = data.transformConstraints[i];\n      this.transformConstraints.push(new TransformConstraint(transformConstraintData, this));\n    }\n    this.pathConstraints = new Array();\n    for (let i = 0; i < data.pathConstraints.length; i++) {\n      const pathConstraintData = data.pathConstraints[i];\n      this.pathConstraints.push(new PathConstraint(pathConstraintData, this));\n    }\n    this.color = new Color(1, 1, 1, 1);\n    this.updateCache();\n  }\n  /** Caches information about bones and constraints. Must be called if the {@link #getSkin()} is modified or if bones,\n   * constraints, or weighted path attachments are added or removed. */\n  updateCache() {\n    const updateCache = this._updateCache;\n    updateCache.length = 0;\n    const bones = this.bones;\n    for (let i = 0, n = bones.length; i < n; i++) {\n      const bone = bones[i];\n      bone.sorted = bone.data.skinRequired;\n      bone.active = !bone.sorted;\n    }\n    if (this.skin) {\n      const skinBones = this.skin.bones;\n      for (let i = 0, n = this.skin.bones.length; i < n; i++) {\n        let bone = this.bones[skinBones[i].index];\n        do {\n          bone.sorted = false;\n          bone.active = true;\n          bone = bone.parent;\n        } while (bone);\n      }\n    }\n    const ikConstraints = this.ikConstraints;\n    const transformConstraints = this.transformConstraints;\n    const pathConstraints = this.pathConstraints;\n    const ikCount = ikConstraints.length;\n    const transformCount = transformConstraints.length;\n    const pathCount = pathConstraints.length;\n    const constraintCount = ikCount + transformCount + pathCount;\n    outer:\n      for (let i = 0; i < constraintCount; i++) {\n        for (let ii = 0; ii < ikCount; ii++) {\n          const constraint = ikConstraints[ii];\n          if (constraint.data.order == i) {\n            this.sortIkConstraint(constraint);\n            continue outer;\n          }\n        }\n        for (let ii = 0; ii < transformCount; ii++) {\n          const constraint = transformConstraints[ii];\n          if (constraint.data.order == i) {\n            this.sortTransformConstraint(constraint);\n            continue outer;\n          }\n        }\n        for (let ii = 0; ii < pathCount; ii++) {\n          const constraint = pathConstraints[ii];\n          if (constraint.data.order == i) {\n            this.sortPathConstraint(constraint);\n            continue outer;\n          }\n        }\n      }\n    for (let i = 0, n = bones.length; i < n; i++)\n      this.sortBone(bones[i]);\n  }\n  sortIkConstraint(constraint) {\n    constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || this.skin && Utils.contains(this.skin.constraints, constraint.data, true));\n    if (!constraint.active)\n      return;\n    const target = constraint.target;\n    this.sortBone(target);\n    const constrained = constraint.bones;\n    const parent = constrained[0];\n    this.sortBone(parent);\n    if (constrained.length == 1) {\n      this._updateCache.push(constraint);\n      this.sortReset(parent.children);\n    } else {\n      const child = constrained[constrained.length - 1];\n      this.sortBone(child);\n      this._updateCache.push(constraint);\n      this.sortReset(parent.children);\n      child.sorted = true;\n    }\n  }\n  sortPathConstraint(constraint) {\n    constraint.active = constraint.target.bone.isActive() && (!constraint.data.skinRequired || this.skin && Utils.contains(this.skin.constraints, constraint.data, true));\n    if (!constraint.active)\n      return;\n    const slot = constraint.target;\n    const slotIndex = slot.data.index;\n    const slotBone = slot.bone;\n    if (this.skin)\n      this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);\n    if (this.data.defaultSkin && this.data.defaultSkin != this.skin)\n      this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);\n    for (let i = 0, n = this.data.skins.length; i < n; i++)\n      this.sortPathConstraintAttachment(this.data.skins[i], slotIndex, slotBone);\n    const attachment = slot.getAttachment();\n    if (attachment instanceof PathAttachment)\n      this.sortPathConstraintAttachmentWith(attachment, slotBone);\n    const constrained = constraint.bones;\n    const boneCount = constrained.length;\n    for (let i = 0; i < boneCount; i++)\n      this.sortBone(constrained[i]);\n    this._updateCache.push(constraint);\n    for (let i = 0; i < boneCount; i++)\n      this.sortReset(constrained[i].children);\n    for (let i = 0; i < boneCount; i++)\n      constrained[i].sorted = true;\n  }\n  sortTransformConstraint(constraint) {\n    constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || this.skin && Utils.contains(this.skin.constraints, constraint.data, true));\n    if (!constraint.active)\n      return;\n    this.sortBone(constraint.target);\n    const constrained = constraint.bones;\n    const boneCount = constrained.length;\n    if (constraint.data.local) {\n      for (let i = 0; i < boneCount; i++) {\n        const child = constrained[i];\n        this.sortBone(child.parent);\n        this.sortBone(child);\n      }\n    } else {\n      for (let i = 0; i < boneCount; i++) {\n        this.sortBone(constrained[i]);\n      }\n    }\n    this._updateCache.push(constraint);\n    for (let i = 0; i < boneCount; i++)\n      this.sortReset(constrained[i].children);\n    for (let i = 0; i < boneCount; i++)\n      constrained[i].sorted = true;\n  }\n  sortPathConstraintAttachment(skin, slotIndex, slotBone) {\n    const attachments = skin.attachments[slotIndex];\n    if (!attachments)\n      return;\n    for (const key in attachments) {\n      this.sortPathConstraintAttachmentWith(attachments[key], slotBone);\n    }\n  }\n  sortPathConstraintAttachmentWith(attachment, slotBone) {\n    if (!(attachment instanceof PathAttachment))\n      return;\n    const pathBones = attachment.bones;\n    if (!pathBones)\n      this.sortBone(slotBone);\n    else {\n      const bones = this.bones;\n      for (let i = 0, n = pathBones.length; i < n; ) {\n        let nn = pathBones[i++];\n        nn += i;\n        while (i < nn)\n          this.sortBone(bones[pathBones[i++]]);\n      }\n    }\n  }\n  sortBone(bone) {\n    if (!bone)\n      return;\n    if (bone.sorted)\n      return;\n    const parent = bone.parent;\n    if (parent)\n      this.sortBone(parent);\n    bone.sorted = true;\n    this._updateCache.push(bone);\n  }\n  sortReset(bones) {\n    for (let i = 0, n = bones.length; i < n; i++) {\n      const bone = bones[i];\n      if (!bone.active)\n        continue;\n      if (bone.sorted)\n        this.sortReset(bone.children);\n      bone.sorted = false;\n    }\n  }\n  /** Updates the world transform for each bone and applies all constraints.\n   *\n   * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine\n   * Runtimes Guide. */\n  updateWorldTransform() {\n    const bones = this.bones;\n    for (let i = 0, n = bones.length; i < n; i++) {\n      const bone = bones[i];\n      bone.ax = bone.x;\n      bone.ay = bone.y;\n      bone.arotation = bone.rotation;\n      bone.ascaleX = bone.scaleX;\n      bone.ascaleY = bone.scaleY;\n      bone.ashearX = bone.shearX;\n      bone.ashearY = bone.shearY;\n    }\n    const updateCache = this._updateCache;\n    for (let i = 0, n = updateCache.length; i < n; i++)\n      updateCache[i].update();\n  }\n  updateWorldTransformWith(parent) {\n    const rootBone = this.getRootBone();\n    const pa = parent.matrix.a;\n    const pb = parent.matrix.c;\n    const pc = parent.matrix.b;\n    const pd = parent.matrix.d;\n    rootBone.matrix.tx = pa * this.x + pb * this.y + parent.worldX;\n    rootBone.matrix.ty = pc * this.x + pd * this.y + parent.worldY;\n    const rotationY = rootBone.rotation + 90 + rootBone.shearY;\n    const la = MathUtils.cosDeg(rootBone.rotation + rootBone.shearX) * rootBone.scaleX;\n    const lb = MathUtils.cosDeg(rotationY) * rootBone.scaleY;\n    const lc = MathUtils.sinDeg(rootBone.rotation + rootBone.shearX) * rootBone.scaleX;\n    const ld = MathUtils.sinDeg(rotationY) * rootBone.scaleY;\n    const sx = this.scaleX;\n    const sy = settings.yDown ? -this.scaleY : this.scaleY;\n    rootBone.matrix.a = (pa * la + pb * lc) * sx;\n    rootBone.matrix.c = (pa * lb + pb * ld) * sx;\n    rootBone.matrix.b = (pc * la + pd * lc) * sy;\n    rootBone.matrix.d = (pc * lb + pd * ld) * sy;\n    const updateCache = this._updateCache;\n    for (let i = 0, n = updateCache.length; i < n; i++) {\n      const updatable = updateCache[i];\n      if (updatable != rootBone)\n        updatable.update();\n    }\n  }\n  /** Sets the bones, constraints, and slots to their setup pose values. */\n  setToSetupPose() {\n    this.setBonesToSetupPose();\n    this.setSlotsToSetupPose();\n  }\n  /** Sets the bones and constraints to their setup pose values. */\n  setBonesToSetupPose() {\n    const bones = this.bones;\n    for (let i = 0, n = bones.length; i < n; i++)\n      bones[i].setToSetupPose();\n    const ikConstraints = this.ikConstraints;\n    for (let i = 0, n = ikConstraints.length; i < n; i++) {\n      const constraint = ikConstraints[i];\n      constraint.mix = constraint.data.mix;\n      constraint.softness = constraint.data.softness;\n      constraint.bendDirection = constraint.data.bendDirection;\n      constraint.compress = constraint.data.compress;\n      constraint.stretch = constraint.data.stretch;\n    }\n    const transformConstraints = this.transformConstraints;\n    for (let i = 0, n = transformConstraints.length; i < n; i++) {\n      const constraint = transformConstraints[i];\n      const data = constraint.data;\n      constraint.mixRotate = data.mixRotate;\n      constraint.mixX = data.mixX;\n      constraint.mixY = data.mixY;\n      constraint.mixScaleX = data.mixScaleX;\n      constraint.mixScaleY = data.mixScaleY;\n      constraint.mixShearY = data.mixShearY;\n    }\n    const pathConstraints = this.pathConstraints;\n    for (let i = 0, n = pathConstraints.length; i < n; i++) {\n      const constraint = pathConstraints[i];\n      const data = constraint.data;\n      constraint.position = data.position;\n      constraint.spacing = data.spacing;\n      constraint.mixRotate = data.mixRotate;\n      constraint.mixX = data.mixX;\n      constraint.mixY = data.mixY;\n    }\n  }\n  /** Sets the slots and draw order to their setup pose values. */\n  setSlotsToSetupPose() {\n    const slots = this.slots;\n    Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);\n    for (let i = 0, n = slots.length; i < n; i++)\n      slots[i].setToSetupPose();\n  }\n  /** @returns May return null. */\n  getRootBone() {\n    if (this.bones.length == 0)\n      return null;\n    return this.bones[0];\n  }\n  /** @returns May be null. */\n  findBone(boneName) {\n    if (!boneName)\n      throw new Error(\"boneName cannot be null.\");\n    const bones = this.bones;\n    for (let i = 0, n = bones.length; i < n; i++) {\n      const bone = bones[i];\n      if (bone.data.name == boneName)\n        return bone;\n    }\n    return null;\n  }\n  /** @returns -1 if the bone was not found. */\n  findBoneIndex(boneName) {\n    if (!boneName)\n      throw new Error(\"boneName cannot be null.\");\n    const bones = this.bones;\n    for (let i = 0, n = bones.length; i < n; i++)\n      if (bones[i].data.name == boneName)\n        return i;\n    return -1;\n  }\n  /** Finds a slot by comparing each slot's name. It is more efficient to cache the results of this method than to call it\n   * repeatedly.\n   * @returns May be null. */\n  findSlot(slotName) {\n    if (!slotName)\n      throw new Error(\"slotName cannot be null.\");\n    const slots = this.slots;\n    for (let i = 0, n = slots.length; i < n; i++) {\n      const slot = slots[i];\n      if (slot.data.name == slotName)\n        return slot;\n    }\n    return null;\n  }\n  /** @returns -1 if the bone was not found. */\n  findSlotIndex(slotName) {\n    if (!slotName)\n      throw new Error(\"slotName cannot be null.\");\n    const slots = this.slots;\n    for (let i = 0, n = slots.length; i < n; i++)\n      if (slots[i].data.name == slotName)\n        return i;\n    return -1;\n  }\n  /** Sets a skin by name.\n   *\n   * See {@link #setSkin()}. */\n  setSkinByName(skinName) {\n    const skin = this.data.findSkin(skinName);\n    if (!skin)\n      throw new Error(`Skin not found: ${skinName}`);\n    this.setSkin(skin);\n  }\n  /** Sets the skin used to look up attachments before looking in the {@link SkeletonData#defaultSkin default skin}. If the\n   * skin is changed, {@link #updateCache()} is called.\n   *\n   * Attachments from the new skin are attached if the corresponding attachment from the old skin was attached. If there was no\n   * old skin, each slot's setup mode attachment is attached from the new skin.\n   *\n   * After changing the skin, the visible attachments can be reset to those attached in the setup pose by calling\n   * {@link #setSlotsToSetupPose()}. Also, often {@link AnimationState#apply()} is called before the next time the\n   * skeleton is rendered to allow any attachment keys in the current animation(s) to hide or show attachments from the new skin.\n   * @param newSkin May be null. */\n  setSkin(newSkin) {\n    if (newSkin == this.skin)\n      return;\n    if (newSkin) {\n      if (this.skin)\n        newSkin.attachAll(this, this.skin);\n      else {\n        const slots = this.slots;\n        for (let i = 0, n = slots.length; i < n; i++) {\n          const slot = slots[i];\n          const name = slot.data.attachmentName;\n          if (name) {\n            const attachment = newSkin.getAttachment(i, name);\n            if (attachment)\n              slot.setAttachment(attachment);\n          }\n        }\n      }\n    }\n    this.skin = newSkin;\n    this.updateCache();\n  }\n  /** Finds an attachment by looking in the {@link #skin} and {@link SkeletonData#defaultSkin} using the slot name and attachment\n   * name.\n   *\n   * See {@link #getAttachment()}.\n   * @returns May be null. */\n  getAttachmentByName(slotName, attachmentName) {\n    const slot = this.data.findSlot(slotName);\n    if (!slot)\n      throw new Error(`Can't find slot with name ${slotName}`);\n    return this.getAttachment(slot.index, attachmentName);\n  }\n  /** Finds an attachment by looking in the {@link #skin} and {@link SkeletonData#defaultSkin} using the slot index and\n   * attachment name. First the skin is checked and if the attachment was not found, the default skin is checked.\n   *\n   * See [Runtime skins](http://esotericsoftware.com/spine-runtime-skins) in the Spine Runtimes Guide.\n   * @returns May be null. */\n  getAttachment(slotIndex, attachmentName) {\n    if (!attachmentName)\n      throw new Error(\"attachmentName cannot be null.\");\n    if (this.skin) {\n      const attachment = this.skin.getAttachment(slotIndex, attachmentName);\n      if (attachment)\n        return attachment;\n    }\n    if (this.data.defaultSkin)\n      return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);\n    return null;\n  }\n  /** A convenience method to set an attachment by finding the slot with {@link #findSlot()}, finding the attachment with\n   * {@link #getAttachment()}, then setting the slot's {@link Slot#attachment}.\n   * @param attachmentName May be null to clear the slot's attachment. */\n  setAttachment(slotName, attachmentName) {\n    if (!slotName)\n      throw new Error(\"slotName cannot be null.\");\n    const slots = this.slots;\n    for (let i = 0, n = slots.length; i < n; i++) {\n      const slot = slots[i];\n      if (slot.data.name == slotName) {\n        let attachment = null;\n        if (attachmentName) {\n          attachment = this.getAttachment(i, attachmentName);\n          if (!attachment)\n            throw new Error(`Attachment not found: ${attachmentName}, for slot: ${slotName}`);\n        }\n        slot.setAttachment(attachment);\n        return;\n      }\n    }\n    throw new Error(`Slot not found: ${slotName}`);\n  }\n  /** Finds an IK constraint by comparing each IK constraint's name. It is more efficient to cache the results of this method\n   * than to call it repeatedly.\n   * @return May be null. */\n  findIkConstraint(constraintName) {\n    if (!constraintName)\n      throw new Error(\"constraintName cannot be null.\");\n    const ikConstraints = this.ikConstraints;\n    for (let i = 0, n = ikConstraints.length; i < n; i++) {\n      const ikConstraint = ikConstraints[i];\n      if (ikConstraint.data.name == constraintName)\n        return ikConstraint;\n    }\n    return null;\n  }\n  /** Finds a transform constraint by comparing each transform constraint's name. It is more efficient to cache the results of\n   * this method than to call it repeatedly.\n   * @return May be null. */\n  findTransformConstraint(constraintName) {\n    if (!constraintName)\n      throw new Error(\"constraintName cannot be null.\");\n    const transformConstraints = this.transformConstraints;\n    for (let i = 0, n = transformConstraints.length; i < n; i++) {\n      const constraint = transformConstraints[i];\n      if (constraint.data.name == constraintName)\n        return constraint;\n    }\n    return null;\n  }\n  /** Finds a path constraint by comparing each path constraint's name. It is more efficient to cache the results of this method\n   * than to call it repeatedly.\n   * @return May be null. */\n  findPathConstraint(constraintName) {\n    if (!constraintName)\n      throw new Error(\"constraintName cannot be null.\");\n    const pathConstraints = this.pathConstraints;\n    for (let i = 0, n = pathConstraints.length; i < n; i++) {\n      const constraint = pathConstraints[i];\n      if (constraint.data.name == constraintName)\n        return constraint;\n    }\n    return null;\n  }\n  /** Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose as `{ x: number, y: number, width: number, height: number }`.\n   * Note that this method will create temporary objects which can add to garbage collection pressure. Use `getBounds()` if garbage collection is a concern. */\n  getBoundsRect() {\n    const offset = new Vector2();\n    const size = new Vector2();\n    this.getBounds(offset, size);\n    return { x: offset.x, y: offset.y, width: size.x, height: size.y };\n  }\n  /** Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose.\n   * @param offset An output value, the distance from the skeleton origin to the bottom left corner of the AABB.\n   * @param size An output value, the width and height of the AABB.\n   * @param temp Working memory to temporarily store attachments' computed world vertices. */\n  getBounds(offset, size, temp = new Array(2)) {\n    if (!offset)\n      throw new Error(\"offset cannot be null.\");\n    if (!size)\n      throw new Error(\"size cannot be null.\");\n    const drawOrder = this.drawOrder;\n    let minX = Number.POSITIVE_INFINITY;\n    let minY = Number.POSITIVE_INFINITY;\n    let maxX = Number.NEGATIVE_INFINITY;\n    let maxY = Number.NEGATIVE_INFINITY;\n    for (let i = 0, n = drawOrder.length; i < n; i++) {\n      const slot = drawOrder[i];\n      if (!slot.bone.active)\n        continue;\n      let verticesLength = 0;\n      let vertices = null;\n      const attachment = slot.getAttachment();\n      if (attachment instanceof RegionAttachment) {\n        verticesLength = 8;\n        vertices = Utils.setArraySize(temp, verticesLength, 0);\n        attachment.computeWorldVertices(slot, vertices, 0, 2);\n      } else if (attachment instanceof MeshAttachment) {\n        const mesh = attachment;\n        verticesLength = mesh.worldVerticesLength;\n        vertices = Utils.setArraySize(temp, verticesLength, 0);\n        mesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);\n      }\n      if (vertices) {\n        for (let ii = 0, nn = vertices.length; ii < nn; ii += 2) {\n          const x = vertices[ii];\n          const y = vertices[ii + 1];\n          minX = Math.min(minX, x);\n          minY = Math.min(minY, y);\n          maxX = Math.max(maxX, x);\n          maxY = Math.max(maxY, y);\n        }\n      }\n    }\n    offset.set(minX, minY);\n    size.set(maxX - minX, maxY - minY);\n  }\n  get flipX() {\n    return this.scaleX == -1;\n  }\n  set flipX(value) {\n    if (!_Skeleton.deprecatedWarning1) {\n      _Skeleton.deprecatedWarning1 = true;\n      console.warn(\"Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY\");\n    }\n    this.scaleX = value ? 1 : -1;\n  }\n  get flipY() {\n    return this.scaleY == -1;\n  }\n  set flipY(value) {\n    if (!_Skeleton.deprecatedWarning1) {\n      _Skeleton.deprecatedWarning1 = true;\n      console.warn(\"Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY\");\n    }\n    this.scaleY = value ? 1 : -1;\n  }\n};\nlet Skeleton = _Skeleton;\nSkeleton.deprecatedWarning1 = false;\n\nexport { Skeleton };\n//# sourceMappingURL=Skeleton.mjs.map\n","class SkeletonData {\n  constructor() {\n    /** The skeleton's name, which by default is the name of the skeleton data file, if possible. May be null. */\n    this.name = null;\n    /** The skeleton's bones, sorted parent first. The root bone is always the first bone. */\n    this.bones = new Array();\n    // Ordered parents first.\n    /** The skeleton's slots. */\n    this.slots = new Array();\n    // Setup pose draw order.\n    this.skins = new Array();\n    /** The skeleton's default skin. By default this skin contains all attachments that were not in a skin in Spine.\n     *\n     * See {@link Skeleton#getAttachmentByName()}.\n     * May be null. */\n    this.defaultSkin = null;\n    /** The skeleton's events. */\n    this.events = new Array();\n    /** The skeleton's animations. */\n    this.animations = new Array();\n    /** The skeleton's IK constraints. */\n    this.ikConstraints = new Array();\n    /** The skeleton's transform constraints. */\n    this.transformConstraints = new Array();\n    /** The skeleton's path constraints. */\n    this.pathConstraints = new Array();\n    /** The X coordinate of the skeleton's axis aligned bounding box in the setup pose. */\n    this.x = 0;\n    /** The Y coordinate of the skeleton's axis aligned bounding box in the setup pose. */\n    this.y = 0;\n    /** The width of the skeleton's axis aligned bounding box in the setup pose. */\n    this.width = 0;\n    /** The height of the skeleton's axis aligned bounding box in the setup pose. */\n    this.height = 0;\n    /** The Spine version used to export the skeleton data, or null. */\n    this.version = null;\n    /** The skeleton data hash. This value will change if any of the skeleton data has changed. May be null. */\n    this.hash = null;\n    // Nonessential\n    /** The dopesheet FPS in Spine. Available only when nonessential data was exported. */\n    this.fps = 0;\n    /** The path to the images directory as defined in Spine. Available only when nonessential data was exported. May be null. */\n    this.imagesPath = null;\n    /** The path to the audio directory as defined in Spine. Available only when nonessential data was exported. May be null. */\n    this.audioPath = null;\n  }\n  /** Finds a bone by comparing each bone's name. It is more efficient to cache the results of this method than to call it\n   * multiple times.\n   * @returns May be null. */\n  findBone(boneName) {\n    if (!boneName)\n      throw new Error(\"boneName cannot be null.\");\n    const bones = this.bones;\n    for (let i = 0, n = bones.length; i < n; i++) {\n      const bone = bones[i];\n      if (bone.name == boneName)\n        return bone;\n    }\n    return null;\n  }\n  /** removed from spine-ts runtime **/\n  findBoneIndex(boneName) {\n    if (!boneName)\n      throw new Error(\"boneName cannot be null.\");\n    const bones = this.bones;\n    for (let i = 0, n = bones.length; i < n; i++)\n      if (bones[i].name == boneName)\n        return i;\n    return -1;\n  }\n  /** Finds a slot by comparing each slot's name. It is more efficient to cache the results of this method than to call it\n   * multiple times.\n   * @returns May be null. */\n  findSlot(slotName) {\n    if (!slotName)\n      throw new Error(\"slotName cannot be null.\");\n    const slots = this.slots;\n    for (let i = 0, n = slots.length; i < n; i++) {\n      const slot = slots[i];\n      if (slot.name == slotName)\n        return slot;\n    }\n    return null;\n  }\n  /** removed from spine-ts runtime **/\n  findSlotIndex(slotName) {\n    if (!slotName)\n      throw new Error(\"slotName cannot be null.\");\n    const slots = this.slots;\n    for (let i = 0, n = slots.length; i < n; i++)\n      if (slots[i].name == slotName)\n        return i;\n    return -1;\n  }\n  /** Finds a skin by comparing each skin's name. It is more efficient to cache the results of this method than to call it\n   * multiple times.\n   * @returns May be null. */\n  findSkin(skinName) {\n    if (!skinName)\n      throw new Error(\"skinName cannot be null.\");\n    const skins = this.skins;\n    for (let i = 0, n = skins.length; i < n; i++) {\n      const skin = skins[i];\n      if (skin.name == skinName)\n        return skin;\n    }\n    return null;\n  }\n  /** Finds an event by comparing each events's name. It is more efficient to cache the results of this method than to call it\n   * multiple times.\n   * @returns May be null. */\n  findEvent(eventDataName) {\n    if (!eventDataName)\n      throw new Error(\"eventDataName cannot be null.\");\n    const events = this.events;\n    for (let i = 0, n = events.length; i < n; i++) {\n      const event = events[i];\n      if (event.name == eventDataName)\n        return event;\n    }\n    return null;\n  }\n  /** Finds an animation by comparing each animation's name. It is more efficient to cache the results of this method than to\n   * call it multiple times.\n   * @returns May be null. */\n  findAnimation(animationName) {\n    if (!animationName)\n      throw new Error(\"animationName cannot be null.\");\n    const animations = this.animations;\n    for (let i = 0, n = animations.length; i < n; i++) {\n      const animation = animations[i];\n      if (animation.name == animationName)\n        return animation;\n    }\n    return null;\n  }\n  /** Finds an IK constraint by comparing each IK constraint's name. It is more efficient to cache the results of this method\n   * than to call it multiple times.\n   * @return May be null. */\n  findIkConstraint(constraintName) {\n    if (!constraintName)\n      throw new Error(\"constraintName cannot be null.\");\n    const ikConstraints = this.ikConstraints;\n    for (let i = 0, n = ikConstraints.length; i < n; i++) {\n      const constraint = ikConstraints[i];\n      if (constraint.name == constraintName)\n        return constraint;\n    }\n    return null;\n  }\n  /** Finds a transform constraint by comparing each transform constraint's name. It is more efficient to cache the results of\n   * this method than to call it multiple times.\n   * @return May be null. */\n  findTransformConstraint(constraintName) {\n    if (!constraintName)\n      throw new Error(\"constraintName cannot be null.\");\n    const transformConstraints = this.transformConstraints;\n    for (let i = 0, n = transformConstraints.length; i < n; i++) {\n      const constraint = transformConstraints[i];\n      if (constraint.name == constraintName)\n        return constraint;\n    }\n    return null;\n  }\n  /** Finds a path constraint by comparing each path constraint's name. It is more efficient to cache the results of this method\n   * than to call it multiple times.\n   * @return May be null. */\n  findPathConstraint(constraintName) {\n    if (!constraintName)\n      throw new Error(\"constraintName cannot be null.\");\n    const pathConstraints = this.pathConstraints;\n    for (let i = 0, n = pathConstraints.length; i < n; i++) {\n      const constraint = pathConstraints[i];\n      if (constraint.name == constraintName)\n        return constraint;\n    }\n    return null;\n  }\n  /** removed from spine-ts runtime **/\n  findPathConstraintIndex(pathConstraintName) {\n    if (pathConstraintName == null)\n      throw new Error(\"pathConstraintName cannot be null.\");\n    const pathConstraints = this.pathConstraints;\n    for (let i = 0, n = pathConstraints.length; i < n; i++)\n      if (pathConstraints[i].name == pathConstraintName)\n        return i;\n    return -1;\n  }\n}\n\nexport { SkeletonData };\n//# sourceMappingURL=SkeletonData.mjs.map\n","import { Color } from '@pixi-spine/base';\nimport { BLEND_MODES } from '@pixi/core';\n\nclass SlotData {\n  constructor(index, name, boneData) {\n    /** The index of the slot in {@link Skeleton#getSlots()}. */\n    this.index = 0;\n    /** The color used to tint the slot's attachment. If {@link #getDarkColor()} is set, this is used as the light color for two\n     * color tinting. */\n    this.color = new Color(1, 1, 1, 1);\n    /** The dark color used to tint the slot's attachment for two color tinting, or null if two color tinting is not used. The dark\n     * color's alpha is not used. */\n    this.darkColor = null;\n    /** The name of the attachment that is visible for this slot in the setup pose, or null if no attachment is visible. */\n    this.attachmentName = null;\n    /** The blend mode for drawing the slot's attachment. */\n    this.blendMode = BLEND_MODES.NORMAL;\n    if (index < 0)\n      throw new Error(\"index must be >= 0.\");\n    if (!name)\n      throw new Error(\"name cannot be null.\");\n    if (!boneData)\n      throw new Error(\"boneData cannot be null.\");\n    this.index = index;\n    this.name = name;\n    this.boneData = boneData;\n  }\n}\n\nexport { SlotData };\n//# sourceMappingURL=SlotData.mjs.map\n","import { ConstraintData } from './ConstraintData.mjs';\n\nclass TransformConstraintData extends ConstraintData {\n  constructor(name) {\n    super(name, 0, false);\n    /** The bones that will be modified by this transform constraint. */\n    this.bones = new Array();\n    /** The target bone whose world transform will be copied to the constrained bones. */\n    this._target = null;\n    this.mixRotate = 0;\n    this.mixX = 0;\n    this.mixY = 0;\n    this.mixScaleX = 0;\n    this.mixScaleY = 0;\n    this.mixShearY = 0;\n    /** An offset added to the constrained bone rotation. */\n    this.offsetRotation = 0;\n    /** An offset added to the constrained bone X translation. */\n    this.offsetX = 0;\n    /** An offset added to the constrained bone Y translation. */\n    this.offsetY = 0;\n    /** An offset added to the constrained bone scaleX. */\n    this.offsetScaleX = 0;\n    /** An offset added to the constrained bone scaleY. */\n    this.offsetScaleY = 0;\n    /** An offset added to the constrained bone shearY. */\n    this.offsetShearY = 0;\n    this.relative = false;\n    this.local = false;\n  }\n  set target(boneData) {\n    this._target = boneData;\n  }\n  get target() {\n    if (!this._target)\n      throw new Error(\"BoneData not set.\");\n    else\n      return this._target;\n  }\n}\n\nexport { TransformConstraintData };\n//# sourceMappingURL=TransformConstraintData.mjs.map\n","import './attachments/Attachment.mjs';\nimport '@pixi-spine/base';\nimport { MeshAttachment } from './attachments/MeshAttachment.mjs';\nimport './attachments/RegionAttachment.mjs';\nimport './attachments/Sequence.mjs';\n\nclass SkinEntry {\n  constructor(slotIndex, name, attachment) {\n    this.slotIndex = slotIndex;\n    this.name = name;\n    this.attachment = attachment;\n  }\n}\nclass Skin {\n  constructor(name) {\n    this.attachments = new Array();\n    this.bones = Array();\n    this.constraints = new Array();\n    if (!name)\n      throw new Error(\"name cannot be null.\");\n    this.name = name;\n  }\n  /** Adds an attachment to the skin for the specified slot index and name. */\n  setAttachment(slotIndex, name, attachment) {\n    if (!attachment)\n      throw new Error(\"attachment cannot be null.\");\n    const attachments = this.attachments;\n    if (slotIndex >= attachments.length)\n      attachments.length = slotIndex + 1;\n    if (!attachments[slotIndex])\n      attachments[slotIndex] = {};\n    attachments[slotIndex][name] = attachment;\n  }\n  /** Adds all attachments, bones, and constraints from the specified skin to this skin. */\n  addSkin(skin) {\n    for (let i = 0; i < skin.bones.length; i++) {\n      const bone = skin.bones[i];\n      let contained = false;\n      for (let ii = 0; ii < this.bones.length; ii++) {\n        if (this.bones[ii] == bone) {\n          contained = true;\n          break;\n        }\n      }\n      if (!contained)\n        this.bones.push(bone);\n    }\n    for (let i = 0; i < skin.constraints.length; i++) {\n      const constraint = skin.constraints[i];\n      let contained = false;\n      for (let ii = 0; ii < this.constraints.length; ii++) {\n        if (this.constraints[ii] == constraint) {\n          contained = true;\n          break;\n        }\n      }\n      if (!contained)\n        this.constraints.push(constraint);\n    }\n    const attachments = skin.getAttachments();\n    for (let i = 0; i < attachments.length; i++) {\n      const attachment = attachments[i];\n      this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\n    }\n  }\n  /** Adds all bones and constraints and copies of all attachments from the specified skin to this skin. Mesh attachments are not\n   * copied, instead a new linked mesh is created. The attachment copies can be modified without affecting the originals. */\n  copySkin(skin) {\n    for (let i = 0; i < skin.bones.length; i++) {\n      const bone = skin.bones[i];\n      let contained = false;\n      for (let ii = 0; ii < this.bones.length; ii++) {\n        if (this.bones[ii] == bone) {\n          contained = true;\n          break;\n        }\n      }\n      if (!contained)\n        this.bones.push(bone);\n    }\n    for (let i = 0; i < skin.constraints.length; i++) {\n      const constraint = skin.constraints[i];\n      let contained = false;\n      for (let ii = 0; ii < this.constraints.length; ii++) {\n        if (this.constraints[ii] == constraint) {\n          contained = true;\n          break;\n        }\n      }\n      if (!contained)\n        this.constraints.push(constraint);\n    }\n    const attachments = skin.getAttachments();\n    for (let i = 0; i < attachments.length; i++) {\n      const attachment = attachments[i];\n      if (!attachment.attachment)\n        continue;\n      if (attachment.attachment instanceof MeshAttachment) {\n        attachment.attachment = attachment.attachment.newLinkedMesh();\n        this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\n      } else {\n        attachment.attachment = attachment.attachment.copy();\n        this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\n      }\n    }\n  }\n  /** Returns the attachment for the specified slot index and name, or null. */\n  getAttachment(slotIndex, name) {\n    const dictionary = this.attachments[slotIndex];\n    return dictionary ? dictionary[name] : null;\n  }\n  /** Removes the attachment in the skin for the specified slot index and name, if any. */\n  removeAttachment(slotIndex, name) {\n    const dictionary = this.attachments[slotIndex];\n    if (dictionary)\n      delete dictionary[name];\n  }\n  /** Returns all attachments in this skin. */\n  getAttachments() {\n    const entries = new Array();\n    for (let i = 0; i < this.attachments.length; i++) {\n      const slotAttachments = this.attachments[i];\n      if (slotAttachments) {\n        for (const name in slotAttachments) {\n          const attachment = slotAttachments[name];\n          if (attachment)\n            entries.push(new SkinEntry(i, name, attachment));\n        }\n      }\n    }\n    return entries;\n  }\n  /** Returns all attachments in this skin for the specified slot index. */\n  getAttachmentsForSlot(slotIndex, attachments) {\n    const slotAttachments = this.attachments[slotIndex];\n    if (slotAttachments) {\n      for (const name in slotAttachments) {\n        const attachment = slotAttachments[name];\n        if (attachment)\n          attachments.push(new SkinEntry(slotIndex, name, attachment));\n      }\n    }\n  }\n  /** Clears all attachments, bones, and constraints. */\n  clear() {\n    this.attachments.length = 0;\n    this.bones.length = 0;\n    this.constraints.length = 0;\n  }\n  /** Attach each attachment in this skin if the corresponding attachment in the old skin is currently attached. */\n  attachAll(skeleton, oldSkin) {\n    let slotIndex = 0;\n    for (let i = 0; i < skeleton.slots.length; i++) {\n      const slot = skeleton.slots[i];\n      const slotAttachment = slot.getAttachment();\n      if (slotAttachment && slotIndex < oldSkin.attachments.length) {\n        const dictionary = oldSkin.attachments[slotIndex];\n        for (const key in dictionary) {\n          const skinAttachment = dictionary[key];\n          if (slotAttachment == skinAttachment) {\n            const attachment = this.getAttachment(slotIndex, key);\n            if (attachment)\n              slot.setAttachment(attachment);\n            break;\n          }\n        }\n      }\n      slotIndex++;\n    }\n  }\n}\n\nexport { Skin, SkinEntry };\n//# sourceMappingURL=Skin.mjs.map\n","import { AlphaTimeline, RGB2Timeline, RGBA2Timeline, RGBTimeline, RGBATimeline, AttachmentTimeline, ShearYTimeline, ShearXTimeline, ShearTimeline, ScaleYTimeline, ScaleXTimeline, ScaleTimeline, TranslateYTimeline, TranslateXTimeline, TranslateTimeline, RotateTimeline, IkConstraintTimeline, TransformConstraintTimeline, PathConstraintMixTimeline, PathConstraintSpacingTimeline, PathConstraintPositionTimeline, SequenceTimeline, DeformTimeline, DrawOrderTimeline, EventTimeline, Animation } from './Animation.mjs';\nimport { Event } from './Event.mjs';\nimport { SkeletonData } from './SkeletonData.mjs';\nimport { SlotData } from './SlotData.mjs';\nimport { BoneData } from './BoneData.mjs';\nimport { IkConstraintData } from './IkConstraintData.mjs';\nimport { TransformConstraintData } from './TransformConstraintData.mjs';\nimport { PathConstraintData, SpacingMode } from './PathConstraintData.mjs';\nimport { Skin } from './Skin.mjs';\nimport { EventData } from './EventData.mjs';\nimport { BinaryInput, Color, PositionMode, Utils, AttachmentType } from '@pixi-spine/base';\nimport { BLEND_MODES } from '@pixi/core';\nimport './attachments/Attachment.mjs';\nimport './attachments/RegionAttachment.mjs';\nimport { Sequence, SequenceModeValues } from './attachments/Sequence.mjs';\n\nclass SkeletonBinary {\n  constructor(attachmentLoader) {\n    this.ver40 = false;\n    /** Scales bone positions, image sizes, and translations as they are loaded. This allows different size images to be used at\n     * runtime than were used in Spine.\n     *\n     * See [Scaling](http://esotericsoftware.com/spine-loading-skeleton-data#Scaling) in the Spine Runtimes Guide. */\n    this.scale = 1;\n    this.linkedMeshes = new Array();\n    this.attachmentLoader = attachmentLoader;\n  }\n  readSkeletonData(binary) {\n    const scale = this.scale;\n    const skeletonData = new SkeletonData();\n    skeletonData.name = \"\";\n    const input = new BinaryInput(binary);\n    const lowHash = input.readInt32();\n    const highHash = input.readInt32();\n    skeletonData.hash = highHash == 0 && lowHash == 0 ? null : highHash.toString(16) + lowHash.toString(16);\n    skeletonData.version = input.readString();\n    const verShort = skeletonData.version.substr(0, 3);\n    if (verShort !== \"4.0\" && verShort !== \"4.1\") {\n      const error = `Spine 4.1 loader cant load version ${skeletonData.version}. Please configure your pixi-spine bundle`;\n      console.error(error);\n    }\n    this.ver40 = verShort === \"4.0\";\n    skeletonData.x = input.readFloat();\n    skeletonData.y = input.readFloat();\n    skeletonData.width = input.readFloat();\n    skeletonData.height = input.readFloat();\n    const nonessential = input.readBoolean();\n    if (nonessential) {\n      skeletonData.fps = input.readFloat();\n      skeletonData.imagesPath = input.readString();\n      skeletonData.audioPath = input.readString();\n    }\n    let n = 0;\n    n = input.readInt(true);\n    for (let i = 0; i < n; i++) {\n      const str = input.readString();\n      if (!str)\n        throw new Error(\"String in string table must not be null.\");\n      input.strings.push(str);\n    }\n    n = input.readInt(true);\n    for (let i = 0; i < n; i++) {\n      const name = input.readString();\n      if (!name)\n        throw new Error(\"Bone name must not be null.\");\n      const parent = i == 0 ? null : skeletonData.bones[input.readInt(true)];\n      const data = new BoneData(i, name, parent);\n      data.rotation = input.readFloat();\n      data.x = input.readFloat() * scale;\n      data.y = input.readFloat() * scale;\n      data.scaleX = input.readFloat();\n      data.scaleY = input.readFloat();\n      data.shearX = input.readFloat();\n      data.shearY = input.readFloat();\n      data.length = input.readFloat() * scale;\n      data.transformMode = input.readInt(true);\n      data.skinRequired = input.readBoolean();\n      if (nonessential)\n        Color.rgba8888ToColor(data.color, input.readInt32());\n      skeletonData.bones.push(data);\n    }\n    n = input.readInt(true);\n    for (let i = 0; i < n; i++) {\n      const slotName = input.readString();\n      if (!slotName)\n        throw new Error(\"Slot name must not be null.\");\n      const boneData = skeletonData.bones[input.readInt(true)];\n      const data = new SlotData(i, slotName, boneData);\n      Color.rgba8888ToColor(data.color, input.readInt32());\n      const darkColor = input.readInt32();\n      if (darkColor != -1)\n        Color.rgb888ToColor(data.darkColor = new Color(), darkColor);\n      data.attachmentName = input.readStringRef();\n      data.blendMode = input.readInt(true);\n      skeletonData.slots.push(data);\n    }\n    n = input.readInt(true);\n    for (let i = 0, nn; i < n; i++) {\n      const name = input.readString();\n      if (!name)\n        throw new Error(\"IK constraint data name must not be null.\");\n      const data = new IkConstraintData(name);\n      data.order = input.readInt(true);\n      data.skinRequired = input.readBoolean();\n      nn = input.readInt(true);\n      for (let ii = 0; ii < nn; ii++)\n        data.bones.push(skeletonData.bones[input.readInt(true)]);\n      data.target = skeletonData.bones[input.readInt(true)];\n      data.mix = input.readFloat();\n      data.softness = input.readFloat() * scale;\n      data.bendDirection = input.readByte();\n      data.compress = input.readBoolean();\n      data.stretch = input.readBoolean();\n      data.uniform = input.readBoolean();\n      skeletonData.ikConstraints.push(data);\n    }\n    n = input.readInt(true);\n    for (let i = 0, nn; i < n; i++) {\n      const name = input.readString();\n      if (!name)\n        throw new Error(\"Transform constraint data name must not be null.\");\n      const data = new TransformConstraintData(name);\n      data.order = input.readInt(true);\n      data.skinRequired = input.readBoolean();\n      nn = input.readInt(true);\n      for (let ii = 0; ii < nn; ii++)\n        data.bones.push(skeletonData.bones[input.readInt(true)]);\n      data.target = skeletonData.bones[input.readInt(true)];\n      data.local = input.readBoolean();\n      data.relative = input.readBoolean();\n      data.offsetRotation = input.readFloat();\n      data.offsetX = input.readFloat() * scale;\n      data.offsetY = input.readFloat() * scale;\n      data.offsetScaleX = input.readFloat();\n      data.offsetScaleY = input.readFloat();\n      data.offsetShearY = input.readFloat();\n      data.mixRotate = input.readFloat();\n      data.mixX = input.readFloat();\n      data.mixY = input.readFloat();\n      data.mixScaleX = input.readFloat();\n      data.mixScaleY = input.readFloat();\n      data.mixShearY = input.readFloat();\n      skeletonData.transformConstraints.push(data);\n    }\n    n = input.readInt(true);\n    for (let i = 0, nn; i < n; i++) {\n      const name = input.readString();\n      if (!name)\n        throw new Error(\"Path constraint data name must not be null.\");\n      const data = new PathConstraintData(name);\n      data.order = input.readInt(true);\n      data.skinRequired = input.readBoolean();\n      nn = input.readInt(true);\n      for (let ii = 0; ii < nn; ii++)\n        data.bones.push(skeletonData.bones[input.readInt(true)]);\n      data.target = skeletonData.slots[input.readInt(true)];\n      data.positionMode = input.readInt(true);\n      data.spacingMode = input.readInt(true);\n      data.rotateMode = input.readInt(true);\n      data.offsetRotation = input.readFloat();\n      data.position = input.readFloat();\n      if (data.positionMode == PositionMode.Fixed)\n        data.position *= scale;\n      data.spacing = input.readFloat();\n      if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed)\n        data.spacing *= scale;\n      data.mixRotate = input.readFloat();\n      data.mixX = input.readFloat();\n      data.mixY = input.readFloat();\n      skeletonData.pathConstraints.push(data);\n    }\n    const defaultSkin = this.readSkin(input, skeletonData, true, nonessential);\n    if (defaultSkin) {\n      skeletonData.defaultSkin = defaultSkin;\n      skeletonData.skins.push(defaultSkin);\n    }\n    {\n      let i = skeletonData.skins.length;\n      Utils.setArraySize(skeletonData.skins, n = i + input.readInt(true));\n      for (; i < n; i++) {\n        const skin = this.readSkin(input, skeletonData, false, nonessential);\n        if (!skin)\n          throw new Error(\"readSkin() should not have returned null.\");\n        skeletonData.skins[i] = skin;\n      }\n    }\n    n = this.linkedMeshes.length;\n    for (let i = 0; i < n; i++) {\n      const linkedMesh = this.linkedMeshes[i];\n      const skin = !linkedMesh.skin ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\n      if (!skin)\n        throw new Error(\"Not skin found for linked mesh.\");\n      if (!linkedMesh.parent)\n        throw new Error(\"Linked mesh parent must not be null\");\n      const parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\n      if (!parent)\n        throw new Error(`Parent mesh not found: ${linkedMesh.parent}`);\n      linkedMesh.mesh.timelineAttachment = linkedMesh.inheritTimeline ? parent : linkedMesh.mesh;\n      linkedMesh.mesh.setParentMesh(parent);\n    }\n    this.linkedMeshes.length = 0;\n    n = input.readInt(true);\n    for (let i = 0; i < n; i++) {\n      const eventName = input.readStringRef();\n      if (!eventName)\n        throw new Error();\n      const data = new EventData(eventName);\n      data.intValue = input.readInt(false);\n      data.floatValue = input.readFloat();\n      data.stringValue = input.readString();\n      data.audioPath = input.readString();\n      if (data.audioPath) {\n        data.volume = input.readFloat();\n        data.balance = input.readFloat();\n      }\n      skeletonData.events.push(data);\n    }\n    n = input.readInt(true);\n    for (let i = 0; i < n; i++) {\n      const animationName = input.readString();\n      if (!animationName)\n        throw new Error(\"Animatio name must not be null.\");\n      skeletonData.animations.push(this.readAnimation(input, animationName, skeletonData));\n    }\n    return skeletonData;\n  }\n  readSkin(input, skeletonData, defaultSkin, nonessential) {\n    let skin = null;\n    let slotCount = 0;\n    if (defaultSkin) {\n      slotCount = input.readInt(true);\n      if (slotCount == 0)\n        return null;\n      skin = new Skin(\"default\");\n    } else {\n      const skinName = input.readStringRef();\n      if (!skinName)\n        throw new Error(\"Skin name must not be null.\");\n      skin = new Skin(skinName);\n      skin.bones.length = input.readInt(true);\n      for (let i = 0, n = skin.bones.length; i < n; i++)\n        skin.bones[i] = skeletonData.bones[input.readInt(true)];\n      for (let i = 0, n = input.readInt(true); i < n; i++)\n        skin.constraints.push(skeletonData.ikConstraints[input.readInt(true)]);\n      for (let i = 0, n = input.readInt(true); i < n; i++)\n        skin.constraints.push(skeletonData.transformConstraints[input.readInt(true)]);\n      for (let i = 0, n = input.readInt(true); i < n; i++)\n        skin.constraints.push(skeletonData.pathConstraints[input.readInt(true)]);\n      slotCount = input.readInt(true);\n    }\n    for (let i = 0; i < slotCount; i++) {\n      const slotIndex = input.readInt(true);\n      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n        const name = input.readStringRef();\n        if (!name)\n          throw new Error(\"Attachment name must not be null\");\n        const attachment = this.readAttachment(input, skeletonData, skin, slotIndex, name, nonessential);\n        if (attachment)\n          skin.setAttachment(slotIndex, name, attachment);\n      }\n    }\n    return skin;\n  }\n  readAttachment(input, skeletonData, skin, slotIndex, attachmentName, nonessential) {\n    const scale = this.scale;\n    let name = input.readStringRef();\n    if (!name)\n      name = attachmentName;\n    switch (input.readByte()) {\n      case AttachmentType.Region: {\n        let path = input.readStringRef();\n        const rotation = input.readFloat();\n        const x = input.readFloat();\n        const y = input.readFloat();\n        const scaleX = input.readFloat();\n        const scaleY = input.readFloat();\n        const width = input.readFloat();\n        const height = input.readFloat();\n        const color = input.readInt32();\n        const sequence = this.readSequence(input);\n        if (!path)\n          path = name;\n        const region = this.attachmentLoader.newRegionAttachment(skin, name, path, sequence);\n        if (!region)\n          return null;\n        region.path = path;\n        region.x = x * scale;\n        region.y = y * scale;\n        region.scaleX = scaleX;\n        region.scaleY = scaleY;\n        region.rotation = rotation;\n        region.width = width * scale;\n        region.height = height * scale;\n        Color.rgba8888ToColor(region.color, color);\n        region.sequence = sequence;\n        if (sequence == null)\n          region.updateRegion();\n        return region;\n      }\n      case AttachmentType.BoundingBox: {\n        const vertexCount = input.readInt(true);\n        const vertices = this.readVertices(input, vertexCount);\n        const color = nonessential ? input.readInt32() : 0;\n        const box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\n        if (!box)\n          return null;\n        box.worldVerticesLength = vertexCount << 1;\n        box.vertices = vertices.vertices;\n        box.bones = vertices.bones;\n        if (nonessential)\n          Color.rgba8888ToColor(box.color, color);\n        return box;\n      }\n      case AttachmentType.Mesh: {\n        let path = input.readStringRef();\n        const color = input.readInt32();\n        const vertexCount = input.readInt(true);\n        const uvs = this.readFloatArray(input, vertexCount << 1, 1);\n        const triangles = this.readShortArray(input);\n        const vertices = this.readVertices(input, vertexCount);\n        const hullLength = input.readInt(true);\n        const sequence = this.readSequence(input);\n        let edges = [];\n        let width = 0;\n        let height = 0;\n        if (nonessential) {\n          edges = this.readShortArray(input);\n          width = input.readFloat();\n          height = input.readFloat();\n        }\n        if (!path)\n          path = name;\n        const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path, sequence);\n        if (!mesh)\n          return null;\n        mesh.path = path;\n        Color.rgba8888ToColor(mesh.color, color);\n        mesh.bones = vertices.bones;\n        mesh.vertices = vertices.vertices;\n        mesh.worldVerticesLength = vertexCount << 1;\n        mesh.triangles = triangles;\n        mesh.regionUVs = new Float32Array(uvs);\n        mesh.hullLength = hullLength << 1;\n        mesh.sequence = sequence;\n        if (nonessential) {\n          mesh.edges = edges;\n          mesh.width = width * scale;\n          mesh.height = height * scale;\n        }\n        return mesh;\n      }\n      case AttachmentType.LinkedMesh: {\n        let path = input.readStringRef();\n        const color = input.readInt32();\n        const skinName = input.readStringRef();\n        const parent = input.readStringRef();\n        const inheritTimelines = input.readBoolean();\n        const sequence = this.readSequence(input);\n        let width = 0;\n        let height = 0;\n        if (nonessential) {\n          width = input.readFloat();\n          height = input.readFloat();\n        }\n        if (!path)\n          path = name;\n        const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path, sequence);\n        if (!mesh)\n          return null;\n        mesh.path = path;\n        Color.rgba8888ToColor(mesh.color, color);\n        mesh.sequence = sequence;\n        if (nonessential) {\n          mesh.width = width * scale;\n          mesh.height = height * scale;\n        }\n        this.linkedMeshes.push(new LinkedMesh(mesh, skinName, slotIndex, parent, inheritTimelines));\n        return mesh;\n      }\n      case AttachmentType.Path: {\n        const closed = input.readBoolean();\n        const constantSpeed = input.readBoolean();\n        const vertexCount = input.readInt(true);\n        const vertices = this.readVertices(input, vertexCount);\n        const lengths = Utils.newArray(vertexCount / 3, 0);\n        for (let i = 0, n = lengths.length; i < n; i++)\n          lengths[i] = input.readFloat() * scale;\n        const color = nonessential ? input.readInt32() : 0;\n        const path = this.attachmentLoader.newPathAttachment(skin, name);\n        if (!path)\n          return null;\n        path.closed = closed;\n        path.constantSpeed = constantSpeed;\n        path.worldVerticesLength = vertexCount << 1;\n        path.vertices = vertices.vertices;\n        path.bones = vertices.bones;\n        path.lengths = lengths;\n        if (nonessential)\n          Color.rgba8888ToColor(path.color, color);\n        return path;\n      }\n      case AttachmentType.Point: {\n        const rotation = input.readFloat();\n        const x = input.readFloat();\n        const y = input.readFloat();\n        const color = nonessential ? input.readInt32() : 0;\n        const point = this.attachmentLoader.newPointAttachment(skin, name);\n        if (!point)\n          return null;\n        point.x = x * scale;\n        point.y = y * scale;\n        point.rotation = rotation;\n        if (nonessential)\n          Color.rgba8888ToColor(point.color, color);\n        return point;\n      }\n      case AttachmentType.Clipping: {\n        const endSlotIndex = input.readInt(true);\n        const vertexCount = input.readInt(true);\n        const vertices = this.readVertices(input, vertexCount);\n        const color = nonessential ? input.readInt32() : 0;\n        const clip = this.attachmentLoader.newClippingAttachment(skin, name);\n        if (!clip)\n          return null;\n        clip.endSlot = skeletonData.slots[endSlotIndex];\n        clip.worldVerticesLength = vertexCount << 1;\n        clip.vertices = vertices.vertices;\n        clip.bones = vertices.bones;\n        if (nonessential)\n          Color.rgba8888ToColor(clip.color, color);\n        return clip;\n      }\n    }\n    return null;\n  }\n  readSequence(input) {\n    if (this.ver40 || !input.readBoolean())\n      return null;\n    const sequence = new Sequence(input.readInt(true));\n    sequence.start = input.readInt(true);\n    sequence.digits = input.readInt(true);\n    sequence.setupIndex = input.readInt(true);\n    return sequence;\n  }\n  readDeformTimelineType(input) {\n    if (this.ver40)\n      return ATTACHMENT_DEFORM;\n    return input.readByte();\n  }\n  readVertices(input, vertexCount) {\n    const scale = this.scale;\n    const verticesLength = vertexCount << 1;\n    const vertices = new Vertices();\n    if (!input.readBoolean()) {\n      vertices.vertices = this.readFloatArray(input, verticesLength, scale);\n      return vertices;\n    }\n    const weights = new Array();\n    const bonesArray = new Array();\n    for (let i = 0; i < vertexCount; i++) {\n      const boneCount = input.readInt(true);\n      bonesArray.push(boneCount);\n      for (let ii = 0; ii < boneCount; ii++) {\n        bonesArray.push(input.readInt(true));\n        weights.push(input.readFloat() * scale);\n        weights.push(input.readFloat() * scale);\n        weights.push(input.readFloat());\n      }\n    }\n    vertices.vertices = Utils.toFloatArray(weights);\n    vertices.bones = bonesArray;\n    return vertices;\n  }\n  readFloatArray(input, n, scale) {\n    const array = new Array(n);\n    if (scale == 1) {\n      for (let i = 0; i < n; i++)\n        array[i] = input.readFloat();\n    } else {\n      for (let i = 0; i < n; i++)\n        array[i] = input.readFloat() * scale;\n    }\n    return array;\n  }\n  readShortArray(input) {\n    const n = input.readInt(true);\n    const array = new Array(n);\n    for (let i = 0; i < n; i++)\n      array[i] = input.readShort();\n    return array;\n  }\n  readAnimation(input, name, skeletonData) {\n    input.readInt(true);\n    const timelines = new Array();\n    const scale = this.scale;\n    for (let i = 0, n = input.readInt(true); i < n; i++) {\n      const slotIndex = input.readInt(true);\n      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n        const timelineType = input.readByte();\n        const frameCount = input.readInt(true);\n        const frameLast = frameCount - 1;\n        switch (timelineType) {\n          case SLOT_ATTACHMENT: {\n            const timeline = new AttachmentTimeline(frameCount, slotIndex);\n            for (let frame = 0; frame < frameCount; frame++)\n              timeline.setFrame(frame, input.readFloat(), input.readStringRef());\n            timelines.push(timeline);\n            break;\n          }\n          case SLOT_RGBA: {\n            const bezierCount = input.readInt(true);\n            const timeline = new RGBATimeline(frameCount, bezierCount, slotIndex);\n            let time = input.readFloat();\n            let r = input.readUnsignedByte() / 255;\n            let g = input.readUnsignedByte() / 255;\n            let b = input.readUnsignedByte() / 255;\n            let a = input.readUnsignedByte() / 255;\n            for (let frame = 0, bezier = 0; ; frame++) {\n              timeline.setFrame(frame, time, r, g, b, a);\n              if (frame == frameLast)\n                break;\n              const time2 = input.readFloat();\n              const r2 = input.readUnsignedByte() / 255;\n              const g2 = input.readUnsignedByte() / 255;\n              const b2 = input.readUnsignedByte() / 255;\n              const a2 = input.readUnsignedByte() / 255;\n              switch (input.readByte()) {\n                case CURVE_STEPPED:\n                  timeline.setStepped(frame);\n                  break;\n                case CURVE_BEZIER:\n                  setBezier(input, timeline, bezier++, frame, 0, time, time2, r, r2, 1);\n                  setBezier(input, timeline, bezier++, frame, 1, time, time2, g, g2, 1);\n                  setBezier(input, timeline, bezier++, frame, 2, time, time2, b, b2, 1);\n                  setBezier(input, timeline, bezier++, frame, 3, time, time2, a, a2, 1);\n              }\n              time = time2;\n              r = r2;\n              g = g2;\n              b = b2;\n              a = a2;\n            }\n            timelines.push(timeline);\n            break;\n          }\n          case SLOT_RGB: {\n            const bezierCount = input.readInt(true);\n            const timeline = new RGBTimeline(frameCount, bezierCount, slotIndex);\n            let time = input.readFloat();\n            let r = input.readUnsignedByte() / 255;\n            let g = input.readUnsignedByte() / 255;\n            let b = input.readUnsignedByte() / 255;\n            for (let frame = 0, bezier = 0; ; frame++) {\n              timeline.setFrame(frame, time, r, g, b);\n              if (frame == frameLast)\n                break;\n              const time2 = input.readFloat();\n              const r2 = input.readUnsignedByte() / 255;\n              const g2 = input.readUnsignedByte() / 255;\n              const b2 = input.readUnsignedByte() / 255;\n              switch (input.readByte()) {\n                case CURVE_STEPPED:\n                  timeline.setStepped(frame);\n                  break;\n                case CURVE_BEZIER:\n                  setBezier(input, timeline, bezier++, frame, 0, time, time2, r, r2, 1);\n                  setBezier(input, timeline, bezier++, frame, 1, time, time2, g, g2, 1);\n                  setBezier(input, timeline, bezier++, frame, 2, time, time2, b, b2, 1);\n              }\n              time = time2;\n              r = r2;\n              g = g2;\n              b = b2;\n            }\n            timelines.push(timeline);\n            break;\n          }\n          case SLOT_RGBA2: {\n            const bezierCount = input.readInt(true);\n            const timeline = new RGBA2Timeline(frameCount, bezierCount, slotIndex);\n            let time = input.readFloat();\n            let r = input.readUnsignedByte() / 255;\n            let g = input.readUnsignedByte() / 255;\n            let b = input.readUnsignedByte() / 255;\n            let a = input.readUnsignedByte() / 255;\n            let r2 = input.readUnsignedByte() / 255;\n            let g2 = input.readUnsignedByte() / 255;\n            let b2 = input.readUnsignedByte() / 255;\n            for (let frame = 0, bezier = 0; ; frame++) {\n              timeline.setFrame(frame, time, r, g, b, a, r2, g2, b2);\n              if (frame == frameLast)\n                break;\n              const time2 = input.readFloat();\n              const nr = input.readUnsignedByte() / 255;\n              const ng = input.readUnsignedByte() / 255;\n              const nb = input.readUnsignedByte() / 255;\n              const na = input.readUnsignedByte() / 255;\n              const nr2 = input.readUnsignedByte() / 255;\n              const ng2 = input.readUnsignedByte() / 255;\n              const nb2 = input.readUnsignedByte() / 255;\n              switch (input.readByte()) {\n                case CURVE_STEPPED:\n                  timeline.setStepped(frame);\n                  break;\n                case CURVE_BEZIER:\n                  setBezier(input, timeline, bezier++, frame, 0, time, time2, r, nr, 1);\n                  setBezier(input, timeline, bezier++, frame, 1, time, time2, g, ng, 1);\n                  setBezier(input, timeline, bezier++, frame, 2, time, time2, b, nb, 1);\n                  setBezier(input, timeline, bezier++, frame, 3, time, time2, a, na, 1);\n                  setBezier(input, timeline, bezier++, frame, 4, time, time2, r2, nr2, 1);\n                  setBezier(input, timeline, bezier++, frame, 5, time, time2, g2, ng2, 1);\n                  setBezier(input, timeline, bezier++, frame, 6, time, time2, b2, nb2, 1);\n              }\n              time = time2;\n              r = nr;\n              g = ng;\n              b = nb;\n              a = na;\n              r2 = nr2;\n              g2 = ng2;\n              b2 = nb2;\n            }\n            timelines.push(timeline);\n            break;\n          }\n          case SLOT_RGB2: {\n            const bezierCount = input.readInt(true);\n            const timeline = new RGB2Timeline(frameCount, bezierCount, slotIndex);\n            let time = input.readFloat();\n            let r = input.readUnsignedByte() / 255;\n            let g = input.readUnsignedByte() / 255;\n            let b = input.readUnsignedByte() / 255;\n            let r2 = input.readUnsignedByte() / 255;\n            let g2 = input.readUnsignedByte() / 255;\n            let b2 = input.readUnsignedByte() / 255;\n            for (let frame = 0, bezier = 0; ; frame++) {\n              timeline.setFrame(frame, time, r, g, b, r2, g2, b2);\n              if (frame == frameLast)\n                break;\n              const time2 = input.readFloat();\n              const nr = input.readUnsignedByte() / 255;\n              const ng = input.readUnsignedByte() / 255;\n              const nb = input.readUnsignedByte() / 255;\n              const nr2 = input.readUnsignedByte() / 255;\n              const ng2 = input.readUnsignedByte() / 255;\n              const nb2 = input.readUnsignedByte() / 255;\n              switch (input.readByte()) {\n                case CURVE_STEPPED:\n                  timeline.setStepped(frame);\n                  break;\n                case CURVE_BEZIER:\n                  setBezier(input, timeline, bezier++, frame, 0, time, time2, r, nr, 1);\n                  setBezier(input, timeline, bezier++, frame, 1, time, time2, g, ng, 1);\n                  setBezier(input, timeline, bezier++, frame, 2, time, time2, b, nb, 1);\n                  setBezier(input, timeline, bezier++, frame, 3, time, time2, r2, nr2, 1);\n                  setBezier(input, timeline, bezier++, frame, 4, time, time2, g2, ng2, 1);\n                  setBezier(input, timeline, bezier++, frame, 5, time, time2, b2, nb2, 1);\n              }\n              time = time2;\n              r = nr;\n              g = ng;\n              b = nb;\n              r2 = nr2;\n              g2 = ng2;\n              b2 = nb2;\n            }\n            timelines.push(timeline);\n            break;\n          }\n          case SLOT_ALPHA: {\n            const timeline = new AlphaTimeline(frameCount, input.readInt(true), slotIndex);\n            let time = input.readFloat();\n            let a = input.readUnsignedByte() / 255;\n            for (let frame = 0, bezier = 0; ; frame++) {\n              timeline.setFrame(frame, time, a);\n              if (frame == frameLast)\n                break;\n              const time2 = input.readFloat();\n              const a2 = input.readUnsignedByte() / 255;\n              switch (input.readByte()) {\n                case CURVE_STEPPED:\n                  timeline.setStepped(frame);\n                  break;\n                case CURVE_BEZIER:\n                  setBezier(input, timeline, bezier++, frame, 0, time, time2, a, a2, 1);\n              }\n              time = time2;\n              a = a2;\n            }\n            timelines.push(timeline);\n          }\n        }\n      }\n    }\n    for (let i = 0, n = input.readInt(true); i < n; i++) {\n      const boneIndex = input.readInt(true);\n      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n        const type = input.readByte();\n        const frameCount = input.readInt(true);\n        const bezierCount = input.readInt(true);\n        switch (type) {\n          case BONE_ROTATE:\n            timelines.push(readTimeline1(input, new RotateTimeline(frameCount, bezierCount, boneIndex), 1));\n            break;\n          case BONE_TRANSLATE:\n            timelines.push(readTimeline2(input, new TranslateTimeline(frameCount, bezierCount, boneIndex), scale));\n            break;\n          case BONE_TRANSLATEX:\n            timelines.push(readTimeline1(input, new TranslateXTimeline(frameCount, bezierCount, boneIndex), scale));\n            break;\n          case BONE_TRANSLATEY:\n            timelines.push(readTimeline1(input, new TranslateYTimeline(frameCount, bezierCount, boneIndex), scale));\n            break;\n          case BONE_SCALE:\n            timelines.push(readTimeline2(input, new ScaleTimeline(frameCount, bezierCount, boneIndex), 1));\n            break;\n          case BONE_SCALEX:\n            timelines.push(readTimeline1(input, new ScaleXTimeline(frameCount, bezierCount, boneIndex), 1));\n            break;\n          case BONE_SCALEY:\n            timelines.push(readTimeline1(input, new ScaleYTimeline(frameCount, bezierCount, boneIndex), 1));\n            break;\n          case BONE_SHEAR:\n            timelines.push(readTimeline2(input, new ShearTimeline(frameCount, bezierCount, boneIndex), 1));\n            break;\n          case BONE_SHEARX:\n            timelines.push(readTimeline1(input, new ShearXTimeline(frameCount, bezierCount, boneIndex), 1));\n            break;\n          case BONE_SHEARY:\n            timelines.push(readTimeline1(input, new ShearYTimeline(frameCount, bezierCount, boneIndex), 1));\n        }\n      }\n    }\n    for (let i = 0, n = input.readInt(true); i < n; i++) {\n      const index = input.readInt(true);\n      const frameCount = input.readInt(true);\n      const frameLast = frameCount - 1;\n      const timeline = new IkConstraintTimeline(frameCount, input.readInt(true), index);\n      let time = input.readFloat();\n      let mix = input.readFloat();\n      let softness = input.readFloat() * scale;\n      for (let frame = 0, bezier = 0; ; frame++) {\n        timeline.setFrame(frame, time, mix, softness, input.readByte(), input.readBoolean(), input.readBoolean());\n        if (frame == frameLast)\n          break;\n        const time2 = input.readFloat();\n        const mix2 = input.readFloat();\n        const softness2 = input.readFloat() * scale;\n        switch (input.readByte()) {\n          case CURVE_STEPPED:\n            timeline.setStepped(frame);\n            break;\n          case CURVE_BEZIER:\n            setBezier(input, timeline, bezier++, frame, 0, time, time2, mix, mix2, 1);\n            setBezier(input, timeline, bezier++, frame, 1, time, time2, softness, softness2, scale);\n        }\n        time = time2;\n        mix = mix2;\n        softness = softness2;\n      }\n      timelines.push(timeline);\n    }\n    for (let i = 0, n = input.readInt(true); i < n; i++) {\n      const index = input.readInt(true);\n      const frameCount = input.readInt(true);\n      const frameLast = frameCount - 1;\n      const timeline = new TransformConstraintTimeline(frameCount, input.readInt(true), index);\n      let time = input.readFloat();\n      let mixRotate = input.readFloat();\n      let mixX = input.readFloat();\n      let mixY = input.readFloat();\n      let mixScaleX = input.readFloat();\n      let mixScaleY = input.readFloat();\n      let mixShearY = input.readFloat();\n      for (let frame = 0, bezier = 0; ; frame++) {\n        timeline.setFrame(frame, time, mixRotate, mixX, mixY, mixScaleX, mixScaleY, mixShearY);\n        if (frame == frameLast)\n          break;\n        const time2 = input.readFloat();\n        const mixRotate2 = input.readFloat();\n        const mixX2 = input.readFloat();\n        const mixY2 = input.readFloat();\n        const mixScaleX2 = input.readFloat();\n        const mixScaleY2 = input.readFloat();\n        const mixShearY2 = input.readFloat();\n        switch (input.readByte()) {\n          case CURVE_STEPPED:\n            timeline.setStepped(frame);\n            break;\n          case CURVE_BEZIER:\n            setBezier(input, timeline, bezier++, frame, 0, time, time2, mixRotate, mixRotate2, 1);\n            setBezier(input, timeline, bezier++, frame, 1, time, time2, mixX, mixX2, 1);\n            setBezier(input, timeline, bezier++, frame, 2, time, time2, mixY, mixY2, 1);\n            setBezier(input, timeline, bezier++, frame, 3, time, time2, mixScaleX, mixScaleX2, 1);\n            setBezier(input, timeline, bezier++, frame, 4, time, time2, mixScaleY, mixScaleY2, 1);\n            setBezier(input, timeline, bezier++, frame, 5, time, time2, mixShearY, mixShearY2, 1);\n        }\n        time = time2;\n        mixRotate = mixRotate2;\n        mixX = mixX2;\n        mixY = mixY2;\n        mixScaleX = mixScaleX2;\n        mixScaleY = mixScaleY2;\n        mixShearY = mixShearY2;\n      }\n      timelines.push(timeline);\n    }\n    for (let i = 0, n = input.readInt(true); i < n; i++) {\n      const index = input.readInt(true);\n      const data = skeletonData.pathConstraints[index];\n      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n        switch (input.readByte()) {\n          case PATH_POSITION:\n            timelines.push(\n              readTimeline1(\n                input,\n                new PathConstraintPositionTimeline(input.readInt(true), input.readInt(true), index),\n                data.positionMode == PositionMode.Fixed ? scale : 1\n              )\n            );\n            break;\n          case PATH_SPACING:\n            timelines.push(\n              readTimeline1(\n                input,\n                new PathConstraintSpacingTimeline(input.readInt(true), input.readInt(true), index),\n                data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed ? scale : 1\n              )\n            );\n            break;\n          case PATH_MIX:\n            const timeline = new PathConstraintMixTimeline(input.readInt(true), input.readInt(true), index);\n            let time = input.readFloat();\n            let mixRotate = input.readFloat();\n            let mixX = input.readFloat();\n            let mixY = input.readFloat();\n            for (let frame = 0, bezier = 0, frameLast = timeline.getFrameCount() - 1; ; frame++) {\n              timeline.setFrame(frame, time, mixRotate, mixX, mixY);\n              if (frame == frameLast)\n                break;\n              const time2 = input.readFloat();\n              const mixRotate2 = input.readFloat();\n              const mixX2 = input.readFloat();\n              const mixY2 = input.readFloat();\n              switch (input.readByte()) {\n                case CURVE_STEPPED:\n                  timeline.setStepped(frame);\n                  break;\n                case CURVE_BEZIER:\n                  setBezier(input, timeline, bezier++, frame, 0, time, time2, mixRotate, mixRotate2, 1);\n                  setBezier(input, timeline, bezier++, frame, 1, time, time2, mixX, mixX2, 1);\n                  setBezier(input, timeline, bezier++, frame, 2, time, time2, mixY, mixY2, 1);\n              }\n              time = time2;\n              mixRotate = mixRotate2;\n              mixX = mixX2;\n              mixY = mixY2;\n            }\n            timelines.push(timeline);\n        }\n      }\n    }\n    for (let i = 0, n = input.readInt(true); i < n; i++) {\n      const skin = skeletonData.skins[input.readInt(true)];\n      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n        const slotIndex = input.readInt(true);\n        for (let iii = 0, nnn = input.readInt(true); iii < nnn; iii++) {\n          const attachmentName = input.readStringRef();\n          if (!attachmentName)\n            throw new Error(\"attachmentName must not be null.\");\n          const attachment = skin.getAttachment(slotIndex, attachmentName);\n          const timelineType = this.readDeformTimelineType(input);\n          const frameCount = input.readInt(true);\n          const frameLast = frameCount - 1;\n          switch (timelineType) {\n            case ATTACHMENT_DEFORM: {\n              const vertexAttachment = attachment;\n              const weighted = vertexAttachment.bones;\n              const vertices = vertexAttachment.vertices;\n              const deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;\n              const bezierCount = input.readInt(true);\n              const timeline = new DeformTimeline(frameCount, bezierCount, slotIndex, vertexAttachment);\n              let time = input.readFloat();\n              for (let frame = 0, bezier = 0; ; frame++) {\n                let deform;\n                let end = input.readInt(true);\n                if (end == 0)\n                  deform = weighted ? Utils.newFloatArray(deformLength) : vertices;\n                else {\n                  deform = Utils.newFloatArray(deformLength);\n                  const start = input.readInt(true);\n                  end += start;\n                  if (scale == 1) {\n                    for (let v = start; v < end; v++)\n                      deform[v] = input.readFloat();\n                  } else {\n                    for (let v = start; v < end; v++)\n                      deform[v] = input.readFloat() * scale;\n                  }\n                  if (!weighted) {\n                    for (let v = 0, vn = deform.length; v < vn; v++)\n                      deform[v] += vertices[v];\n                  }\n                }\n                timeline.setFrame(frame, time, deform);\n                if (frame == frameLast)\n                  break;\n                const time2 = input.readFloat();\n                switch (input.readByte()) {\n                  case CURVE_STEPPED:\n                    timeline.setStepped(frame);\n                    break;\n                  case CURVE_BEZIER:\n                    setBezier(input, timeline, bezier++, frame, 0, time, time2, 0, 1, 1);\n                }\n                time = time2;\n              }\n              timelines.push(timeline);\n              break;\n            }\n            case ATTACHMENT_SEQUENCE: {\n              const timeline = new SequenceTimeline(frameCount, slotIndex, attachment);\n              for (let frame = 0; frame < frameCount; frame++) {\n                const time = input.readFloat();\n                const modeAndIndex = input.readInt32();\n                timeline.setFrame(frame, time, SequenceModeValues[modeAndIndex & 15], modeAndIndex >> 4, input.readFloat());\n              }\n              timelines.push(timeline);\n              break;\n            }\n          }\n        }\n      }\n    }\n    const drawOrderCount = input.readInt(true);\n    if (drawOrderCount > 0) {\n      const timeline = new DrawOrderTimeline(drawOrderCount);\n      const slotCount = skeletonData.slots.length;\n      for (let i = 0; i < drawOrderCount; i++) {\n        const time = input.readFloat();\n        const offsetCount = input.readInt(true);\n        const drawOrder = Utils.newArray(slotCount, 0);\n        for (let ii = slotCount - 1; ii >= 0; ii--)\n          drawOrder[ii] = -1;\n        const unchanged = Utils.newArray(slotCount - offsetCount, 0);\n        let originalIndex = 0;\n        let unchangedIndex = 0;\n        for (let ii = 0; ii < offsetCount; ii++) {\n          const slotIndex = input.readInt(true);\n          while (originalIndex != slotIndex)\n            unchanged[unchangedIndex++] = originalIndex++;\n          drawOrder[originalIndex + input.readInt(true)] = originalIndex++;\n        }\n        while (originalIndex < slotCount)\n          unchanged[unchangedIndex++] = originalIndex++;\n        for (let ii = slotCount - 1; ii >= 0; ii--)\n          if (drawOrder[ii] == -1)\n            drawOrder[ii] = unchanged[--unchangedIndex];\n        timeline.setFrame(i, time, drawOrder);\n      }\n      timelines.push(timeline);\n    }\n    const eventCount = input.readInt(true);\n    if (eventCount > 0) {\n      const timeline = new EventTimeline(eventCount);\n      for (let i = 0; i < eventCount; i++) {\n        const time = input.readFloat();\n        const eventData = skeletonData.events[input.readInt(true)];\n        const event = new Event(time, eventData);\n        event.intValue = input.readInt(false);\n        event.floatValue = input.readFloat();\n        event.stringValue = input.readBoolean() ? input.readString() : eventData.stringValue;\n        if (event.data.audioPath) {\n          event.volume = input.readFloat();\n          event.balance = input.readFloat();\n        }\n        timeline.setFrame(i, event);\n      }\n      timelines.push(timeline);\n    }\n    let duration = 0;\n    for (let i = 0, n = timelines.length; i < n; i++)\n      duration = Math.max(duration, timelines[i].getDuration());\n    return new Animation(name, timelines, duration);\n  }\n}\nSkeletonBinary.BlendModeValues = [BLEND_MODES.NORMAL, BLEND_MODES.ADD, BLEND_MODES.MULTIPLY, BLEND_MODES.SCREEN];\nclass LinkedMesh {\n  constructor(mesh, skin, slotIndex, parent, inheritDeform) {\n    this.mesh = mesh;\n    this.skin = skin;\n    this.slotIndex = slotIndex;\n    this.parent = parent;\n    this.inheritTimeline = inheritDeform;\n  }\n}\nclass Vertices {\n  constructor(bones = null, vertices = null) {\n    this.bones = bones;\n    this.vertices = vertices;\n  }\n}\nfunction readTimeline1(input, timeline, scale) {\n  let time = input.readFloat();\n  let value = input.readFloat() * scale;\n  for (let frame = 0, bezier = 0, frameLast = timeline.getFrameCount() - 1; ; frame++) {\n    timeline.setFrame(frame, time, value);\n    if (frame == frameLast)\n      break;\n    const time2 = input.readFloat();\n    const value2 = input.readFloat() * scale;\n    switch (input.readByte()) {\n      case CURVE_STEPPED:\n        timeline.setStepped(frame);\n        break;\n      case CURVE_BEZIER:\n        setBezier(input, timeline, bezier++, frame, 0, time, time2, value, value2, scale);\n    }\n    time = time2;\n    value = value2;\n  }\n  return timeline;\n}\nfunction readTimeline2(input, timeline, scale) {\n  let time = input.readFloat();\n  let value1 = input.readFloat() * scale;\n  let value2 = input.readFloat() * scale;\n  for (let frame = 0, bezier = 0, frameLast = timeline.getFrameCount() - 1; ; frame++) {\n    timeline.setFrame(frame, time, value1, value2);\n    if (frame == frameLast)\n      break;\n    const time2 = input.readFloat();\n    const nvalue1 = input.readFloat() * scale;\n    const nvalue2 = input.readFloat() * scale;\n    switch (input.readByte()) {\n      case CURVE_STEPPED:\n        timeline.setStepped(frame);\n        break;\n      case CURVE_BEZIER:\n        setBezier(input, timeline, bezier++, frame, 0, time, time2, value1, nvalue1, scale);\n        setBezier(input, timeline, bezier++, frame, 1, time, time2, value2, nvalue2, scale);\n    }\n    time = time2;\n    value1 = nvalue1;\n    value2 = nvalue2;\n  }\n  return timeline;\n}\nfunction setBezier(input, timeline, bezier, frame, value, time1, time2, value1, value2, scale) {\n  timeline.setBezier(bezier, frame, value, time1, value1, input.readFloat(), input.readFloat() * scale, input.readFloat(), input.readFloat() * scale, time2, value2);\n}\nconst BONE_ROTATE = 0;\nconst BONE_TRANSLATE = 1;\nconst BONE_TRANSLATEX = 2;\nconst BONE_TRANSLATEY = 3;\nconst BONE_SCALE = 4;\nconst BONE_SCALEX = 5;\nconst BONE_SCALEY = 6;\nconst BONE_SHEAR = 7;\nconst BONE_SHEARX = 8;\nconst BONE_SHEARY = 9;\nconst SLOT_ATTACHMENT = 0;\nconst SLOT_RGBA = 1;\nconst SLOT_RGB = 2;\nconst SLOT_RGBA2 = 3;\nconst SLOT_RGB2 = 4;\nconst SLOT_ALPHA = 5;\nconst ATTACHMENT_DEFORM = 0;\nconst ATTACHMENT_SEQUENCE = 1;\nconst PATH_POSITION = 0;\nconst PATH_SPACING = 1;\nconst PATH_MIX = 2;\nconst CURVE_STEPPED = 1;\nconst CURVE_BEZIER = 2;\n\nexport { SkeletonBinary };\n//# sourceMappingURL=SkeletonBinary.mjs.map\n","import { SkeletonBoundsBase } from '@pixi-spine/base';\n\nclass SkeletonBounds extends SkeletonBoundsBase {\n}\n\nexport { SkeletonBounds };\n//# sourceMappingURL=SkeletonBounds.mjs.map\n","import { AttachmentTimeline, RGBATimeline, RGBTimeline, AlphaTimeline, RGBA2Timeline, RGB2Timeline, RotateTimeline, TranslateTimeline, TranslateXTimeline, TranslateYTimeline, ScaleTimeline, ScaleXTimeline, ScaleYTimeline, ShearTimeline, ShearXTimeline, ShearYTimeline, IkConstraintTimeline, TransformConstraintTimeline, PathConstraintPositionTimeline, PathConstraintSpacingTimeline, PathConstraintMixTimeline, DeformTimeline, SequenceTimeline, DrawOrderTimeline, EventTimeline, Animation } from './Animation.mjs';\nimport { Event } from './Event.mjs';\nimport { SkeletonData } from './SkeletonData.mjs';\nimport { SlotData } from './SlotData.mjs';\nimport { BoneData } from './BoneData.mjs';\nimport { IkConstraintData } from './IkConstraintData.mjs';\nimport { TransformConstraintData } from './TransformConstraintData.mjs';\nimport { PathConstraintData, SpacingMode } from './PathConstraintData.mjs';\nimport { Skin } from './Skin.mjs';\nimport { EventData } from './EventData.mjs';\nimport { Utils, TransformMode, Color, PositionMode, RotateMode, settings } from '@pixi-spine/base';\nimport { BLEND_MODES } from '@pixi/core';\nimport { Sequence, SequenceMode } from './attachments/Sequence.mjs';\n\nclass SkeletonJson {\n  constructor(attachmentLoader) {\n    /** Scales bone positions, image sizes, and translations as they are loaded. This allows different size images to be used at\n     * runtime than were used in Spine.\n     *\n     * See [Scaling](http://esotericsoftware.com/spine-loading-skeleton-data#Scaling) in the Spine Runtimes Guide. */\n    this.scale = 1;\n    this.linkedMeshes = new Array();\n    this.attachmentLoader = attachmentLoader;\n  }\n  readSkeletonData(json) {\n    const scale = this.scale;\n    const skeletonData = new SkeletonData();\n    const root = typeof json === \"string\" ? JSON.parse(json) : json;\n    const skeletonMap = root.skeleton;\n    if (skeletonMap) {\n      skeletonData.hash = skeletonMap.hash;\n      skeletonData.version = skeletonMap.spine;\n      const verShort = skeletonData.version.substr(0, 3);\n      if (verShort !== \"4.0\" && verShort !== \"4.1\") {\n        const error = `Spine 4.1 loader cant load version ${skeletonMap.spine}. Please configure your pixi-spine bundle`;\n        console.error(error);\n      }\n      skeletonData.x = skeletonMap.x;\n      skeletonData.y = skeletonMap.y;\n      skeletonData.width = skeletonMap.width;\n      skeletonData.height = skeletonMap.height;\n      skeletonData.fps = skeletonMap.fps;\n      skeletonData.imagesPath = skeletonMap.images;\n    }\n    if (root.bones) {\n      for (let i = 0; i < root.bones.length; i++) {\n        const boneMap = root.bones[i];\n        let parent = null;\n        const parentName = getValue(boneMap, \"parent\", null);\n        if (parentName != null) {\n          parent = skeletonData.findBone(parentName);\n          if (parent == null)\n            throw new Error(`Parent bone not found: ${parentName}`);\n        }\n        const data = new BoneData(skeletonData.bones.length, boneMap.name, parent);\n        data.length = getValue(boneMap, \"length\", 0) * scale;\n        data.x = getValue(boneMap, \"x\", 0) * scale;\n        data.y = getValue(boneMap, \"y\", 0) * scale;\n        data.rotation = getValue(boneMap, \"rotation\", 0);\n        data.scaleX = getValue(boneMap, \"scaleX\", 1);\n        data.scaleY = getValue(boneMap, \"scaleY\", 1);\n        data.shearX = getValue(boneMap, \"shearX\", 0);\n        data.shearY = getValue(boneMap, \"shearY\", 0);\n        data.transformMode = Utils.enumValue(TransformMode, getValue(boneMap, \"transform\", \"Normal\"));\n        data.skinRequired = getValue(boneMap, \"skin\", false);\n        const color = getValue(boneMap, \"color\", null);\n        if (color)\n          data.color.setFromString(color);\n        skeletonData.bones.push(data);\n      }\n    }\n    if (root.slots) {\n      for (let i = 0; i < root.slots.length; i++) {\n        const slotMap = root.slots[i];\n        const boneData = skeletonData.findBone(slotMap.bone);\n        if (!boneData)\n          throw new Error(`Couldn't find bone ${slotMap.bone} for slot ${slotMap.name}`);\n        const data = new SlotData(skeletonData.slots.length, slotMap.name, boneData);\n        const color = getValue(slotMap, \"color\", null);\n        if (color)\n          data.color.setFromString(color);\n        const dark = getValue(slotMap, \"dark\", null);\n        if (dark)\n          data.darkColor = Color.fromString(dark);\n        data.attachmentName = getValue(slotMap, \"attachment\", null);\n        data.blendMode = SkeletonJson.blendModeFromString(getValue(slotMap, \"blend\", \"normal\"));\n        skeletonData.slots.push(data);\n      }\n    }\n    if (root.ik) {\n      for (let i = 0; i < root.ik.length; i++) {\n        const constraintMap = root.ik[i];\n        const data = new IkConstraintData(constraintMap.name);\n        data.order = getValue(constraintMap, \"order\", 0);\n        data.skinRequired = getValue(constraintMap, \"skin\", false);\n        for (let ii = 0; ii < constraintMap.bones.length; ii++) {\n          const boneName = constraintMap.bones[ii];\n          const bone = skeletonData.findBone(boneName);\n          if (bone == null)\n            throw new Error(`IK bone not found: ${boneName}`);\n          data.bones.push(bone);\n        }\n        data.target = skeletonData.findBone(constraintMap.target);\n        data.mix = getValue(constraintMap, \"mix\", 1);\n        data.softness = getValue(constraintMap, \"softness\", 0) * scale;\n        data.bendDirection = getValue(constraintMap, \"bendPositive\", true) ? 1 : -1;\n        data.compress = getValue(constraintMap, \"compress\", false);\n        data.stretch = getValue(constraintMap, \"stretch\", false);\n        data.uniform = getValue(constraintMap, \"uniform\", false);\n        skeletonData.ikConstraints.push(data);\n      }\n    }\n    if (root.transform) {\n      for (let i = 0; i < root.transform.length; i++) {\n        const constraintMap = root.transform[i];\n        const data = new TransformConstraintData(constraintMap.name);\n        data.order = getValue(constraintMap, \"order\", 0);\n        data.skinRequired = getValue(constraintMap, \"skin\", false);\n        for (let ii = 0; ii < constraintMap.bones.length; ii++) {\n          const boneName = constraintMap.bones[ii];\n          const bone = skeletonData.findBone(boneName);\n          if (!bone)\n            throw new Error(`Couldn't find bone ${boneName} for transform constraint ${constraintMap.name}.`);\n          data.bones.push(bone);\n        }\n        const targetName = constraintMap.target;\n        const target = skeletonData.findBone(targetName);\n        if (!target)\n          throw new Error(`Couldn't find target bone ${targetName} for transform constraint ${constraintMap.name}.`);\n        data.target = target;\n        data.local = getValue(constraintMap, \"local\", false);\n        data.relative = getValue(constraintMap, \"relative\", false);\n        data.offsetRotation = getValue(constraintMap, \"rotation\", 0);\n        data.offsetX = getValue(constraintMap, \"x\", 0) * scale;\n        data.offsetY = getValue(constraintMap, \"y\", 0) * scale;\n        data.offsetScaleX = getValue(constraintMap, \"scaleX\", 0);\n        data.offsetScaleY = getValue(constraintMap, \"scaleY\", 0);\n        data.offsetShearY = getValue(constraintMap, \"shearY\", 0);\n        data.mixRotate = getValue(constraintMap, \"mixRotate\", 1);\n        data.mixX = getValue(constraintMap, \"mixX\", 1);\n        data.mixY = getValue(constraintMap, \"mixY\", data.mixX);\n        data.mixScaleX = getValue(constraintMap, \"mixScaleX\", 1);\n        data.mixScaleY = getValue(constraintMap, \"mixScaleY\", data.mixScaleX);\n        data.mixShearY = getValue(constraintMap, \"mixShearY\", 1);\n        skeletonData.transformConstraints.push(data);\n      }\n    }\n    if (root.path) {\n      for (let i = 0; i < root.path.length; i++) {\n        const constraintMap = root.path[i];\n        const data = new PathConstraintData(constraintMap.name);\n        data.order = getValue(constraintMap, \"order\", 0);\n        data.skinRequired = getValue(constraintMap, \"skin\", false);\n        for (let ii = 0; ii < constraintMap.bones.length; ii++) {\n          const boneName = constraintMap.bones[ii];\n          const bone = skeletonData.findBone(boneName);\n          if (!bone)\n            throw new Error(`Couldn't find bone ${boneName} for path constraint ${constraintMap.name}.`);\n          data.bones.push(bone);\n        }\n        const targetName = constraintMap.target;\n        const target = skeletonData.findSlot(targetName);\n        if (!target)\n          throw new Error(`Couldn't find target slot ${targetName} for path constraint ${constraintMap.name}.`);\n        data.target = target;\n        data.positionMode = Utils.enumValue(PositionMode, getValue(constraintMap, \"positionMode\", \"Percent\"));\n        data.spacingMode = Utils.enumValue(SpacingMode, getValue(constraintMap, \"spacingMode\", \"Length\"));\n        data.rotateMode = Utils.enumValue(RotateMode, getValue(constraintMap, \"rotateMode\", \"Tangent\"));\n        data.offsetRotation = getValue(constraintMap, \"rotation\", 0);\n        data.position = getValue(constraintMap, \"position\", 0);\n        if (data.positionMode == PositionMode.Fixed)\n          data.position *= scale;\n        data.spacing = getValue(constraintMap, \"spacing\", 0);\n        if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed)\n          data.spacing *= scale;\n        data.mixRotate = getValue(constraintMap, \"mixRotate\", 1);\n        data.mixX = getValue(constraintMap, \"mixX\", 1);\n        data.mixY = getValue(constraintMap, \"mixY\", data.mixX);\n        skeletonData.pathConstraints.push(data);\n      }\n    }\n    if (root.skins) {\n      for (let i = 0; i < root.skins.length; i++) {\n        const skinMap = root.skins[i];\n        const skin = new Skin(skinMap.name);\n        if (skinMap.bones) {\n          for (let ii = 0; ii < skinMap.bones.length; ii++) {\n            const boneName = skinMap.bones[ii];\n            const bone = skeletonData.findBone(boneName);\n            if (!bone)\n              throw new Error(`Couldn't find bone ${boneName} for skin ${skinMap.name}.`);\n            skin.bones.push(bone);\n          }\n        }\n        if (skinMap.ik) {\n          for (let ii = 0; ii < skinMap.ik.length; ii++) {\n            const constraintName = skinMap.ik[ii];\n            const constraint = skeletonData.findIkConstraint(constraintName);\n            if (!constraint)\n              throw new Error(`Couldn't find IK constraint ${constraintName} for skin ${skinMap.name}.`);\n            skin.constraints.push(constraint);\n          }\n        }\n        if (skinMap.transform) {\n          for (let ii = 0; ii < skinMap.transform.length; ii++) {\n            const constraintName = skinMap.transform[ii];\n            const constraint = skeletonData.findTransformConstraint(constraintName);\n            if (!constraint)\n              throw new Error(`Couldn't find transform constraint ${constraintName} for skin ${skinMap.name}.`);\n            skin.constraints.push(constraint);\n          }\n        }\n        if (skinMap.path) {\n          for (let ii = 0; ii < skinMap.path.length; ii++) {\n            const constraintName = skinMap.path[ii];\n            const constraint = skeletonData.findPathConstraint(constraintName);\n            if (!constraint)\n              throw new Error(`Couldn't find path constraint ${constraintName} for skin ${skinMap.name}.`);\n            skin.constraints.push(constraint);\n          }\n        }\n        for (const slotName in skinMap.attachments) {\n          const slot = skeletonData.findSlot(slotName);\n          if (!slot)\n            throw new Error(`Couldn't find slot ${slotName} for skin ${skinMap.name}.`);\n          const slotMap = skinMap.attachments[slotName];\n          for (const entryName in slotMap) {\n            const attachment = this.readAttachment(slotMap[entryName], skin, slot.index, entryName, skeletonData);\n            if (attachment)\n              skin.setAttachment(slot.index, entryName, attachment);\n          }\n        }\n        skeletonData.skins.push(skin);\n        if (skin.name == \"default\")\n          skeletonData.defaultSkin = skin;\n      }\n    }\n    for (let i = 0, n = this.linkedMeshes.length; i < n; i++) {\n      const linkedMesh = this.linkedMeshes[i];\n      const skin = !linkedMesh.skin ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\n      if (!skin)\n        throw new Error(`Skin not found: ${linkedMesh.skin}`);\n      const parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\n      if (!parent)\n        throw new Error(`Parent mesh not found: ${linkedMesh.parent}`);\n      linkedMesh.mesh.timelineAttachment = linkedMesh.inheritTimeline ? parent : linkedMesh.mesh;\n      linkedMesh.mesh.setParentMesh(parent);\n    }\n    this.linkedMeshes.length = 0;\n    if (root.events) {\n      for (const eventName in root.events) {\n        const eventMap = root.events[eventName];\n        const data = new EventData(eventName);\n        data.intValue = getValue(eventMap, \"int\", 0);\n        data.floatValue = getValue(eventMap, \"float\", 0);\n        data.stringValue = getValue(eventMap, \"string\", \"\");\n        data.audioPath = getValue(eventMap, \"audio\", null);\n        if (data.audioPath) {\n          data.volume = getValue(eventMap, \"volume\", 1);\n          data.balance = getValue(eventMap, \"balance\", 0);\n        }\n        skeletonData.events.push(data);\n      }\n    }\n    if (root.animations) {\n      for (const animationName in root.animations) {\n        const animationMap = root.animations[animationName];\n        this.readAnimation(animationMap, animationName, skeletonData);\n      }\n    }\n    return skeletonData;\n  }\n  readAttachment(map, skin, slotIndex, name, skeletonData) {\n    const scale = this.scale;\n    name = getValue(map, \"name\", name);\n    switch (getValue(map, \"type\", \"region\")) {\n      case \"region\": {\n        const path = getValue(map, \"path\", name);\n        const sequence = this.readSequence(getValue(map, \"sequence\", null));\n        const region = this.attachmentLoader.newRegionAttachment(skin, name, path, sequence);\n        if (!region)\n          return null;\n        region.path = path;\n        region.x = getValue(map, \"x\", 0) * scale;\n        region.y = getValue(map, \"y\", 0) * scale;\n        region.scaleX = getValue(map, \"scaleX\", 1);\n        region.scaleY = getValue(map, \"scaleY\", 1);\n        region.rotation = getValue(map, \"rotation\", 0);\n        region.width = map.width * scale;\n        region.height = map.height * scale;\n        region.sequence = sequence;\n        const color = getValue(map, \"color\", null);\n        if (color)\n          region.color.setFromString(color);\n        return region;\n      }\n      case \"boundingbox\": {\n        const box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\n        if (!box)\n          return null;\n        this.readVertices(map, box, map.vertexCount << 1);\n        const color = getValue(map, \"color\", null);\n        if (color)\n          box.color.setFromString(color);\n        return box;\n      }\n      case \"mesh\":\n      case \"linkedmesh\": {\n        const path = getValue(map, \"path\", name);\n        const sequence = this.readSequence(getValue(map, \"sequence\", null));\n        const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path, sequence);\n        if (!mesh)\n          return null;\n        mesh.path = path;\n        const color = getValue(map, \"color\", null);\n        if (color)\n          mesh.color.setFromString(color);\n        mesh.width = getValue(map, \"width\", 0) * scale;\n        mesh.height = getValue(map, \"height\", 0) * scale;\n        mesh.sequence = sequence;\n        const parent = getValue(map, \"parent\", null);\n        if (parent) {\n          this.linkedMeshes.push(new LinkedMesh(mesh, getValue(map, \"skin\", null), slotIndex, parent, getValue(map, \"timelines\", true)));\n          return mesh;\n        }\n        const uvs = map.uvs;\n        this.readVertices(map, mesh, uvs.length);\n        mesh.triangles = map.triangles;\n        mesh.regionUVs = new Float32Array(uvs);\n        mesh.edges = getValue(map, \"edges\", null);\n        mesh.hullLength = getValue(map, \"hull\", 0) * 2;\n        return mesh;\n      }\n      case \"path\": {\n        const path = this.attachmentLoader.newPathAttachment(skin, name);\n        if (!path)\n          return null;\n        path.closed = getValue(map, \"closed\", false);\n        path.constantSpeed = getValue(map, \"constantSpeed\", true);\n        const vertexCount = map.vertexCount;\n        this.readVertices(map, path, vertexCount << 1);\n        const lengths = Utils.newArray(vertexCount / 3, 0);\n        for (let i = 0; i < map.lengths.length; i++)\n          lengths[i] = map.lengths[i] * scale;\n        path.lengths = lengths;\n        const color = getValue(map, \"color\", null);\n        if (color)\n          path.color.setFromString(color);\n        return path;\n      }\n      case \"point\": {\n        const point = this.attachmentLoader.newPointAttachment(skin, name);\n        if (!point)\n          return null;\n        point.x = getValue(map, \"x\", 0) * scale;\n        point.y = getValue(map, \"y\", 0) * scale;\n        point.rotation = getValue(map, \"rotation\", 0);\n        const color = getValue(map, \"color\", null);\n        if (color)\n          point.color.setFromString(color);\n        return point;\n      }\n      case \"clipping\": {\n        const clip = this.attachmentLoader.newClippingAttachment(skin, name);\n        if (!clip)\n          return null;\n        const end = getValue(map, \"end\", null);\n        if (end != null) {\n          const slot = skeletonData.findSlot(end);\n          if (slot == null)\n            throw new Error(`Clipping end slot not found: ${end}`);\n          clip.endSlot = slot;\n        }\n        const vertexCount = map.vertexCount;\n        this.readVertices(map, clip, vertexCount << 1);\n        const color = getValue(map, \"color\", null);\n        if (color)\n          clip.color.setFromString(color);\n        return clip;\n      }\n    }\n    return null;\n  }\n  readSequence(map) {\n    if (map == null)\n      return null;\n    const sequence = new Sequence(getValue(map, \"count\", 0));\n    sequence.start = getValue(map, \"start\", 1);\n    sequence.digits = getValue(map, \"digits\", 0);\n    sequence.setupIndex = getValue(map, \"setup\", 0);\n    return sequence;\n  }\n  readVertices(map, attachment, verticesLength) {\n    const scale = this.scale;\n    attachment.worldVerticesLength = verticesLength;\n    const vertices = map.vertices;\n    if (verticesLength == vertices.length) {\n      const scaledVertices = Utils.toFloatArray(vertices);\n      if (scale != 1) {\n        for (let i = 0, n = vertices.length; i < n; i++)\n          scaledVertices[i] *= scale;\n      }\n      attachment.vertices = scaledVertices;\n      return;\n    }\n    const weights = new Array();\n    const bones = new Array();\n    for (let i = 0, n = vertices.length; i < n; ) {\n      const boneCount = vertices[i++];\n      bones.push(boneCount);\n      for (let nn = i + boneCount * 4; i < nn; i += 4) {\n        bones.push(vertices[i]);\n        weights.push(vertices[i + 1] * scale);\n        weights.push(vertices[i + 2] * scale);\n        weights.push(vertices[i + 3]);\n      }\n    }\n    attachment.bones = bones;\n    attachment.vertices = Utils.toFloatArray(weights);\n  }\n  readAnimation(map, name, skeletonData) {\n    const scale = this.scale;\n    const timelines = new Array();\n    if (map.slots) {\n      for (const slotName in map.slots) {\n        const slotMap = map.slots[slotName];\n        const slot = skeletonData.findSlot(slotName);\n        if (!slot)\n          throw new Error(`Slot not found: ${slotName}`);\n        const slotIndex = slot.index;\n        for (const timelineName in slotMap) {\n          const timelineMap = slotMap[timelineName];\n          if (!timelineMap)\n            continue;\n          const frames = timelineMap.length;\n          if (timelineName == \"attachment\") {\n            const timeline = new AttachmentTimeline(frames, slotIndex);\n            for (let frame = 0; frame < frames; frame++) {\n              const keyMap = timelineMap[frame];\n              timeline.setFrame(frame, getValue(keyMap, \"time\", 0), getValue(keyMap, \"name\", null));\n            }\n            timelines.push(timeline);\n          } else if (timelineName == \"rgba\") {\n            const timeline = new RGBATimeline(frames, frames << 2, slotIndex);\n            let keyMap = timelineMap[0];\n            let time = getValue(keyMap, \"time\", 0);\n            let color = Color.fromString(keyMap.color);\n            for (let frame = 0, bezier = 0; ; frame++) {\n              timeline.setFrame(frame, time, color.r, color.g, color.b, color.a);\n              const nextMap = timelineMap[frame + 1];\n              if (!nextMap) {\n                timeline.shrink(bezier);\n                break;\n              }\n              const time2 = getValue(nextMap, \"time\", 0);\n              const newColor = Color.fromString(nextMap.color);\n              const curve = keyMap.curve;\n              if (curve) {\n                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, color.a, newColor.a, 1);\n              }\n              time = time2;\n              color = newColor;\n              keyMap = nextMap;\n            }\n            timelines.push(timeline);\n          } else if (timelineName == \"rgb\") {\n            const timeline = new RGBTimeline(frames, frames * 3, slotIndex);\n            let keyMap = timelineMap[0];\n            let time = getValue(keyMap, \"time\", 0);\n            let color = Color.fromString(keyMap.color);\n            for (let frame = 0, bezier = 0; ; frame++) {\n              timeline.setFrame(frame, time, color.r, color.g, color.b);\n              const nextMap = timelineMap[frame + 1];\n              if (!nextMap) {\n                timeline.shrink(bezier);\n                break;\n              }\n              const time2 = getValue(nextMap, \"time\", 0);\n              const newColor = Color.fromString(nextMap.color);\n              const curve = keyMap.curve;\n              if (curve) {\n                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);\n              }\n              time = time2;\n              color = newColor;\n              keyMap = nextMap;\n            }\n            timelines.push(timeline);\n          } else if (timelineName == \"alpha\") {\n            timelines.push(readTimeline1(timelineMap, new AlphaTimeline(frames, frames, slotIndex), 0, 1));\n          } else if (timelineName == \"rgba2\") {\n            const timeline = new RGBA2Timeline(frames, frames * 7, slotIndex);\n            let keyMap = timelineMap[0];\n            let time = getValue(keyMap, \"time\", 0);\n            let color = Color.fromString(keyMap.light);\n            let color2 = Color.fromString(keyMap.dark);\n            for (let frame = 0, bezier = 0; ; frame++) {\n              timeline.setFrame(frame, time, color.r, color.g, color.b, color.a, color2.r, color2.g, color2.b);\n              const nextMap = timelineMap[frame + 1];\n              if (!nextMap) {\n                timeline.shrink(bezier);\n                break;\n              }\n              const time2 = getValue(nextMap, \"time\", 0);\n              const newColor = Color.fromString(nextMap.light);\n              const newColor2 = Color.fromString(nextMap.dark);\n              const curve = keyMap.curve;\n              if (curve) {\n                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, color.a, newColor.a, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 4, time, time2, color2.r, newColor2.r, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 5, time, time2, color2.g, newColor2.g, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 6, time, time2, color2.b, newColor2.b, 1);\n              }\n              time = time2;\n              color = newColor;\n              color2 = newColor2;\n              keyMap = nextMap;\n            }\n            timelines.push(timeline);\n          } else if (timelineName == \"rgb2\") {\n            const timeline = new RGB2Timeline(frames, frames * 6, slotIndex);\n            let keyMap = timelineMap[0];\n            let time = getValue(keyMap, \"time\", 0);\n            let color = Color.fromString(keyMap.light);\n            let color2 = Color.fromString(keyMap.dark);\n            for (let frame = 0, bezier = 0; ; frame++) {\n              timeline.setFrame(frame, time, color.r, color.g, color.b, color2.r, color2.g, color2.b);\n              const nextMap = timelineMap[frame + 1];\n              if (!nextMap) {\n                timeline.shrink(bezier);\n                break;\n              }\n              const time2 = getValue(nextMap, \"time\", 0);\n              const newColor = Color.fromString(nextMap.light);\n              const newColor2 = Color.fromString(nextMap.dark);\n              const curve = keyMap.curve;\n              if (curve) {\n                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, color2.r, newColor2.r, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 4, time, time2, color2.g, newColor2.g, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 5, time, time2, color2.b, newColor2.b, 1);\n              }\n              time = time2;\n              color = newColor;\n              color2 = newColor2;\n              keyMap = nextMap;\n            }\n            timelines.push(timeline);\n          }\n        }\n      }\n    }\n    if (map.bones) {\n      for (const boneName in map.bones) {\n        const boneMap = map.bones[boneName];\n        const bone = skeletonData.findBone(boneName);\n        if (!bone)\n          throw new Error(`Bone not found: ${boneName}`);\n        const boneIndex = bone.index;\n        for (const timelineName in boneMap) {\n          const timelineMap = boneMap[timelineName];\n          const frames = timelineMap.length;\n          if (frames == 0)\n            continue;\n          if (timelineName === \"rotate\") {\n            timelines.push(readTimeline1(timelineMap, new RotateTimeline(frames, frames, boneIndex), 0, 1));\n          } else if (timelineName === \"translate\") {\n            const timeline = new TranslateTimeline(frames, frames << 1, boneIndex);\n            timelines.push(readTimeline2(timelineMap, timeline, \"x\", \"y\", 0, scale));\n          } else if (timelineName === \"translatex\") {\n            const timeline = new TranslateXTimeline(frames, frames, boneIndex);\n            timelines.push(readTimeline1(timelineMap, timeline, 0, scale));\n          } else if (timelineName === \"translatey\") {\n            const timeline = new TranslateYTimeline(frames, frames, boneIndex);\n            timelines.push(readTimeline1(timelineMap, timeline, 0, scale));\n          } else if (timelineName === \"scale\") {\n            const timeline = new ScaleTimeline(frames, frames << 1, boneIndex);\n            timelines.push(readTimeline2(timelineMap, timeline, \"x\", \"y\", 1, 1));\n          } else if (timelineName === \"scalex\") {\n            const timeline = new ScaleXTimeline(frames, frames, boneIndex);\n            timelines.push(readTimeline1(timelineMap, timeline, 1, 1));\n          } else if (timelineName === \"scaley\") {\n            const timeline = new ScaleYTimeline(frames, frames, boneIndex);\n            timelines.push(readTimeline1(timelineMap, timeline, 1, 1));\n          } else if (timelineName === \"shear\") {\n            const timeline = new ShearTimeline(frames, frames << 1, boneIndex);\n            timelines.push(readTimeline2(timelineMap, timeline, \"x\", \"y\", 0, 1));\n          } else if (timelineName === \"shearx\") {\n            const timeline = new ShearXTimeline(frames, frames, boneIndex);\n            timelines.push(readTimeline1(timelineMap, timeline, 0, 1));\n          } else if (timelineName === \"sheary\") {\n            const timeline = new ShearYTimeline(frames, frames, boneIndex);\n            timelines.push(readTimeline1(timelineMap, timeline, 0, 1));\n          }\n        }\n      }\n    }\n    if (map.ik) {\n      for (const constraintName in map.ik) {\n        const constraintMap = map.ik[constraintName];\n        let keyMap = constraintMap[0];\n        if (!keyMap)\n          continue;\n        const constraint = skeletonData.findIkConstraint(constraintName);\n        if (!constraint)\n          throw new Error(`IK Constraint not found: ${constraintName}`);\n        const constraintIndex = skeletonData.ikConstraints.indexOf(constraint);\n        const timeline = new IkConstraintTimeline(constraintMap.length, constraintMap.length << 1, constraintIndex);\n        let time = getValue(keyMap, \"time\", 0);\n        let mix = getValue(keyMap, \"mix\", 1);\n        let softness = getValue(keyMap, \"softness\", 0) * scale;\n        for (let frame = 0, bezier = 0; ; frame++) {\n          timeline.setFrame(\n            frame,\n            time,\n            mix,\n            softness,\n            getValue(keyMap, \"bendPositive\", true) ? 1 : -1,\n            getValue(keyMap, \"compress\", false),\n            getValue(keyMap, \"stretch\", false)\n          );\n          const nextMap = constraintMap[frame + 1];\n          if (!nextMap) {\n            timeline.shrink(bezier);\n            break;\n          }\n          const time2 = getValue(nextMap, \"time\", 0);\n          const mix2 = getValue(nextMap, \"mix\", 1);\n          const softness2 = getValue(nextMap, \"softness\", 0) * scale;\n          const curve = keyMap.curve;\n          if (curve) {\n            bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, mix, mix2, 1);\n            bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, softness, softness2, scale);\n          }\n          time = time2;\n          mix = mix2;\n          softness = softness2;\n          keyMap = nextMap;\n        }\n        timelines.push(timeline);\n      }\n    }\n    if (map.transform) {\n      for (const constraintName in map.transform) {\n        const timelineMap = map.transform[constraintName];\n        let keyMap = timelineMap[0];\n        if (!keyMap)\n          continue;\n        const constraint = skeletonData.findTransformConstraint(constraintName);\n        if (!constraint)\n          throw new Error(`Transform constraint not found: ${constraintName}`);\n        const constraintIndex = skeletonData.transformConstraints.indexOf(constraint);\n        const timeline = new TransformConstraintTimeline(timelineMap.length, timelineMap.length * 6, constraintIndex);\n        let time = getValue(keyMap, \"time\", 0);\n        let mixRotate = getValue(keyMap, \"mixRotate\", 1);\n        let mixX = getValue(keyMap, \"mixX\", 1);\n        let mixY = getValue(keyMap, \"mixY\", mixX);\n        let mixScaleX = getValue(keyMap, \"mixScaleX\", 1);\n        let mixScaleY = getValue(keyMap, \"mixScaleY\", mixScaleX);\n        const mixShearY = getValue(keyMap, \"mixShearY\", 1);\n        for (let frame = 0, bezier = 0; ; frame++) {\n          timeline.setFrame(frame, time, mixRotate, mixX, mixY, mixScaleX, mixScaleY, mixShearY);\n          const nextMap = timelineMap[frame + 1];\n          if (!nextMap) {\n            timeline.shrink(bezier);\n            break;\n          }\n          const time2 = getValue(nextMap, \"time\", 0);\n          const mixRotate2 = getValue(nextMap, \"mixRotate\", 1);\n          const mixX2 = getValue(nextMap, \"mixX\", 1);\n          const mixY2 = getValue(nextMap, \"mixY\", mixX2);\n          const mixScaleX2 = getValue(nextMap, \"mixScaleX\", 1);\n          const mixScaleY2 = getValue(nextMap, \"mixScaleY\", mixScaleX2);\n          const mixShearY2 = getValue(nextMap, \"mixShearY\", 1);\n          const curve = keyMap.curve;\n          if (curve) {\n            bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, mixRotate, mixRotate2, 1);\n            bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, mixX, mixX2, 1);\n            bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, mixY, mixY2, 1);\n            bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, mixScaleX, mixScaleX2, 1);\n            bezier = readCurve(curve, timeline, bezier, frame, 4, time, time2, mixScaleY, mixScaleY2, 1);\n            bezier = readCurve(curve, timeline, bezier, frame, 5, time, time2, mixShearY, mixShearY2, 1);\n          }\n          time = time2;\n          mixRotate = mixRotate2;\n          mixX = mixX2;\n          mixY = mixY2;\n          mixScaleX = mixScaleX2;\n          mixScaleY = mixScaleY2;\n          mixScaleX = mixScaleX2;\n          keyMap = nextMap;\n        }\n        timelines.push(timeline);\n      }\n    }\n    if (map.path) {\n      for (const constraintName in map.path) {\n        const constraintMap = map.path[constraintName];\n        const constraint = skeletonData.findPathConstraint(constraintName);\n        if (!constraint)\n          throw new Error(`Path constraint not found: ${constraintName}`);\n        const constraintIndex = skeletonData.pathConstraints.indexOf(constraint);\n        for (const timelineName in constraintMap) {\n          const timelineMap = constraintMap[timelineName];\n          let keyMap = timelineMap[0];\n          if (!keyMap)\n            continue;\n          const frames = timelineMap.length;\n          if (timelineName === \"position\") {\n            const timeline = new PathConstraintPositionTimeline(frames, frames, constraintIndex);\n            timelines.push(readTimeline1(timelineMap, timeline, 0, constraint.positionMode == PositionMode.Fixed ? scale : 1));\n          } else if (timelineName === \"spacing\") {\n            const timeline = new PathConstraintSpacingTimeline(frames, frames, constraintIndex);\n            timelines.push(\n              readTimeline1(timelineMap, timeline, 0, constraint.spacingMode == SpacingMode.Length || constraint.spacingMode == SpacingMode.Fixed ? scale : 1)\n            );\n          } else if (timelineName === \"mix\") {\n            const timeline = new PathConstraintMixTimeline(frames, frames * 3, constraintIndex);\n            let time = getValue(keyMap, \"time\", 0);\n            let mixRotate = getValue(keyMap, \"mixRotate\", 1);\n            let mixX = getValue(keyMap, \"mixX\", 1);\n            let mixY = getValue(keyMap, \"mixY\", mixX);\n            for (let frame = 0, bezier = 0; ; frame++) {\n              timeline.setFrame(frame, time, mixRotate, mixX, mixY);\n              const nextMap = timelineMap[frame + 1];\n              if (!nextMap) {\n                timeline.shrink(bezier);\n                break;\n              }\n              const time2 = getValue(nextMap, \"time\", 0);\n              const mixRotate2 = getValue(nextMap, \"mixRotate\", 1);\n              const mixX2 = getValue(nextMap, \"mixX\", 1);\n              const mixY2 = getValue(nextMap, \"mixY\", mixX2);\n              const curve = keyMap.curve;\n              if (curve) {\n                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, mixRotate, mixRotate2, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, mixX, mixX2, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, mixY, mixY2, 1);\n              }\n              time = time2;\n              mixRotate = mixRotate2;\n              mixX = mixX2;\n              mixY = mixY2;\n              keyMap = nextMap;\n            }\n            timelines.push(timeline);\n          }\n        }\n      }\n    }\n    if (map.deform) {\n      map.attachments = {};\n      for (const deformName in map.deform) {\n        const deformMap = map.deform[deformName];\n        const outMap = map.attachments[deformName] = {};\n        for (const slotName in deformMap) {\n          const slotMap = deformMap[slotName];\n          const outMap2 = outMap[slotName] = {};\n          for (const innerMapName in slotMap) {\n            outMap2[innerMapName] = {\n              deform: slotMap[innerMapName]\n            };\n          }\n        }\n      }\n    }\n    if (map.attachments) {\n      for (const attachmentsName in map.attachments) {\n        const attachmentsMap = map.attachments[attachmentsName];\n        const skin = skeletonData.findSkin(attachmentsName);\n        if (skin == null) {\n          if (settings.FAIL_ON_NON_EXISTING_SKIN) {\n            throw new Error(`Skin not found: ${attachmentsName}`);\n          } else {\n            continue;\n          }\n        }\n        for (const slotMapName in attachmentsMap) {\n          const slotMap = attachmentsMap[slotMapName];\n          const slot = skeletonData.findSlot(slotMapName);\n          if (!slot)\n            throw new Error(`Slot not found: ${slotMapName}`);\n          const slotIndex = slot.index;\n          for (const attachmentMapName in slotMap) {\n            const attachmentMap = slotMap[attachmentMapName];\n            const attachment = skin.getAttachment(slotIndex, attachmentMapName);\n            for (const timelineMapName in attachmentMap) {\n              const timelineMap = attachmentMap[timelineMapName];\n              let keyMap = timelineMap[0];\n              if (!keyMap)\n                continue;\n              if (timelineMapName == \"deform\") {\n                const weighted = attachment.bones;\n                const vertices = attachment.vertices;\n                const deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;\n                const timeline = new DeformTimeline(timelineMap.length, timelineMap.length, slotIndex, attachment);\n                let time = getValue(keyMap, \"time\", 0);\n                for (let frame = 0, bezier = 0; ; frame++) {\n                  let deform;\n                  const verticesValue = getValue(keyMap, \"vertices\", null);\n                  if (!verticesValue)\n                    deform = weighted ? Utils.newFloatArray(deformLength) : vertices;\n                  else {\n                    deform = Utils.newFloatArray(deformLength);\n                    const start = getValue(keyMap, \"offset\", 0);\n                    Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);\n                    if (scale != 1) {\n                      for (let i = start, n = i + verticesValue.length; i < n; i++)\n                        deform[i] *= scale;\n                    }\n                    if (!weighted) {\n                      for (let i = 0; i < deformLength; i++)\n                        deform[i] += vertices[i];\n                    }\n                  }\n                  timeline.setFrame(frame, time, deform);\n                  const nextMap = timelineMap[frame + 1];\n                  if (!nextMap) {\n                    timeline.shrink(bezier);\n                    break;\n                  }\n                  const time2 = getValue(nextMap, \"time\", 0);\n                  const curve = keyMap.curve;\n                  if (curve)\n                    bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, 0, 1, 1);\n                  time = time2;\n                  keyMap = nextMap;\n                }\n                timelines.push(timeline);\n              } else if (timelineMapName == \"sequence\") {\n                const timeline = new SequenceTimeline(timelineMap.length, slotIndex, attachment);\n                let lastDelay = 0;\n                for (let frame = 0; frame < timelineMap.length; frame++) {\n                  const delay = getValue(keyMap, \"delay\", lastDelay);\n                  const time = getValue(keyMap, \"time\", 0);\n                  const mode = SequenceMode[getValue(keyMap, \"mode\", \"hold\")];\n                  const index = getValue(keyMap, \"index\", 0);\n                  timeline.setFrame(frame, time, mode, index, delay);\n                  lastDelay = delay;\n                  keyMap = timelineMap[frame + 1];\n                }\n                timelines.push(timeline);\n              }\n            }\n          }\n        }\n      }\n    }\n    if (map.drawOrder) {\n      const timeline = new DrawOrderTimeline(map.drawOrder.length);\n      const slotCount = skeletonData.slots.length;\n      let frame = 0;\n      for (let i = 0; i < map.drawOrder.length; i++, frame++) {\n        const drawOrderMap = map.drawOrder[i];\n        let drawOrder = null;\n        const offsets = getValue(drawOrderMap, \"offsets\", null);\n        if (offsets) {\n          drawOrder = Utils.newArray(slotCount, -1);\n          const unchanged = Utils.newArray(slotCount - offsets.length, 0);\n          let originalIndex = 0;\n          let unchangedIndex = 0;\n          for (let ii = 0; ii < offsets.length; ii++) {\n            const offsetMap = offsets[ii];\n            const slot = skeletonData.findSlot(offsetMap.slot);\n            if (!slot)\n              throw new Error(`Slot not found: ${slot}`);\n            const slotIndex = slot.index;\n            while (originalIndex != slotIndex)\n              unchanged[unchangedIndex++] = originalIndex++;\n            drawOrder[originalIndex + offsetMap.offset] = originalIndex++;\n          }\n          while (originalIndex < slotCount)\n            unchanged[unchangedIndex++] = originalIndex++;\n          for (let ii = slotCount - 1; ii >= 0; ii--)\n            if (drawOrder[ii] == -1)\n              drawOrder[ii] = unchanged[--unchangedIndex];\n        }\n        timeline.setFrame(frame, getValue(drawOrderMap, \"time\", 0), drawOrder);\n      }\n      timelines.push(timeline);\n    }\n    if (map.events) {\n      const timeline = new EventTimeline(map.events.length);\n      let frame = 0;\n      for (let i = 0; i < map.events.length; i++, frame++) {\n        const eventMap = map.events[i];\n        const eventData = skeletonData.findEvent(eventMap.name);\n        if (!eventData)\n          throw new Error(`Event not found: ${eventMap.name}`);\n        const event = new Event(Utils.toSinglePrecision(getValue(eventMap, \"time\", 0)), eventData);\n        event.intValue = getValue(eventMap, \"int\", eventData.intValue);\n        event.floatValue = getValue(eventMap, \"float\", eventData.floatValue);\n        event.stringValue = getValue(eventMap, \"string\", eventData.stringValue);\n        if (event.data.audioPath) {\n          event.volume = getValue(eventMap, \"volume\", 1);\n          event.balance = getValue(eventMap, \"balance\", 0);\n        }\n        timeline.setFrame(frame, event);\n      }\n      timelines.push(timeline);\n    }\n    let duration = 0;\n    for (let i = 0, n = timelines.length; i < n; i++)\n      duration = Math.max(duration, timelines[i].getDuration());\n    if (isNaN(duration)) {\n      throw new Error(\"Error while parsing animation, duration is NaN\");\n    }\n    skeletonData.animations.push(new Animation(name, timelines, duration));\n  }\n  static blendModeFromString(str) {\n    str = str.toLowerCase();\n    if (str == \"normal\")\n      return BLEND_MODES.NORMAL;\n    if (str == \"additive\")\n      return BLEND_MODES.ADD;\n    if (str == \"multiply\")\n      return BLEND_MODES.MULTIPLY;\n    if (str == \"screen\")\n      return BLEND_MODES.SCREEN;\n    throw new Error(`Unknown blend mode: ${str}`);\n  }\n}\nclass LinkedMesh {\n  constructor(mesh, skin, slotIndex, parent, inheritDeform) {\n    this.mesh = mesh;\n    this.skin = skin;\n    this.slotIndex = slotIndex;\n    this.parent = parent;\n    this.inheritTimeline = inheritDeform;\n  }\n}\nfunction readTimeline1(keys, timeline, defaultValue, scale) {\n  let keyMap = keys[0];\n  let time = getValue(keyMap, \"time\", 0);\n  let value = getValue(keyMap, \"value\", defaultValue) * scale;\n  let bezier = 0;\n  for (let frame = 0; ; frame++) {\n    timeline.setFrame(frame, time, value);\n    const nextMap = keys[frame + 1];\n    if (!nextMap) {\n      timeline.shrink(bezier);\n      return timeline;\n    }\n    const time2 = getValue(nextMap, \"time\", 0);\n    const value2 = getValue(nextMap, \"value\", defaultValue) * scale;\n    if (keyMap.curve)\n      bezier = readCurve(keyMap.curve, timeline, bezier, frame, 0, time, time2, value, value2, scale);\n    time = time2;\n    value = value2;\n    keyMap = nextMap;\n  }\n}\nfunction readTimeline2(keys, timeline, name1, name2, defaultValue, scale) {\n  let keyMap = keys[0];\n  let time = getValue(keyMap, \"time\", 0);\n  let value1 = getValue(keyMap, name1, defaultValue) * scale;\n  let value2 = getValue(keyMap, name2, defaultValue) * scale;\n  let bezier = 0;\n  for (let frame = 0; ; frame++) {\n    timeline.setFrame(frame, time, value1, value2);\n    const nextMap = keys[frame + 1];\n    if (!nextMap) {\n      timeline.shrink(bezier);\n      return timeline;\n    }\n    const time2 = getValue(nextMap, \"time\", 0);\n    const nvalue1 = getValue(nextMap, name1, defaultValue) * scale;\n    const nvalue2 = getValue(nextMap, name2, defaultValue) * scale;\n    const curve = keyMap.curve;\n    if (curve) {\n      bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, value1, nvalue1, scale);\n      bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, value2, nvalue2, scale);\n    }\n    time = time2;\n    value1 = nvalue1;\n    value2 = nvalue2;\n    keyMap = nextMap;\n  }\n}\nfunction readCurve(curve, timeline, bezier, frame, value, time1, time2, value1, value2, scale) {\n  if (curve == \"stepped\") {\n    timeline.setStepped(frame);\n    return bezier;\n  }\n  const i = value << 2;\n  const cx1 = curve[i];\n  const cy1 = curve[i + 1] * scale;\n  const cx2 = curve[i + 2];\n  const cy2 = curve[i + 3] * scale;\n  timeline.setBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);\n  return bezier + 1;\n}\nfunction getValue(map, property, defaultValue) {\n  return map[property] !== void 0 ? map[property] : defaultValue;\n}\n\nexport { SkeletonJson };\n//# sourceMappingURL=SkeletonJson.mjs.map\n","import { SpineBase } from '@pixi-spine/base';\nimport { Skeleton } from './core/Skeleton.mjs';\nimport { AnimationState } from './core/AnimationState.mjs';\nimport { AnimationStateData } from './core/AnimationStateData.mjs';\n\nclass Spine extends SpineBase {\n  createSkeleton(spineData) {\n    this.skeleton = new Skeleton(spineData);\n    this.skeleton.updateWorldTransform();\n    this.stateData = new AnimationStateData(spineData);\n    this.state = new AnimationState(this.stateData);\n  }\n}\n\nexport { Spine };\n//# sourceMappingURL=Spine.mjs.map\n","var SPINE_VERSION = /* @__PURE__ */ ((SPINE_VERSION2) => {\n  SPINE_VERSION2[SPINE_VERSION2[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  SPINE_VERSION2[SPINE_VERSION2[\"VER34\"] = 34] = \"VER34\";\n  SPINE_VERSION2[SPINE_VERSION2[\"VER37\"] = 37] = \"VER37\";\n  SPINE_VERSION2[SPINE_VERSION2[\"VER38\"] = 38] = \"VER38\";\n  SPINE_VERSION2[SPINE_VERSION2[\"VER40\"] = 40] = \"VER40\";\n  SPINE_VERSION2[SPINE_VERSION2[\"VER41\"] = 41] = \"VER41\";\n  return SPINE_VERSION2;\n})(SPINE_VERSION || {});\nfunction detectSpineVersion(version) {\n  const ver3 = version.substr(0, 3);\n  const verNum = Math.floor(Number(ver3) * 10 + 1e-3);\n  if (ver3 === \"3.3\") {\n    return 34 /* VER34 */;\n  }\n  if (ver3 === \"3.4\") {\n    return 34 /* VER34 */;\n  }\n  if (ver3 === \"3.7\") {\n    return 37 /* VER37 */;\n  }\n  if (ver3 === \"3.8\") {\n    return 38 /* VER38 */;\n  }\n  if (ver3 === \"4.0\") {\n    return 40 /* VER40 */;\n  }\n  if (ver3 === \"4.1\") {\n    return 41 /* VER41 */;\n  }\n  if (verNum < 37 /* VER37 */) {\n    return 37 /* VER37 */;\n  }\n  return 0 /* UNKNOWN */;\n}\n\nexport { SPINE_VERSION, detectSpineVersion };\n//# sourceMappingURL=versions.mjs.map\n","import { SpineLoaderAbstract } from '@pixi-spine/loader-base';\nimport { BinaryInput } from '@pixi-spine/base';\nimport './runtime-3.4/lib/core/attachments/Attachment.mjs';\nimport './runtime-3.4/lib/core/attachments/RegionAttachment.mjs';\nimport './runtime-3.4/lib/core/vertexeffects/SwirlEffect.mjs';\nimport './runtime-3.4/lib/core/Animation.mjs';\nimport './runtime-3.4/lib/core/AnimationState.mjs';\nimport './runtime-3.4/lib/core/AnimationStateData.mjs';\nimport { AtlasAttachmentLoader } from './runtime-3.4/lib/core/AtlasAttachmentLoader.mjs';\nimport '@pixi/core';\nimport './runtime-3.4/lib/core/PathConstraint.mjs';\nimport './runtime-3.4/lib/core/Skeleton.mjs';\nimport { SkeletonBinary } from './runtime-3.4/lib/core/SkeletonBinary.mjs';\nimport * as spine38 from '@pixi-spine/runtime-3.8';\nimport * as spine37 from '@pixi-spine/runtime-3.7';\nimport * as spine41 from '@pixi-spine/runtime-4.1';\nimport { detectSpineVersion, SPINE_VERSION } from './versions.mjs';\n\nclass UniBinaryParser {\n  constructor() {\n    this.scale = 1;\n  }\n  readSkeletonData(atlas, dataToParse) {\n    let parser = null;\n    let version = this.readVersionOldFormat(dataToParse);\n    let ver = detectSpineVersion(version);\n    if (ver === SPINE_VERSION.VER34) {\n      parser = new SkeletonBinary(new AtlasAttachmentLoader(atlas));\n    }\n    if (ver === SPINE_VERSION.VER38) {\n      parser = new spine38.SkeletonBinary(new spine38.AtlasAttachmentLoader(atlas));\n    }\n    version = this.readVersionNewFormat(dataToParse);\n    ver = detectSpineVersion(version);\n    if (ver === SPINE_VERSION.VER40 || ver === SPINE_VERSION.VER41) {\n      parser = new spine41.SkeletonBinary(new spine41.AtlasAttachmentLoader(atlas));\n    }\n    if (!parser) {\n      const error = `Unsupported version of spine model ${version}, please update pixi-spine`;\n      console.error(error);\n    }\n    parser.scale = this.scale;\n    return parser.readSkeletonData(dataToParse);\n  }\n  readVersionOldFormat(dataToParse) {\n    const input = new BinaryInput(dataToParse);\n    let version;\n    try {\n      input.readString();\n      version = input.readString();\n    } catch (e) {\n      version = \"\";\n    }\n    return version || \"\";\n  }\n  readVersionNewFormat(dataToParse) {\n    const input = new BinaryInput(dataToParse);\n    input.readInt32();\n    input.readInt32();\n    let version;\n    try {\n      version = input.readString();\n    } catch (e) {\n      version = \"\";\n    }\n    return version || \"\";\n  }\n}\nclass UniJsonParser {\n  constructor() {\n    this.scale = 1;\n  }\n  readSkeletonData(atlas, dataToParse) {\n    const version = dataToParse.skeleton.spine;\n    const ver = detectSpineVersion(version);\n    let parser = null;\n    if (ver === SPINE_VERSION.VER37) {\n      parser = new spine37.SkeletonJson(new spine37.AtlasAttachmentLoader(atlas));\n    }\n    if (ver === SPINE_VERSION.VER38) {\n      parser = new spine38.SkeletonJson(new spine38.AtlasAttachmentLoader(atlas));\n    }\n    if (ver === SPINE_VERSION.VER40 || ver === SPINE_VERSION.VER41) {\n      parser = new spine41.SkeletonJson(new spine41.AtlasAttachmentLoader(atlas));\n    }\n    if (!parser) {\n      const error = `Unsupported version of spine model ${version}, please update pixi-spine`;\n      console.error(error);\n    }\n    parser.scale = this.scale;\n    return parser.readSkeletonData(dataToParse);\n  }\n}\nclass SpineLoader extends SpineLoaderAbstract {\n  createBinaryParser() {\n    return new UniBinaryParser();\n  }\n  createJsonParser() {\n    return new UniJsonParser();\n  }\n  parseData(parser, atlas, dataToParse) {\n    const parserCast = parser;\n    return {\n      spineData: parserCast.readSkeletonData(atlas, dataToParse),\n      spineAtlas: atlas\n    };\n  }\n}\n\nexport { SpineLoader };\n//# sourceMappingURL=SpineLoader.mjs.map\n","import { MathUtils } from '@pixi-spine/base';\n\nclass JitterEffect {\n  constructor(jitterX, jitterY) {\n    this.jitterX = 0;\n    this.jitterY = 0;\n    this.jitterX = jitterX;\n    this.jitterY = jitterY;\n  }\n  begin(skeleton) {\n  }\n  transform(position, uv, light, dark) {\n    position.x += MathUtils.randomTriangular(-this.jitterX, this.jitterY);\n    position.y += MathUtils.randomTriangular(-this.jitterX, this.jitterY);\n  }\n  end() {\n  }\n}\n\nexport { JitterEffect };\n//# sourceMappingURL=JitterEffect.mjs.map\n","import { SkeletonBoundsBase } from '@pixi-spine/base';\n\nclass SkeletonBounds extends SkeletonBoundsBase {\n}\n\nexport { SkeletonBounds };\n//# sourceMappingURL=SkeletonBounds.mjs.map\n","import { Event } from './Event.mjs';\nimport { SkeletonData } from './SkeletonData.mjs';\nimport { SlotData } from './SlotData.mjs';\nimport { BoneData } from './BoneData.mjs';\nimport { IkConstraintData } from './IkConstraintData.mjs';\nimport { TransformConstraintData } from './TransformConstraintData.mjs';\nimport { PathConstraintData, SpacingMode } from './PathConstraintData.mjs';\nimport { Skin } from './Skin.mjs';\nimport { EventData } from './EventData.mjs';\nimport { AttachmentTimeline, ColorTimeline, TwoColorTimeline, RotateTimeline, ScaleTimeline, ShearTimeline, TranslateTimeline, IkConstraintTimeline, TransformConstraintTimeline, PathConstraintSpacingTimeline, PathConstraintPositionTimeline, PathConstraintMixTimeline, DeformTimeline, DrawOrderTimeline, EventTimeline, Animation } from './Animation.mjs';\nimport { Color, PositionMode, Utils, settings, RotateMode, TransformMode } from '@pixi-spine/base';\nimport { BLEND_MODES } from '@pixi/core';\n\nclass SkeletonJson {\n  constructor(attachmentLoader) {\n    this.scale = 1;\n    this.linkedMeshes = new Array();\n    this.attachmentLoader = attachmentLoader;\n  }\n  readSkeletonData(json) {\n    const scale = this.scale;\n    const skeletonData = new SkeletonData();\n    const root = typeof json === \"string\" ? JSON.parse(json) : json;\n    const skeletonMap = root.skeleton;\n    if (skeletonMap != null) {\n      skeletonData.hash = skeletonMap.hash;\n      skeletonData.version = skeletonMap.spine;\n      if (skeletonData.version.substr(0, 3) !== \"3.4\") {\n        const error = `Spine 3.4 loader cant load version ${skeletonMap.spine}. Please configure your pixi-spine bundle`;\n        console.error(error);\n      }\n      if (skeletonData.version === \"3.4.75\") {\n        const error = `Unsupported skeleton data, 3.4.75 is deprecated, please export with a newer version of Spine.`;\n        console.error(error);\n      }\n      skeletonData.x = skeletonMap.x;\n      skeletonData.y = skeletonMap.y;\n      skeletonData.width = skeletonMap.width;\n      skeletonData.height = skeletonMap.height;\n      skeletonData.fps = skeletonMap.fps;\n      skeletonData.imagesPath = skeletonMap.images;\n    }\n    if (root.bones) {\n      for (let i = 0; i < root.bones.length; i++) {\n        const boneMap = root.bones[i];\n        let parent = null;\n        const parentName = this.getValue(boneMap, \"parent\", null);\n        if (parentName != null) {\n          parent = skeletonData.findBone(parentName);\n          if (parent == null)\n            throw new Error(`Parent bone not found: ${parentName}`);\n        }\n        const data = new BoneData(skeletonData.bones.length, boneMap.name, parent);\n        data.length = this.getValue(boneMap, \"length\", 0) * scale;\n        data.x = this.getValue(boneMap, \"x\", 0) * scale;\n        data.y = this.getValue(boneMap, \"y\", 0) * scale;\n        data.rotation = this.getValue(boneMap, \"rotation\", 0);\n        data.scaleX = this.getValue(boneMap, \"scaleX\", 1);\n        data.scaleY = this.getValue(boneMap, \"scaleY\", 1);\n        data.shearX = this.getValue(boneMap, \"shearX\", 0);\n        data.shearY = this.getValue(boneMap, \"shearY\", 0);\n        data.transformMode = SkeletonJson.transformModeFromString(this.getValue(boneMap, \"transform\", \"normal\"));\n        data.skinRequired = this.getValue(boneMap, \"skin\", false);\n        skeletonData.bones.push(data);\n      }\n    }\n    if (root.slots) {\n      for (let i = 0; i < root.slots.length; i++) {\n        const slotMap = root.slots[i];\n        const slotName = slotMap.name;\n        const boneName = slotMap.bone;\n        const boneData = skeletonData.findBone(boneName);\n        if (boneData == null)\n          throw new Error(`Slot bone not found: ${boneName}`);\n        const data = new SlotData(skeletonData.slots.length, slotName, boneData);\n        const color = this.getValue(slotMap, \"color\", null);\n        if (color != null)\n          data.color.setFromString(color);\n        const dark = this.getValue(slotMap, \"dark\", null);\n        if (dark != null) {\n          data.darkColor = new Color(1, 1, 1, 1);\n          data.darkColor.setFromString(dark);\n        }\n        data.attachmentName = this.getValue(slotMap, \"attachment\", null);\n        data.blendMode = SkeletonJson.blendModeFromString(this.getValue(slotMap, \"blend\", \"normal\"));\n        skeletonData.slots.push(data);\n      }\n    }\n    if (root.ik) {\n      for (let i = 0; i < root.ik.length; i++) {\n        const constraintMap = root.ik[i];\n        const data = new IkConstraintData(constraintMap.name);\n        data.order = this.getValue(constraintMap, \"order\", 0);\n        data.skinRequired = this.getValue(constraintMap, \"skin\", false);\n        for (let j = 0; j < constraintMap.bones.length; j++) {\n          const boneName = constraintMap.bones[j];\n          const bone = skeletonData.findBone(boneName);\n          if (bone == null)\n            throw new Error(`IK bone not found: ${boneName}`);\n          data.bones.push(bone);\n        }\n        const targetName = constraintMap.target;\n        data.target = skeletonData.findBone(targetName);\n        if (data.target == null)\n          throw new Error(`IK target bone not found: ${targetName}`);\n        data.mix = this.getValue(constraintMap, \"mix\", 1);\n        data.softness = this.getValue(constraintMap, \"softness\", 0) * scale;\n        data.bendDirection = this.getValue(constraintMap, \"bendPositive\", true) ? 1 : -1;\n        data.compress = this.getValue(constraintMap, \"compress\", false);\n        data.stretch = this.getValue(constraintMap, \"stretch\", false);\n        data.uniform = this.getValue(constraintMap, \"uniform\", false);\n        skeletonData.ikConstraints.push(data);\n      }\n    }\n    if (root.transform) {\n      for (let i = 0; i < root.transform.length; i++) {\n        const constraintMap = root.transform[i];\n        const data = new TransformConstraintData(constraintMap.name);\n        data.order = this.getValue(constraintMap, \"order\", 0);\n        data.skinRequired = this.getValue(constraintMap, \"skin\", false);\n        for (let j = 0; j < constraintMap.bones.length; j++) {\n          const boneName = constraintMap.bones[j];\n          const bone = skeletonData.findBone(boneName);\n          if (bone == null)\n            throw new Error(`Transform constraint bone not found: ${boneName}`);\n          data.bones.push(bone);\n        }\n        const targetName = constraintMap.target;\n        data.target = skeletonData.findBone(targetName);\n        if (data.target == null)\n          throw new Error(`Transform constraint target bone not found: ${targetName}`);\n        data.local = this.getValue(constraintMap, \"local\", false);\n        data.relative = this.getValue(constraintMap, \"relative\", false);\n        data.offsetRotation = this.getValue(constraintMap, \"rotation\", 0);\n        data.offsetX = this.getValue(constraintMap, \"x\", 0) * scale;\n        data.offsetY = this.getValue(constraintMap, \"y\", 0) * scale;\n        data.offsetScaleX = this.getValue(constraintMap, \"scaleX\", 0);\n        data.offsetScaleY = this.getValue(constraintMap, \"scaleY\", 0);\n        data.offsetShearY = this.getValue(constraintMap, \"shearY\", 0);\n        data.rotateMix = this.getValue(constraintMap, \"rotateMix\", 1);\n        data.translateMix = this.getValue(constraintMap, \"translateMix\", 1);\n        data.scaleMix = this.getValue(constraintMap, \"scaleMix\", 1);\n        data.shearMix = this.getValue(constraintMap, \"shearMix\", 1);\n        skeletonData.transformConstraints.push(data);\n      }\n    }\n    if (root.path) {\n      for (let i = 0; i < root.path.length; i++) {\n        const constraintMap = root.path[i];\n        const data = new PathConstraintData(constraintMap.name);\n        data.order = this.getValue(constraintMap, \"order\", 0);\n        data.skinRequired = this.getValue(constraintMap, \"skin\", false);\n        for (let j = 0; j < constraintMap.bones.length; j++) {\n          const boneName = constraintMap.bones[j];\n          const bone = skeletonData.findBone(boneName);\n          if (bone == null)\n            throw new Error(`Transform constraint bone not found: ${boneName}`);\n          data.bones.push(bone);\n        }\n        const targetName = constraintMap.target;\n        data.target = skeletonData.findSlot(targetName);\n        if (data.target == null)\n          throw new Error(`Path target slot not found: ${targetName}`);\n        data.positionMode = SkeletonJson.positionModeFromString(this.getValue(constraintMap, \"positionMode\", \"percent\"));\n        data.spacingMode = SkeletonJson.spacingModeFromString(this.getValue(constraintMap, \"spacingMode\", \"length\"));\n        data.rotateMode = SkeletonJson.rotateModeFromString(this.getValue(constraintMap, \"rotateMode\", \"tangent\"));\n        data.offsetRotation = this.getValue(constraintMap, \"rotation\", 0);\n        data.position = this.getValue(constraintMap, \"position\", 0);\n        if (data.positionMode == PositionMode.Fixed)\n          data.position *= scale;\n        data.spacing = this.getValue(constraintMap, \"spacing\", 0);\n        if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed)\n          data.spacing *= scale;\n        data.rotateMix = this.getValue(constraintMap, \"rotateMix\", 1);\n        data.translateMix = this.getValue(constraintMap, \"translateMix\", 1);\n        skeletonData.pathConstraints.push(data);\n      }\n    }\n    if (root.skins) {\n      for (let i = 0; i < root.skins.length; i++) {\n        const skinMap = root.skins[i];\n        const skin = new Skin(skinMap.name);\n        if (skinMap.bones) {\n          for (let ii = 0; ii < skinMap.bones.length; ii++) {\n            const bone = skeletonData.findBone(skinMap.bones[ii]);\n            if (bone == null)\n              throw new Error(`Skin bone not found: ${skinMap.bones[i]}`);\n            skin.bones.push(bone);\n          }\n        }\n        if (skinMap.ik) {\n          for (let ii = 0; ii < skinMap.ik.length; ii++) {\n            const constraint = skeletonData.findIkConstraint(skinMap.ik[ii]);\n            if (constraint == null)\n              throw new Error(`Skin IK constraint not found: ${skinMap.ik[i]}`);\n            skin.constraints.push(constraint);\n          }\n        }\n        if (skinMap.transform) {\n          for (let ii = 0; ii < skinMap.transform.length; ii++) {\n            const constraint = skeletonData.findTransformConstraint(skinMap.transform[ii]);\n            if (constraint == null)\n              throw new Error(`Skin transform constraint not found: ${skinMap.transform[i]}`);\n            skin.constraints.push(constraint);\n          }\n        }\n        if (skinMap.path) {\n          for (let ii = 0; ii < skinMap.path.length; ii++) {\n            const constraint = skeletonData.findPathConstraint(skinMap.path[ii]);\n            if (constraint == null)\n              throw new Error(`Skin path constraint not found: ${skinMap.path[i]}`);\n            skin.constraints.push(constraint);\n          }\n        }\n        for (const slotName in skinMap.attachments) {\n          const slot = skeletonData.findSlot(slotName);\n          if (slot == null)\n            throw new Error(`Slot not found: ${slotName}`);\n          const slotMap = skinMap.attachments[slotName];\n          for (const entryName in slotMap) {\n            const attachment = this.readAttachment(slotMap[entryName], skin, slot.index, entryName, skeletonData);\n            if (attachment != null)\n              skin.setAttachment(slot.index, entryName, attachment);\n          }\n        }\n        skeletonData.skins.push(skin);\n        if (skin.name == \"default\")\n          skeletonData.defaultSkin = skin;\n      }\n    }\n    for (let i = 0, n = this.linkedMeshes.length; i < n; i++) {\n      const linkedMesh = this.linkedMeshes[i];\n      const skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\n      if (skin == null)\n        throw new Error(`Skin not found: ${linkedMesh.skin}`);\n      const parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\n      if (parent == null)\n        throw new Error(`Parent mesh not found: ${linkedMesh.parent}`);\n      linkedMesh.mesh.deformAttachment = linkedMesh.inheritDeform ? parent : linkedMesh.mesh;\n      linkedMesh.mesh.setParentMesh(parent);\n    }\n    this.linkedMeshes.length = 0;\n    if (root.events) {\n      for (const eventName in root.events) {\n        const eventMap = root.events[eventName];\n        const data = new EventData(eventName);\n        data.intValue = this.getValue(eventMap, \"int\", 0);\n        data.floatValue = this.getValue(eventMap, \"float\", 0);\n        data.stringValue = this.getValue(eventMap, \"string\", \"\");\n        data.audioPath = this.getValue(eventMap, \"audio\", null);\n        if (data.audioPath != null) {\n          data.volume = this.getValue(eventMap, \"volume\", 1);\n          data.balance = this.getValue(eventMap, \"balance\", 0);\n        }\n        skeletonData.events.push(data);\n      }\n    }\n    if (root.animations) {\n      for (const animationName in root.animations) {\n        const animationMap = root.animations[animationName];\n        this.readAnimation(animationMap, animationName, skeletonData);\n      }\n    }\n    return skeletonData;\n  }\n  readAttachment(map, skin, slotIndex, name, skeletonData) {\n    const scale = this.scale;\n    name = this.getValue(map, \"name\", name);\n    const type = this.getValue(map, \"type\", \"region\");\n    switch (type) {\n      case \"region\": {\n        const path = this.getValue(map, \"path\", name);\n        const region = this.attachmentLoader.newRegionAttachment(skin, name, path);\n        if (region == null)\n          return null;\n        region.path = path;\n        region.x = this.getValue(map, \"x\", 0) * scale;\n        region.y = this.getValue(map, \"y\", 0) * scale;\n        region.scaleX = this.getValue(map, \"scaleX\", 1);\n        region.scaleY = this.getValue(map, \"scaleY\", 1);\n        region.rotation = this.getValue(map, \"rotation\", 0);\n        region.width = map.width * scale;\n        region.height = map.height * scale;\n        const color = this.getValue(map, \"color\", null);\n        if (color != null)\n          region.color.setFromString(color);\n        return region;\n      }\n      case \"boundingbox\": {\n        const box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\n        if (box == null)\n          return null;\n        this.readVertices(map, box, map.vertexCount << 1);\n        const color = this.getValue(map, \"color\", null);\n        if (color != null)\n          box.color.setFromString(color);\n        return box;\n      }\n      case \"mesh\":\n      case \"linkedmesh\": {\n        const path = this.getValue(map, \"path\", name);\n        const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\n        if (mesh == null)\n          return null;\n        mesh.path = path;\n        const color = this.getValue(map, \"color\", null);\n        if (color != null)\n          mesh.color.setFromString(color);\n        mesh.width = this.getValue(map, \"width\", 0) * scale;\n        mesh.height = this.getValue(map, \"height\", 0) * scale;\n        const parent = this.getValue(map, \"parent\", null);\n        if (parent != null) {\n          this.linkedMeshes.push(new LinkedMesh(mesh, this.getValue(map, \"skin\", null), slotIndex, parent, this.getValue(map, \"deform\", true)));\n          return mesh;\n        }\n        const uvs = map.uvs;\n        this.readVertices(map, mesh, uvs.length);\n        mesh.triangles = map.triangles;\n        mesh.regionUVs = new Float32Array(uvs);\n        mesh.edges = this.getValue(map, \"edges\", null);\n        mesh.hullLength = this.getValue(map, \"hull\", 0) * 2;\n        return mesh;\n      }\n      case \"path\": {\n        const path = this.attachmentLoader.newPathAttachment(skin, name);\n        if (path == null)\n          return null;\n        path.closed = this.getValue(map, \"closed\", false);\n        path.constantSpeed = this.getValue(map, \"constantSpeed\", true);\n        const vertexCount = map.vertexCount;\n        this.readVertices(map, path, vertexCount << 1);\n        const lengths = Utils.newArray(vertexCount / 3, 0);\n        for (let i = 0; i < map.lengths.length; i++)\n          lengths[i] = map.lengths[i] * scale;\n        path.lengths = lengths;\n        const color = this.getValue(map, \"color\", null);\n        if (color != null)\n          path.color.setFromString(color);\n        return path;\n      }\n      case \"point\": {\n        const point = this.attachmentLoader.newPointAttachment(skin, name);\n        if (point == null)\n          return null;\n        point.x = this.getValue(map, \"x\", 0) * scale;\n        point.y = this.getValue(map, \"y\", 0) * scale;\n        point.rotation = this.getValue(map, \"rotation\", 0);\n        const color = this.getValue(map, \"color\", null);\n        if (color != null)\n          point.color.setFromString(color);\n        return point;\n      }\n      case \"clipping\": {\n        const clip = this.attachmentLoader.newClippingAttachment(skin, name);\n        if (clip == null)\n          return null;\n        const end = this.getValue(map, \"end\", null);\n        if (end != null) {\n          const slot = skeletonData.findSlot(end);\n          if (slot == null)\n            throw new Error(`Clipping end slot not found: ${end}`);\n          clip.endSlot = slot;\n        }\n        const vertexCount = map.vertexCount;\n        this.readVertices(map, clip, vertexCount << 1);\n        const color = this.getValue(map, \"color\", null);\n        if (color != null)\n          clip.color.setFromString(color);\n        return clip;\n      }\n    }\n    return null;\n  }\n  readVertices(map, attachment, verticesLength) {\n    const scale = this.scale;\n    attachment.worldVerticesLength = verticesLength;\n    const vertices = map.vertices;\n    if (verticesLength == vertices.length) {\n      const scaledVertices = Utils.toFloatArray(vertices);\n      if (scale != 1) {\n        for (let i = 0, n = vertices.length; i < n; i++)\n          scaledVertices[i] *= scale;\n      }\n      attachment.vertices = scaledVertices;\n      return;\n    }\n    const weights = new Array();\n    const bones = new Array();\n    for (let i = 0, n = vertices.length; i < n; ) {\n      const boneCount = vertices[i++];\n      bones.push(boneCount);\n      for (let nn = i + boneCount * 4; i < nn; i += 4) {\n        bones.push(vertices[i]);\n        weights.push(vertices[i + 1] * scale);\n        weights.push(vertices[i + 2] * scale);\n        weights.push(vertices[i + 3]);\n      }\n    }\n    attachment.bones = bones;\n    attachment.vertices = Utils.toFloatArray(weights);\n  }\n  readAnimation(map, name, skeletonData) {\n    const scale = this.scale;\n    const timelines = new Array();\n    let duration = 0;\n    if (map.slots) {\n      for (const slotName in map.slots) {\n        const slotMap = map.slots[slotName];\n        const slotIndex = skeletonData.findSlotIndex(slotName);\n        if (slotIndex == -1)\n          throw new Error(`Slot not found: ${slotName}`);\n        for (const timelineName in slotMap) {\n          const timelineMap = slotMap[timelineName];\n          if (timelineName == \"attachment\") {\n            const timeline = new AttachmentTimeline(timelineMap.length);\n            timeline.slotIndex = slotIndex;\n            let frameIndex = 0;\n            for (let i = 0; i < timelineMap.length; i++) {\n              const valueMap = timelineMap[i];\n              timeline.setFrame(frameIndex++, this.getValue(valueMap, \"time\", 0), valueMap.name);\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n          } else if (timelineName == \"color\") {\n            const timeline = new ColorTimeline(timelineMap.length);\n            timeline.slotIndex = slotIndex;\n            let frameIndex = 0;\n            for (let i = 0; i < timelineMap.length; i++) {\n              const valueMap = timelineMap[i];\n              const color = new Color();\n              color.setFromString(valueMap.color || \"ffffffff\");\n              timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), color.r, color.g, color.b, color.a);\n              this.readCurve(valueMap, timeline, frameIndex);\n              frameIndex++;\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * ColorTimeline.ENTRIES]);\n          } else if (timelineName == \"twoColor\") {\n            const timeline = new TwoColorTimeline(timelineMap.length);\n            timeline.slotIndex = slotIndex;\n            let frameIndex = 0;\n            for (let i = 0; i < timelineMap.length; i++) {\n              const valueMap = timelineMap[i];\n              const light = new Color();\n              const dark = new Color();\n              light.setFromString(valueMap.light);\n              dark.setFromString(valueMap.dark);\n              timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), light.r, light.g, light.b, light.a, dark.r, dark.g, dark.b);\n              this.readCurve(valueMap, timeline, frameIndex);\n              frameIndex++;\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TwoColorTimeline.ENTRIES]);\n          } else\n            throw new Error(`Invalid timeline type for a slot: ${timelineName} (${slotName})`);\n        }\n      }\n    }\n    if (map.bones) {\n      for (const boneName in map.bones) {\n        const boneMap = map.bones[boneName];\n        const boneIndex = skeletonData.findBoneIndex(boneName);\n        if (boneIndex == -1)\n          throw new Error(`Bone not found: ${boneName}`);\n        for (const timelineName in boneMap) {\n          const timelineMap = boneMap[timelineName];\n          if (timelineName === \"rotate\") {\n            const timeline = new RotateTimeline(timelineMap.length);\n            timeline.boneIndex = boneIndex;\n            let frameIndex = 0;\n            for (let i = 0; i < timelineMap.length; i++) {\n              const valueMap = timelineMap[i];\n              timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), this.getValue(valueMap, \"angle\", 0));\n              this.readCurve(valueMap, timeline, frameIndex);\n              frameIndex++;\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * RotateTimeline.ENTRIES]);\n          } else if (timelineName === \"translate\" || timelineName === \"scale\" || timelineName === \"shear\") {\n            let timeline = null;\n            let timelineScale = 1;\n            let defaultValue = 0;\n            if (timelineName === \"scale\") {\n              timeline = new ScaleTimeline(timelineMap.length);\n              defaultValue = 1;\n            } else if (timelineName === \"shear\")\n              timeline = new ShearTimeline(timelineMap.length);\n            else {\n              timeline = new TranslateTimeline(timelineMap.length);\n              timelineScale = scale;\n            }\n            timeline.boneIndex = boneIndex;\n            let frameIndex = 0;\n            for (let i = 0; i < timelineMap.length; i++) {\n              const valueMap = timelineMap[i];\n              const x = this.getValue(valueMap, \"x\", defaultValue);\n              const y = this.getValue(valueMap, \"y\", defaultValue);\n              timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), x * timelineScale, y * timelineScale);\n              this.readCurve(valueMap, timeline, frameIndex);\n              frameIndex++;\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TranslateTimeline.ENTRIES]);\n          } else\n            throw new Error(`Invalid timeline type for a bone: ${timelineName} (${boneName})`);\n        }\n      }\n    }\n    if (map.ik) {\n      for (const constraintName in map.ik) {\n        const constraintMap = map.ik[constraintName];\n        const constraint = skeletonData.findIkConstraint(constraintName);\n        const timeline = new IkConstraintTimeline(constraintMap.length);\n        timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(constraint);\n        let frameIndex = 0;\n        for (let i = 0; i < constraintMap.length; i++) {\n          const valueMap = constraintMap[i];\n          timeline.setFrame(\n            frameIndex,\n            this.getValue(valueMap, \"time\", 0),\n            this.getValue(valueMap, \"mix\", 1),\n            this.getValue(valueMap, \"softness\", 0) * scale\n            // TODO: JSON fix\n            // this.getValue(valueMap, 'bendPositive', true) ? 1 : -1,\n            // this.getValue(valueMap, 'compress', false),\n            // this.getValue(valueMap, 'stretch', false)\n          );\n          this.readCurve(valueMap, timeline, frameIndex);\n          frameIndex++;\n        }\n        timelines.push(timeline);\n        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * IkConstraintTimeline.ENTRIES]);\n      }\n    }\n    if (map.transform) {\n      for (const constraintName in map.transform) {\n        const constraintMap = map.transform[constraintName];\n        const constraint = skeletonData.findTransformConstraint(constraintName);\n        const timeline = new TransformConstraintTimeline(constraintMap.length);\n        timeline.transformConstraintIndex = skeletonData.transformConstraints.indexOf(constraint);\n        let frameIndex = 0;\n        for (let i = 0; i < constraintMap.length; i++) {\n          const valueMap = constraintMap[i];\n          timeline.setFrame(\n            frameIndex,\n            this.getValue(valueMap, \"time\", 0),\n            this.getValue(valueMap, \"rotateMix\", 1),\n            this.getValue(valueMap, \"translateMix\", 1),\n            this.getValue(valueMap, \"scaleMix\", 1),\n            this.getValue(valueMap, \"shearMix\", 1)\n          );\n          this.readCurve(valueMap, timeline, frameIndex);\n          frameIndex++;\n        }\n        timelines.push(timeline);\n        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TransformConstraintTimeline.ENTRIES]);\n      }\n    }\n    if (map.path) {\n      for (const constraintName in map.path) {\n        const constraintMap = map.path[constraintName];\n        const index = skeletonData.findPathConstraintIndex(constraintName);\n        if (index == -1)\n          throw new Error(`Path constraint not found: ${constraintName}`);\n        const data = skeletonData.pathConstraints[index];\n        for (const timelineName in constraintMap) {\n          const timelineMap = constraintMap[timelineName];\n          if (timelineName === \"position\" || timelineName === \"spacing\") {\n            let timeline = null;\n            let timelineScale = 1;\n            if (timelineName === \"spacing\") {\n              timeline = new PathConstraintSpacingTimeline(timelineMap.length);\n              if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed)\n                timelineScale = scale;\n            } else {\n              timeline = new PathConstraintPositionTimeline(timelineMap.length);\n              if (data.positionMode == PositionMode.Fixed)\n                timelineScale = scale;\n            }\n            timeline.pathConstraintIndex = index;\n            let frameIndex = 0;\n            for (let i = 0; i < timelineMap.length; i++) {\n              const valueMap = timelineMap[i];\n              timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), this.getValue(valueMap, timelineName, 0) * timelineScale);\n              this.readCurve(valueMap, timeline, frameIndex);\n              frameIndex++;\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * PathConstraintPositionTimeline.ENTRIES]);\n          } else if (timelineName === \"mix\") {\n            const timeline = new PathConstraintMixTimeline(timelineMap.length);\n            timeline.pathConstraintIndex = index;\n            let frameIndex = 0;\n            for (let i = 0; i < timelineMap.length; i++) {\n              const valueMap = timelineMap[i];\n              timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), this.getValue(valueMap, \"rotateMix\", 1), this.getValue(valueMap, \"translateMix\", 1));\n              this.readCurve(valueMap, timeline, frameIndex);\n              frameIndex++;\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * PathConstraintMixTimeline.ENTRIES]);\n          }\n        }\n      }\n    }\n    if (map.deform) {\n      for (const deformName in map.deform) {\n        const deformMap = map.deform[deformName];\n        const skin = skeletonData.findSkin(deformName);\n        if (skin == null) {\n          if (settings.FAIL_ON_NON_EXISTING_SKIN) {\n            throw new Error(`Skin not found: ${deformName}`);\n          } else {\n            continue;\n          }\n        }\n        for (const slotName in deformMap) {\n          const slotMap = deformMap[slotName];\n          const slotIndex = skeletonData.findSlotIndex(slotName);\n          if (slotIndex == -1)\n            throw new Error(`Slot not found: ${slotMap.name}`);\n          for (const timelineName in slotMap) {\n            const timelineMap = slotMap[timelineName];\n            const attachment = skin.getAttachment(slotIndex, timelineName);\n            if (attachment == null)\n              throw new Error(`Deform attachment not found: ${timelineMap.name}`);\n            const weighted = attachment.bones != null;\n            const vertices = attachment.vertices;\n            const deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;\n            const timeline = new DeformTimeline(timelineMap.length);\n            timeline.slotIndex = slotIndex;\n            timeline.attachment = attachment;\n            let frameIndex = 0;\n            for (let j = 0; j < timelineMap.length; j++) {\n              const valueMap = timelineMap[j];\n              let deform;\n              const verticesValue = this.getValue(valueMap, \"vertices\", null);\n              if (verticesValue == null)\n                deform = weighted ? Utils.newFloatArray(deformLength) : vertices;\n              else {\n                deform = Utils.newFloatArray(deformLength);\n                const start = this.getValue(valueMap, \"offset\", 0);\n                Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);\n                if (scale != 1) {\n                  for (let i = start, n = i + verticesValue.length; i < n; i++)\n                    deform[i] *= scale;\n                }\n                if (!weighted) {\n                  for (let i = 0; i < deformLength; i++)\n                    deform[i] += vertices[i];\n                }\n              }\n              timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), deform, skin.name);\n              this.readCurve(valueMap, timeline, frameIndex);\n              frameIndex++;\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n          }\n        }\n      }\n    }\n    let drawOrderNode = map.drawOrder;\n    if (drawOrderNode == null)\n      drawOrderNode = map.draworder;\n    if (drawOrderNode != null) {\n      const timeline = new DrawOrderTimeline(drawOrderNode.length);\n      const slotCount = skeletonData.slots.length;\n      let frameIndex = 0;\n      for (let j = 0; j < drawOrderNode.length; j++) {\n        const drawOrderMap = drawOrderNode[j];\n        let drawOrder = null;\n        const offsets = this.getValue(drawOrderMap, \"offsets\", null);\n        if (offsets != null) {\n          drawOrder = Utils.newArray(slotCount, -1);\n          const unchanged = Utils.newArray(slotCount - offsets.length, 0);\n          let originalIndex = 0;\n          let unchangedIndex = 0;\n          for (let i = 0; i < offsets.length; i++) {\n            const offsetMap = offsets[i];\n            const slotIndex = skeletonData.findSlotIndex(offsetMap.slot);\n            if (slotIndex == -1)\n              throw new Error(`Slot not found: ${offsetMap.slot}`);\n            while (originalIndex != slotIndex)\n              unchanged[unchangedIndex++] = originalIndex++;\n            drawOrder[originalIndex + offsetMap.offset] = originalIndex++;\n          }\n          while (originalIndex < slotCount)\n            unchanged[unchangedIndex++] = originalIndex++;\n          for (let i = slotCount - 1; i >= 0; i--)\n            if (drawOrder[i] == -1)\n              drawOrder[i] = unchanged[--unchangedIndex];\n        }\n        timeline.setFrame(frameIndex++, this.getValue(drawOrderMap, \"time\", 0), drawOrder);\n      }\n      timelines.push(timeline);\n      duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n    }\n    if (map.events) {\n      const timeline = new EventTimeline(map.events.length);\n      let frameIndex = 0;\n      for (let i = 0; i < map.events.length; i++) {\n        const eventMap = map.events[i];\n        const eventData = skeletonData.findEvent(eventMap.name);\n        if (eventData == null)\n          throw new Error(`Event not found: ${eventMap.name}`);\n        const event = new Event(Utils.toSinglePrecision(this.getValue(eventMap, \"time\", 0)), eventData);\n        event.intValue = this.getValue(eventMap, \"int\", eventData.intValue);\n        event.floatValue = this.getValue(eventMap, \"float\", eventData.floatValue);\n        event.stringValue = this.getValue(eventMap, \"string\", eventData.stringValue);\n        if (event.data.audioPath != null) {\n          event.volume = this.getValue(eventMap, \"volume\", 1);\n          event.balance = this.getValue(eventMap, \"balance\", 0);\n        }\n        timeline.setFrame(frameIndex++, event);\n      }\n      timelines.push(timeline);\n      duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n    }\n    if (isNaN(duration)) {\n      throw new Error(\"Error while parsing animation, duration is NaN\");\n    }\n    skeletonData.animations.push(new Animation(name, timelines, duration));\n  }\n  readCurve(map, timeline, frameIndex) {\n    if (!map.hasOwnProperty(\"curve\"))\n      return;\n    if (map.curve === \"stepped\")\n      timeline.setStepped(frameIndex);\n    else {\n      const curve = map.curve;\n      timeline.setCurve(frameIndex, curve, this.getValue(map, \"c2\", 0), this.getValue(map, \"c3\", 1), this.getValue(map, \"c4\", 1));\n    }\n  }\n  getValue(map, prop, defaultValue) {\n    return map[prop] !== void 0 ? map[prop] : defaultValue;\n  }\n  static blendModeFromString(str) {\n    str = str.toLowerCase();\n    if (str == \"normal\")\n      return BLEND_MODES.NORMAL;\n    if (str == \"additive\")\n      return BLEND_MODES.ADD;\n    if (str == \"multiply\")\n      return BLEND_MODES.MULTIPLY;\n    if (str == \"screen\")\n      return BLEND_MODES.SCREEN;\n    throw new Error(`Unknown blend mode: ${str}`);\n  }\n  static positionModeFromString(str) {\n    str = str.toLowerCase();\n    if (str == \"fixed\")\n      return PositionMode.Fixed;\n    if (str == \"percent\")\n      return PositionMode.Percent;\n    throw new Error(`Unknown position mode: ${str}`);\n  }\n  static spacingModeFromString(str) {\n    str = str.toLowerCase();\n    if (str == \"length\")\n      return SpacingMode.Length;\n    if (str == \"fixed\")\n      return SpacingMode.Fixed;\n    if (str == \"percent\")\n      return SpacingMode.Percent;\n    throw new Error(`Unknown position mode: ${str}`);\n  }\n  static rotateModeFromString(str) {\n    str = str.toLowerCase();\n    if (str == \"tangent\")\n      return RotateMode.Tangent;\n    if (str == \"chain\")\n      return RotateMode.Chain;\n    if (str == \"chainscale\")\n      return RotateMode.ChainScale;\n    throw new Error(`Unknown rotate mode: ${str}`);\n  }\n  static transformModeFromString(str) {\n    str = str.toLowerCase();\n    if (str == \"normal\")\n      return TransformMode.Normal;\n    if (str == \"onlytranslation\")\n      return TransformMode.OnlyTranslation;\n    if (str == \"norotationorreflection\")\n      return TransformMode.NoRotationOrReflection;\n    if (str == \"noscale\")\n      return TransformMode.NoScale;\n    if (str == \"noscaleorreflection\")\n      return TransformMode.NoScaleOrReflection;\n    throw new Error(`Unknown transform mode: ${str}`);\n  }\n}\nclass LinkedMesh {\n  constructor(mesh, skin, slotIndex, parent, inheritDeform) {\n    this.mesh = mesh;\n    this.skin = skin;\n    this.slotIndex = slotIndex;\n    this.parent = parent;\n    this.inheritDeform = inheritDeform;\n  }\n}\n\nexport { SkeletonJson };\n//# sourceMappingURL=SkeletonJson.mjs.map\n","import { SpineBase } from '@pixi-spine/base';\nimport { Skeleton } from './core/Skeleton.mjs';\nimport { AnimationState } from './core/AnimationState.mjs';\nimport { AnimationStateData } from './core/AnimationStateData.mjs';\n\nclass Spine extends SpineBase {\n  createSkeleton(spineData) {\n    this.skeleton = new Skeleton(spineData);\n    this.skeleton.updateWorldTransform();\n    this.stateData = new AnimationStateData(spineData);\n    this.state = new AnimationState(this.stateData);\n  }\n}\n\nexport { Spine };\n//# sourceMappingURL=Spine.mjs.map\n","import { SpineBase } from '@pixi-spine/base';\nimport * as index from './runtime-3.4/lib/index.mjs';\nimport * as spine38 from '@pixi-spine/runtime-3.8';\nimport * as spine37 from '@pixi-spine/runtime-3.7';\nimport * as spine41 from '@pixi-spine/runtime-4.1';\nimport { detectSpineVersion, SPINE_VERSION } from './versions.mjs';\n\nclass Spine extends SpineBase {\n  createSkeleton(spineData) {\n    const ver = detectSpineVersion(spineData.version);\n    let spine = null;\n    if (ver === SPINE_VERSION.VER34) {\n      spine = index;\n    }\n    if (ver === SPINE_VERSION.VER37) {\n      spine = spine37;\n    }\n    if (ver === SPINE_VERSION.VER38) {\n      spine = spine38;\n    }\n    if (ver === SPINE_VERSION.VER40 || ver === SPINE_VERSION.VER41) {\n      spine = spine41;\n    }\n    if (!spine) {\n      const error = `Cant detect version of spine model ${spineData.version}`;\n      console.error(error);\n    }\n    this.skeleton = new spine.Skeleton(spineData);\n    this.skeleton.updateWorldTransform();\n    this.stateData = new spine.AnimationStateData(spineData);\n    this.state = new spine.AnimationState(this.stateData);\n  }\n}\n\nexport { Spine };\n//# sourceMappingURL=Spine.mjs.map\n","import '@pixi-spine/loader-base';\nimport { SpineLoader } from './SpineLoader.mjs';\nexport { Spine } from './Spine.mjs';\nexport { SPINE_VERSION, detectSpineVersion } from './versions.mjs';\n\nnew SpineLoader().installLoader();\n//# sourceMappingURL=index.mjs.map\n"],"names":["AttachmentType","AttachmentType2","BinaryInput","data","strings","index","buffer","value","optimizePositive","b","result","byteCount","chars","i","MixBlend","MixBlend2","MixDirection","MixDirection2","PositionMode","PositionMode2","RotateMode","RotateMode2","TransformMode","TransformMode2","filterFromString","text","TextureFilter","wrapFromString","TextureWrap","TextureFilter2","TextureWrap2","TextureRegion","tex","RegionFields","TextureAtlas","atlasText","textureLoader","callback","name","texture","pages","page","TextureAtlasPage","baseTexture","region","TextureAtlasRegion","textures","stripExtension","key","reader","TextureAtlasReader","entry","pageFields","regionFields","rotateValue","rotate","line","iterateParser","field","ALPHA_MODES","atlasRegion","names","values","count","entryValues","resolution","swapWH","frame","Rectangle","orig","trim","Texture","colon","lastMatch","comma","filter","SCALE_MODES","MIPMAP_MODES","IntSet","contains","StringSet","oldSize","n","_Color","r","g","a","c","hex","color","Color","_MathUtils","min","max","degrees","x","y","mode","u","d","MathUtils","Interpolation","start","end","Pow","power","PowOut","_Utils","source","sourceStart","dest","destStart","numElements","j","array","fromIndex","toIndex","size","defaultValue","alpha","blend","element","identity","type","Utils","DebugUtils","skeleton","bone","mat","Pool","instantiator","item","items","Vector2","len","TimeKeeper","now","WindowedMean","windowSize","mean","SkeletonBoundsBase","updateAabb","boundingBoxes","polygons","polygonPool","slots","slotCount","slot","attachment","boundingBox","polygon","minX","minY","maxX","maxY","vertices","ii","nn","x1","y1","x2","y2","m","bounds","prevIndex","inside","vertexY","prevY","vertexX","width12","height12","det1","x3","y3","x4","y4","det2","width34","height34","det3","settings","tempRgb","SpineSprite","Sprite","SpineMesh","SimpleMesh","uvs","indices","drawMode","_SpineBase","Container","spineData","slotContainer","spriteName","sprite","mesh","_a","utils","dt","delayLimit","globalClr","light","dark","spriteColor","attColor","transform2","Transform","id","meshId","r0","g0","b0","drawOrder","clippingAttachment","clippingContainer","timeDelta","defName","strip","DRAW_MODES","clip","graphics","poly","Polygon","geom","slotIndex","slotName","attachmentName","currentAttachment","Graphics","nameSuffix","group","outGroup","list_d","list_n","target","options","SpineBase","SpineDebugRenderer","spine","debugDisplayObjects","scale","lineWidth","skeletonX","skeletonY","bones","boneLen","starX","starY","endX","endY","w","h","a2","b2","c2","rad","B","gp","refRation","rotation","startDotSize","regionAttachment","meshAttachment","triangles","hullLength","i2","len2","v1","v2","v3","lastX","lastY","world","drawPolygon","polygonVertices","_offset","paths","dotSize","pathAttachment","cx1","cy1","cx2","cy2","spineTextureAtlasLoader","ExtensionType","LoaderParserPriority","url","checkExtension","asset","isExtensionRight","isString","loader","metadata","basePath","resolve","reject","retPromise","res","rej","retval","resolveCallback","newAtlas","makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject","atlas","atlasBasePath","imageMetadata","imageURL","pageName","textureLoadedCallback","extensions","validJSONExtension","validJSONMIME","validAtlasMIMEs","validImageMIMEs","isJson","resource","isBuffer","SpineLoaderAbstract","spineAdapter","spineLoaderExtension","checkDataUrl","dataURLToArrayBuffer","isJsonSpineModel","isBinarySpineModel","isMetadataAngry","loadAsset","fileExt","fileName","parser","dataToParse","metadataSkeletonScale","metadataAtlas","textAtlas","auxResolve","auxReject","atlasPromise","textureAtlas2","atlasPath","textureAtlas","dataURL","base64","binaryString","length","arrayBuffer","uint8Array","Attachment$3","_VertexAttachment","Attachment","worldVertices","offset","stride","deformArray","vx","vy","v","skip","skeletonBones","wx","wy","weight","deform","f","VertexAttachment","VertexAttachment$3","Slot$3","time","_RegionAttachment","regionScaleX","regionScaleY","localX","localY","localX2","localY2","radians","cos","sin","localXCos","localXSin","localYCos","localYSin","localX2Cos","localX2Sin","localY2Cos","localY2Sin","vertexOffset","Slot","offsetX","offsetY","copy","RegionAttachment","RegionAttachment$3","_SwirlEffect","radius","position","uv","radAngle","dist","theta","SwirlEffect","Animation$3","timelines","duration","lastTime","loop","events","direction","step","low","high","current","last","TimelineType","TimelineType2","_CurveTimeline","frameCount","frameIndex","tmpx","tmpy","dddfx","dddfy","ddfx","ddfy","dfx","dfy","curves","percent","prevX","CurveTimeline","CurveTimeline$3","_RotateTimeline","frames","r2","Animation","prevRotation","frameTime","RotateTimeline","_TranslateTimeline","TranslateTimeline","ScaleTimeline","bx","by","ShearTimeline","_ColorTimeline","setup","ColorTimeline","_TwoColorTimeline","g2","setupLight","setupDark","TwoColorTimeline","AttachmentTimeline$3","zeros","skin","firedEvents","slotAttachment","frameVertices","vertexCount","vertexAttachment","deform2","setupVertices","lastVertices","vertexAttachment2","prevVertices","nextVertices","prev","EventTimeline$3","event","DrawOrderTimeline$3","drawOrderToSetupIndex","_IkConstraintTimeline","mix","bendDirection","constraint","IkConstraintTimeline","_TransformConstraintTimeline","rotateMix","translateMix","scaleMix","shearMix","translate","shear","TransformConstraintTimeline","_PathConstraintPositionTimeline","PathConstraintPositionTimeline","spacing","PathConstraintSpacingTimeline","_PathConstraintMixTimeline","PathConstraintMixTimeline","PathConstraintMixTimeline$3","_AnimationState","EventQueue","TrackEntry","delta","tracks","currentDelta","next","nextTime","from","to","finished","applied","animationLast","animationTime","timelineCount","timeline","AttachmentTimeline","timelineMode","firstFrame","timelinesRotation","timelineBlend","setupState","attachments","alphaHold","alphaMix","timelineHoldMix","DrawOrderTimeline","holdMix","rotateTimeline","r1","total","diff","lastTotal","lastDiff","dir","animationStart","animationEnd","trackLastWrapped","complete","oldDrainDisabled","trackIndex","interrupt","animationName","animation","delay","mixDuration","timelinesCount","timelineDipMix","propertyIDs","outer","EventTimeline","listener","AnimationState","_TrackEntry","_EventQueue","animState","EventType","objects","listeners","EventType2","AnimationStateAdapter$2","_AnimationStateData","skeletonData","fromName","toName","AnimationStateData","AnimationStateData$3","BoundingBoxAttachment","ClippingAttachment","parentMesh","MeshAttachment","PathAttachment","point","PointAttachment","AtlasAttachmentLoader$3","path","ConstraintData$2","order","skinRequired","ConstraintData","SpacingMode","SpacingMode2","_PathConstraint","spacingMode","lengthSpacing","rotateMode","tangents","boneCount","spacesCount","spaces","lengths","setupLength","positions","boneX","boneY","offsetRotation","tip","p","dx","dy","s","percentPosition","percentSpacing","out","closed","verticesLength","curveCount","prevCurve","pathLength2","o","curve","space","pathLength","segments","curveLength","segment","temp","tt","ttt","uu","uuu","ut","ut3","uut3","utt3","PathConstraint","PathConstraint$3","Bone$3","parent","Matrix","scaleX","scaleY","shearX","shearY","sx","sy","rotationY","pa","pb","pc","pd","la","lb","lc","ld","prx","rx","ry","za","zc","zb","zd","pm","pid","ia","ib","ic","ra","rb","rc","rd","det","invDet","local","worldRotation","localRotation","IkConstraint$3","targetX","targetY","compress","stretch","uniform","rotationIK","tx","ty","sa","sc","dd","child","bendDir","softness","px","py","psx","psy","csx","pmat","os1","os2","s2","cx","cy","cwx","cwy","pp","l1","l2","a1","td","sd","aa","bb","ta","c1","q","minAngle","minDist","maxAngle","maxDist","os","TransformConstraint$3","targetMat","tb","tc","degRadReflect","offsetShearY","modified","ts","_Skeleton","boneData","Bone","slotData","ikConstraintData","IkConstraint","transformConstraintData","TransformConstraint","pathConstraintData","updateCache","skinBones","ikConstraints","transformConstraints","pathConstraints","ikCount","transformCount","pathCount","constraintCount","constrained","slotBone","pathBones","boneIndex","updateCacheReset","boneName","skinName","newSkin","constraintName","ikConstraint","Skeleton","Skeleton$3","Event$3","SkeletonData$3","skins","eventDataName","animations","pathConstraintName","SlotData$3","BoneData$3","SkinEntry$2","Skin$3","contained","dictionary","entries","slotAttachments","SkinEntry","oldSkin","skinAttachment","EventData$3","_SkeletonBinary","attachmentLoader","binary","SkeletonData","input","nonessential","BoneData","SlotData","IkConstraintData","TransformConstraintData","PathConstraintData","defaultSkin","linkedMesh","EventData","Skin","typeIndex","width","height","box","edges","inheritDeform","LinkedMesh","constantSpeed","endSlotIndex","Vertices","myVertices","weights","bonesArray","bone2","weight1","weight2","weight3","tempColor1","timelineType","timelineScale","iii","nnn","weighted","deformLength","DeformTimeline","vn","drawOrderCount","offsetCount","unchanged","originalIndex","unchangedIndex","eventCount","eventData","Event","SkeletonBinary","SkeletonBinary$2","BLEND_MODES","LinkedMesh$6","Vertices$2","cVertices","Attachment$2","VertexAttachment$2","Slot$2","RegionAttachment$2","JitterEffect$2","jitterX","jitterY","Animation$2","CurveTimeline$2","AttachmentTimeline$2","EventTimeline$2","DrawOrderTimeline$2","PathConstraintMixTimeline$2","AnimationStateAdapter$1","AnimationStateData$2","AtlasAttachmentLoader$2","Bone$2","BoneData$2","ConstraintData$1","Event$2","EventData$2","IkConstraint$2","PathConstraint$2","TransformConstraint$2","Skeleton$2","SkeletonData$2","SlotData$2","SkinEntry$1","Skin$2","darkColor","tempColor2","SkeletonBinary$1","LinkedMesh$5","Vertices$1","SkeletonJson$3","json","root","skeletonMap","error","boneMap","parentName","SkeletonJson","slotMap","constraintMap","targetName","skinMap","entryName","eventName","eventMap","animationMap","map","scaledVertices","timelineName","timelineMap","valueMap","deformName","deformMap","verticesValue","drawOrderNode","drawOrderMap","offsets","offsetMap","prop","str","LinkedMesh$4","Attachment$1","sourceAttachment","VertexAttachment$1","Slot$1","RegionAttachment$1","JitterEffect$1","Animation$1","CurveTimeline$1","AttachmentTimeline$1","attachmentName2","verticesArray","vertices2","EventTimeline$1","DrawOrderTimeline$1","PathConstraintMixTimeline$1","AnimationStateAdapter2","AnimationStateData$1","AtlasAttachmentLoader$1","Bone$1","BoneData$1","Event$1","EventData$1","IkConstraint$1","IkConstraintData$1","PathConstraintData$1","PathConstraint$1","TransformConstraint$1","Skeleton$1","SkeletonData$1","SlotData$1","TransformConstraintData$1","Skin$1","SkeletonJson$2","LinkedMesh$3","_Sequence","Sequence","SequenceMode","SequenceMode2","SequenceModeValues","ids","Property","Timeline","propertyIds","bezierCount","newCurves","bezier","time1","value1","time2","value2","dddx","dddy","ddx","ddy","valueOffset","CurveTimeline1","propertyId","curveType","before","CurveTimeline2","propertyId1","propertyId2","t","TranslateXTimeline","TranslateYTimeline","ScaleXTimeline","ScaleYTimeline","ShearXTimeline","ShearYTimeline","RGBATimeline","RGBTimeline","AlphaTimeline","RGBA2Timeline","RGB2Timeline","_EventTimeline","_DrawOrderTimeline","idx","ikConstraintIndex","transformConstraintIndex","mixRotate","mixX","mixY","mixScaleX","mixScaleY","mixShearY","pathConstraintIndex","_SequenceTimeline","modeAndIndex","SequenceTimeline","applyTime","applyEvents","shortestRotation","SUBSEQUENT","SETUP","FIRST","HOLD_SUBSEQUENT","HOLD_FIRST","CURRENT","HOLD_MIX","AnimationStateAdapter","AtlasAttachmentLoader","sequence","regions","skelX","skelY","sum","multiplier2","multiplier","rootBone","updatable","lowHash","highHash","verShort","inheritTimelines","ATTACHMENT_DEFORM","frameLast","SLOT_ATTACHMENT","SLOT_RGBA","CURVE_STEPPED","CURVE_BEZIER","setBezier","SLOT_RGB","SLOT_RGBA2","nr","ng","nb","na","nr2","ng2","nb2","SLOT_RGB2","SLOT_ALPHA","BONE_ROTATE","readTimeline1","BONE_TRANSLATE","readTimeline2","BONE_TRANSLATEX","BONE_TRANSLATEY","BONE_SCALE","BONE_SCALEX","BONE_SCALEY","BONE_SHEAR","BONE_SHEARX","BONE_SHEARY","mix2","softness2","mixRotate2","mixX2","mixY2","mixScaleX2","mixScaleY2","mixShearY2","PATH_POSITION","PATH_SPACING","PATH_MIX","ATTACHMENT_SEQUENCE","LinkedMesh$2","nvalue1","nvalue2","SkeletonJson$1","getValue","keyMap","nextMap","newColor","readCurve","color2","newColor2","constraintIndex","outMap","outMap2","innerMapName","attachmentsName","attachmentsMap","slotMapName","attachmentMapName","attachmentMap","timelineMapName","lastDelay","LinkedMesh$1","keys","name1","name2","property","SPINE_VERSION","SPINE_VERSION2","detectSpineVersion","version","ver3","verNum","UniBinaryParser","ver","spine38.SkeletonBinary","spine38.AtlasAttachmentLoader","spine41.SkeletonBinary","spine41.AtlasAttachmentLoader","e","UniJsonParser","spine37.SkeletonJson","spine37.AtlasAttachmentLoader","spine38.SkeletonJson","spine41.SkeletonJson","SpineLoader","JitterEffect","SkeletonBounds","Spine","spine37","spine38","spine41"],"mappings":"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"}